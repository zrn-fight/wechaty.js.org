<!DOCTYPE html>
<html lang="en">
<head>
    <!-- https://github.com/t-richards/jekyll-google-tag-manager -->
    <!-- Begin Jekyll GTM tag v1.0.3 -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-PD2PL84');</script>
<!-- End Jekyll GTM tag v1.0.3 -->


    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    

    <title>
      Shwetal Soni: GSOD'21 project proposal for wechaty | Wechaty
    </title>

    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Shwetal Soni: GSOD’21 project proposal for wechaty | Wechaty</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Shwetal Soni: GSOD’21 project proposal for wechaty" />
<meta name="author" content="shwetalsoni" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="GSOD21 Proposal for Wechaty" />
<meta property="og:description" content="GSOD21 Proposal for Wechaty" />
<link rel="canonical" href="https://wechaty.js.org/2021/05/03/gsod-project-proposal-shwetal-wechaty/" />
<meta property="og:url" content="https://wechaty.js.org/2021/05/03/gsod-project-proposal-shwetal-wechaty/" />
<meta property="og:site_name" content="Wechaty" />
<meta property="og:image" content="https://wechaty.js.org/assets/2021/05-gsod-project-proposal-shwetal-wechaty/profilepic.webp" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-05-03T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://wechaty.js.org/assets/2021/05-gsod-project-proposal-shwetal-wechaty/profilepic.webp" />
<meta property="twitter:title" content="Shwetal Soni: GSOD’21 project proposal for wechaty" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Shwetal Soni: GSOD’21 project proposal for wechaty","dateModified":"2021-05-03T00:00:00+00:00","datePublished":"2021-05-03T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://wechaty.js.org/2021/05/03/gsod-project-proposal-shwetal-wechaty/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://wechaty.js.org/assets/images/logo.png"},"name":"shwetalsoni"},"url":"https://wechaty.js.org/2021/05/03/gsod-project-proposal-shwetal-wechaty/","author":{"@type":"Person","name":"shwetalsoni"},"description":"GSOD21 Proposal for Wechaty","image":"https://wechaty.js.org/assets/2021/05-gsod-project-proposal-shwetal-wechaty/profilepic.webp","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="shortcut icon" type="image/x-icon" href="/assets/images/favicon.ico">

    <link rel="manifest" href="/manifest.json">

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://s3.pstatp.com/cdn/expire-1-M/font-awesome/5.3.1/css/all.css" crossorigin="anonymous">

    <!-- Google Fonts in China Thanks @crossly @sidny -->
    <link href="https://fonts.loli.net/css?family=Lora" rel="stylesheet">

    <!-- Bootstrap Modified -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!-- Theme Stylesheet -->
    <link rel="stylesheet" href="/assets/css/theme.css">

    <!-- Highlight Stylesheet -->
    <link rel="stylesheet" href="/assets/css/highlight.css">

    <!-- Jquery on header to make sure everything works, the rest  of the scripts in footer for fast loading -->
    <script
    src="https://s0.pstatp.com/cdn/expire-1-M/jquery/3.3.1/jquery.min.js"
    integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
    crossorigin="anonymous"></script>

</head>

<body class="">
    <!-- https://github.com/t-richards/jekyll-google-tag-manager -->
    <!-- Begin Jekyll GTM tag v1.0.3 (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PD2PL84"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Jekyll GTM tag v1.0.3 (noscript) -->


    <!-- Navbar -->
    <nav id="MagicMenu" class="topnav navbar navbar-expand-lg navbar-light bg-white fixed-top">
    <div class="container">
        <a class="navbar-brand" href="/"><strong>Wechaty</strong></a>
        <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarColor02" aria-controls="navbarColor02" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
        </button>
        <div class="navbar-collapse collapse" id="navbarColor02">
            <ul class="navbar-nav mr-auto d-flex align-items-center">
               <!--  Replace menu links here -->

<li class="nav-item">
  <a class="nav-link" href="/news/">News</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="/blog/">Blog</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="/docs/">Docs</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="/contributors/">Contributors</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="https://github.com/wechaty/PMC#wechaty-committers" target="_blank">Talks</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="https://github.com/wechaty/wechaty#readme" target="_blank">GitHub</a>
</li>


            </ul>
            <ul class="navbar-nav ml-auto d-flex align-items-center">
                <script src="/assets/js/lunr.js"></script>

<script>
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 1000 );
        $( "body" ).removeClass( "modal-open" );
    });
});


var documents = [{
    "id": 0,
    "url": "https://wechaty.js.org/about.html",
    "title": "About",
    "body": "      {% assign preangel = site. contributors   where: ‘slug’, ‘preangel’   first %}   {% assign partners = ‘’ | split: ‘,’ %}{% for person in site. peoples %} {% if preangel. people contains person. slug %}   {% assign partners = partners | push: person %} {% endif %}{% endfor %}  {% assign item_type = 'peoples' %} {% for item in partners %}  {% include main-loop-card-item. html %} {% endfor %} CONNECTING CHATBOTS: Wechaty is a Bot SDK for Wechat Individual Account which can help you create a bot in 6 lines of javascript,with cross-platform support including Linux,Windows, Darwin(OSX/Mac)and Docker. VOICE OF DEVELOPERS:  “Wechaty is a great solution, I believe there would be much more users recognize it. ” link— @Gcaufy, Tencent Engineer, Author of WePY  “太好用，好用的想哭”— @xinbenlv, Google Engineer, Founder of HaoShiYou. org  “最好的微信开发库” link— @Jarvis, Baidu Engineer  “Wechaty让运营人员更多的时间思考如何进行活动策划、留存用户，商业变现” link— @lijiarui, CEO of BotOrange.  “If you know js … try Wechaty, it’s easy to use. ”— @Urinx Uri Lee, Author of WeixinBot(Python) See more at Wiki:Voice Of Developer My Talk: Wechaty 101: from v0. 0 to v0. 7 at Node Party Beijing on Dec 2016 Talk Video: Presentation Slides: Wechaty 101 Slides is hosted on Google Slides(Docs) at here Made with by @Huan "
    }, {
    "id": 1,
    "url": "https://wechaty.js.org/buy-me-a-coffee.html",
    "title": "Buy me a coffee",
    "body": "Hi! I am Sal, web designer &amp; developer at WowThemes. net. The free items I create are my side projects and Mundana for Jekyll is one of them. You can find all the work I release for free here. You have my permission to use the free items I develop in your personal, commercial or client projects. If you’d like to reward my work, I would be honored and I could dedicate more time maintaining the free projects. Thank you so much! Buy me a coffee "
    }, {
    "id": 2,
    "url": "https://wechaty.js.org/categories.html",
    "title": "Categories",
    "body": "          Categories    {% for category in site. categories %}    {{ category[0] }}:     {% assign pages_list = category[1] %}    {% for post in pages_list %}    {% if post. title != null %}     {% if group == null or group == post. group %}      {% include main-loop-card-post. html %}     {% endif %}    {% endif %}    {% endfor %}    {% assign pages_list = nil %}    {% assign group = nil %}    {% endfor %}              {% include sidebar-featured. html %}    "
    }, {
    "id": 3,
    "url": "https://wechaty.js.org/contact.html",
    "title": "Contact",
    "body": "Please send your message to {{site. name}}. We will reply as soon as possible! "
    }, {
    "id": 4,
    "url": "https://wechaty.js.org/contributors/",
    "title": "Contributors Directory",
    "body": ""
    }, {
    "id": 5,
    "url": "https://wechaty.js.org/blog/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 6,
    "url": "https://wechaty.js.org/news/",
    "title": "Wechaty - News",
    "body": "{% assign news_posts = site. tags[‘news’] %}     {% assign latest_post = news_posts[0] %}        &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;        {{ latest_post. title }}  :       {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                      {{ latest_post. date | date: '%b %d, %Y' }}                      {%- assign second_post = news_posts[1] -%}            {% if second_post. image %}                         &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                        {% endif %}                            {{ second_post. title }}          :                       In             {% for category in second_post. categories %}            {{ category }},             {% endfor %}                                            {{ second_post. date | date: '%b %d, %Y' }}                                {%- assign third_post = news_posts[2] -%}            {% if third_post. image %}                         &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                        {% endif %}                            {{ third_post. title }}          :                       In             {% for category in third_post. categories %}            {{ category }},             {% endfor %}                                            {{ third_post. date | date: '%b %d, %Y' }}                                {%- assign fourth_post = news_posts[3] -%}            {% if fourth_post. image %}                        &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                        {% endif %}                            {{ fourth_post. title }}          :                       In             {% for category in fourth_post. categories %}            {{ category }},             {% endfor %}                                            {{ fourth_post. date | date: '%b %d, %Y' }}                          {% for post in news_posts %}{% if post. tags contains  sticky  %}                    {{post. title}}                  {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                 Read More                        {% endif %}{% endfor %}      All News:     {% for post in news_posts %}      {% include main-loop-card-post. html %}    {% endfor %}        {% assign news = true %}    {% include sidebar-featured. html %}  "
    }, {
    "id": 7,
    "url": "https://wechaty.js.org/privacy-policy.html",
    "title": "Privacy Policy",
    "body": "”{{site. name}}” takes your privacy seriously. To better protect your privacy we provide this privacy policy notice explaining the way your personal information is collected and used. Collection of Routine Information: This website track basic information about their visitors. This information includes, but is not limited to, IP addresses, browser details, timestamps and referring pages. None of this information can personally identify specific visitor to this website. The information is tracked for routine administration and maintenance purposes. Cookies: Where necessary, this website uses cookies to store information about a visitor’s preferences and history in order to better serve the visitor and/or present the visitor with customized content. Advertisement and Other Third Parties: Advertising partners and other third parties may use cookies, scripts and/or web beacons to track visitor activities on this website in order to display advertisements and other useful information. Such tracking is done directly by the third parties through their own servers and is subject to their own privacy policies. This website has no access or control over these cookies, scripts and/or web beacons that may be used by third parties. Learn how to opt out of Google’s cookie usage. Links to Third Party Websites: We have included links on this website for your use and reference. We are not responsible for the privacy policies on these websites. You should be aware that the privacy policies of these websites may differ from our own. Security: The security of your personal information is important to us, but remember that no method of transmission over the Internet, or method of electronic storage, is 100% secure. While we strive to use commercially acceptable means to protect your personal information, we cannot guarantee its absolute security. Changes To This Privacy Policy: This Privacy Policy is effective and will remain in effect except with respect to any changes in its provisions in the future, which will be in effect immediately after being posted on this page. We reserve the right to update or change our Privacy Policy at any time and you should check this Privacy Policy periodically. If we make any material changes to this Privacy Policy, we will notify you either through the email address you have provided us, or by placing a prominent notice on our website. Contact Information: For any questions or concerns regarding the privacy policy, please contact us here. "
    }, {
    "id": 8,
    "url": "https://wechaty.js.org/tags.html",
    "title": "Tags",
    "body": "          Tags    {% for tag in site. tags %}    {{ tag[0] }}:     {% assign pages_list = tag[1] %}    {% for post in pages_list %}    {% if post. title != null %}     {% if group == null or group == post. group %}      {% include main-loop-card-post. html %}     {% endif %}    {% endif %}    {% endfor %}    {% assign pages_list = nil %}    {% assign group = nil %}    {% endfor %}              {% include sidebar-featured. html %}    "
    }, {
    "id": 9,
    "url": "https://wechaty.js.org/blog/page2/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 10,
    "url": "https://wechaty.js.org/blog/page3/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 11,
    "url": "https://wechaty.js.org/blog/page4/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 12,
    "url": "https://wechaty.js.org/blog/page5/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 13,
    "url": "https://wechaty.js.org/blog/page6/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 14,
    "url": "https://wechaty.js.org/blog/page7/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 15,
    "url": "https://wechaty.js.org/blog/page8/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 16,
    "url": "https://wechaty.js.org/blog/page9/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 17,
    "url": "https://wechaty.js.org/blog/page10/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 18,
    "url": "https://wechaty.js.org/blog/page11/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 19,
    "url": "https://wechaty.js.org/blog/page12/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 20,
    "url": "https://wechaty.js.org/blog/page13/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 21,
    "url": "https://wechaty.js.org/blog/page14/",
    "title": "Wechaty - Blog Updates",
    "body": "{% assign blog_posts = ‘’ | split: ‘,’ %}{% for post in site. posts %} {% unless post. tags contains ‘news’ %}   {% assign blog_posts = blog_posts | push: post %} {% endunless %}{% endfor %}  {% unless page. url contains 'page' %}        {% assign latest_post = blog_posts[0] %}            &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{ latest_post. image | absolute_url }}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;            {{ latest_post. title }}   :         {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   In          {% for category in latest_post. categories %}         {{ category }},          {% endfor %}                          {{ latest_post. date | date: '%b %d, %Y' }}                              {%- assign second_post = blog_posts[1] -%}              {% if second_post. image %}                            &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image | absolute_url }}{% endif %}  alt= {{ second_post. title }} &gt;                           {% endif %}                               {{ second_post. title }}           :                         In              {% for category in second_post. categories %}             {{ category }},              {% endfor %}                                                {{ second_post. date | date: '%b %d, %Y' }}                                     {%- assign third_post = blog_posts[2] -%}              {% if third_post. image %}                            &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{ third_post. image | absolute_url }}{% endif %}  alt= {{ third_post. title }} &gt;                           {% endif %}                               {{ third_post. title }}           :                         In              {% for category in third_post. categories %}             {{ category }},              {% endfor %}                                                {{ third_post. date | date: '%b %d, %Y' }}                                     {%- assign fourth_post = blog_posts[3] -%}              {% if fourth_post. image %}                           &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{ fourth_post. image | absolute_url }}{% endif %}  alt= {{ fourth_post. title }} &gt;                           {% endif %}                               {{ fourth_post. title }}           :                         In              {% for category in fourth_post. categories %}             {{ category }},              {% endfor %}                                                {{ fourth_post. date | date: '%b %d, %Y' }}                                 {% for post in blog_posts %} {% if post. tags contains  sticky  %}                         {{post. title}}                    {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                   Read More                               {% endif %} {% endfor %} {% endunless %}           All Blogs:      {% for post in paginator. posts %}       {% include main-loop-card-post. html %}     {% endfor %}                  {% if paginator. total_pages &gt; 1 %}               {% if paginator. previous_page %}         &laquo; Prev        {% else %}         &laquo;        {% endif %}        {% for page in (1. . paginator. total_pages) %}         {% if page == paginator. page %}         {{ page }}         {% elsif page == 1 %}         {{ page }}         {% else %}         {{ page }}         {% endif %}        {% endfor %}        {% if paginator. next_page %}         Next &raquo;        {% else %}         &raquo;        {% endif %}              {% endif %}                {% include sidebar-featured. html %}     "
    }, {
    "id": 22,
    "url": "https://wechaty.js.org/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 23,
    "url": "https://wechaty.js.org/2021/11/16/wechaty-landing-page-final-blog/",
    "title": "Google Season of Docs 2021 Final Blog - Landing Page",
    "body": "2021/11/16 - We have beenn a part of Google Season of Docs 2021 for reconstruction of landing page with value propositions. It was an incredible trip with the Wechaty community through the GSoD 2021, and the landing page reconstruction has been completed and deployed, and you can visit the new landing page on the Wechaty website. Synopsis:  Abstract Structure for the New Landing Page Project Goals ConclusionAbstract: Most of the new users come to wechaty website by landing on the landing homepage. Unfortunately, the landing page is too simple and lacks enough information for new users, especially no value proposition. This problem leads to losing lots of new users, or making new users take more time to understand what wechaty can do and why we are the best. Previously, the landing page used the default Docusaurus template, which lacks adequate value propositions and CTAs. Wechaty’s site has now been totally improved/reconstructed, including value propositions, CTAs, and many other features. This blog article describes our experience with the Wechaty community, as well as how we handled the problem and revamped the complete landing page. Here’s a quick rundown of our responsibilities:  To reconstruct landing page with value propositions Identify all the benefits of wechaty offers Describe what makes these benefits valuable Identify our new users main problem Connect this value to our users problem Differentiate wechaty as the preferred provider of this valueYou can view our complete project proposal here Structure of the New Landing Page: We separated the landing page into eight pieces and created each area as a separate react component that we blended together. The sections are listed below: 1)Hero Section: In a single line, describe what wechaty is and include wechaty quotations. 2)Features Section: This section highlights all of the capabilities that Wechaty offers as well as the value propositions of Wechaty in a concise manner, and it also serves as a placeholder for the Wechaty introduction video. Once the video is complete, it will be added to this section. 3)Lets Get Started Section: This section provides an overview of the documentation sections, and new users may use it to get started with Wechaty fast. 4)Talks Section: List of popular talks about the wechaty. 5)Honors and Award Section: Displays the awards and honors that was given to wechaty community. 6)Voice of Developers Section: Contains what developers say about the wechaty, as well as quotations from them. 7)Sponsors Section: This section contains a list of wecahty community sponsors. 8)Footer Section: It is footer of the landing page and contains the required important links. Project Goals: We fulfilled all of the GSoD tasks outlined in our project proposal. During this GSoD session, we completed a total of 13 Pull Requests, including 8 PRs for each section with associated CSS and pictures, 1 PR for the dark theme, and 4 PRs to correct some minor errors on the landing page. We designed and constructed the complete new landing page, and we came up with the greatest value proposition, CTA’s, and quotations for the wechaty. View our whole design file here. We also worked with the ADVIDS team to produce the Wechaty introduction video, and we ensured that both the new landing page and the introduction video would have the same theme, value propositions, and everything else in common in the final result. You may view our contributions by clicking on the relevant links in this section. All Pull Requests completed by us can be found in the links below:  Sajen’s PRs Arnab’s PRsBelow are the complete list of all the contributions that we have made during the Google Season of Docs 2021: 1)Hero Section of the new wechaty landing page (Section 1) #12582)Features Section of the new wechaty landing page (Section 2) #12623)Lets Get Started Section of the new Wechaty landing page (Section 3) #12664)Talks Section of the new Wechaty landing page (Section 4) #12675)Honors and Awards section of the new wechaty landing page (Section 5) #12696)voice of developers section of the new wechaty landing page (Section 6) #12717)Sponsors section of the new wecahty landing page (Section 7) #12728)Footer section of the new wecahty landing page (Section 8) #12929)Dark Theme Implementation in the new landing page #136610)link colour according to the theme #136511)Bugs and misalignments rectification #136012)Several alignment issues resolved #135813)Error sections fixed in the new landing page #1357 Conclusion: The updated Wechaty landing page has a better design and includes value propositions, CTAs, and other features that capture new visitors’ attention and result in a high conversion rate. With a quick glance at the redesigned landing page, users can quickly comprehend what wechaty is, what wecahty is capable of, and the features of wechaty. Thank you to the mentors (Huan &amp; Rui) and volunteers (Rohitesh &amp; Simin) for their assistance during the documentation period and for making our GSoD 2021 season a success. "
    }, {
    "id": 24,
    "url": "https://wechaty.js.org/2021/11/07/how-to-develop-wechaty-puppet-module-supporting-5g-messages/",
    "title": "支持5G消息的 puppet-walnut 接入介绍",
    "body": "2021/11/07 - 很荣幸能参加”暑期2021“活动，接触到开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块这一开源项目,下面来和大家分享一下开发流程，希望能帮助更多的开发者快速上手这个项目。 一、准备工作: 在开发之前，你需要准备以下工具：  postman：用来测试5G Chatbot的接口 终端测试消息APP：安装时设为默认短信应用 服务器整体步骤分为两步：  测通5G Chatbot的上下行接口 将5G Chatbot接入wechaty puppet中二、测试5G Chatbot的接口: 1. 下行消息: 接口申请：: 在5G消息开发者社区申请开发接口，填写Chatbot信息并准备一个回调地址，可以是服务器的公网IP和端口号构成，也可以是提前申请好的域名。 获取token：:  首先要实现 https://{notifyURL}/notifyPath 这个接口进行身份鉴权并将代码部署到服务器上，其中{notifyURL}为申请Chatbot时所设置的回调地址。该接口的实现逻辑只需原样返回请求消息中的echoStr随机字符串和appId，如下面的这段验证示例所示，具体的实现不限语言。可参考 中国电信-中国联通 5G 消息业务平台行业客户接入接口技术规范 V1. 0. 4文档（以下简称“接口文档”）中第6. 2 部分。notify  将以下代码导入 postman，修改 sipID、appID、appKey 和 senderPhone，点击 send 按钮即可获取到 token，可查看参考中国电信-中国联通 5G 消息业务平台行业客户接入接口技术规范 V1. 0. 4文档 中6. 1部分。{   name :  get_token ,   event : [{     listen :  prerequest ,     script : {      exec : [        \r ,        //////////skn环境测试 信息///////////////\r ,        pm. globals. set(\ sipID\ , \ 你的chatbot的sipID\ );\r ,        pm. globals. set(\ appID\ , \ 你的chatbot的appID\ );  \r ,        pm. globals. set(\ appKey\ , \ 你的chatbot的appKey\ );\r ,        \r ,        pm. globals. set(\ senderPhone\ , \ 你的手机号码\ );\r ,        \r ,        pm. globals. set(\ url\ , \ maap. 5g-msg. com:30001\ );\r ,                ],      type :  text/javascript      }    },    {      listen :  test ,      script : {      exec : [        var acquiretoken = JSON. parse(responseBody);\r ,        pm. globals. set(\ accessToken\ ,acquiretoken. accessToken);       ],       type :  text/javascript       }     }    ],    request : {     method :  POST ,     header : [],     body : {      mode :  raw ,      raw :  {\ appId\ :\ {{appID}}\ ,\ appKey\ :\ {{appKey}}\ } ,      options : {      raw : {      language :  json       }     }    },     url : {      raw :  http://{{url}}/bot/v1/sip:{{sipID}}@botplatform. rcs. chinaunicom. cn/accessToken ,      protocol :  http ,      host : [       {{url}}      ],      path : [       bot ,       v1 ,       sip:{{sipID}}@botplatform. rcs. chinaunicom. cn ,       accessToken      ]    },     description :  获取token     },     response : []}下行消息：: 获取 token 后，即可进行下行消息发送，即终端 APP 可收到 Chatbot 所发送的消息。需要实现 https://{serverRoot}/bot/{apiVersion}/{chatbotId}/messages 接口。具体的请求方法，参照中国电信-中国联通 5G 消息业务平台行业客户接入接口技术规范 V1. 0. 4文档 的 9. 2部分。 终端接收到短信示例，如图： 2. 上行消息: 需要实现 http://{notifyURL}/messageNotification/{chatbotId}/messages 这个接口，具体的请求方法参照中国电信-中国联通 5G 消息业务平台行业客户接入接口技术规范 V1. 0. 4文档 中的 11. 1 部分，实现该接口后，终端即可向Chatbot发送消息，如下图所示： message2 三、将5G Chatbot接入wechaty puppet中:  将上述身份鉴权和上行消息的业务逻辑在start()函数中实现,可参考如下代码：  把Chatbot的消息结构转换为puppet的消息结构,重写messageRawPayloadParser函数override async messageRawPayloadParser (smsPayload: any): Promise&lt;MessagePayload&gt; {  const payload: MessagePayload = {   fromId: smsPayload. senderAddress,   id: smsPayload. messageId,   text: smsPayload. messageList[0]. contentText,   timestamp: Date. now(),   toId: smsPayload. destinationAddress[0],   type: MessageType. Text,  }  return payload } 把chatbot要发送的消息连上puppet，将实现下行消息的逻辑在messageSend()函数中实现，可参考如下代码： 参考资料: 《中国电信-中国联通 5G 消息业务平台行业客户接入接口技术规范 V1. 0. 4》： {% include iframe. html src=”/assets/2021/11-how-to-develop-wechaty-puppet-module-supporting-5g-messages/5g-message-service-platform-industry-customer-access-interface-specification. pdf” %}  项目仓库: https://github. com/wechaty/wechaty-puppet-walnut npm包：https://www. npmjs. com/package/wechaty-puppet-walnut 作者: zrn-fight "
    }, {
    "id": 25,
    "url": "https://wechaty.js.org/2021/11/07/gsod-2021-improve-introduction-and-explanation-project-joint-report/",
    "title": "Google Season of Docs 2021 Team Report - Introduction and Explanation",
    "body": "2021/11/07 - This is the joint project report for Improve the Introduction and Explanations secondary project under Google Season of Docs 2021. Technical writers: Mukosa Joseph Mawa: I am a self-taught web developer and technical writer with a passion for open source software. I have published a number of beginner friendly technical articles on dev. to and freeCodeCamp. Before transitioning into tech, I was a high school teacher. One of my core responsibilities as a teacher was simplifying and sequencing text written in complex technical language for learners to easily understand. I have also been a frequent contributor to a couple of open source software. Notable ones are ocaml. org and disease. sh. Chris Estepa: Currently, I am a full-time technical writer supporting users how to use their applications by creating how-tos, video tutorials, training materials, FAQs, and requirement analysis documents, among others. I love technical writing because it being a combination of communication and technology allows me to write and provide support to users, especially newbies. I know the pain and frustration of not getting the information that the users need and now, I am here to help users through my writing. Through GSOD and Wechaty, I will be able to engage more users to have a wonderful experience with their Wechaty chatbots. Proposal Video Presentation: {% include iframe. html src=”https://youtu. be/HghT9K8JNSI” %} Final Report Video Presentation: {% include iframe. html src=”https://youtu. be/j3RW6rhdZok” %} Project title: Improve the Introduction and Explanations sections of wechaty. js. org. Project overview: Our project, Improve the Introduction and Explanation sections, focused on improving the Introduction and Explanation sections of the Wechaty documentation. We followed the Divio Documentation System, which comprised of four (4) sections namely Tutorials, How-to Guides, Explanation, and Reference. We wrote the content for the Introduction and Explanation sections. For more information, you may refer to our project proposal. Project scope: The scope of this project was limited to improving the Introduction and Explanation sections of the wechaty. js. org website. Analysis of the Introduction and Explanations sections of wechaty. js. org: We did an analysis of the documentation prior to the project start and came up with following purposes for the Introduction and Explanation sections. Purpose of Introduction section of wechaty. js. org:  Help technical and non-technical people understand what Wechaty is.  Help potential individual and institutional users of Wechaty understand some of the business challenges/problems they can solve by using Wechaty.  Help total beginners understand how to start using or learning Wechaty.  Helps the user understand why and what sets Wechaty apart from other chatbot SDKs. Purpose of explanation section of wechaty. js. org:  Describe other concrete pieces of information which have not been covered in other areas of the documentation in an easy manner understood by all types of users.  Deepen and enrich users’ knowledge of Wechaty by providing alternative/contrary viewpoints and approaches than what has been presented in other sections of the documentation. Project approach: Introduction section: We were guided by the following questions when writing the introduction section. What is Wechaty? Brief introduction to Wechaty The People/Companies behind Wechaty Releases made since creation of Wechaty Original motivation for creating Wechaty The long term Vision and Mission of WechatyWhat can you do with Wechaty? What problems can businesses/individuals solve with Wechaty? What business problems have been solved by using Wechaty? How has Wechaty solved the problems of people/businesses?Who is using Wechaty? Which companies/individuals are using Wechaty? Are there testimonials from users of Wechaty on the value it has delivered to their businesses?Explanations section: The Explanation section was primarily for broadening the documentation’s coverage of the different topics. We planned to add the following content to the Explanation section in the project proposal.  Overview Lifecycle Architecture Alternatives Testing DevOps CI/CD Software Development Kit (SDK) TroubleshootingMerged pull requests: Main pull requests:       Week   Section   Sub-section   PR         1   Introduction   Overview of Wechaty documentation   870       1   Introduction   What is Wechaty   871       1   Introduction   What can you do with Wechaty   873       2   Introduction   Who are the users of Wechaty   900       2   Introduction   Getting started with Wechaty   899       2   Introduction   Main concepts in Wechaty   904       3   Explanation   Overview of the Explanation section   915       4   Explanation   Software Development Kit   930       4   Explanation   Wechaty chatbot testing   936       5   Explanation   Wechaty DevOps Toolset   949       5   Explanation   Troubleshooting in Wechaty   950       6   Explanation   Wechaty chatbots architecture   977   Additional pull requests:       Section   Sub-section   PR         Introduction   Showcases:Index   1362       Introduction   Contributing to Wechaty   1344       Explanation   Glossary   1314       Explanation   SDK and CUI   1312       Explanation   FAQ   1321   Evaluation: As mentioned in the introduction, our overall goal was to improve the Introduction and Explanation sections of the Wechaty documentation. As per our proposal, we achieved nearly everything we had set out to do. The Introduction and Explanation sections are orders of magnitude much better than they were before the GSoD 2021. We reorganized and simplified the Introduction and explanation sections to be followed and understood by even absolute beginners to Wechaty. Overall, it was an exciting project to work on and there was a lot to learn. We estimated the project to take approximately six weeks. Unfortunately, it took us more than three months. This was mainly due to delays in the final stages of the code review process. We did not reorganize the Introduction and Explanation sections as we had planned. We believe sub-sections such as Showcases, Case study, Community and Contributing to Wechaty which are currently in the Introduction section make the documentation unnecessarily bloated and therefore, should be relocated. They contain useful information and should be somewhere within the wechaty. org site but not in the documentation. Lessons learned:  We learned a lot about the DIVIO documentation system and the Google developer documentation style guide.  We learned how to work and collaborate in a remote, distributed and largely multicultural team.  We also gained invaluable skills of contributing to open source projects. Acknowledgement: We would like to thank the project mentors, Huan Li and Jiarui Li for the invaluable and constructive feedback throughout the GSoD period. We also like to thank the volunteers, Rohitesh Jain and Simin Liao, for timely reviewing all the pull requests and for providing constructive feedback. Your contributions have been invaluable. We would also love to extend our sincere gratitude to the all the members of the other teams. It was nice having your company for the entire GSoD period. Finally this wouldn’t have been possible without the support of Google. Thank you so much for sponsoring this project. "
    }, {
    "id": 26,
    "url": "https://wechaty.js.org/2021/11/05/kaiyuanshe-oss-con-2021-wechaty-gsod/",
    "title": "COSCon21 社区治理 (GC）Wechaty 开源社区文档协作 Google Season of Docs 实践",
    "body": "2021/11/05 - Google Season of Docs （GSoD）是 Google 自 2019 年发起的一项面向全球开源社区的文档支持计划，目标是为开源社区提供资金、指导完善他们的开源项目文档，并且通过了解开源社区的文档协作情况，帮助更多开发者习得专业的技术文档写作方法。 入选的 GSoD 的开源项目，除了可以得到 5000-15000 元美金的资金资助以外。组织会帮助开源项目一起对现有技术文档进行重新设计，创建新的文档体系，优化技术文档的生产流程，以创作出更优质的技术文档内容。 在今年的 GSoD 中，全球共有 30 个项目最终入选 GSoD，其中作为中国首位入选的中国开源项目 Wechaty，获得了广泛的关注。在项目期间，共有 12 位技术文档专家共同参与、协作，完成了对 Wechaty 技术文档的优化与完善。 目标听众：开源项目 Author# Maintainer# Contributor#Technical Writers 视频回放: {% include iframe. html src=”https://youtu. be/BC2-n7GrYSM” %}  https://www. bilibili. com/video/BV1nq4y1r7nd?t=1555 Slides: {% include iframe. html src=”https://docs. google. com/presentation/d/e/2PACX-1vQV8hJWS97ga10fhfaC3wwEmwBWRoC9csmv3tQOspRzBFb-PAwfEC6azXubXabBZ8gb4SkzQHMg40ba/embed?start=false&amp;loop=true&amp;delayms=3000” %}  Wechaty 开源社区文档协作 Google Season of Docs 实践分享 - Google Slide Link 个人简介: 李卓桓，谷歌开发者专家 (Machine Learning)，TensorFlow. js 布道师。《Chatbot 从 0 到 1》《简明的 TensorFlow 2》联合作者，GitHub 万星开源 Conversational RPA SDK Wechaty 作者。 PreAngel 天使投资人，专注 AI/Chatbot 领域创业团队和项目。 中国开源年会 （COSCon): 中国开源年会是中国开源业界最具影响力的年度盛会，由开源社举办。 开源社是一个在国内外开源界深具影响力、厂商中立、纯志愿者组成、非营利的开源社区联合体。我们专注于开源治理、国际接轨、社区发展和开源项目。开源社倾力打造的开源年度盛会 COSCon 一路走来也聚焦于这四个核心。 COSCon 以其独特定位及日益增加的影响力，吸引越来越多的顶级企业和国际基金会的大力支持。与一般企业、IT媒体、行业协会或国外基金会在国内所举办的行业大会大不相同的是，COSCon 除了吸引跨企业和跨项目社区的不同用户之外，也专注于吸引国内外大咖开源开发者、贡献者和提交者的关注及参与项目及其社区。 2021年，CONCon的主题是：Happy Hacking，开心开源。  Source: COSCon21 社区治理 (GC）论坛介绍 "
    }, {
    "id": 27,
    "url": "https://wechaty.js.org/2021/10/30/gsod-2021-report-on-improve-the-grpc-and-openapi-ecosystem/",
    "title": "GSoD 2021 report on Improve the gRPC and OpenAPI ecosystem",
    "body": "2021/10/30 - Introduction: This is the project report for Improve the gRPC and OpenAPI ecosystem which was completed during Google Season of Docs 2021. The status of the project can be regarded as complete due to the fact that all pull requests have been merged and all the initial premises of the project have been fulfilled. https://github. com/iamrajiv/GSoD-2021 repository contains details about my work in Google Season of Docs 2021. Learnings: I am very glad that I had the opportunity to take part in the Google Season of Docs program project. Participating in this program has helped me to:  Got involved with an amazing Wechaty community.  Got to know about Robotic Process Automation (RPA) SDK for Chatbot Makers.  Learned about Docusaurus, JavaScript XML(JSX), and Progressive web apps (PWAs).  Got a deeper understanding of Go, gRPC and Swagger UI, etc. Acknowledgments: I am deeply grateful to my mentors Huan LI and Li Jiarui and volunteers Simin Liao and Rohitesh Kumar Jain. Mentors and volunteers guided me patiently through the project and were always ready to help, review work in progress, gave feedback regarding the overall shape of the project and the feasibility of certain solutions, and maintained a very friendly, supportive, and stimulating atmosphere on the team. They devoted a lot of time to this project and led the video meetings in a well-organized, yet non-stressful manner. The project could not be completed without the generous feedback and help from the Wechaty team. Last but not least, I would like to thank Google and Google Season of Docs organizers for this initiative. "
    }, {
    "id": 28,
    "url": "https://wechaty.js.org/2021/10/29/zilliz-milvus-open-source-panel/",
    "title": "1024 程序员节：Milvus 社区五位开源界程序员心路历程分享",
    "body": "2021/10/29 -  「开源」如何帮你增加市场竞争力？ 离开大厂，「开源」如何成为一种新的创业模式？ 如何积累开源项目经验，打造一份完美的简历？ 商业公司吸引开源人才，有哪些妙招？ 1024 程序员节， Milvus 社区邀请到了五位开源界程序员大牛，为大家分享自己成长的心路历程。 视频回放: 「开源」如何帮助你增加职场竞争力？离开大厂，「开源」成为一种新的创业模式？如何积累开源项目经验，打造一份完美的简历？来听听五位开源大咖分享他们的成长秘诀：  顾钧，Zilliz合伙人、LF AI &amp; Data基金会TAC成员； 李建盛，作者，开源之道主创, Linux基金会APAC开源布道者； 李卓桓，万星开源项目 Wechaty 发起人，PreAngel天使基金合伙人； 程浩，上海白玉兰开源开放研究院研究员、示说网社区发起人； 赵生宇，同济大学计算机博士在读，Wuhan 2020开源项目发起人。{% include iframe. html src=”https://www. bilibili. com/video/BV1hU4y1u7VD” %} 你是怎么走上开源道路的？: 李建盛：我的职业生涯大概有十七八年，前十年主要在搞技术，2015 年到现在主要是作者，以文字工作和开源布道为主，是 Linux 基金会 APAC 开源布道者。欢迎关注我的公众号「开源之道」，在 GitHub 上也有相应的主页。 李卓桓：我是一个从业三十年的资深程序员，从小喜欢写程序，92 年写 basic，玩小霸王学习机。在清华上学阶段正好赶上互联网第一波浪潮，后来做了自己的公司，当优酷网首席科学家，做了国内早期的微博网站「叽歪网」，再后来成为 PreAngel 投资人。最近我关注人工智能，尤其是 Chatbot 自然语言对话方向。 程浩：我 2004 年毕业后，一直从事软件开发工作。2010 年我第一次接触开源，2012 年加入因特尔，我在大数据团队中正式制作了开源软件，做了很多功能优化和开发。我很有幸见证了开源和大数据在国内逐渐兴起繁荣的过程。2018 年，我开始做自己的创业项目，之后会详细介绍。 赵生宇：我从小就比较喜欢玩计算机，是一个十足的「网瘾少年」，我当时没有上过专业的课程，于是跟着杂志上的教程做了一些源代码的实现，做了一些游戏管理器、屏保等小项目。清华计算机系毕业后，我正好赶上了移动互联网的浪潮，于是开始创业，做了一些早期的安卓开发工作。在北大读硕士的最后一年，我在美团做大数据分析，有一次正好赶上了 Apache 的中国路演，我作为北大学生的身份去做志愿者。后来就来到微软做社区运营，研究生毕业后我在网易游戏做研发，但依然持续地做开源社区的志愿活动。2018 年，我去了阿里做开源运营的工作。在工作中，我发现设计治理和开源研究这一块非常有意思，我和王伟导师一拍即合，去同济大学计算机系读博，目前主要研究方向是开源理论和行为数据研究。去年我们发起 Wuhan 2020，尝试把开源的模式推广到数字公益领域。也感谢李卓桓的 Wechaty 的项目，对志愿者分流有很大的帮助。 开源到底是什么？: 赵生宇：我一直对开源很感兴趣，大规模协作、生产资料共享的模式，对传统的协作模式产生了很大影响。开源不仅是技术，还是制度和流程的创新。可以追溯到 licences、CLA 法律文件的产生，这些协议和制度上的创新带来了协作上的改变。开源可以说是，数字化对软件开发的赋能的产物。 李建盛：从「布道」的角度，我认为开源已成为数字化时代人和人之间「打交道」的方式。开源的外延很广泛，不仅限于代码，还是一种文化。我们可以把开源作为一种文化去普及。 顾钧：开源有一套约定俗成的惯例，通用的「打交道」的做法。当新人加入到开源中，可能不熟悉这种开源的习俗。那么，如何激活开源社区？社区之间如何做好沟通？Wechaty 是一个很大的开源项目，在中国很多社群都需要微信机器人。请问李卓桓，你们是如何组织和维护这样一个社群的呢？ 李卓桓：国内对微信机器人有很大的需求。哪怕是简单的自动回复就能大大提高人的工作效率，更不用说用自然语言处理来来让智能客服帮用户解决问题。最早设立聊天机器人的动机起源于我个人的使用痛点，因为我在微信上的消息爆满，所以我想做一个机器人回复这些问题。于是，我开始着手做一个聊天机器人。这个项目开源以后，在 GitHub 上收到了第一个 pr，提出并解决我的项目不支持收发图片的问题。之后又有一些 pr 新增代码功能、修改文档。我看到了外部开发者也在使用和维护这个项目，我开始相信，这个项目可能不会变成一个一个尸体！（之前写过一个局域网聊天工具 Zixia chat，现在已经变成尸体了）于是，我开始思考如何将这个项目运营地更好。我们的社区 base 在 GitHub 上，有两百多位社区贡献者，通过使用 GitHub 团队协作、管理、审批、issues 链接等功能，进行内容协作管理。除了 GitHub 工具，我们受到了 Apache 很多影响，使用 Apache 的社区管理方式，将大多数的决策讨论放在 issue 里公开给大家。最后，我自己对微信聊天机器人是真爱！因为是真爱，所以我有热情维护好这个项目。 开源如何增加职场竞争力？: 顾钧：大家觉得开源是否可以增加自己的职场竞争力？李建盛老师，你的工作一开始就围绕着 Linux 发行版展开，深度参与到了开源中，你觉得开源是如何加速新人的成长呢？ 李建盛：我们这一代经历了全球互联网高速发展和 GitHub 崛起的年代。一个工程师如果想学习物理、离散数学等各种知识，找身边的人讨论可能不如找网友讨论。当你参与到全球互联网中，你可以和最顶尖的高手对话、交流，专门领域的社区加速工程师的成长。互联网的崛起、开源的崛起帮助帮助大家深入讨论，比如 VB 是一个典型的闭源时代的产物，如果你要讨论 VB 编译技术，你要跑到微软内部，这基本上不太可能；但如果你学 gcc，讨论壁垒就大大降低了。 顾钧：参与开源帮你找到了一个和别人的共同话题；互联网帮你找到共同感兴趣的社区讨论交流。「开源+互联网社区」大大加速工程师技术能力的成长。我也想把这个话题抛给程浩老师。程老师 2004 年毕业，2012 年加入英特尔，参与到很多开源项目的研发中，目前在上海白玉兰开放研究院工作。我很好奇，您在参与开源的过程中，是如何提升自我并做出改变的？ 程浩：对我来说，2012 年是一个明显的分水岭，我从一个开源项目的用户转变为开发者。  从使用的角度来说，做一些应用软件，我的软件跑起来就结束了；开发开源软件时，我需要吸收不同人给我的信息。 从思维冲击角度来说，一个开源的项目一般适用于基础架构或基础中间件，不一定有明确的应用场景的指示，因此开发设计的思维模式就和应用软件不一样，也需要多与社区伙伴讨论。 从技术能力角度来说，开源有意思的地方是，你写的每一行代码都会被千千万万人看到，你写的代码会被千千万万人「拷打」，你会得到直观的帮助和指点，大大提高编码技巧。 从打交道的方式来说，代码背后是一个个鲜活的人，每个人都有不同解决问题的思路。我们如何得到一个统一的方案？高效简洁、有理有据的沟通方法是要经受训练的。 从需求管理的角度，我会更多地思考：如何看待场景和需求？哪些应该是眼前要实现的，哪些可以放在后面？顾钧：开源带来了视角的转变，需要考虑更加通用的场景，这一点我深有体会。我之前在 IBM 做售前技术工程师，在闭源的环境下，数据库的研发不会直接接触用户，而是通过售前和售后技术工程师来沟通，研发不知道用户是如何使用的；在开源的环境下，这个问题就被巧妙地解决了。 有什么给年轻程序员的建议？: 顾钧：关于程序员成长话题，大家有什么经验分享呢？ 赵生宇：我最大的启发是，本以为自己会写一辈子程序，没想到开源拓宽了我的视野。传统软件模式是线性的，但开源模式是网状关联的。这种视野上的拓宽，让我看待整个世界的视角就不一样了。一个餐厅、一个企业、一个国家是怎么样运转的？我有了更多看待世界的眼光，我找到了我想实现的事情，而技术是成为一种手段。 李卓桓：我的建议是，开源可以让喜欢写程序的人获得最大的乐趣。如果想要让自己的潜力得到最大的发挥，还是应该做自己感兴趣的事情。从工作的场景下，如果你在开源社区有一些经验，你会学习到一些「纯网友协作」的交流方法。提问、回答问题、鼓励他人提问……这些方法在学校很难学到；从求职角度，开源的经验对于自己产出和在公司内协作，都有很大的帮助。 李建盛：我不太敢给年轻人提建议。从我个人的经历来说，如果没有开源，我可能就会陷入迷茫。开源，给个人和企业带来无限机会，保持开放，不管是对家人、朋友，还是对技术，都需要保持开放。 程浩：当自己的工作经历积累到一定程度后，我就思考我到底应该干什么？我离开大厂，想要做一些自己觉得更有价值、更有意思的工作。我做了示说网，这是一个面向开发者和程序员的社区、聚焦开发人员成长的平台。 有什么推荐给程序员阅读的书籍？: 李建盛：我推荐《匠人》，这是当代社会学家理查德•桑内特的作品。作者认为，从古到今各种职业，只要有一种「为了把一件事做好而做好」的冲动，都可以被称为叫匠人。匠人的领域远远大于熟练手工劳动的范围；今天的程序员、医生、父母和公民都需要了解匠人精神的价值所在。希望大家在各行各业，都追求精益求精的精神。 李卓桓：我推荐《Chatbot从0到1：对话式交互设计实践指南》，这本书是我写的，欢迎大家斧正。我觉得我算是一个聊天机器人领域的「匠人」，文中没有太多技术代码的内容，主要讲的是如何用文本来做交互。欢迎对自然语言处理（NLP）、对话式人工智能（Conversational AI）感兴趣的朋友阅读。 赵生宇：我推荐《俞军产品方法论》。这本书贯穿了管理学和新制度经济学的思想，书中最重要的「交易成本」概念，其实不仅适用于产品设计，还可以应用到各个领域，直至每个个体的具体决策中。新制度经济学视角下观察分析开源，也可以产生很多不同的视角。把开源社区当成产品来设计，会让贡献的流程异常清晰巧妙。这本书读起来稍有晦涩，但我个人非常喜欢，书中还写了俞军早期在滴滴所做的一些思考和案例，我非常推荐。 程浩：我推荐《世界是平的》这本书，这本书描述信息技术让社会生产方式发生重大变革。很多程序员都怀揣着改变世界的梦想，但当我们身处其中时，反而不以为意，这本书虽然已经出版很久，但是可以培养工程师的软性的思考，拓宽视野。 顾钧：我推荐《大空头》，这本书最好搭配《史上最伟大的交易》一起来看。这两本书都以 2008年次贷危机为背景。《大空头》中，基金经理 Michael Burry 最早地预测到了信用违约掉期（CDS） 会挂掉，在早期做了很多铺垫，整个过程非常曲折痛苦，尽管最后赚了一笔钱，但他的投资关系就崩了。《史上最伟大的交易》中，对冲基金经理约翰·保尔森在次贷危机中的收益超过一百亿美金，被誉为「史上最伟大的交易」。一个人再聪明、再有远见，也不一定有最好的结果，因为这个世界有其客观规律。当自己特别顺利的时候，我会提醒自己「人外有人」，这可能是因为正好踩上了时间点。 作为开源小白，有什么适合新手的开源项目吗？: 顾钧：接下来是 Q&amp;A 时间。第一个观众提问是：作为开源小白，有什么适合新手的开源项目吗？从今天的聊天中，已经有两个项目了：开源向量数据库 Milvus 和聊天机器人 Wechaty。 李卓桓：如果你要做聊天机器人的自然语言处理，你肯定会遇到向量相似度匹配的问题，如果你要用到海量数据，那你肯定需要开源向量数据库 Milvus。如果能把 Milvus 和 Wechaty 两个项目结合起来，甚至可能可以做出像科幻电影《Her》里面一样逼真的效果。 李建盛：开源的道理很简单，可以总结为保持开放、保持多样。 顾钧：开源社区非常友善，新手不用紧张，欢迎你们加入开源。 你为什么跳出大厂，出来创业？: 顾钧：下一个问题是，你们当中有很多都在大厂待过然后跳出大厂自己创业，是哪个时间点或者事件，促使你做出改变的？ 程浩：大厂的优势是平台大，有很多通用、基础的问题等待我们解决，身边的同事和资源也很多，大厂对年轻人的成长有比较正面的影响；但是在大厂工作时间长了以后，我觉得碰到了天花板，思维上碰到了瓶颈。在这个节骨眼儿，要么个人选择更换业务，要么直接跳出这个平台。我就是在那个时刻，觉得自己想要做出改变，做一些技术以外的尝试。不存在哪个更好，只是每个人在自我的成长阶段中，对自己有一些期待，做出一些尝试。 顾钧：深有感触，我也有一些类似的经历。之前我陆陆续续服务的都是一些大型的机构，不是说这些大平台不好，而是我想做一些不一样的事情。 商业公司可以通过哪些方式吸引开源人才？: 顾钧：下一个观众提问是，现在有越来越多的商业公司开始做开源，需要一些资深人才来带动团队，那么商业公司可以通过哪些方式吸引开源人才？ 李卓桓：根据我个人在 GitHub 上的经验，我有三种方法：  第一种，也是我最喜欢的方法是：我在 GitHub 上看到一个特别活跃的开发者，我就会好奇并想去了解他。有好几次，我点进他们的个人主页，发现写了很多优秀的技术文章，然后发现他们是一些公司的 CTO。Typeform 是一个对话式的表单，交互体验非常友好。我知道这个项目是因为他们的 CTO 在 GitHub 上超级活跃，我顺着这个人找到了他们的项目，然后成为他们的用户。 另一种方式是，有时候我会收到一些 GitHub 找过来的招聘信息，这些招聘不是群发，显然是对我本人的经历和项目做了一些研究的。所以反之同理，创业公司可以在 GitHub 找一些和自己领域契合的项目，这些项目有哪些优秀的开发者？他们之前有哪些经历？我相信这种方式成功率也很高。 第三种方式是，比如我对于高维向量检索方面的人才感兴趣，那我就在向量数据库 Milvus 的项目主页，看有哪些人为这个项目点了 Star，然后再在这些人中筛选、看他们的主页，然后很有诚意地发邮件就好了！李建盛：如何「管理」好开源人才？过去的管理理论一般都是基于「人是需要监督的」，但是真正的开源人才是非常主动的、希望把代码写好。我们要对传统的管理方式做出改变，多元地衡量产出，而不是用硬性的 KPI 去衡量。  Source: Zilliz 想不到 HR 都在 GitHub 捞人！五位开源大牛分享成长经历欢迎在评论区回复留言你的想法，我们将选取点赞数量最高的评论，送出讲师们推荐的《匠人》《Chatbot从0到1》《俞军产品方法论》《世界是平的》《大空头》《神秘的程序员们》六本书籍！ "
    }, {
    "id": 29,
    "url": "https://wechaty.js.org/2021/10/28/osschat-is-what-you-need-for-opensouce-community-operations/",
    "title": "微信机器人上线自动回复，OSSChat 助力开源社区运营",
    "body": "2021/10/28 - 大家好，我是春松客服开源社区首席运营，我们常常发现，微信群，尤其是人多的时候，超过 30 人，就变成了不能“谈事情”的地方，很多想法匆匆而过。一些是非常值得追踪下去的想法，背后有一个很有必要做的任务，可是微信群，或者在微信上，我们不专注。 运营人员苦不堪言: 对于以上，我们常常的解决思路就是：运营的人，一次次回答同样的问题；运营的人，叮嘱或者亲自，在 GitHub 上建立一个 Issue 工单。把这个事情记录下来，GitHub 或者其它什么地方，有时候，我们甚至会建立一个新群。然而问题还是存在，群里的有价值的对话数据，没有放在一个公开的地方，能被搜索到的地方。用户不喜欢联系你，用户喜欢自助式的服务。假如，用户能在搜索引擎上，或者 GitHub Issue 上直接搜索到，会是一个多么酷的事情。简而言之，微信群运营，苦不堪言。每天回答的重复的问题，浪费了我们多少时间？ 一次次重复回答: 在微信群人多的时候，也变成了一个效率极低的地方，比如每个新人进群，总会问之前重复的问题。 能开个工单说吗: 另外一个问题是，用户不喜欢开工单。我们过着快节奏的生活，每个事情都在匆匆之间，Everything is in a rush. 并不是每个事情都值得开工单，有的时候就是闲聊，而当一个任务浮现，我们就需要一个工单，一个有状态有 Owner 的记录，可以流转、委派、跟踪、评论等等。工单意义重大，工单是一个承诺，工单是一个明确的需要输出的工作清单。我们可以容许工单开始写的不怎么样，但随后，我们就持续的跟进，这是工单的奇妙之处。以前我用 Wunderlist，现在使用微软 To-do，有了一个记录，执行力一下子就提升了。但是，在微信群，我们聊的热火朝天，口干舌燥，待到要创建一个任务，就突然艰巨了起来。 从打开 GitHub Issue 到粘贴对话，到保存。动作很简单，但是只有少数人做这一步。相信我，只要开出工单，事情就会得到解决，甚至这个工单，后来发现，是一项不值得做的工作，那么这也是一项收获。一方面，有了工单，对我们工作很有好处；一方面，很少有人去开工单。 我们有一些惰性，我们甚至从文化上分析这个事情的合理性，多么荒谬。 你告诉我一个困难的工作，我给你开个工单，这个工作会解决，至少会有起色。你在微信群里告诉我一个事情，然后明天和下周，你得多提醒我。人的大脑，有它工作的原理。工单帮助我们建立一种信守承诺的文化，工单帮助大家有更多信任。 提升执行力的秘密是，做出第一步：从微信的讨论出发，然后建立出工单，开始执行。 数据隐藏着价值: 另外一项，非常非常重要的事情，非常重要！数据隐藏着你项目成功的秘密，大家在微信里每天聊，你知道他们关注什么吗？你知道现在你应该怎么安排任务的优先级吗？ 用户常问的问题，我们整理成 FAQs 常见问题列表，用户常要做的流程，我们能不能用聊天机器人多轮对话解决？用户关心的事情，我们查看关键词。 这些都依赖于数据，而这些数据在微信群里，这些数据弄好了，你的项目可以在 90 天内活跃 10 倍！我没有过度承诺的习惯 :-)，我说的是聊天数据的分析，可以帮助你真正做到以“客户”为中心。 微信不创新: 8 年前，扎克伯克说经常的看微信，学习微信的创新，看看人家这劲头，汉语现在是呱呱流利，而现在，你知道吗？ Facebook Messenger 的创新，已经领先了微信一个产品世代！ Messenger 对 AR，Chatbot 等 Metaverse 元宇宙级别的场景做到了相当不错的体验。微信不创新，如果你体验了 Messenger 对 Chatbot 的交互的支持，你会和我有同感。 我们就像微信奴隶一样，将数据给了微信，微信挖掘这些价值来榨干我们。 英雄降临: 事情不会这样结束，历史的车轮滚滚向前，终于有一天，一些人觉醒了：拿回我们的数据，我们要创新！ Wechaty，非常酷，使用 RPA 将微信变成了可编程微信，使用代码管理你的联系人、消息和微信群，对，你的，都是你的，中间那个微信是你的。然后是 Chatopera，非常酷，是定制机器人的大脑，做智能问答和对话流程。这样，我们就可以和 GitHub 集成了，让微信群和 Github 工单能自由的同步。 我有一个梦想，有一天，我在微信群里的聊天的数据，我可以分析出大家常聊什么，这样我可以做知识库机器人自动回答；我有一个梦想，有一天，GitHub Issue 的创建和评论的事件，我可以在微信群自动的得到通知；我有一个梦想，有一天，我只消说，“以上创建工单”，就可以将微信群的聊天记录自动创建为 GitHub Issue；我有一个梦想，有一天，我可以和她一起 . . . 好的，继续说工作的事情，这个梦想，可以实现。非常的酷的想法，有点激动，这些目标可以使用 Wechaty + Chatopera + 微信 + GitHub 实现，但是工作量比较大，此处省略十万字。 在二十多位贡献者的参与下，这个想法终于实现了。 https://github. com/kaiyuanshe/osschat 2021-10-14，OSSChat 自动回复功能上线: 自 2020 年 3 月，OSSChat 云服务上线，但是直到 2021 年 10 月 14 日，OSSChat 的自动回复功能，才做好，因为工作量确实比较大。现在我们只需要在微信群里说：以上五条开工单，那么对应的 GitHub Issue 就会开出来发群里。 这是我们在春松客服开发者群里的一个对话，一句话，GitHub Issue 就创建了，香不香？激动不激动？羡慕不羡慕？ 一个开工单的过程节省 5 分钟，并最终让执行力拔高一个层次。 一旦一个复杂流程的第一步启动，那么流程有它自己的执行力。 我要使用 OSSChat:  接受托管云服务接入，只需要联系登记和授权。 How to use osschat  不托管，自己打理自己来，运行服务并配置。工作量是接受托管的 20 倍！欢迎来折腾！ 参考 README. md 文档 https://github. com/kaiyuanshe/osschat 发现更多: 微信机器人上线自动回复，OSSChat 助力开源社区运营。在 2021 年 10 月 14 日晚，OSSChat 项目组做了一次在线分享，为已经上线了 OSSChat 的用户第一次介绍自动开 Issue 等功能。 For visiters come from China who can not visit YouTube. com, this video is also hosted on bilibili. com Video:  微信机器人上线自动回复，OSSChat 助力开源社区运营 | Wechaty @ bilibili{% include iframe. html src=”https://youtu. be/qWxDnSaa29s” %} "
    }, {
    "id": 30,
    "url": "https://wechaty.js.org/2021/10/28/opentekr-oss-pioneer-interview-huan/",
    "title": "OpenTEKr｜OSS Pioneer｜Interview with Huan Li",
    "body": "2021/10/28 - With 25 years of programming experience, Huan Li has gone from entrepreneurs to investors. He has practiced a variety of open source methods, and in the field of open source contributions, Huan Li is also a pioneer. Whether publishing open source projects with a cumulative total of more than 11,000 Stars on Github, or being invited by other open source organizations to become an Owner or a Maintainer, Huan Li has formed his own unique observation and experience of open source as a solution. This time it comes to “OSS Pioneer”, what new insights will Li Zhuohuan bring to everyone? The 1% energy of the open source community contribute every day, how to reverse the giant Microsoft’s contempt on Linux to integrate Linux into its own system? How does the open source project Wechaty arouse everyone’s enthusiasm for collaborative development? Let’s find out. Video Playback: {% include iframe. html src=”https://youtu. be/v0FjLrZ0zfw” %} Today let’s meet Zhuohuan Li 李卓桓. #OpenTEKr #OSSPioneer He is the founder of #Wechaty and an evangelist of #Chatbot. He is also an angel investor and a mentor at 璞跃中国 Plug and Play China Venture Partner. #opensource About OpenTEKr: OpenTEKr has been sharing cutting-edge knowledge and insights via a series of interviews with founders, initiators, mentors, and experts within the open-source community. In its latest efforts, the OSS Pioneer series of interviews are being conducted starting from December in 2020, with a goal to gather 100 thought-leadersand contributors in China’s open-source space. OpenTEKr is a non-for-profit open organization with advancing open-source software and open hardware technology at its core, dedicated to shaping a sustainable open technology ecosystem. We envision a better tomorrow for all mankind with individuals and organizations inspired and empowered to realize their aspirations through transformative technologies and world-class innovation. For more detail, please visit www. opentekr. com  Source: OpenTEKr "
    }, {
    "id": 31,
    "url": "https://wechaty.js.org/2021/10/20/wechaty-tutorials-final-blog/",
    "title": "Google Season of Docs 2021 Final Blog - Tutorials",
    "body": "2021/10/20 - We have been a part of Google Season of Docs 2021 for creating and improving the Wechaty documentation, specifically the Tutorials section. It was an amazing journey of 17 weeks (roughly 4 months) contributing to the Wechaty documentation, during which we got an opportunity to try out and learn a lot about the Wechaty bots. When we initially started contributing to the Docs, we didn’t have any idea about how Wechaty bots can be created that runs on various instant messaging (IM) systems like WhatsApp and Wechat. But gradually we became comfortable with building the bots and started building the documentation. A brief introduction about us is available below. Souvik Biswas: I am Souvik Biswas, currently pursuing a B. Tech degree in Computer Science and Engineering from IIIT Kalyani in India. I am a freelance technical writer of Codemagic and LogRocket Blog, and a passionate mobile app developer. You can also find some of my articles on Medium, and explore my projects on GitHub. Shwetal Soni: I am Shwetal Soni, currently pursuing B. Tech in Computer Science and Engineering from NIT Hamirpur in India. I am interested in UI/UX Design, Frontend web development and recently I’m also exploring the field of Technical Writing. Recently I have only written one technical blog on writing smart contracts on Tezos Blockchain. You can check it out here Medium. You can also find my projects on Github. Final Video Presentation: {% include iframe. html src=”https://youtu. be/lDaBTTSeXck” %} Abstract: Our main goal was to improve the Wechaty Tutorials documentation and make it easier to follow for beginner users of Wechaty. We have added step by step guide for building each Wechaty bot from scratch and added interactive CodeSandboxes using which users can try out the bot directly from within the documentation page. Here’s a brief overview of our tasks:  Refactor the overall Tutorials documentation Add / improve the step-by-step instructions Add interactive CodeSandbox Screenshots / GIF of the bot running on a device Add various bots building tutorials to Examples Create a video tutorialEarlier the tutorial pages lacked a proper structure, so it might not be easy to follow and build a bot for a user to is new to Wechaty. So, we have introduced a structure that is followed on every documentation page, more information about it is below. Structure of tutorial pages: This is an overview of the final structure for each of the tutorial pages that we have followed so that all the tutorials are consistent and easy to follow for any user.  Introduction: Highlights the goal of the tutorial.  Try out the bot: Contains the CodeSandbox of the bot along with an editable link.  Requirements: List of the required tools in order to follow the tutorial.  Getting started: Covers the installation step of the required tools and how users can try out the bot locally by cloning its GitHub repo.  Building the bot: The main section where we include the step by step guide Running the bot: Contains commands for running the bot on the user’s system Bot demonstration: Describes the commands that can be used within the bot along with some screenshots/GIFs if required.  Conclusion &amp; References: Any links that the users can check out for knowing more about a particular concept related to the bot. Project Goals: We managed to complete all the GSoD tasks as per our initial proposal. In 17 weeks, we have done a total of 40 pull requests which consist of 33 weekly PRs (addition or improvement of documentation pages that we had included in our initial proposal), and 7 miscellaneous PRs (fixes that we have done to some of the pages). We have also created a video tutorial for building the most basic Wechaty bot, called the Ding Dong Bot, from scratch. {% include iframe. html src=”https://youtu. be/LHT49Q_x5D8” %} You can take a look at our contributions by going to the respective links present in this section. You can find all PRs done by us in the links below:  Shwetal’s PRs Souvik’s PRsHere’s a complete list of all the contributions that we have done during the GSoD season:       Week   Pull Requests   Technical Writer         1   Add instructions and interactive sandbox for Vorpal #779   Souvik Biswas       1   Update the Vorpal demo screenshot #780   Souvik Biswas       1   Improve Vorpal docs #791   Souvik Biswas       1   Improve and update Vorpal bot steps #882   Souvik Biswas       1   Runnning Locally (Ding Dong bot) #888   Shwetal Soni       2   Getting Started Overview #935   Shwetal Soni       2   Tutorials Overview #934   Shwetal Soni       2   Add installation page under tutorials #905   Souvik Biswas       3   Add Google Cloud Shell tutorial #922   Souvik Biswas       3   Running Ding Dong bot on gitpod #923   Shwetal Soni       5   Update Wechaty Plugin Overview page under Tutorials #957   Souvik Biswas       5   Add tutorial for EventLogger plugin #963   Souvik Biswas       6   Add tutorial for QR code terminal plugin #969   Shwetal Soni       6   Add tutorial for Heartbeat plugin #985   Souvik Biswas       7   Using Redux with wechaty overview #989   Shwetal Soni       8   Add Redux: Ducks proposal style docs #1126   Souvik Biswas       9   Add Starter Bot under Examples: Basic #1076   Souvik Biswas       9   Improve the Contact Bot page #1099   Souvik Biswas       9   Updated ding dong bot under examples #1103   Shwetal Soni       9   Updated World's Shortest Chatbot under examples #1104   Shwetal Soni       10   Created tutorial for room-bot #1131   Shwetal Soni       10   Tutorial for examples/advanced/busy-bot #1134   Shwetal Soni       10   Update the Friend bot page #1138   Souvik Biswas       11   Add tutorial for Media File Bot #1155   Souvik Biswas       12   Tutorial for using vanilla redux with wechaty #1165   Shwetal Soni       12   Add tutorial for Ctrl C Signal Bot #1204   Souvik Biswas       13   Tutorial for Tuling123 Bot #1207   Shwetal Soni       16   Add video demo of ding ding bot #1249   Souvik Biswas       16   Add missing badges to Event Logger plugin page #1250   Souvik Biswas       16   Add missing badges to Heartbeat plugin page #1251   Souvik Biswas       16   Updated links in tutorials overview page and removed empty pages from examples section #1254   Shwetal Soni       16   Added missing badges to QR code terminal plugin #1253   Shwetal Soni       16   Update order of language display #1252   Shwetal Soni   Conclusion: The current version of Wechaty documentation consists of a lot of easy-to-follow tutorials for building Wechaty bots from scratch. Users will find relevant links to all the resources required for building the bot by themselves and can also run some of the bots directly on the documentation page inside the CodeSandboxes that we have included. Thanks to all the mentors (Huan &amp; Rui) and volunteers (Rohitesh &amp; Simin) for helping us during the documentation period and making our GSoD 2021 season successful. "
    }, {
    "id": 32,
    "url": "https://wechaty.js.org/2021/10/19/jyy-chatbot-blog/",
    "title": "献给新生女儿的礼物：基于wechaty和语义开放平台打造的育儿机器人",
    "body": "2021/10/19 - 最近的生活里多了个女儿(蒋一一)，为了数字化育儿，我写了这个机器人，可以自动通过微信记录小宝宝的日常起居，将结构化育儿数据记录下来，以达到数据驱动育儿。  关于我：毕业于复旦/剑桥自然语言处理组。2013-2018年在创业公司出门问问带领团队负责语义分析算法、开放平台开发，支持了包括了谷歌、江淮、微鲸、大众等众多客户。现在在WhatsApp负责假新闻、反广告机器学习开发。欢迎关注我知户主页。 需求：如何养娃: 新生儿无法用完整语言来表达自己的需求，因此作为父母，除了”哭闹”这样的被动信号，我们也需要“主动记录”宝宝日常的一些行为作息数据，来确保宝宝健康成长。这些数据包括：  喂奶量: 新生儿在生长初期的喂奶量相对固定的(虽然存在个体差异)，因此需要追踪宝宝每天的喂奶量和喂奶频率。例如，在我开发机器人的时候，我女儿蒋一一正好两周，她需要每隔3~4小时左右喂一次奶，每天6~8次左右。 尿布: 尿布的量是为了追踪宝宝每日是否摄入了足够的营养和水分。例如，蒋一一需要每天至少6片以上的湿尿布，否则可能意味着水分摄入不足。 睡眠: 为了追踪宝宝每日睡眠情况。比如，蒋一一每天大约要睡15小时左右，这样才能保证她的大脑和身体的发育。同时，充足的睡眠也保证了父母的有足够的时间追剧打王者荣耀。因此，为了科学养娃，我决定写这个微信机器人，允许用户的自然语言输入，并自动转换成结构化数据，以便之后分析处理: 比如： # 输入蒋一一上午9点喝了30毫升的奶# 输出event: 喂奶time: 2021-10-19 09:00:00quantity: 30技术设计思路：语义开放平台: 从自然语言文本中提取关键信息，简单的当然可以用正则表达式来实现，例如： (?&lt;time&gt;(上午|下午)?\d+点). *(?&lt;event&gt;喂奶|奶粉|睡觉|起床|拉屎|拉尿). *(?&lt;quantity&gt;\d+(毫升|克))?但显然用正经的语义分析算法才是更好的选择。这里的语义分析算法特指任务型对话使用的，基于意图分类（分类算法）和语义槽提取（序列标注算法）的数据驱动的语义分析算法。详情可以百度/谷歌关键字NLU 语义分析 任务型对话，或者直接看这篇科普文。 相比于之前基于规则的识别，基于机器学习模型的算法有以下优势：  识别范围更广：不需要严格规则匹配，有非常大的自由度来应对不同遣词造句。 易于维护扩展：特别是对于复杂语义系统，规则的数量会指数级增长，以至于不可维护。而基于机器学习的语义分析，只需要提供带标注的训练文本，机器学习算法会自动的搞定剩下的。并且，在2021年的当下，基础的语义分析都已经平台化了，这意味着：  不需要从头开始训练模型，可以完全图形化界面配置自己的语义分析。 对于一些常见任务有现成的处理方法，比如时间（今天、明天9点、下周五），度量衡（三十毫升，40°， 一米半） 也可以方便的拓展到带上下文的对话语义分析。在这个任务里，我使用的是出门问问的语义开放平台。市面上有很多其他的语义分析开放平台（比如百度、科大讯飞、Facebook的wit. ai)，我选择出门问问这个平台的原因很简单，因为是我自己写的。 具体的使用方法可以参见平台的文档，总之，我大概花了10分钟的，提交了一些训练数据，就自动得到了一个可以用的语义分析模型，并且支持HTTP GET直接调用, 实际调用如下： // input: 蒋一一喂奶了30毫升// output: semantic : {   slots : {     event_type : [      {         prob : 0. 8787958032333055,         index : {           3-5 :  喂奶         },         raw_data :  喂奶 ,         norm_value :  喂奶       }    ],     quantity : [      {         prob : 0. 9999999999999982,         index : {           6-10 :  30毫升         },         raw_data :  30毫升 ,         norm_value :  30       }    ]  },}技术设计思路: 微信机器人: 相比语义开放平台，微信API的部分就比较简单直接。 我直接参考了wechaty的ding-dong-bot. js代码，直接把onMessage加入对出门问问开放平台的调用，然后就可以写入GoogleDoc数据存储以便之后分析。详细代码我会更新在我的代码仓库。 不过，在前期调研的过程中，也看了很多不同的微信代码库，包括以前用过的itchat也无法登录个人微信了。除了其他的基于dll代码注入的方法，wechaty是我尝试下来唯一能用的API了。不过长期来讲，利用个人微信号来做机器人本来就是风险很大的事情，所以我在代码设计的时候也做了抽象封装，便于如果真的个人微信API不能用的情况下，方便移植到其他平台（微信公众号、企业微信等等）。 延伸：是否存在商业价值: 这个小机器人本身难度不是很大，它能替代的事情也无非是帮忙记录带娃过程中的一些数据而已，甚至不比手动记录或者excel记录方便多少。 但我觉得这个项目更重要的意义是打通了微信工作流，通过自然语言处理的方式将平时的自然语言转换成计算机可以处理的结构化语义，这样就可以在此基础上搭建各种自动化流程。 各种智能客服、RPA机器人平台也就是为了这个愿景而创造出来的。不过这些基于通用场景的平台工具，在有些时候仍然缺乏灵活性以支持自己的实际场景。 因此，我想通过这个小项目，探索出来一套低成本的DIY自动化工作流程，以便之后复制到更多的个人工作流中。 "
    }, {
    "id": 33,
    "url": "https://wechaty.js.org/2021/10/12/kai-yuan-she-2021/",
    "title": "今年的 COSCon 中国开源年会，让我们聊点不一样的",
    "body": "2021/10/12 - 人们常常说，在熬过了数十年寒冬，2020 -2021 我们终于迎来了本土开源的拐点，国家政策的引导、基础软件的崛起、开放协作精神的觉醒……各种各样的数据报告也无一不支撑着这一观点。 Wechaty 自创建以来坚持深根于Conversation RPA SDK领域，目前Star数量 11000+，支持微信、钉钉、飞书、WhatsApp、Gitter以及WhatsApp等多IM平台，此外也支持多种不同的编程语言，如JavaScript/TypeScript、Python、Java、Go、Scala等，只需要行代码即可开发出聊天机器人。 第六届中国开源年会终于在10. 30号&amp;10. 31号开始了，此次Wechaty社区也积极参与此次活动，分别有如下分享：  《Wechaty 开源社区文档协作 Google Season of Docs 实践分享》 ~ from Huan 《OSS. Chat - 通往 Apache Way 的一道虹桥》 ~ from jiarui 《基于wechaty和paddlepaddle的智能对话机器人》 ~ from wj-Mcat非常欢迎大家届时参加，观看不同领域的实践经验分享。以下是COSCon’21的相关介绍。  | 作者：COSCon’21 组委会| 编辑：钱英宇| 设计：朱亿钦| 责编：王玥敏原文地址  GitHub 2015 - 2020 年事件日志量、活跃仓库数量、活跃账号数量总体情况 今年我被委以重任，负责中国开源年会主论坛的出品，这让我既兴奋又惶恐，我思考着，站在这一行业发展的“历史拐点”，我们到底要和大家聊些什么？我们渴望做出真正有意义又有特色的优质内容。 思考后，我和我们开源社理事长庄表伟老师达成共识，今年主论坛的策划将围绕以下几个关键词展开 —— 多样性、跨学科、对话未来、开心开源。帮助更多人入门开源！ 开源的历程筚路蓝缕，开源的未来充满机遇与挑战，然而由于热爱开源，我们能一路开心地坚持走下去。今年大会的主题是开心开源，我们希望能将「为何开源是开心的？什么样的开源叫开心？如何参与开源才能开心？」的理念与多样化的实践，清晰地分享给更广大的观众。 第一篇章: 今年是 Linux 诞生的第 30 个年头，回望“激荡三十年”，在主会场的【第一篇章】，我们计划从技术、文化、社区、到商业，与大家聊聊“开源从哪里来？” 这一行需要居中第一篇章：激荡三十年（开源的 1991-2021)计算机技术发展（开源技术发展）↓开源文化的兴起↓开源社区的诞生与繁荣↓开源商业：从饱受争议到崭露头角↓圆桌：激荡三十年，开源带给人们的启发第二篇章: 站在历史拐点，展望即将进击的未来十年，在主会场的【第二篇章】，我们计划和大家聊聊教育、新技术、面向未来的开源社区和开源商业，他们将决定着“开源到哪里去？” 第二篇章：进击十年（开源的 2022-2032）开源教育：让更多人迈出第一步↓开源与新技术（新一代操作系统、数据库、云原生、AI、区块链等）↓圆桌：进击的未来十年，开源技术何去何从↓开源社区：面向未来的开源社区↓开源商业：成为开源独角兽↓圆桌：进击的未来十年，开源商业何去何从第三篇章: 进击的十年，由谁去实现？面向未来的，是社区里千千万万的贡献者开源包罗万象，跨学科，也跨人种、跨性别、跨职业，千人千面……人是社区的核心在第三篇章，我们想最大限度地为大家展现开源万象“未来十年，谁带我们进击”第三篇章： 开源万象，Peaple in CommunityWelcome Diversity在第三篇章，我们想邀请社区中 100 位同学，每人 1~2 分钟让更多人了解“活生生”的社区如果你愿意和我们一起站到历史拐点的舞台如果你愿意和我们一起研读历史、展望未来**我们在 COSCon'21 中国开源年会等你！** 相关链接     COSCon’21 社区征集令–开心开源、进行到底   重启：COSCon’21 讲师征集令 1+N   重启：第六届中国开源年会 (COSCon’21) 1+N   "
    }, {
    "id": 34,
    "url": "https://wechaty.js.org/2021/10/09/summer-2021-wechaty-soc-final-demo-day/",
    "title": "Wechaty OSPP(开源之夏) Final Demo Day",
    "body": "2021/10/09 - “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 Wechaty 作为中国最大的聊天机器人开源项目，合计发布了9个项目，共收到来自上海大学、华东理工大学、长沙理工大学、中国科学技术大学、电子科技大学等高校的几十份申请。 此次的9个项目的学生开发者，均录制了一份路演视频，向社区介绍具体的项目进展和后续规划。除了按顺序播放视频，还会邀请社区导师和开发者进行评价和指导，并给出切实有效的建议。 此外，开发者们可以在路演日中找到自己感兴趣的项目，并在路演日结束后，与对应的开发者取得联系并在后续共同开发。 开发者和项目地址：    Wechaty Open Source Promotion Plan 2021 Kickoff Meeting     项目地址  结项汇报（Final-Term Demo Day）会议纪实: {% include iframe. html src=”https://www. youtube. com/watch?v=xqJN3NmGukg”%} You can learn more from our meeting_notes Agendas议程:  0:00:00 0. 会议开始 0:08:30 1. 介绍会议议程 0:10:30 2. 陈婧：开发基于 Wechaty 实现微俱乐部会员&amp;活动管理的微信小程序 0:29:40 3. 肖良玉:基于 Itchat为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet 0:46:50 4. 张瑞宁,邵琦:开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块 1:05:00 5. 马田慧:基于开放 API 封装 Wechaty 接口下的飞书聊天机器人 1:19:30 6. 刘靖:基于 Blessed 的 Wechaty 命令行文本客户端软件（仿IRC） 1:34:00 7. 林宇靖，张瑞宁:基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善 1:51:00 8. anaivebird:开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块 2:21:30 9. 左雁茹:基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善 2:42:40 10. 井维嘉: 基于Wechaty 开发开源的二师兄社群逗乐机器人 3:09:56 11. 总结Wechaty 期末项目列表: Wechaty 在多平台、多功能多个维度上，共发布了 9 项任务，并通过 issue 的方式进行每周的更新。如果你有看到感兴趣的项目，可以直接在对应 issue 下面找到负责对应任务的开发者。 你可以在查看首次KickOff博客了解更多信息。 开发基于 Wechaty 实现微俱乐部会员&amp;活动管理的微信小程序:  导师：鲁玉超 物联网行业产品经理、微信小程序群组大师开发者（atorber@163. com） 学生开发者：陈婧，华东理工大学本科生（1017137803@qq. com） 项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/78 OSPP 2021-期初报告-开发基于微信实现微俱乐部会员&amp;活动管理的微信小程序 OSPP 2021-期中报告-开发基于微信实现微俱乐部会员&amp;活动管理的微信小程序 OSPP 2021-结项报告-开发基于Wechaty实现微俱乐部会员&amp;活动管理的微信小程序展示视频: {% include iframe. html src=”https://www. youtube. com/watch?v=eSgaD32njVw” %} Live Demo 视频: {% include iframe. html src=”https://www. youtube. com/watch?v=5LZ08re5YR8” %} 基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet:  导师：吴京京 Python Wechaty creator，Wechaty committer （wjmcater@gmail. com）；李卓桓 Wechaty creator，Python Wechaty maintainer，Tencent TVP of Chatbot （zixia@zixia. net） 学生开发者：肖良玉，杭州电子科技大学本科生（x@lyleshaw. com） 项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/75 OSPP 2021-期初报告-基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet OSPP 2021-期中报告-基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet OSPP 2021-结项报告-基于Itchat为Python Wechaty实现社区首个Python语言的本地Puppet展示视频: {% include iframe. html src=”https://www. youtube. com/watch?v=SKhgnRaljzk” %} Live Demo 视频: {% include iframe. html src=”https://www. youtube. com/watch?v=fGjEd5O97lQ” %} 开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块:  导师：康嘉 硬核桃社区PM （sj-kangj@dimpt. com）；李佳芮 Wechaty co-creator，Founder &amp; CEO of Juzi. BOT （rui@chatie. io） 学生开发者：张瑞宁，长沙理工大学本科生（3134191406@qq. com）；邵琦（shaoqichn@qq. com） 项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/74 OSPP 2021-期初报告-开发支持电信运营商5G Chatbot/RCS的 Wechaty接入Puppet模块 OSPP 2021-期中报告-开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块 OSPP 2021-结项报告-开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块展示视频: {% include iframe. html src=”https://www. youtube. com/watch?v=cQydTnaym7Y” %} Live Demo 视频: {% include iframe. html src=”https://www. youtube. com/watch?v=4-0lW0kvelE” %} 基于开放API封装 Wechaty 接口下的飞书聊天机器人:  导师： 范蕊 飞书Puppet作者 （froxanne1024@gmail. com） 学生开发者：马田慧（tianhuima01@gmail. com） 项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/38 OSPP 2021-期初报告-基于开放 API 封装 Wechaty 接口下的飞书聊天机器人 OSPP 2021-期中报告-基于开放 API 封装 Wechaty 接口下的飞书聊天机器人 OSPP 2021-结项报告-基于开放 API 封装 Wechaty 接口下的飞书聊天机器人展示视频: {% include iframe. html src=”https://youtu. be/-HOF0LV1d54” %} Live Demo 视频: {% include iframe. html src=”https://youtu. be/lH3giTpdOtM” %} 基于 Blessed 的 Wechaty 命令行文本客户端软件（仿IRC）:  导师：李卓桓 Creator of Wechaty，Tencent TVP of Chatbot （zixia@zixia. net） 学生开发者：刘靖，上海大学本科生（liuchinggg@gmail. com） 项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/80 OSPP 2021-期初报告-基于 Blessed 的 Wechaty 命令行文本客户端软件 OSPP 2021-期中报告-基于 Blessed 的 Wechaty 命令行文本客户端软件 OSPP 2021-结项报告-基于 Blessed 的 Wechaty 命令行文本客户端软件展示视频: {% include iframe. html src=”https://youtu. be/PssH9epe0tU” %} Live Demo 视频: {% include iframe. html src=”https://youtu. be/D5QbX183kb8” %} 基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善:  导师：yswtrue Wechaty contributor （yswtrue@gmail. com），李卓桓 Creator of Wechaty，Tencent TVP of Chatbot （zixia@zixia. net） 学生开发者：林宇靖, 上海海洋大学本科生（545641826@qq. com）；张瑞宁, 长沙理工大学本科生（3134191406@qq. com） 项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/59 OSPP 2021-期初报告-基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善 OSPP 2021-期中报告-基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善 OSPP 2021-结项报告-基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善展示视频: {% include iframe. html src=”https://www. youtube. com/watch?v=3j3BGRnoVtE” %} Live Demo 视频: {% include iframe. html src=”https://www. youtube. com/watch?v=qtbExkN0uoI” %} 开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块:  导师：李佳芮 Wechaty co-creator，Founder &amp; CEO of Juzi. BOT （rui@chatie. io）；李卓桓 Creator of Wechaty，Tencent TVP of Chatbot （zixia@zixia. net） 学生开发者：anaivebird（20210240029@fudan. edu. cn） 项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/81 OSPP 2021-期初报告-开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块 OSPP 2021-期中报告-开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块 OSPP 2021-结项报告-开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块展示视频: {% include iframe. html src=”https://www. youtube. com/watch?v=Z2IIPe0FLA4” %} Live Demo 视频: {% include iframe. html src=”https://www. youtube. com/watch?v=TbIgFhSWVxI” %} 基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善:  导师：吴京京 Python Wechaty creator，Wechaty committer （wjmcater@gmail. com） 学生开发者：左雁茹，中国科学技术大学研究生（zuoyanru@mail. ustc. edu. cn） 项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/82 OSPP 2021-期初报告-基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善 OSPP 2021-期中报告-基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善 OSPP 2021-结项报告-基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善展示视频: {% include iframe. html src=”https://www. youtube. com/watch?v=ySxpkKjv018” %} Live Demo 视频: {% include iframe. html src=”https://www. youtube. com/watch?v=iVyutBZMZRE” %} 基于Wechaty 开发开源的二师兄社群逗乐机器人:  导师：王玉丹 Wechaty Contributor，AI Chatbot Wechaty x PaddleHub UP主，Wechaty社区大使 （valeriewyd@gmail. com）；鲁玉超 物联网行业产品经理、微信小程序群组大师开发者 （atorber@163. com）；韩磊 百度飞桨PPDE，飞桨上海领航团团长 （iregisteru@163. com） 学生开发者：井维嘉，海南大学（hbsjzjwj@163. com） 项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/83 OSPP 2021-期初报告-基于 Wechaty 开发开源的二师兄社群逗乐机器人 OSPP 2021-期中报告-基于 Wechaty 开发开源的二师兄社群逗乐机器人 OSPP 2021-结项报告-基于 Wechaty 开发开源的二师兄社群逗乐机器人展示视频: {% include iframe. html src=”https://youtu. be/Na9pGdf_6oY” %} Live Demo 视频: {% include iframe. html src=”https://youtu. be/51EwCNB_Y90” %} 欢迎报名开源之夏 2022！: 报名学生开发者:  在校生都可以报名 原始博客见： OSPP（开源之夏）指导手册 - 2021 Wechaty 的项目 Issue 作为本次同学和导师通知的主要渠道，请所有同学在入选后，务必完成第一件事：在项目清单 Issue 下面，把所有同学和导师需要完成的工作，以 checklist 的形式回复到 Issue 下面，方便后续同学和导师完成相关工作，完成后在 Comment 中打钩确认 Wechaty 社区秉持开源开放的的原则，所有会议记录、在线会议、阶段性报告等视频、文档资料都会对社区完全开放。对自己的视频、文档资料介意开放的同学，请谨慎考虑加入。 参与项目的同学完成 日常工作 和 阶段性工作，具体如下： 学生日常工作: 学生每周在 issue 下回复进度报告。 日常工作以 OSPP 2020 的优秀学生突出贡献奖获得者江姗姗的周报告和导师总结为例，详见编写一个“每日一句”插件 报告模板参考：student-weekly-report-template 学生阶段性工作:  期初报告要求 期中报告要求 期中答辩(Mid-term Demo Day) 期末报告要求 期末答辩(Final-term Demo Day)报名社区导师:  社区的 Contributor 都可以报名 导师日常工作: 导师每周在 issue 下根据学生的进度报告进行评分。 日常工作以 OSPP 2020 的优秀学生突出贡献奖获得者江姗姗的周报告和导师总结为例，详见编写一个“每日一句”插件 报告模板参考：mentor-weekly-report-template 导师阶段性工作:  期初报告评审 期中报告评审 期中答辩(Mid-term Demo Day) 期末报告评审 期末答辩(Final-term Demo Day)报名Wechaty OSPP Org Admin:  当过导师的 Wechaty Contributor 可以报名 工具包:  社区 Repo: https://github. com/wechaty/summer 社区通知 Issue：https://github. com/wechaty/summer/issues/筹备会中完成后确认的项目清单链接 社区微信群：Summer of Wechaty - SoW 社区 Org Admin 组委会群：Summer of Wechaty Org Admin SoW Wechaty Contributor 群：Wechaty Contributors 所有发布到 Wechaty 的博客需要打上如下标签：     ospp-admin   summer-2022   summer-of-wechaty   ospp   ospp-2022   Org Admin 阶段性工作:  筹备阶段 期初见面会 期中报告状态收集 &amp; 答辩 期末报告状态收集 &amp; 答辩 复盘 &amp; 展望欢迎正在阅读的你参与其中: 虽然“暑期2021”的报名已经结束，但Wechaty社区依然欢迎正在阅读本篇内容的你参与到暑期2021的工作中来。以下是几种可能的参与方式：  时刻跟进Wechaty SoC项目的每周例行更新Issue，并直接与相关负责导师和学生开发者取得联系，和他们交流相关进展。 在 Wechaty 开发者群内，为学生开发者们的Plan Blog、POC Blog和Finished Blog点赞和提出想法。 直接参与已经完成部分工作的项目开发，为学生开发者们负责的复杂项目添砖加瓦。 了解更多"
    }, {
    "id": 35,
    "url": "https://wechaty.js.org/2021/10/09/how-to-save-your-memory-with-technology/",
    "title": "小白入门：如何用科技拯救你的记忆力",
    "body": "2021/10/09 - 过去的一周接触到了 wechaty ，非常兴奋，首先对于这个神奇的东西感到惊奇，其次我是一个比较喜欢解决问题的人，可以用它解决很多实际问题，于是便开始了我的 wechaty 之路，下面和大家简单说一下我做的一个小demo，本文介绍使用的技术都是基本中的基本，几乎是对前端技术稍有了解的人就可以轻易完成，此举旨在帮助刚接触 wechaty 的同学（包括我）建立信心，不至于被挫败感吓跑。 开发需求: 这个小功能的需求来源于我老婆，作为一个科研工作者，她在工作当中需要记录的东西很多，但有些情况又不能及时记录，所以常常会把一些需要记得东西发给我（如图），然后我一脸懵的还以为要我做什么，但是慢慢也就习惯人肉备忘录的设定，歪个楼，我老婆就是我的产品经理，碰到问题就找我，我的很多技术也是这样学会的： 但是这种方法的弊端很多，微信毕竟是聊天软件，聊天记录掺杂过多，检索起来费时费力等缺点，于是我就尝试着寻找解决方法，此时恰巧碰到 wechaty，简单了解后，它完全解决了我当前的痛点，简就是直万事俱备，只欠coding了，话不多说，说干就干。 项目目录: 本次主要介绍的是onMessage. js 中的内容  memory-assistant  |── src  |  |── index. js     # 入口文件  |  |── config. js # 配置文件  |  |── onScan. js # 机器人需要扫描二维码时监听回调  |  |── onLogin. js # 监听登录  |  |── onMessage. js   # 消息监听回调  |  └── storage-room. json # 存储信息保存文件  └── package. json      # 项目初始化文件准备工作: 技术需求: 由于本人刚接触，所以尽量以最少的代码量及技术栈来实现功能    wechaty   wechaty：用来接收微信发来的消息以及根据对应指令进行处理及响应     nodeJs 基本操作   fs 文件操作模块：用来操作读写功能，实现数据保存   path 系统路径模块：用来获取存储文件位置等操作     javascript 相关技术   本文默认读者已熟悉 js 基本知识，如数组遍历、字符串拼接等相关操作  开发过程: 项目构建:    wechaty 引入及协议配置   初始化项目文件夹，并安装以下依赖   // 链接转化二维码控制台输出 cnpm i qrcode-terminal -D  // wechaty核心包 cnpm i wechaty -D  // ipad协议包 按个人不同的token切换不同协议 cnpm i wechaty-puppet-padlocal -D    wechaty官网   token申请   如果没有 pad 协议 token 的可参考web协议，感谢作者@Leo chen分享，需要注意的是web协议获取不到固定的id值以及部分接口无法使用，但是如果只针对一个人的话是可行的。     入口文件 index. js 编写   const { Wechaty } = require( wechaty ); const { PuppetPadlocal } = require( wechaty-puppet-padlocal ); const QrcodeTerminal = require( qrcode-terminal ); const onMessage = require('. /onMessage. js') const bot = new Wechaty({  puppet: new PuppetPadlocal({   token:  puppet_padlocal_token , // 填写自己的token，一般长这样puppet_padlocal_asd4a564d56ad456s4d6a4256515  }), });   bot  // 扫码登录  . on( scan , (qrcode, status) =&gt; {   console. log(`Scan QR Code to login: ${status}\nhttps://api. qrserver. com/v1/create-qr-code/?data=${encodeURIComponent(qrcode)}`);   QrcodeTerminal. generate(qrcode);  })  // 登录监听  . on( login , (user) =&gt; {   console. log(user,  logined );  })  // 消息监听  . on( message , onMessage)  . start();      消息处理文件 onMessage. js 文件之存东西   // 发消息人 const contact = msg. talker(); // 消息内容 const content = msg. text(). trim(); // 是否是群消息 const room = msg. room(); if (!room) {  // 当前只处理非群消息，如果需要处理群消息可以利用 mention 相关接口  if (   content ===  存东西  ||   content ===  怎么存东西  ||   content ===  咋存东西  ||   content ===  如何存东西   ) {   contact. say(     你可以发送：存东西 钥匙 笔筒里 ，这样我就会帮你把钥匙存到笔筒里哦    );  } else if (content. indexOf( 存东西 ) &gt;= 0) {   //文件路径，__dirname为当前运行js文件的目录   var file = path. join(__dirname,  . /storage_room. json );   let storageInfo = content. replace( 存东西  ,   ). split(   ); // ['钥匙', '鞋柜上']   //读取json文件   fs. readFile(file,  utf-8 , function (err, data) {    if (err) {     console. log( 文件读取失败 );    } else {     // json 文件的数据     let storage = eval( (  + data +  ) );     // 检查当前用户是否储存过     let currentUser = storage. find((item) =&gt; {      return item. id == contact. id;     });     // 数据库没有该用户，需要新建用户     if (!currentUser) {      console. log( 当前用户没存储过，开始存储 );      // 没存过 ==&gt; 新增      let tempVal = {       id: contact. id,       data: [        {         name: storageInfo[0],         place: storageInfo[1],         date: new Date(),        },       ],      };      storage. push(tempVal);      fs. writeFile(        . /storage_room. json ,       JSON. stringify(storage),       function (err) {        if (err) {         console. error(err);        }        contact. say(`已经把${storageInfo[0]}放在${storageInfo[1]}了 [OK]`);       }      );     } else {      // 数据库存在当前用户      let oldPlace =   ;      console. log( 当前用户存储过，添加物品或更改位置 );      // 存过 ==&gt; 更新位置      let obj = currentUser. data. find((item) =&gt; {       return item. name == storageInfo[0];      });      // 如果当前物品储存过，就需要更改位置      if (obj) {       // 更改位置       oldPlace = obj. place;       obj. place = storageInfo[1];       obj. date = new Date();      } else {       // 如果当前物品没储存过，需要将当前物品push到储存列表中       let newStorage = {        name: storageInfo[0],        place: storageInfo[1],        date: new Date(),       };       currentUser. data. push(newStorage);      }      // 写入文件添加物品      fs. writeFile(        . /storage_room. json ,       JSON. stringify(storage),       function (err) {        if (err) {         console. error(err);        }        if (obj) {         // 更改位置文案提示         contact. say(          `已经把${storageInfo[0]}从${oldPlace}挪到了${storageInfo[1]}了 [OK]`         );        } else {         // 新建位置文案提示         contact. say(`已经把${storageInfo[0]}放到${storageInfo[1]}了 [OK]`);        }       }      );     }    }   });  } }      消息处理文件 onMessage. js 文件之找东西   主要逻辑是读取仓库文件，遍历仓库当前存储的用户中有没有当前发起请求的用户，没有的话就开始新建，如果该用户已经存储过，则查看当前用户请求存储的物品有没有在仓库中存储过，如果之前存储过该物品，则进行位置更新，如果之前没存储过该物品，则进行新建。    // 因与 step3 在同一个文件内，相关变量来源课参考 step3  if (content. indexOf( 在哪 ) &gt;= 0) {   //文件路径，__dirname为当前运行js文件的目录   var file = path. join(__dirname,  . /storage_room. json );   //读取json文件   fs. readFile(file,  utf-8 , function (err, data) {    if (err) {     console. log( 文件读取失败 );    } else {     let storage = eval( (  + data +  ) );     let currentUser = storage. find((item) =&gt; {      return item. id == contact. id;     });     if (!currentUser) {      return contact. say(        你还没有东西存在我这里哦，可以发送：存东西 钥匙 鞋柜上，这样我就能帮你把钥匙存到鞋柜上啦       );     }     let findThing = currentUser. data. find((item) =&gt; {      return item. name == content. replace( 在哪 ,   );     });     if (!findThing) {      return contact. say(       `仓库里还没有 ${content. replace(         在哪 ,                 )} 哦，可以发送 找东西 来查看仓库列表~`      );     }     contact. say(      `你忘了吗，你把 ${findThing. name} 放在了 ${findThing. place} ，找到了别忘了来感谢我哦~ `     );    }   });  } else if (content. indexOf( 找东西 ) &gt;= 0) {   //文件路径，__dirname为当前运行js文件的目录   var file = path. join(__dirname,  . /storage_room. json );   //读取json文件   fs. readFile(file,  utf-8 , function (err, data) {    if (err) {     console. log( 文件读取失败 );    } else {     let storage = eval( (  + data +  ) );     let currentUser = storage. find((item) =&gt; {      return item. id == contact. id;     });     if (!currentUser) {      return contact. say(        你还没有东西存在我这里哦，可以发送：存东西 钥匙 鞋柜上，这样我就能帮你把钥匙存啦！       );     }     let list =  储物清单\n\n ;     currentUser. data. forEach((item, index) =&gt; {      list += index + 1 +  .   + item. name +  在  + item. place +  \n ;     });     // 返回清单     contact. say(list);    }   });  }       仓库存储文件storage-room. json 内容     [   {     id :  tester ,     data : [     {       name :  靴子 ,       place :  鞋柜里 ,       date :  Sun Oct 10 2021 14:31:06GMT+0800      },     {       name :  电脑 ,       place :  书房桌子上 ,       date :  Sun Oct 08 2021 18:21:06GMT+0800      },     {       name :  钱包 ,       place :  床头柜里 ,       date :  Sun Oct 04 2021 09:14:06GMT+0800      },     {       name :  保鲜膜 ,       place :  厨柜里 ,       date :  Sun Oct 09 2021 18:51:06GMT+0800      },     {       name :  钥匙 ,       place :  笔筒里 ,       date :  Sun Oct 08 2021 08:16:06GMT+0800      },     {       name :  乒乓球 ,       place :  阳台储物柜 ,       date :  Sun Oct 06 2021 15:17:06GMT+0800      }    ]   }  ]      消息处理流程示意图    graph TD  A[Start] --&gt; B(接收到存储请求)    B --&gt; C(读取数据库json文件)    C --&gt; D(是否存在该用户)    D --&gt; |Y| E(是否存在该物品)    E --&gt; |Y| I(更新物品位置)    I --&gt; |T| K(返回成功信息)    I --&gt; |F| L(返回失败信息)    K --&gt; | | Z[End]    L --&gt; | | Z    E --&gt; |N| J(创建物品位置)    J --&gt; |T| M(返回成功信息)    J --&gt; |F| N(返回失败信息)    M --&gt; | | Z    N --&gt; | | Z    D --&gt; |N| F(创建该用户以及物品位置)    F --&gt; |T| G(返回成功信息)    F --&gt; |F| H(返回失败信息)    G --&gt; | | Z    H --&gt; | | Z    效果   作者: stefan，流水线 coder，曾获得学习委员和尊师标兵荣誉称号。 "
    }, {
    "id": 36,
    "url": "https://wechaty.js.org/2021/10/09/gsod-document-quality-final-report/",
    "title": "Google Season of Docs 2021 Volunteer Report: Document Quality",
    "body": "2021/10/09 - It’s a great honor to be part of Wechaty family in Google Season of Docs 2021. This report demonstrates the improvement of document quality. Abstract: After solid four months in Google Season of Docs in Wechaty, we 13 technical writers had successfully created more than 130 pieces of new content, one demonstration video, one advertising video, and a brand-new landing page for Wechaty. Being a volunteer/ technical writer lead in charge of the quality of documents written by other 11 technical writers in the project, the journey was precious and wonderful. I also grew a lot when reviewing over 150 pull requests on Github, ranging from new topics to documentation structure updates. Working with such a large team is never easy, especially when most other tech writers are developers who didn’t have official technical writing training before. Improvement: Before we started the GSoD project, the existing documentation of Wechaty had some issues. The committee updated documents like blog posts. Whenever the committee came up with some ideas or per user requests, they created user guides for specific topics. The information was scattering and wasn’t well-organized. Basically, in the beginning, there were only some documents about the installation or basic implementation of the software that were rather explicit. For the rest, instead of documents, they were more like technical notes that weren’t formatted logically. Structure: For the reasons above, we set the Wechaty documentation structure as the table below, which Divio. com proposed. The team paired up in groups based on the following divisions, and I worked as a final reviewer.  After we had finalized the structure, it was time to determine the content inside. I analyzed the overlaps and topics inside each section in Documentation structure. In the article, I had each team propose their frameworks first and then compare theirs with other groups’. As there were going to be four sections for the same software Wechaty, one of my jobs was to collect all the documents together and ensure no missing topics or overlaps. The first approach I took was to identify the classifications again. Rather than adding as much content as possible, each subject should focus on the goal they would like to achieve. We should provide a clear boundary of each section for user-friendliness and document maintenance in the future. Later in the meeting, I had the teams talk about their respective proposals and discuss the distribution with similar topics in other groups. Tutorials: Tutorials are usually the first documents that users encounter when they start Wechaty. At this moment, the users had no prior knowledge of the software and might not be experienced in the SDK world either. The purpose of the tutorials is to teach our audience how to use Wechaty from scratch. According to the reasons above, the tutorials are organized in terms of levels of difficulty. The audience is initially introduced to the elementary use cases and then moved on to advanced examples. Examples are shown in Starter bot. It is the very beginning bot with no actual functions. As the user learned more methods about Wechaty, they could create complex bots like Tuling 123 bot. How-to guides: For documents like tutorials and how-to guides, these instruction-based documents should explicitly guide how to reach the results. These include step-by-step guides, preparation, and reference links to provide related information or lead users to the correct page if they run into some troubles. Here is an example of how I modified the structure of the content in how-to guides. Originally it was formatted as topic, introduction, and then listed down two functions. See the following picture.  The original one was ok for API reference documents but wasn’t suitable for how-to guides as it provided no instructions but information only. The updated version published as Manage contact is more user-friendly if they ask a specific question, “how to manage contact?” Reference: Let’s take a look at the reference section. A reference section is designed to include technical descriptions only and is information-oriented. Typical reference procedures include tables or bulleted lists, which present a large quantity of data in an organized way. An example of my modification could refer to Added Wechaty token section (my account as proudofsimin). The format was reconstructed to prevent giving instructions, and we should list down all the information. Some minor syntax errors or writing tone should also be considered, such as the sentence structures were supposed to be coherent in the article, and the active voice was more favorable than passive. Explanation: When it comes to the introduction and explanation section, the section is unique in content as it contains information about the background knowledge of the software. Despite it being a technical article, some marketing purposes should be included to promote to a more significant number of people. In the example Who is using Wechaty?, the sub-section of the introduction section, the target audience isn’t those already using Wechaty, but those still considering applying Wechaty to their work. As the screenshot is shown in the pull request, the original version implied that most users are Chinese companies. Though there was nothing wrong with this statement, when it comes to users outside China, it doesn’t look so attractive to them as the article described the software as a local application rather than recognized around the world. In the revised version, the word “Chinese” is eliminated and focused on the part that those companies are multinational with customers around the globe. "
    }, {
    "id": 37,
    "url": "https://wechaty.js.org/2021/10/07/ospp-final-term-5g-chatbot-puppet/",
    "title": "OSPP 2021-结项报告-开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块",
    "body": "2021/10/07 - [开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块]信息:  导师：[李佳芮 康嘉 李卓桓] 学生：[张瑞宁 邵琦] 项目介绍：https://github. com/wechaty/summer/issues/74 项目名称： 开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块 方案描述：     使用5g Chatbot接口，把收发消息测通   使用 https://github. com/wechaty/wechaty-puppet-official-account 项目作为模版，将其中的微信公众平台调用全部封装为RCS模块的调用   发布 Git Repo wechaty-puppet-5g-msg，实现文本消息的发送和接收   进行测试，完善项目文档   配置 GitHub Actions 实现自动化测试（可选）    时间规划：     使用5g Chatbot接口，把收发消息测通         7/12 - 7/18     配置好服务器，测通相关接口          使用 https://github. com/wechaty/wechaty-puppet-official-account 项目作为模版，将其中的微信公众平台调用全部封装为RCS模块的调用         7/19 - 8/10     学习现有源码，学习RCS的相关知识。     接入wechaty，进行代码整合，提高代码质量。          项目中期总结         8/11 - 8/15     实现阶段性目标，总结项目阶段性成果。          发布 Git Repo wechaty-puppet-5g-msg，实现文本消息的发送和接收         8/16 - 8/31     提供一个 examples/ding-dong-bot. ts ，完成“接收到文字消息ding时，自动回复消息dong”的功能          项目完善优化         9/1 - 9/15     撰写整个项目过程的总结博客。配置 GitHub Actions 实现自动化测试，增加单元测试等。          项目结项         9/16 - 9/30     总结项目成果，项目经验，准备结项材料。          项目总结:  项目成果：     测通了RCS接口，在终端发送ding时，可以收到dong   对wechaty和puppet的源码进行了学习，尝试理解消息发送的流程   提交了初期和中期博客   完成了wechaty-puppet-walnut模块，把puppet的消息收发流程测通    遇到的问题及解决方案：     这是我第一次参加开源项目，是一次很棒的体验，在此次项目中我体验到了完整的开源项目的贡献流程，认识了很多技术大佬，学会了使用issue和pr来参与项目的讨论，熟悉了ts和nodejs的使用。由于自己的知识储备不足，开发过程并不顺利，很感谢导师对我的包容，从最初的测通RCS接口到接入puppet，我主动和导师交流的次数不多，遇到问题没有及时反馈，找到的资料也不多，以至于项目的进度非常缓慢，沟通交流能力在一个团队中是非常重要的一点，而这也是我非常欠缺的一个方面，后面我会在这方面进行改进    项目展望：     发布npm包，连接wechaty-puppet-getting-started项目。   丰富项目功能，增加发送图片等富文本消息的功能。   项目成果: 项目仓库: https://github. com/wechaty/wechaty-puppet-walnut npm包：https://www. npmjs. com/package/wechaty-puppet-walnut live coding视频：: {% include iframe. html src=”https://www. youtube. com/watch?v=4-0lW0kvelE” %}  国内版：https://www. bilibili. com/video/BV1b44y1t7vz PPT展示视频：: {% include iframe. html src=”https://www. youtube. com/watch?v=cQydTnaym7Y” %}  国内版：https://www. bilibili. com/video/BV12L4y1z7sQ 项目PPT：: {% include iframe. html src=”/assets/2021/10-ospp-final-term-5g-chatbot-puppet/5g-chatbot-ppt. pdf” %} 联系我们:  项目链接：https://github. com/wechaty/summer/issues/74 联系方式：     张瑞宁：3134191406@qq. com   邵琦：shaoqichn@qq. com   “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 本项目 [开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块] 系 暑期2021 支持的开源项目。 "
    }, {
    "id": 38,
    "url": "https://wechaty.js.org/2021/10/06/ospp-final-term-wechaty-piggy-bro/",
    "title": "OSPP 2021-结项报告-基于 Wechaty 开发开源的二师兄社群逗乐机器人",
    "body": "2021/10/06 - 暑期2021: “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。官网：https://summer. iscas. ac. cn/ 本项目 [基于 Wechaty 开发开源的二师兄社群逗乐机器人] 系 暑期2021 支持的开源项目。 项目信息:  导师：韩磊、鲁玉超、王玉丹 学生：井维嘉   项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/83     项目名称：基于 Wechaty 开发开源的二师兄社群逗乐机器人     方案描述   本项目需要基于Wechaty开发一个多功能群聊机器人。   该机器人的核心功能是编写并配置拦截器来实现对消息的响应。拦截器是一种固定传入参数和返回值类型的函数，通过编写拦截器的逻辑，可以拦截消息或放行消息给下一个拦截器，同时做出一定的响应。   本项目预置了若干功能，如查天气、讲笑话、成语接龙、猜字谜等以供使用和参考。同时，本项目希望能够允许用户自行添加功能，所以用户可以通过自己编写拦截器的方式，来为机器人添加功能。   本项目也将提供一个二师兄后花园页面，作为扩展的帮助文档、状态查询和日活功能使用。     时间规划：      开发可扩展式开发框架（7. 1-7. 7）         熟悉Wechaty开发模式     搭建二师兄开发脚手架          具体功能实现（7. 8-7. 30）         初步实现要求中的具体功能，可能包括且不限于：讲笑话、看热搜、查天气、成语接龙、猜图片、猜歌名     初步编写相关功能API的注册与部署文档          设计二师兄Logo及形象（8. 1-8. 7）         为二师兄的Logo和形象做出初步描述     Logo及形象定稿          开发二师兄后花园（8. 8-8. 30）         设计后花园功能和页面布局     搭建二师兄后花园服务及页面          编写文档与完善功能（9. 1-9. 30）         编写使用、部署及开发文档     整理代码并完善功能          项目总结: 项目仓库：https://github. com/ReiKohaku/piggy-bro 项目成果: 截至到项目结束，取得了如下成果：  搭建了在任意支持的环境中可以自行部署的开箱即用的微信机器人。 内置了讲笑话、查天气、搜音乐、看热搜、成语接龙和猜字谜六项基本娱乐功能。 设计了“具备电子感、偏卡通的、类似大众心目中传统二师兄形象”的Logo。 编写了基本的后花园服务和页面，通过阅读文档可以学会部署的方法。后花园提供了使用帮助和状态查询两个模块。 编写了详细的部署文档，以及功能开发相关的文档。项目原计划的核心目标已经全部完成。 Live Code视频: {% include iframe. html src=”https://www. youtube. com/embed/51EwCNB_Y90” %} 国内链接：https://v. qq. com/x/page/t3300psc439. html PPT展示视频: {% include iframe. html src=”https://www. youtube. com/embed/Na9pGdf_6oY” %} 国内链接：https://v. qq. com/x/page/m3300a8rnft. html 项目PPT: {% include iframe. html src=”/assets/2021/10-ospp-final-term-wechaty-piggy-bro/final-ppt. pdf” %} 其它:    联系方式：   微信：ReiKohakuE-mail：hbsjzjwj@163. com  "
    }, {
    "id": 39,
    "url": "https://wechaty.js.org/2021/10/06/ospp-final-term-qq-puppet/",
    "title": "OSPP 2021-结项报告-开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块",
    "body": "2021/10/06 - 本项目通过 Wechaty Puppet 的接口，可以将 QQ 进行 RPA 封装，使其成为 wechaty-puppet-oicq 供 Wechaty 开发者方便接入 QQ 平台，使其成为 Wechaty 可以使用的社区生态模块。 “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 本项目 [开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块] 系 暑期2021 支持的开源项目。 开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块: 项目背景: Wechaty 社区目前已经支持微信、Whatsapp、企业微信、飞书等常见流行即时通讯工具，并且能够通过多语言 SDK (比如 Python Wechaty) 进行调用。QQ 是国内和微信并列的两大聊天软件。我们在本次 Summer 2021 的项目中，Wechaty希望可以实现对 QQ Chatbot 的支持。通过 Wechaty Puppet 的接口，可以将 QQ 进行 RPA 封装，使其成为 wechaty-puppet-oicq 供 Wechaty 开发者方便接入 QQ 平台，使其成为 Wechaty 可以使用的社区生态模块。 方案描述: 使用 https://github. com/wechaty/wechaty-puppet-mock 项目作为模版，参考社区其他的 Wechaty Puppet Provider 代码模块，对 QQ 进行规划、RPA 选型、原型测试，和最终的代码封装。构建一个 Wechaty Puppet Provider 模块。 在初期开发中，能够实现文本消息的接收和发送，即可完成原型验证 POC。 项目技术栈:  TypeScript programming language Git RPA时间规划:  第一阶段（7月-8月）         7. 1-7. 10（已如期完成）     先和导师沟通，并观看Wechaty Puppet Provider 的 workshop 视频，熟悉Wechaty Puppet Provider的业务流程，并对自己目前还没有掌握的nodejs、npm、typescript等内容进行快速的了解和学习，对时间安排做好具体的规划           7. 11-8. 15（已如期完成）     开始正式进行代码的prototyping，先完成基础的功能，完成通过 Wechaty 加载 wechaty-puppet-oicq 模块，并通过oicq项目实现的qq协议，实现文本消息的收发功能。每周协同导师进行功能的开发和完善        第二阶段（8月-10月）         8. 16-8. 30（已如期完成）     完成期中 Demo Day 视频和wechaty. js. org上的中期报告。在现有基础上，对显示二维码，保存设备信息等问题进行调研和解决。           9. 1-9. 30（已如期完成）     将项目包上传npm，并与wechaty-getting-started项目相连，使得用户可以通过设置环境变量一键化使用wechaty-puppet-oicq模块。设置github action自动测试代码，并在push版本时自动上传npm。实现了联系人信息的导入（QQ好友的昵称、性别等信息），wechaty bot可以在终端显示发送消息者的QQ昵称。       项目进度: 已完成部分:  ding dong bot完成登录：实现显示QQ登录二维码，并完成扫码登录环节，成功登录账号 ding dong bot消息回复：扫码即可运行QQ机器人，发送ding给机器人，即可收到dong的消息 使得wechaty-puppet-oicq模块启动ESM（ES Modules）的支持（感谢李卓桓导师的帮助） 设置github action自动测试代码，并在push版本时自动上传npm。 与wechaty-getting-started项目相连，使得用户可以通过设置环境变量一键化使用wechaty-puppet-oicq模块。 ContactPayload相关函数的实现：完成联系人信息的导入（QQ好友的昵称、性别等信息），wechaty bot可以在终端显示发送此消息者的QQ昵称。遇到的困难与解决:    wechaty消息处理链路相对复杂，难以理解`   通过咨询项目导师和wechaty飞书机器人负责人等途径，观看社区live coding视频，对消息处理进行快速学习，并通过编码实践，最终成功将oicq的事件和消息格式转换为了wechaty的messageRawPayload，也加深了对框架架构设计的理解。     遇到QQ风控 通过途径弄到了一些QQ小号方便测试。     在CentOS7机器上安装ruby和jekyll遇到较多报错 原因是ruby version manager依赖的GPG keyserver失效，更换新的服务器地址即可     中期报告修改在PR上讨论，和预览看到的实际效果有些差异，对话中导师想要的效果和我的理解可能不太一样，一次次来回比较费时间。感谢李佳芮导师耐心的指导和审核，最终完成了blog的修正。     与wechaty-getting-started项目连接，做成一键化使用的过程中，遇到不少报错。感谢李卓桓导师的帮助下，完成了ESM（ES Modules）的支持，并跑通npm publish的github action，最终成功连接     oicq库会显示额外的命令行调试信息。已经通过查阅文档去除这些信息。  项目成果: 项目仓库: https://github. com/wechaty/wechaty-puppet-oicq npm包：https://www. npmjs. com/package/wechaty-puppet-oicq live coding视频：: {% include iframe. html src=”https://youtu. be/TbIgFhSWVxI” %}  国内版：http://www. iqiyi. com/v_1uv2wbi4p44. html PPT展示视频：: {% include iframe. html src=”https://youtu. be/Z2IIPe0FLA4” %}  国内版：https://www. iqiyi. com/v_1f3m7rhczog. html 项目PPT：: {% include iframe. html src=”/assets/2021/10-ospp-final-term-qq-puppet/final-qq-puppet. pdf” %} 联系我们:  导师：李佳芮 Wechaty co-creator, Founder &amp; CEO of Juzi. BOT (rui@chatie. io) 导师：李卓桓 Wechaty creator, Tencent TVP of Chatbot (huan@chatie. io) 学生：naivebird(github)：20210240029@fudan. edu. cn 项目链接：https://github. com/wechaty/summer/issues/81"
    }, {
    "id": 40,
    "url": "https://wechaty.js.org/2021/10/05/ospp-final-term-wechaty-itchat-puppet/",
    "title": "OSPP 2021-结项报告-基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet",
    "body": "2021/10/05 - “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。官网：https://summer. iscas. ac. cn/ 本项目 [基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet] 系 暑期2021 支持的开源项目。 基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet信息:  导师：吴京京、李卓桓 学生：肖良玉   项目介绍：https://github. com/wechaty/summer/issues/75   项目名称：基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet 方案描述：     L0阶段：         预期效果：熟悉 Itchat 的各项 API ；熟悉 Wechaty Puppet 的开发流程；创建 python-wechaty-puppet-itchat 的 repository 。     实施方案：阅读 Itchat 文档，了解 Wechaty Puppet。          L1阶段：         预期效果：完成 python-wechaty-puppet-itchat 的登录与初始化部分的实现；完成 ding-dong-bot 的实现。     实施方案：了解 python-wechaty-puppet-service 是如何通过 gRPC 与远程服务器通讯的，并结合 Itchat 的设计模式，对比二者异同，思考如何将 Itchat 的函数封装进 wechaty-puppet ，思考 wechaty-puppet 的哪些代码对于该项目而言是不必要的，并完成对 Itchat 中 auto_login 函数的封装。 在此基础上深入了解 Itchat msg_register 函数的实现方法，并在此基础上封装进 wechaty-puppet ，同时完成发送消息函数的封装。同时参考其他 wechaty-puppet 完成 ding-dong-bot. py 并使其能正常运行。          L2阶段：         预期效果：配置 GitHub Action 实现 python-wechaty-puppet-itchat 自动发布到 Pypi 并完成自动化测试。     实施方案：了解 Pypi 的发布流程，并在参考已有 GitHub Action 配置文件的基础上完成自动发布的流程，同时完成自动化测试。          L3阶段：         预期效果：使用 Itchat 的 API 为 python-wechaty-puppet-itchat 实现 User 和 Room 部分的功能。     实施方案：在该阶段，我计划深入了解 Itchat 关于 User 部分的 get_contact 等函数的实现，封装为 Wechaty 的 User 相关模块的功能。同时将 Itchat create_chatroom 等函数封装为 Wechaty Room 模块的功能。          L4阶段：         预期效果：为 python-wechaty-puppet-itchat 实现 Itchat 的其他功能。     实施方案：在该阶段，我计划将 Itchat 剩余的接口根据 Wechaty 的代码风格封装进 python-wechaty-puppet-itchat 。          *L5阶段：         预期效果：完善 python-wechaty 文档。     实施方案：在了解 python-wechaty 的基础上，我计划在 python-wechaty 原有文档的基础上进行完善和补充。           时间规划：     第一阶段（7月-8月）         L0阶段开发 5天     L1阶段开发 10天     L2阶段开发 20天     中期验收          第二阶段（8月-10月）         L3阶段开发 10天     L4阶段开发 15天     L5阶段开发 15天     结项验收          项目总结:  项目产出：     产出1：Python Wechaty Puppet Itchat：https://github. com/wechaty/python-wechaty-puppet-itchat，代码已合并到社区   产出2：PyPi 包：https://pypi. org/project/wechaty-puppet-itchat/，已可以正常使用    方案进度：     已完成工作：         L0阶段：已完成（PR：init code by python wechaty puppet service #1）     L1阶段：已完成（PR：添加scan/login事件 #4 和 Debug emit problem #6 和 Fix emit bugs add receive msg #10）     L2阶段：已完成（PR：Add CI/CD #7 和 Fix code style to pass ci/cd #8 和 PyPi 打包发布：https://pypi. org/project/wechaty-puppet-itchat/)     L3阶段：已完成（PR：Debug emit problem #6）     L4阶段：已完成（PR：add features #13）           遇到的问题及解决方案：     困难1：对 CI/CD 中的各项工具不熟悉，推代码时遇到困难   解决方案：根据导师推荐的资料，学习 GitHub Action 、 MakeFiles 、 pre-commit 等工具的用法，并配置 GPG key 等   困难2：在 Wechaty Puppet 中无法正常使用 Itchat 的函数   解决方案：根据导师的建议，深入了解了 Python 协程，将 Itchat 函数全部改为异步函数后得以解决   困难3：在使用 AsyncIOEventEmitter 时发现事件无法 Emit 到 Wechaty 层   解决方案：根据导师指导，添加 await asyncio. sleep() 后解决    项目完成质量：     已完成全部预定进度，Python Wechaty Puppet Itchat 已可以正常使用，且代码已通过 CI 检查，符合社区对代码规范的要求   不足之处：在于由于时间有限，未能对 Itchat 的代码进行重构，该项任务将会在后续结项后继续完成   综合以上两点，个人对项目完成质量评价：良好    与导师沟通及反馈情况：     与导师保持积极的沟通，能及时反馈疑问及问题   反馈的问题会及时得到导师的回复，并且导师会通过讨论引导我独立解决    项目展望：     Python Wechaty Puppet Itchat         在结项后，我仍计划持续维护这一 Puppet，并计划将 Itchat 的代码进行重构          Python Wechaty         我计划之后也持续参与到 Python Wechaty 生态的建设中去 （包括但不限于：为 Python Wechaty 贡献代码、为 python-wechaty-plugin-contrib 贡献 Plugin 等）          Wechaty         我还计划于年末为 Wechaty 社区提供一个基于 CQHTTP 的 QQ Puppet wechaty-puppet-cq          项目成果: 项目仓库: https://github. com/wechaty/python-wechaty-puppet-itchat PyPi 包：https://pypi. org/project/wechaty-puppet-itchat/ live coding视频:  国内链接：https://www. bilibili. com/video/BV1sP4y187Vj/ {% include iframe. html src=”https://youtu. be/fGjEd5O97lQ” %} PPT展示视频:  国内链接：https://www. bilibili. com/video/BV1z34y1U7MR/ {% include iframe. html src=”https://youtu. be/SKhgnRaljzk” %} 项目PPT: {% include iframe. html src=”/assets/2021/10-ospp-final-term-wechaty-itchat-puppet/itchat. pdf” %} 联系我们:  项目链接：https://github. com/wechaty/summer/issues/75 联系方式：lyle@hdu. edu. cn"
    }, {
    "id": 41,
    "url": "https://wechaty.js.org/2021/10/03/ospp-final-term-wechaty-puppet-oa/",
    "title": "OSPP 2021-结项报告-基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善",
    "body": "2021/10/03 - “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 本项目 [项目名称] 系 暑期2021 支持的开源项目。 [项目名称]信息:  导师：吴京京 学生：zzzyer 项目介绍：https://github. com/wechaty/summer/issues/82 项目名称：基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善 需求介绍：     申请开发专用测试公众账号   架设 wechaty-puppet-official-account 并可以进行微信公众账号的正常文本消息收发   Wechaty Puppet Official Account 的功能进行试用，分析其当前的功能，然后列出需要完善的功能列表，以及欠缺的功能列表，并作出开发计划   在初期开发中，能够实现图片消息的接收和发送，即可完成原型验证 POC。    模块列表：     文本消息收发模块   图片   音频消息收发模块   小程序消息收发模块：   项目时间规划：: 时间：2021. 07. 01-2021. 07. 21:  申请微信公众平台测试账号 阅读Wechaty Puppet Official Account代码 成功运行Wechaty Puppet Official Account相关样例（ding-dong-bot） 与导师讨论得出要开发的功能模块时间：2021. 07. 21-2021. 08. 15:  完成文本消息收发的功能完善 完成图片消息的简单收发时间：2021. 08. 15-2021. 09. 30:  完善中期开发之前的功能模块 完成音频消息的收发模块 完成小程序消息的收发模块 完成link消息的收发模块项目进度:  已完成工作：     文本消息收发模块   图片消息收发模块   语音消息收发模块   link消息收发模块   小程序消息收发模块（待测试）      遇到的问题及解决方案：   Q&amp;A1:在使用localtunnel进行内网穿透时，使用流程不太了解，在导师的仔细指导下完成了localtunnel内网穿透，对微信测试账号接口进行配置。   Q&amp;A2：在进行图片消息收发的时候，对整个数据的上传下载过程不了解，通过仔细阅读微信公众平台的接口文档了解整个交互机制。   Q&amp;A2：在进行音频消息收发的时候，我们采用的FileBox模块并不能识别出语音文件的amr后缀名，这样就会导致在后续根据后缀名进行mimetype判断时只能得到undefined的值。为了解决这一问题，我们在得到用户发送的语音文件时，直接将文件名指定为’message. amr’而不是用路径作为文件名的方法，这样就可以识别出消息类型了。   Q&amp;A4:在开发小程序发送功能时，经过查阅资料发现公众号只有绑定了小程序的appid才能进行正常的收发，耳测试公众号是没有绑定小程序功能的，所以暂时我只写好了小程序的功能代码，还没有进行测试。为了弥补功能的多样性，我多开发了一个link消息的收发功能。  项目成果: 项目仓库: 项目仓库: https://github. com/wechaty/wechaty-puppet-official-account live coding视频: {% include iframe. html src=”https://youtu. be/iVyutBZMZRE” %} Bilibili link: https://www. bilibili. com/video/BV1CQ4y1Q7dX/ PPT展示视频: {% include iframe. html src=”https://youtu. be/ySxpkKjv018” %} Bilibili link: https://www. bilibili. com/video/BV1344y1t7aU/ 项目PPT: {% include iframe. html src=”/assets/2021/10-ospp-final-term-wechaty-puppet-oa/final-term-ppt. pdf” %} 联系我们:  项目链接：https://github. com/wechaty/wechaty-puppet-official-account/issues/26 联系方式：zuoyanru@mail. ustc. edu. cn"
    }, {
    "id": 42,
    "url": "https://wechaty.js.org/2021/09/30/ospp-final-term-cli/",
    "title": "OSPP 2021-结项报告-基于 Blessed 的 Wechaty 命令行文本客户端软件",
    "body": "2021/09/30 - 本项目基于 blessed 为 wechaty 开发了一个命令行文本客户端，让用户可以使用键盘在终端里聊天，也方便开发者实时观察机器人的行为。 [基于 Blessed 的 Wechaty 命令行文本客户端软件]信息:  导师：李卓桓 学生：刘靖 项目名称：基于 Blessed 的 Wechaty 命令行文本客户端软件 项目介绍：https://github. com/wechaty/summer/issues/80 方案描述：     仿照 Linux 命令行终端的 IRC 文本客户端，实现一个基于 Wechaty 的即时通讯客户端，通过 Wechaty 支持所有现有的 Wechaty Puppet Providers，比如微信、企业微信、飞书、Whatsapp 等。   利用 Blessed 和 blesssed-contrib 提供的组件，绘制终端图形界面程序   监听消息接收和键鼠点击等事件，动态调整组件的内容，提供接近一般聊天软件的交互体验   使用 react-blessed、RxJS 和 Redux 重构代码（选做）    时间规划：     第一阶段（7. 1 - 8. 14）对接后端事件，选择恰当的架构与技术栈完成数据的存储、展示与更新         自行探索做出 demo             7. 1 - 7. 14       实现简单的消息接收和联系人列表展示       与导师沟通架构设计和需使用的技术栈                军训期间，项目暂缓             7. 15 - 7. 29       时间有限，学习前端相关知识或抽空实现较简单的功能                改进代码结构，重点推进数据的存储与状态的管理             8. 1 - 8. 14       实现消息内容按来源存储与查看       联系人与群聊信息的缓存       撰写中期报告                     第二阶段（8. 15 - 9. 30）重点完善前端交互，持续改进用户体验         提供更多的交互选项和管理功能             8. 15 - 8. 30       根据未读消息数量对联系人进行状态管理和智能排序                实现消息的发送             9. 1 - 9. 14                完善文档，编写样例代码和测试             9. 15 - 9. 30                     项目总结:  项目成果：整个项目就是一个在终端里运行的 Wechaty 聊天客户端，可以从以下几个角度总结成果：     数据的获取和展示：在应用启动时会一次性获取所有联系人和群聊，然后监听消息并显示在相应的聊天界面中，由于底层 puppet 实现可能无法在启动时获取所有信息，因此还提供了重新获取联系人和群聊数据的选项。   界面交互的设计：基本完成，界面左侧是好友和群聊列表，右侧是活跃聊天（指有消息往来的好友和群聊）列表，中间大块展示消息记录，中间下侧有发送消息的输入框，最下方是快捷菜单栏，用户可以按下快捷键来触发各种功能，部分功能会在上层弹出窗口，再按一次则窗口消失。值得一提的是对 Vim 常用按键的支持，用户可以使用 j/k/C-u/C-d/g/G 来移动选框，按下 / 则会弹出搜索框，直接输入聊天名称即可尝试搜索并跳转到对应的聊天。   聊天功能的覆盖：基础的文本消息收发已经完成，聊天的管理实现起来也是较为容易，但由于对现有代码架构不满意，并没有想好群和联系人管理该以怎样的布局和交互方式呈现，且与机器人自动化管理聊天的场景不同，用户对联系人和群聊进行增删改的频率并不高，且误操作的后果比较严重，所以管理功能的优先级比较低。   开源生态的完善：首先是开源协作的规范，开发过程通过有意义的 commit message 得以保存，在 issue 和 PR 中使用英语讨论技术细节也能让世界各地的开发者方便地检索和交流。为了提高开发效率，在 Wechaty 社区通用的一套 CI/CD 流程，并采用了 ESM 作为模块管理方式。为便于使用，除了 npm 安装外，还提供了 Docker 构建方式。    部分效果图如下：     遇到的问题及解决方案：   首先是界面设计：最初设计的界面过于理想化，实际在终端中有着诸多限制，包括文字的自动换行，键盘鼠标的交互都有缺陷，最终仿照了 dockly 使用菜单栏+快捷键的方式提供交互，算是比较理想的解决方案。   其次是代码细节上的问题：Blessed 长期无人维护，使用者也少，缺乏可参考的文档和资源，为了解决组件使用中遇到的 bug，我学习了使用 VS Code 调试 Node. js 程序的方法，成功找到了问题的原因并解决，还在导师的鼓励下向社区博客投稿。   最后是架构上的问题：其实在一开始我就搜集了许多小项目准备借鉴，还学习了 RxJS 的基础知识，但个人缺乏独立开发的经验，且由于场景的差异无法直接套用，只好以功能的实现来主导开发，将所有代码集中在两三个文件中。这种方式在一开始其实非常直观易于理解，但到了项目开发的后期，需要维护和控制的状态越来越多，代码粗放式增长使得维护困难，终于体现出了使用设计模式和框架的重要性。预期之后会参照 accursed 尝试使用 React 来渲染，并相应地重构代码。   后续工作安排：     目前基本的聊天功能已粗略实现，联系人和群聊管理还要和导师讨论以何种形式呈现   考虑到 blessed 和终端的特性，一般聊天软件的设计（如新对话置顶）可能无法照搬   在保证可用性的情况下，使用 React 和 Redux 重构项目   live coding视频: {% include iframe. html src=”https://youtu. be/D5QbX183kb8” %}  国内链接：https://www. bilibili. com/video/BV1444y1t7So/ PPT展示视频: {% include iframe. html src=”https://youtu. be/PssH9epe0tU” %}  国内链接：https://www. bilibili. com/video/BV1Wg411F7Gh/ 项目PPT: {% include iframe. html src=”/assets/2021/09-ospp-final-term-cli/final-slides. pdf” %} 联系我们:  项目链接：[https://github. com/wechaty/cli] 联系方式：liuchinggg@gmail. com“开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 本项目 [基于 Blessed 的 Wechaty 命令行文本客户端软件] 系 暑期2021 支持的开源项目。 "
    }, {
    "id": 43,
    "url": "https://wechaty.js.org/2021/09/29/ospp-final-term-wechaty-puppet-lark/",
    "title": "OSPP 2021-结项报告-基于开放 API 封装 Wechaty 接口下的飞书聊天机器人",
    "body": "2021/09/29 -  Code: wechaty-puppet-lark “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 本项目 [基于开放 API 封装 Wechaty 接口下的飞书聊天机器人] 系 暑期2021 支持的开源项目。 [基于开放 API 封装 Wechaty 接口下的飞书聊天机器人]信息:  导师：范蕊 学生：马田慧 项目介绍：https://github. com/wechaty/summer/issues/38 项目名称：基于开放 API 封装 Wechaty 接口下的飞书聊天机器人 方案描述：目前，飞书 Puppet 已经完成了初步开发，目前主要实现的功能有:消息收发（文字、文件、图片）,部分群组相关操作（创建群、修改群名、删除群成员等），部分企业相关操作（查看企业内成员等），接下来需要对照飞书开放平台和 Wechaty 接口，完善该项目。 时间规划：     熟悉wechaty         7. 14 - 7. 17     使用wechaty     了解飞书api          更新api版本         7. 18 - 7. 24          实现之前未实现的函数阶段         7. 25 - 8. 8     分两阶段完成，期间注重与导师交流          连接Contact、Message、Room等类         8. 9 - 8. 21          撰写文档，examples         8. 22 - 8. 28          项目完善         8. 29 - 9. 5     代码重构     发布npm包          项目进度:  已完成工作：     更新api版本，熟悉飞书api和wechaty。   实现之前未实现的函数   连接Contact、Message、Room等类，尝试实现复用   撰写文档、example   发布npm包    遇到的问题及解决方案：     问题主要是在我们这个项目面对的开发者和用户体验上，由于原本体验微信的接口，由于web协议的原因没有体验，对于用户如何使用我们的接口没有具体合适的了解；以及如何将puppet的接口暴露给wechaty-puppet社区的问题，与原本构想不同，我在除了基本消息类型之外的实现没能理清楚消息时如何传递的，最终通过导师的指导，我查看官方文档，阅读源码，通过查看其它项目是如何实现的，最终通过消息仓库的具体使用解决问题。   开发时存在的主要问题在于，开发环境时返回网址网址不固定，开发每次需要到飞书上配置事件订阅的网站，以及本地更新后不能直接部署的问题。这个问题是由于内网穿透网站的连接不稳定造成的，在时间空闲时刻可以返回固定网址，在本地使用热更新技术实现本地修改后代码直接自动部署，加快开发效率。   这是我第一次体验社区式的开发，由于对于项目的严谨性社区生态的发展性理解浅显，在其中社区活动上流程上不太清楚，以及本地工具的细节的不理解而产生种种问题，感谢社区的老师们对我的包容和指导，我从中学到了很多严谨性规范性上的知识；很多问题由于对于开发知识与经验的欠缺，我常常为bug焦头烂额，感谢导师的耐心帮助，希望自己能常常记住这次开发过程中的经验教训，并常常实践以便做到更好。   最后，希望“开源软件供应链点亮计划”系列活动越办越好，祝愿wechaty社区越来越健壮!    项目展望：项目已经完成了预计的功能，但是没能模拟开发者实现时的基本使用，还没有和wechaty-puppet对接过，直接通过puppet利用6行代码实现飞书机器人的功能需要更加集成，这是项目之后发展的一个方向。更多的开发者将自己的创意结合机器人实现个性特点针对不同性能的机器人。项目成果: 项目仓库: https://github. com/wechaty/wechaty-puppet-lark live coding视频: {% include iframe. html src=”https://youtu. be/lH3giTpdOtM” %}国内链接：https://v. qq. com/x/page/h3280a7pbwi. html PPT展示视频: {% include iframe. html src=”https://youtu. be/-HOF0LV1d54” %}国内链接: https://v. qq. com/x/page/h3280md1b6i. html 项目PPT: {% include iframe. html src=”/assets/2021/09-ospp-final-term-wechaty-puppet-lark/final-term-ppt. pdf” %} 联系我们:  项目链接：https://github. com/wechaty/wechaty-puppet-lark               联系方式：+86 18660817606     email：2741102314@qq. com          "
    }, {
    "id": 44,
    "url": "https://wechaty.js.org/2021/09/29/gsod21-final-blog-references/",
    "title": "GSoD 2021-Final-Term-Blog-References",
    "body": "2021/09/29 - After four months of immense learning, we come to the end of Google Season of Docs 2021, here is the final blog of the References team. Team Members: Shraddha Vasant Prasad: Shraddha graduated in 2020 with a B. Tech major in Computer science and Engineering at JSS Academy of Technical Education, Bangalore, and is currently a Software Engineer at American Express and she is also a Student Mentor at Newton School. She is a passionate developer and is a creative blogger. Email: shraddhavp. 1js16cs094@gmail. com&lt;/br&gt;Github Handle: https://github. com/shraddhavp&lt;/br&gt;Medium: https://shraddha-writes. medium. com/&lt;/br&gt; Soumi Bardhan: Soumi Bardhan, is a final year student at IIIT Kalyani. She is a freelance technical writer and software developer and is currently working on Computer vision and AI projects. Email: soumibardhan10@gmail. com&lt;/br&gt;Github Handle: https://github. com/Soumi7&lt;/br&gt;Medium: https://soumibardhan10. medium. com/&lt;/br&gt; Objectives: The reference guide contain the technical description of the machinery. They are code determined and information oriented. The references guides contain clear descriptions of Classes, API, Functions, Methods, Attributes, and many more technical aspects of the software. The Wechaty references aim to guide the end-users completely about Wechaty. The refernces guide will contain the following subsections with the described content below    API ReferencesAdd use cases for API references, add code snippets and also add details about user classes.     PolyglotAdd code snippets with easy-to-understand examples for first-time users in different programming languages.     Puppet ProvidersAdd separate modules for each of the messaging apps and add necessary code snippets.     Puppet ServicesInclude all the puppet services offered by Wechaty.  Final Term Video Presentation: {% include iframe. html src=”https://www. youtube. com/watch?v=YaZ9Q_NjHBM&amp;t=4s” %} Pull Requests/Commits: You can find all PRs done by us in the links below:  Soumi’s PRs Shraddha’s PRsWork Done: This repository contains the details of all the work done by our team in the tenure of Google Season of Docs 2021. Milestones Achieved:  Created a new ,brief and a clean documentation structure for References section.  Created a user friendly documentation with new information ,code snippets,images for the end-users to understand the Wechaty RPA BOT better. Learnings: We are glad to have got the chance and opportunity to be a part of the Google Season of Docs 2021 program organized by Google. The learning curve in the whole journey has been steep. The program has helped me to:  Understand the importance of Technical documentation.  Learn about Docusaurus and MDX(Markdown+ReactJS).  Learn about RPA (Robotic Process Automation) bots.  Get involved in an innovative community that is Wechaty. Acknowledgements: We are thankful to Google Season of Docs and Wechaty for giving us this opportunity. We would also like to thank my mentors Huan LI and Li Jiarui for their constant support and lastly would like to thank the volunteers Simin Liao and Rohitesh Kumar Jain for their constant support. They led the video meetings in a well-organized, interactive manner and made the meetings a great platform for discussion. Future Plans:  Continue to work towards contributing to Wechaty community.  Detect and rectify issues in implementation of the RPA bot if any in the future. "
    }, {
    "id": 45,
    "url": "https://wechaty.js.org/2021/09/29/final-term-club-managment/",
    "title": "OSPP 2021-结项报告-开发基于Wechaty实现微俱乐部会员&活动管理的微信小程序",
    "body": "2021/09/29 - 暑期2021: “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。官网：https://summer. iscas. ac. cn/ 本项目 [开发基于Wechaty实现微俱乐部会员&amp;活动管理的微信小程序] 系 暑期2021 支持的开源项目。 项目信息:    导师：鲁玉超     学生：陈婧     项目介绍：https://github. com/wechaty/summer/issues/78     项目名称：开发基于微信实现微俱乐部会员&amp;活动管理的微信小程序     方案描述：本项目需要基于wechaty开发一个能进行会员和活动管理的小程序。小程序的核心内容为报名服务，WeChat机器人作为服务之一完成接收信息，并响应入库的工作。本程序意在为使用者提供更方便快捷的管理成员及管理活动的功能。     时间规划：      阶段一         完成时间：7月20日     计划描述：引入聊天机器人，整理基础适用/开发生产环境/用户协议，绑定用户数据到俱乐部，使用微信开放平台实现“关键词回复”功能。          阶段二         完成时间：8月15日     计划描述：实践“群主发布活动”功能，实践“群主管理活动”功能，实践“成员标签活动”功能，完善以上功能块进行调试。          阶段三         完成时间：9月5日     计划描述：实践“活动相册”功能、“帮助”功能（将关键词与操作关联，要求提高容错性），如果有空余时间，设计自定功能。          阶段四         完成时间：9月30日     描述计划：实践自设定功能，收集中出现的问题，针对程序运行程序功能，小整体优化升级（用户数据处理）。          项目总结:  项目成果项目仓库: https://github. com/mangguo188/wechaty-club-management  遇到的问题及解决方案：     启动小程序后仅出现授权页面，授权后无应有显示。         方案：本项目需要小程序与机器人一同登录，只有机器人持有者登入小程序，界面才会正确显示。找到云开发日志中机器人持有者发布的消息，将其wxid赋值给小程序使用者（小程序使用者原先的wxid是系统自动生成的数字，仅保证wxid唯一，但无意义）。          云函数编写过程中常出现错误，但是错误查找需要提交运行，时间周期长且提交次数有限，需要发掘更好检验错误的方法。         方案：在老师的建议下，我先在机器人中模拟后端返回，将函数编写在机器人服务中，检验函数的正确性，当所有函数运行完毕无错后再在后端更改相应函数，此举大大减少了云函数的上传次数，降低电脑负荷。          本项目仅对文本信息可做出响应反馈，对于超链接、图片、视频等消息无法提取有效信息。         方案：暂时搭建响应超链接、图片、视频的框架，后续功能待有时间可持续开发。          编写完成后，小程序的云开发部分与前端部分与机器人位于同一文件夹下，两者分别不明晰，加上每个文件夹下都有index. js文件，极易出现修改错误。         方案：将小程序封装到mp文件夹下，机器人封装到wechatbot文件夹下，使两者功能可以分开使用，也易连接（需要注意的是，由于小程序云函数封装到mp文件夹下，从微信开发者工具上查看时只需要打开mp文件夹，不然会出现无法部署的问题）。           项目展望：     本项目仅完成基础功能开发，目前使用者进入小程序可以随时查看群活动与该群内成员id，包括报名记录等便利统计数据的内容。但将基本框架已搭建完毕，后续有时间可加更多功能模块，包括如何将群机器人与小程序1对1的关系解开，方便更多小程序使用者简便获取活动管理功能等。   项目展示: live coding视频：: {% include iframe. html src=”https://youtu. be/5LZ08re5YR8” %}  国内链接：https://www. bilibili. com/video/BV1hR4y1n7AH/ PPT展示视频：: {% include iframe. html src=”https://youtu. be/eSgaD32njVw” %}  国内链接：https://www. bilibili. com/video/BV1uP4y187T9/ 项目PPT：: {% include iframe. html src=”/assets/2021/09-final-term-club-managment/final-term. pdf” %} 联系我们:  项目链接：https://github. com/mangguo188/wechaty-club-management 联系方式：1017137803@qq. com"
    }, {
    "id": 46,
    "url": "https://wechaty.js.org/2021/09/28/the-stupidest-bot-ever-created/",
    "title": "人类的本质是复读机 - 可能是世界上最无聊的机器人",
    "body": "2021/09/28 -  前言: 这个可能是世界上最无聊的机器人。如果你看到了这里，恭喜你，你已经浪费了人生中宝贵的一分钟。如果有四十个人看到了这里，那么一节课的时间已经没了。 机器人的特点是，不经意间触发，意料之外又情理之中，实现一种后现代主义的幽默感。 代码开源在 BurgerBurglar/mouse_bot。我是 TypeScript 初学者，很多地方都是瞎写的。如果代码实在太丑，欢迎留言给我提意见。很多地方我实在是不会写，就用 Python 搭了个 API，再用 TypeScript 调用接口直接回复。 功能列表:  群聊自动复读 无厘头自动回复 成语接龙 游戏发售倒计时 足球比赛预告 足球实时赔率查询 质问别人为什么拍我 艾特别人 让川普举牌子 下载链接里的视频群聊自动复读: 每个群总有几个复读机，喜欢像傻子一样在群聊里复制粘贴别人的话。这时候，如果你不跟着复读，就会显得和这个群的智商水平格格不入。为了避免这种尴尬，我只好让机器人代劳了。  当然有可能有人恶意使用机器人，比如这样： 实现的原理是：对于每一个群聊，生成一个队列，储存最近的十条信息。收到信息时，如果新信息在队列中已经出现了三次，那么就自动复读。 同时，每个群聊还有另外一个队列，储存最近三个已经复读过的内容，避免反复复读刷屏。 无厘头自动回复: 很简单的功能，如果触发了关键词，就随机挑选一个回复。  群友语录: 生活中，总有些话发人深省，总有些句子让你泪流满面。互联网是有记忆的，而记忆也是会随风飘逝的。为了铭记这些句子，机器人正在努力。 成语接龙: 很多群聊里都有成语接龙这一传统爱好。屡次败北之后，我决定使用科技打败他们。 当然，本功能还有很多不足。  比如由于三流网络成语词典，机器人居然把味同嚼蜡读成了味同嚼醋，造成了重大 bug。  机器人的词汇量和初中语文老师（我妈）比，还有一定差距。 本机器人追求的是一个出其不意的效果。谁在群里不小心说了个成语，机器人一定会迅速作出反应，群里就能玩好一会。很多死群都因为这个功能复活了。 开发了这个功能之后，我被一个成语接龙群踢了。  成语接龙代码由 sfyc23/China-idiom 提供 游戏发售倒计时: 总有些吃饱了没事干的群友在群里每天复读某某游戏还有几天发售。为了避免群友手动计算日期，我开发了游戏发售倒计时机器人。 首先在有游戏时光上爬取游戏发售日期，存到数据库里： 然后，使用字符串近似匹配，在游戏群里查询倒计时。无论使用中文名还是外文名，都可以查询。 足球比赛预告/足球实时赔率查询: 适合懒得打开虎扑懂球帝却勤快得在群里打字的人，可能他们都住在微信里了吧。   赔率数据来源 Odds checker，使用实时各大平台最高赔率。 质问别人为什么拍我: 在我开发机器人之前，拍一拍是微信上最无聊的功能。所以当有人手贱拍我的时候，我会大声质问他们： 就是不知道为什么大家拍得更勤快了。 艾特别人: 除我以外，群里总有些自以为很幽默的人，喜欢修改群昵称然后让别人艾特他。为了避免没人搭理他的尴尬，我开发了艾特机器人。  让川普举牌子: 当你有话不方便说的时候，可以让他来帮你表达一下。 {% include iframe. html src=”/assets/2021/09-the-stupidest-bot-ever-created/trump-1-video. webp” %} {% include iframe. html src=”/assets/2021/09-the-stupidest-bot-ever-created/trump-2-video. webp” %}  使用了 ivanseidel 的 rotoscope 下载链接里的视频: 当有人发送视频链接的时候，防火墙可能会阻挡很多人。更过分的是，很多app需要你下载才能打开视频，体验很差。所以，为什么不下载下来发到群里呢？ 黑名单与白名单: 为了避免在不合时宜的情况触发关键词，可以配置黑名单或者白名单。比如： {   userNames : [ 妈妈 ,  领导 ],   roomNames : [     Wechaty Developers' Home 2 ,     非常重要的工作群 ,     家族群   ],   keywords : {     动物保护群 : [ 猴 ]  }}展望未来: 由于 UOS 关闭了 WeChat 用户的接口，机器人现在已经离开了我们 (R. I. P. )。如果能参加 Wechaty Contributor Program，我会用 Padlocal token 复活机器人，并增加一些功能： 点歌功能: UOS 协议不能发送 URL Link，所以这个功能暂时无法实现。我的想法是，收到点歌关键词后，调用网易云音乐的接口，在群里发送可以直接播放的音乐。 优化视频下载: UOS 的视频发送很慢，而且经常有 bug（时长不对，没有声音，电脑端打开会卡死…）使用 Padlocal 发送应该可以解决大部分问题。 优化屏蔽功能: 目前智能全局屏蔽和关键词屏蔽，以后会加上针对每个功能、每个用户、每个群聊的屏蔽功能。 结语: 感谢各位吃饱了没事干的程序员，看我这么无聊的文章。但是我不认为我的工作没有价值，因为人类的本质是#复读机器人。 "
    }, {
    "id": 47,
    "url": "https://wechaty.js.org/2021/09/28/ospp-final-term-matrix-wechaty/",
    "title": "OSPP 2021-结项报告-基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善",
    "body": "2021/09/28 - Matrix AppService Wechaty 是一个 Matrix 应用服务（ AppService ），它可以把 Wechaty 支持的应用桥接到 Matrix 服务器中，帮助我们在 Matrix 客户端收发微信，飞书等通讯平台的消息。本项目基于 Matrix AppService Wechaty 完善了消息收发，用户信息展示，部署和开发流程优化等功能。 Matrix AppService Wechaty项目信息:  导师：李卓桓，yswtrue 学生：林宇靖，张瑞宁   项目介绍：https://github. com/wechaty/summer/issues/59   项目名称：基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善 方案描述：通过 Matrix-Appservice-Bridge 桥接 Wechaty 和 Matrix 的消息，使我们能在 Matrix 收发 Wechaty 消息，即收发来自微信，飞书等的消息。 时间规划：https://github. com/wechaty/summer/issues/59#issuecomment-882246195项目总结:    项目成果：               计划     完成情况     成果                   架设 Matrix 系统     完成     在家庭环境， 境内外VPS 均进行过实验部署， 并部署了一套社区 Matrix 服务器             整合matrix-appservice-wechaty到Matrix系统中     完成     通过该实验熟悉了Matrix系统的各个功能模块，对后面的开发有启发作用             分析项目需求     完成     需求(details)： 图片，附件消息收发；虚拟用户头像，昵称，备注的显示；部署方案的简化；开发方案的简化；实现“双傀儡”，同步其他设备主动发送的消息；             实现图片消息的接收和发送，完成原型验证 POC     完成     成功模拟收发群组和私聊中的图片及附件消息             实现其他欠缺功能     部分完成     支持指定 Chrome 程序； 支持修改消息延迟阈值等； 未实现“双傀儡”             进行测试，完善项目文档     完成     进行自动测试和人工测试，并解决发现的问题             设计实现新部署方案，提供更加简便的部署方案     完成     easy-matrix-wechaty             设计实现新开发方案，提供更加简便的开发环境部署方案     完成     devcontain-support             遇到的问题及解决方案：   学生本科学的是软件工程专业，对软件建模语言有一定了解，课堂项目中也经常使用相关技术产品。   从程序设计到程序系统到软件工程，软件工程解决了很多难题，但软件建模语言在几十年来却一直被诟病为“语义丰富但不严谨”，本人在实际实践中也觉得它们用起来并不怎么方便。   在本项目的实践中，我第一次体验完整的开源项目贡献流程。尽管一开始犯了一些错误，在导师的指导下，我最终学会如何使用 issue 和 PR 请求来高效地参与开源项目。在开发流程中，我几乎没有使用 UML ，但这不妨碍我阅读 issue，README 文档和源码来了解这个项目，并进行开发排错。在开发过程中，我们与导师能更多地就新功能的实现方式进行沟通，而不必花时间讨论以前的代码，这是我以前未体验过的高效的编程体验。   我也怀疑过这是否是因为该项目比较特殊。它有完整的自动测试和自动编译配置（和 CI/CD 类似，但目的通常不是部署），这和 Wechaty 社区里多数项目一致，和其他优秀开源项目一致，但这是可复制的。我也怀疑过是否因为这项目比较简单。然而，一开始的部署方案里，我们要部署近十个服务来实现邮箱，安全认证，突触，突触联合等服务，要求部署计算机有可以申请证书的域名以及一些需要备案的共有IP端口。我们后来做了很多努力才把依赖降低为两个服务器，无域名端口要求，这依赖于 docker 的强大功能，和 linux，matrix 等一系列开源应用的透明易用。   我觉得这个项目的开发流程有很多可以借鉴的地方，虽然我目前没能从事软件工程方面的研究学习，但这份开发经历给我留下了深刻印象，有机会的话我会继续深入研究学习或者应用它。     项目展望：      实现“双傀儡”   实现一个机器人，桥接微信消息到社区 Matrix 房间中，如 &lt;#wechaty_wecahty:gitter. im&gt; 中的 Mike Bo，并且显示每个用户的头像和昵称   让桥接机器人&lt;@Wechaty:localhost&gt;同时为多个 Matrix 用户提供桥接服务   项目成果: 项目仓库: matrix-appservice-wechaty，easy-matrix-wechaty live coding视频: {% include iframe. html src=”https://youtu. be/qtbExkN0uoI” %}  国内链接：https://www. bilibili. com/video/BV1Eq4y1Z7Ya/ PPT展示视频: {% include iframe. html src=”https://youtu. be/3j3BGRnoVtE” %}  国内链接：https://www. bilibili. com/video/BV1QR4y1p7Hd/ 项目PPT: {% include iframe. html src=”/assets/2021/09-ospp-final-term-matrix-wechaty/final-term-report. pdf” %} 联系我们:  项目链接：https://github. com/wechaty/summer/issues/59 联系方式：     林宇靖：lprintf@qq. com   张瑞宁：3134191406@qq. com   “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 本项目 Matrix AppService Wechaty 系 暑期2021 支持的开源项目。 "
    }, {
    "id": 48,
    "url": "https://wechaty.js.org/2021/09/24/gsod-end-term-how-to-guide-blog/",
    "title": "GSoD 2021-End-Term-How-to-guide-Blog",
    "body": "2021/09/24 - This is the End-term Blog for Wechaty How-to-guide documentation for which we are working as a part of Google Season of Docs 2021. It is much more than a summer internship program, it is a year-round effort for the organization and some community members. Team members: Abhishek Jaiswal: Myself Abhishek Jaiswal,a CSE sophomore UG student currently pursuing my B. Tech from IIIT Bhubaneswar. It’s now been more than year, I started writing technical blogs,tutorials,documentation and reviews. I have published many technical with medium and Analytics Vidhya, Devtutorials and Hashnode. I want to learn, build, grow my network, and want to transform open innovation projects into powerful real-world services. Email: abhishek. iiitbbsr@gmail. com&lt;/br&gt;Github Handle: https://github. com/abhishek-iiit&lt;/br&gt;Medium: https://abhishek-iiit. medium. com/&lt;/br&gt;Hashnode: https://abhishek-iiit. hashnode. dev/ Vasvi Sood: I am a sophomore at NIT, Hamirpur. I am a Tech enthusiast and a story writer. For me combining technology with my writing skills is a natural match. I am passionate about blockchain technology. I am also into competitive programming these days. Email: contactvasvisood@gmail. com&lt;/br&gt;Github Handle: https://github. com/vasvi-sood&lt;/br&gt;Medium: https://vasvisood1. medium. com/ Abstract: How to Guide is important because it guides us through the steps involved in addressing key problems and use-cases. They are more advanced than tutorials and assume knowledge of how the product works. On an average 45 - 50% of developers refer to How to guide. It contains instructions on how to use the program, its features and other inbuilt applications as well. Proposed Timeline: The detailed structure for the timeline can be found How-to-guide Team Proposal. Below are the some of the highlights: Week 1:  Concentrate on community bonding.  Chalk out a blueprint.  Add a README file to GitHub. Week 2:  Add about Bot: Adding brief introduction to the bot and its various use cases and functionalities with images. Week 3:  Add Events to your bot: Define what an event is. Provide code snippets along with a brief paragraph about when to use an event. Include code snippets and examples. Week 4:  Add more functionality to your bot: Dealing with messages.  Manage Contacts. Week 5:  Add more functionality to your bot: Manage Rooms.  Send and Accept Friend Requests. Week 6:  Add more functionality to your bot: Sending and Receiving files. Week 7:  Deploy with containers: Deploy with Heroku.  Deploy with Docker. Week 8:  Deploy on IM platform: Deploy in WeChat.  Deploy in WhatsApp. Week 9:  Deploy on IM platform: Deploy in Lark.  Deploy in Gitter. Week 10:  Deploy on IM platform: Deploy in WeChat4U.  Deploy in PadLocal.  Deploy in Official Account. Week 11:  Proofreading the existing tutorials.  Fixing typos and making minor changes to the documentation, if required.  Work on improving the existing topics if required. Week 12:  Request the mentor feedback Work on improvements suggested by the mentor.  Submit a project report for evaluation to the mentorsProposal End-term Video Presentation: {% include iframe. html src=”https://youtu. be/La43NjNp3Dc” %} Work Done: We kick-off with the community bonding and getting familiar with the project. Also, if someone want’s to contribute we had a README file to help future contributors understand how to contribute to the How-to-guide page. We then restructured the How-to-guide section, and added various sub-sections. Some of them are:  Adding Events and customising the bot with providing code snippet for better understanding and its purpose Install wechaty and run the most famous messaging app through it Step by step guide to get familiar with deals with messages Introduction to managing contacts and its use cases Step by Step guide to get familiar with manage contacts Step by Step guide to get familiar with send and accept friend requests Introduction to sending and receiving files and its use cases Detailed deployment with Docker and Heroku Guide to deploy the bot in WeChat, WhatsApp, Lark, Gitter, WeChat4U, PadLocal, and Official Account. Contributions:  #947 How to guide overview #958 Customize bot #962 Added running locally instructions on the main readme file #964 Manage Contact #980 Dealing with messages #981 Friend request #1011 Creating a Room #1022 Send and receive files #1028 Deployment with Docker #1040 Deploying with Heroku #1098 Deploy in WeChat #1101 Deploy in Lark #1106 Whatsapp section #1136 Deploy in WeChat official account #1139 Left Nav bar #1140 Deploy in Padlocal #1141 Deploy in wechat4u #1154 Gitter sectionLesson learned: Working with Wechaty under Google Season of Docs has been an amazing and rewarding experience. It has provided me a chance for learning and self improvement. Here are some of the lessons we have learnt:    Became more familiar with Git, Github and open source culture and software development in general. Also learnt several md, mdx commands and their best practices.     Routine code submission, discussion and review by mentors helped to complete the task in short time and in directed manner.     We learned a great deal about working with the Docusaurus documentation system.     The most out of it, we learned how to work as a team, made lifelong new connections and know the value of time management during this period.  Acknowledgment: Our experience in working on this GSoD’21 project with Wechaty was simply awesome. It was one of the best experiences we’ve ever had. Not only did I get a chance of contributing to such a big real-world project, but also I got to learn a lot throughout the program. We are extremely grateful to our mentors Rohitesh and Simin for helping us out at various stages throughout this summer. Special thanks to Huan and Rui, for facilitating the Summer Program. Sincere gratitude to Google for offering me this great opportunity. "
    }, {
    "id": 49,
    "url": "https://wechaty.js.org/2021/09/21/how-to-get-an-automatic-message-forwarding-weixin-chatbot-with-python-wechaty-aliyun/",
    "title": "如何使用python-wechaty来搭建一个自动转发消息的微信机器人",
    "body": "2021/09/21 -  前言: 用python-wechaty+paddlehub+阿里云白嫖一个智能微信机器人 本人先尝试了一遍，但是因为使用免费Web协议被封和不能登陆的情况经常出现， 所以本篇是关于使用付费Padlocal协议来构建的微信机器人。因为本人在学校，来自老师的微信通知比较多， 手动转发到班群有时候会忘记了，会误事，所以增加了自动转发消息的功能。 在本项目参考了github中 python-wechaty-getting-started 的示例代码，并且有踩坑的情况，纪录下来。 1. 搞定云服务器部分: 这部分大佬可以参考 Lovely-Pig 大佬的一篇 blog 这里面对怎么白嫖一个阿里云服务器以及怎么进行初始的配置有了很清楚详细的介绍，所以这里就不再赘述。这篇博客是采用了 Ubuntu 系统，所以这边也采用这个系统。 前面的 1. 1 到 1. 17 可以完全参考 Lovely-Pig 大佬这篇 blog 但是从 1. 18 开始就有变化，因为从这里开始会使用付费Padlocal协议，即Ipad来登陆你的微信。 1. 1 在终端里输入以下指令: 这里有一个免费的Padlocal协议的token申请地址: http://pad-local. com先申请一下这个七天的token（一）连接服务器并且运行以下代码，做好前期工作 &gt;&gt;&gt; apt update&gt;&gt;&gt; apt install docker. io&gt;&gt;&gt; docker pull wechaty/wechaty:latest（二）配置环境变量 &gt;&gt;&gt; vi /root/. bashrc打开. bashrc，在其末尾编辑以下内容配置环境变量，保存并退出 WECHATY_PUPPET：这里填  wechaty-puppet-padlocal  WECHATY_PUPPET_PADLOCAL_TOKEN ：填写你自己刚刚申请的 token WECHATY_TOKEN：可以任意填写，这个相当于是你的主机到服务器的一个令牌 export WECHATY_LOG= verbose export WECHATY_PUPPET= wechaty-puppet-padlocal export WECHATY_PUPPET_PADLOCAL_TOKEN= your_puppet_padlocal_tokenexport WECHATY_PUPPET_SERVER_PORT= 8086 export WECHATY_TOKEN=your_token&gt;&gt;&gt; source ~/. bashrc（三） 到这里可以使用 export 来查看环境变量是否配置成功 &gt;&gt;&gt; export （四）可以运行机器人了 &gt;&gt;&gt; docker run -ti --name wechaty_puppet_service_token_gateway --rm -e WECHATY_LOG -e WECHATY_PUPPET -e WECHATY_PUPPET_PADLOCAL_TOKEN -e WECHATY_PUPPET_SERVER_PORT -e WECHATY_TOKEN -p  $WECHATY_PUPPET_SERVER_PORT:$WECHATY_PUPPET_SERVER_PORT  wechaty/wechaty:0. 56（五）检查是否运行成功  输入网址: https://api. chatie. io/v0/hosties/your_token_at_here，例如我输入的地址就是这个: https://api. chatie. io/v0/hosties/puppet_padlocal_XXXXX 如果返回了服务器的ip地址以及端口号，比如{“host”:”121. 43. 228. 90”,”port”:8080}，就说明运行成功了，如果返回的是{“host”:”0. 0. 0. 0”,”port”:0}，就说明没有运行成功2. 搞定 python 代码部分: 2. 1 全部的python代码: import asyncioimport loggingfrom typing import Optional, Unionfrom wechaty_puppet import FileBox, ScanStatusfrom wechaty_puppet import MessageTypefrom wechaty import Wechaty, Contactfrom wechaty. user import Message, Roomclass MyBot(Wechaty):  async def on_message(self, msg: Message):           listen for message event           msg_from_contact: Optional[Contact] = msg. talker()        msg_from_text = msg. text()                     msg_from_room: Optional[Room] = msg. room()             msg_from_room_name = ''                       msg_from_contact_name = msg_from_contact. name           msg_to_room = await self. Room. find('XXX')    if msg_from_room is not None:                     msg_from_room_name = str(await msg_from_room. topic())    if msg_from_room_name == 'XXX' and msg_from_contact_name == 'XXX':      if msg. type() == self. Message. Type. MESSAGE_TYPE_TEXT:        await msg_to_room. say(msg_from_text)              if msg. type() == self. Message. Type. MESSAGE_TYPE_IMAGE:           img = await msg. to_file_box()        await img. to_file(f'. /{img. name}')        file_box = FileBox. from_file(f'. /{img. name}')              await msg_to_room. say(file_box)asyncio. run(MyBot(). start())2. 2 踩坑的地方: if msg. type() == self. Message. Type. MESSAGE_TYPE_IMAGE:           img = await msg. to_file_box()        await img. to_file(f'. /{img. name}')        file_box = FileBox. from_file(f'. /{img. name}')      # 注意路径，以及文件不能为空        await msg_to_room. say(file_box)如果要将接收的图片，再转发给别人，这里有一个示例代码，出自于 python-wechaty-getting-started 的示例代码 示例代码如下： elif msg. type() == MessageType. MESSAGE_TYPE_IMAGE:  img = await msg. to_file_box()  # save the image as local file  await img. to_file(f'. /{img. name}')  # send image file to the room  if room:    await room. say(img)此处直接将消息转化成了一个FileBox 对象，能保存图片，但是不能 room. say() 我猜测，是因为微信端对微信图片进行了加密处理，因为一个图片类型的 msg 是一个加密的 xml 文本 可能方法 img. to_file() 中封装了解码的模块，但是 room. say()中没有 所以我的思路是先将图片储存在本地，然后再进行发送，也可以达到转发图片的效果 参考资料:  PaddleHub官网 python-wechaty python-wechaty-getting-started 手把手教你用python-wechaty+paddlehub+阿里云白嫖一个智能微信机器人 作者: Gan-lang "
    }, {
    "id": 50,
    "url": "https://wechaty.js.org/2021/09/12/gsod-2021-tenth-meeting/",
    "title": "GSoD'21 Tenth Meeting",
    "body": "2021/09/12 - Google Season of Docs’21 tenth meeting: Meeting Summary: It was the tenth and the final meeting regarding the discussion of the GSoD’21 projects. Firstly every participant reported theirprogress in-terms of completion, volunteers and tech writers discussed while tech writers were giving report on the same. Later we discussed comments and questions of the participants, and at last, we took a lovely group photo. {% include iframe. html src=”https://youtu. be/Yo9HRBPD83A” %} Attendees: Total 10 attendees attended the meeting. They are:  Rohitesh Jain, Volunteer (UTC + 5:30) Sajen Sarvajith, Reconstruct Landing page writer (UTC + 5:30) Abhishek Jaiswal, How-to-guide section writer (UTC + 05:30) Simin Liao, Volunteer (+8:00) Mukosa Joseph Mawa, Introductions and Explanations section writer (UTC +03:00) Rajiv Ranjan Singh, Improve the gRPC and OpenAPI ecosystem writer, rajivperfect007@gmail. com, (UTC+05:30) Souvik Biswas, Create easy to learn tutorials for beginner users writer, sbis1999@gmail. com (UTC +05:30) Shraddha, Improve References section writer (UTC + 5:30) Arnab Saha, Reconstruction of Landing page with value propositions writer (UTC + 5:30) Chris Estepa, Introduction and Explanations sections writer (UTC +08:00)Note: Meeting started on schedule and everyone attended this ! Agendas:  00:00 0. Introduction &amp; Welcome 01:38 1. Discussion with Tutorials team 02:51 2. Discussion with Introduction and explanation team 03:59 3. Discussion with Landing page team 05:01 4. Discussion with References section team 08:34 5. Discussion with How to guides team 10:14 6. Discussion with gRPC team 16:42 7. Questions/commentsYou can learn more from our meeting notes. Meeting Outcomes:  The community got to know about the completion status of different projects Had a sense of achievement, and a sense of almost completion of GSoD program for WechatyMeeting Follow-ups:  Need Rui’s approval for unmerged PRs We will be seeing final project reports in the coming weekNotable Meeting Questions:  Q: (Arnab &amp; Sharddha) Do we need to submit end term report? A: (Rohitesh) Yes it’s mandatory to submit end term report. "
    }, {
    "id": 51,
    "url": "https://wechaty.js.org/2021/09/10/baidu-paddle-machine-learning-chatbot-competition/",
    "title": "Baidu Paddle ❤️ Wechaty & Mixlab ML Chatbot 大赛作品推荐",
    "body": "2021/09/10 - 由 Wechaty、PaddlePaddle 和 Mixlab 联合主办，未来事务管理局作为媒体支持的「AI创造营 ：Metaverse启动机之重构现世」硬核 Machine Learning (ML) Chatbot 创意赛的项目提交阶段已经结束，共收回33个项目，相比第一、二期创意赛(21个和24个)有了明显提高！  大赛启动博客：AI Chatbot Competition – Metaverse启动机之重构现世！, @valerieeeee, Jul 07, 2021 Wechaty 社区评委们在打分评审过程中，将优秀的项目分享给大家，希望能够帮助大家未来发挥出更多的创意！ 一只能看懂表格图片的数据助手: 基于PaddleOCR解析表格图片数据，并通过Text2SQL进行进行数据查询。场景模拟一份星球数据，数据助手基于数据表格进行结果精准查询。 {% include iframe. html src=”https://www. bilibili. com/video/BV1B64y1i7GM” %} GitHub: https://github. com/thunder95/Paddle_Table_Image_Reader/blob/main/2262444. ipynb 彩虹屁微信机器人:  彩虹屁，不开心哄你开心 舔狗日记，舔与被舔是不是都很开心啊哈哈 毒鸡汤，兄弟干了这碗鸡汤还能熬 带我去one，自动ps人像并动漫到one的每日美图美文中{% include iframe. html src=”https://www. bilibili. com/video/BV19f4y157NL” %}  Huan: I love this BGM! GitHub: https://github. com/livingbody/rainbow_fart 微信数据小助手: 你想导出喜欢得表情包嘛？自定义的，购买的，想看怎么办？导不出来看不了？重要文件能不能默认接受？发的语音、视频能不能自动保存？聊天记录自动保存？那么微信数据小助手来了，可以根据发送的文件类型，按原文件名保存，聊天记录也可以保存下来，完美满足各类需求。 {% include iframe. html src=”https://www. bilibili. com/video/BV1x3411i732” %} GitHub: https://github. com/livingbody/wechat_data_little_assistant 星际旅行向导机器人: 本项目为基于wechaty+paddlehub实现的星际旅行向导机器人 2090年的一天你驱着自己的私人飞船航行在大麦哲伦星系右旋臂附近，恒星的闪光让你流连忘返，殊不知危险以悄然来临。一颗冒失的小行星擦破了你飞船的右燃料箱，让你去巴卡罗马星探望外婆的计划破灭。 “噢，现在担心的不是什么外婆不外婆的，你得赶紧寻找可降落的行星，燃料已经不足以支撑你长久飞行” 情急之下，你连线上了星际旅行向导机器人。 {% include iframe. html src=”https://www. bilibili. com/video/BV1Kb4y1z7kH” %} GitHub: https://github. com/Cursky/Cosmic-Wanderer-Guide-Robot 【微信情景代入对话游戏】参与每个不同的冒险 身临其境的对话游戏:  剧本杀？ 跑团？ 交互式小说？对话小说？ 文字冒险游戏？如果你了解任意其一，那么将很好理解我们项目的愿景：  —— 我们期望通过文字和微信，就能够提供更加身临其境的沉浸感，去体验每一段故事，就像故事里写着的那样。 {% include iframe. html src=”https://www. bilibili. com/video/BV17L4y1Y7cB” %} GitHub: https://github. com/Cursky/Wechat-game 手势识别应用-微信聊天机器人（基于PaadleVideo+Wechaty）: 在本项目中，我们利用已经训练好的手势识别模型来制作了一个模拟的飞船驾照考试官。未来的飞船已经脱离了繁琐的控制界面，均由手势动作来完成对飞船的操纵。基于这一点，我们就可以利用微信聊天机器人和手势识别模型做出下面这个有趣的小项目。 {% include iframe. html src=”https://www. bilibili. com/video/BV1JU4y177s7” %} GitHub: https://github. com/Cursky/Airship-license-examiner-robot 基于paddlenlp+wechaty第一个实时微信语音聊天机器人诞生了: PaddleNLP + Wechaty 的微信闲聊机器人：通过Wechaty获取微信接收的消息，然后使用PaddleNLP的plato-mini模型根据对话的上下文生成新的对话文本，最终以微信消息的形式发送，实现闲聊的交互，可发语音、可发文字聊天，发一张图片，机器人会把图片转换成星际争霸风格的图片。 {% include iframe. html src=”https://www. bilibili. com/video/BV1BQ4y1f7HP” %} GitHub: https://github. com/AI-Mart/paddlenlp_chatbot LPCC：Look at the picture and change the color: 借助飞桨PaddlePaddle技术，构建未来世界的超级ChatBot，根据图像控制现实世界的LED流水灯！ {% include iframe. html src=”https://www. bilibili. com/video/BV1pq4y1p7XH” %} GitHub: https://github. com/zbp-xxxp/LPCC 七夕孤寡机器人: 七夕在即 你还在为怎么说情话烦恼嘛？ 你还在不知道怎么样文艺表白困苦嘛？ 你还在因为分不清口红而被责备嘛？ 你还在为一个人”孤寡”烦恼嘛？ 孤寡机器人解决你的困恼！ {% include iframe. html src=”https://www. bilibili. com/video/BV1ab4y1z7vs” %} GitHub: https://github. com/jhcgt4869/gugua_helps 证件照助手: 你是否苦恼于没有条件将证件照换背景色或是只有大头照。或是只有某种底色，要换其他底色，那么请使用它~它就是你的证件照小助手！ {% include iframe. html src=”https://www. bilibili. com/video/BV1jq4y1Q7NJ” %} GitHub: https://github. com/ITerydh/AImaker-paddleMakePhoto 九宫图爱心生成器~: 抖音风来袭，输入为一张图片，得到9张3*3的图片，画出属于你的爱心~拒绝繁琐的截屏！快来生成你美美的照片吧~送给女朋友的无敌神器！ {% include iframe. html src=”https://www. bilibili. com/video/BV1Cf4y1P7Kc” %} GitHub: https://github. com/ITerydh/Wechaty-makeJiuPic Wander[001] - 未来流浪者 V2. 1: Wander [ 001 ]是一个以AI chatbot为主体的跨媒体互联网艺术项目，包括可交互的微信端机器人、CG影像、以及实时更新的地图网站。 参与者可以通过微信向Wander发送现实中的地点，Wander会从随机的“未来时间点”前往当地，返回科幻游记与街景图。参与者可以用行动指令，让Wander探索未知的地点，甚至与遇到的角色互动交流。 每一次的旅行的时间点是不确定的，而旅行的结果会实时记录于地图网站上。在人类的参与中，未来的地图会被不断完善，形成一个由公众与AI共同构建的科幻未来。艺术家基于Wander传送的游记与图像进行进一步CG创作，通过人机配合延展对未来的构想。 本项目展出于2021 Wave Summit,2021保利春季拍卖NFT展区与2021北京时代美术馆-亚洲数字艺术展。 截至2021年8月，已有超过1000名参与者带领Wander旅行。我们希望Wander能让人们重新审视熟悉的环境，从我们最熟悉的通讯软件里给人带去惊喜。 GitHub: https://github. com/sunyuqian1997/Wander001-V2. 1 铅笔画下的虚拟形象: 在看到B站一些UP主，都是用虚拟AI合成的形象与观众互动，所以我也想用飞桨来自制一个属于自己的虚拟形象，也让大家可以在微信中，生成自己的虚拟形象。 {% include iframe. html src=”https://www. bilibili. com/video/BV1kv411K719” %} GitHub: https://github. com/zengzhuoqi/paddle-virtual-figures-in-penclings 星际终端 Wechaty+PaddleSeg+Paddle LSGAN+CV: 向外太空发信息，去寻找外星生物，外星植物，外星建筑, 或许它就藏匿在你附近。基于微信聊天的 结合增强现实技术（AR）+LBS(暂时基于图像） 的星际漂流瓶 的轻社交游戏。重新认识你身边的世界，或许我们早已与外星生命共同生活着。 {% include iframe. html src=”https://www. bilibili. com/video/BV1hL411E79M” %} GitHub: https://github. com/kevinfu1717/SuperInterstellarTerminal 星星的孩子 - 一款为孤独症孩子设计的聊天机器人游戏: 孤独症儿童是目前常常被忽视的一类群体。他们有着类似性格内向的特征，实际却受着广泛性发育障碍的折磨。这类儿童在与人交往时存在着沟通障碍。为孤独症儿童做出我们的贡献！ {% include iframe. html src=”https://www. bilibili. com/video/BV1hM4y157e3” %} GitHub: https://github. com/tipani86/StarChild 宇宙知识问答wechaty+paddlegan: wechaty+paddlegan制作的宇宙知识问答小游戏 ‘欢迎来玩宇宙知识问答~发送提问获得题目，答完第一题可以发送下一题答题，发一张照片，变成卡通荣誉证书 {% include iframe. html src=”https://www. bilibili. com/video/BV1E64y1s77a” %} GitHub: https://github. com/diandian16/wenda/ Paddlehub+Wechaty搭建能闲聊的聊天机器人: Chatbot是对话式交会的产品形态。 我们身边的Chatbot 闲聊型 任务型 问答型 今天我们就来了解下闲聊型机器人 {% include iframe. html src=”https://www. bilibili. com/video/BV1j64y1e7hE” %} GitHub: https://github. com/diandian16/chatbot 礼仪机器人C-3PO: Aurebesh语言转换器 {% include iframe. html src=”https://www. bilibili. com/video/BV1d44y1q7To” %} GitHub: https://github. com/yongxinliao-hqu/C-3PO_Wechaty_PaddleHub Space Disagreement Resolver: 在这个宇宙里最大的问题是什么？是分歧！但是怎样可以解决掉分歧呢？其实人类早已想到了办法，那就是猜拳，但这个看似很公平的方法其实存在两种致命缺陷，就是出手时的快慢和作弊！就是这两种缺陷而导致其它解决分歧方法的出现，像投票，辩论。但这是本末倒置，应该回到基本！第一代“分歧终端机”在地球上的出现成功解决了人类猜拳时的快慢和作弊问题！第二代“宇宙分歧终端机”的量产，将能够解决一切宇宙间的纷争… {% include iframe. html src=”https://www. bilibili. com/video/BV1ab4y1k74P” %} GitHub: https://github. com/yongxinliao-hqu/SpaceDisagreementResolver 微信刷题机器人: 我的一个朋友正在备考会计，每天看视频刷题。我便想到，能不能给机器人添加一个自动出题，用户答题，然后给答题成绩和解析的功能。毕竟闲聊娱乐只是一时新鲜，实用性才永恒王道，说干就干，于是就有了这个项目。 {% include iframe. html src=”https://www. bilibili. com/video/BV1X64y1W73R” %} GitHub: https://github. com/Turbolisten/wx-bot-java 对话故事生成，创造自己的无限世界: 如果可以，你最想穿越到哪部电影，小说里？ 这次利用 paddlenlp 中提供的 GPT2 和 wechaty 库展开对话故事续写，与 AI 互动共同创造剧情 预先设置你想交互的世界场景，比如面对三体人的进攻，发挥你的脑洞输入你想到的任何动作或者剧情大纲，模型的续写保证让你赞(hei)不(ren)绝(wen)口(hao) {% include iframe. html src=”https://www. bilibili. com/video/BV1Kg411E7PH” %} GitHub: https://github. com/27182812/Paddle_Story_Generation 科幻穿越星座能力者: 12星座若穿越科幻剧，会拥有什么超能力呢？快来迎接你的专属超能力吧！ {% include iframe. html src=”https://www. bilibili. com/video/BV1PL4y1v7nf” %} GitHub: https://github. com/27182812/paddle-wechaty-Zodiac Paint-Master 油画带师: 基于Wechaty和PaintTransformer的图像油画带师。油画中的世界，美不胜收。 {% include iframe. html src=”https://www. bilibili. com/video/BV1TL41187Lb” %} GitHub: https://github. com/AP-Kai/Paint-Master 移动小屋：智能车内互动玩伴: 移动小车， 智能车内互动玩伴 - 提供城市间，长途上和黑夜里多场景下的互动模式。 {% include iframe. html src=”https://www. bilibili. com/video/BV1D64y1i795” %} GitHub: https://github. com/livingbody/joy_rides HowlerBot: HowlerBot 定位是生活帮手，陪玩，整蛊等多元化的机器人。由于目前智商感人，有时候让人抓狂！不过她会成长，所以请给她点耐心，让我们见证脑残儿童的成长吧！ {% include iframe. html src=”https://www. bilibili. com/video/BV1wv411P78p” %} GitHub: https://github. com/jiaqianjing/HowlerBot 恋爱助手 一键表白 带走你的心上人: 你在恋爱时的神助攻 {% include iframe. html src=”https://www. bilibili. com/video/BV1Fg411V7wY” %} GitHub: https://github. com/pangay/PaddlePaddle-Wechaty-Mixlab- 捕捉你的宝可梦吧: 还记得小时候的神奇宝贝吗？ 你是不是也渴望拥有一只自己的宝可梦？哈，现在 Pokemon_Identify_Bot 帮你重回童年 {% include iframe. html src=”https://www. bilibili. com/video/BV1eL4y1Y7yf” %} GitHub: https://github. com/pangay/Pokemon-recognize wechaty+paddleGAN实现人脸融合功能: 在临近七夕的时候paddleGAN更新了人脸融合的新玩法,正好AI创造营开始了,所以两者结合,让wechaty和paddleGAN结合起来 {% include iframe. html src=”https://www. bilibili. com/video/BV1dg41157rZ” %} GitHub: https://github. com/liang1433223/paddleGAN-wechaty 多轮对话吐槽,emoi及打肿脸视频动态实时生成: 构建了可用于多个对话框架的场景型对话的聊天机器人。支持吐槽类情景及情感倾诉型情景。使用wechaty，结合Paddlehub的人脸特征点、动漫人脸生成、对联生成、情感分类，ernie迁移，人脸变胖 {% include iframe. html src=”https://www. bilibili. com/video/BV1nA41157i2” %} GitHub: https://github. com/kevinfu1717/multimediaChatbot 关于Wechaty: Wechaty 是一个开源聊天机器人框架SDK，具有多平台、多语言和多插件的特性，支持Python, Go, Java, Scala, . NET, PHP, Rust 等多语言版本，通过几行代码即可创建一个聊天机器人。经过5年多的发展，现在Wechaty开源社区已拥有数十位Committers，百余位Contributors，并被万名GitHub开发者Star。目前，Wechaty的开发者已遍布全球多个国家和地区，覆盖数万人，是国内活跃的Conversational AI Chatbot 开发者社区。 关于MixLab: MixLab是容纳了多元学科人才的跨界创新社区，目前已汇集5w+科技和设计等多元领域的跨学科人才，并拥有上海、北京、深圳、苏州分会，以期通过去中⼼化的方式，探索新知识、新领域，产生跨领域交汇的新方向。  微信公众号： mixlab无界社区、Mixlab and ibrandup人物 GitHub: https://github. com/MixlabPro关于未来事务管理局: 未来事务管理局是中国科幻文化的领军品牌。致力于以专业能力推动科幻产业发展，在科幻领域挖掘新的产品与价值，打造中国科幻的真正黄金时代。 未来局以科幻创作培育和内容开发为核心，覆盖影视、游戏、广告等业务，线下开展科幻创作工作坊、写作营，为科幻产业持续供给人才与内容。并在每年举办另一颗星球科幻大会APSFcon等大型活动，拥有国内泛科幻领域最具影响力的垂直媒体矩阵。 关于PaddleNLP: PaddleNLP是飞桨生态文本领域的核心开发库，具备简洁易用的文本领域全流程API、多场景的应用示例、非常丰富的预训练模型，深度适配飞桨框架2. x版。只有你想不到，没有PaddleNLP做不到！ 客服、闲聊、“凡尔赛”，对诗、写作、彩虹屁，起名、对联、码代码，参考官方示例，解锁更多超能力！ "
    }, {
    "id": 52,
    "url": "https://wechaty.js.org/2021/08/31/ospp-mid-term-qq-puppet/",
    "title": "OSPP 2021-期中报告-开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块",
    "body": "2021/08/31 - 本项目通过 Wechaty Puppet 的接口，可以将 QQ 进行 RPA 封装，使其成为 wechaty-puppet-oicq 供 Wechaty 开发者方便接入 QQ 平台，使其成为 Wechaty 可以使用的社区生态模块。 “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 本项目 [开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块] 系 暑期2021 支持的开源项目。 开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块: 项目背景: Wechaty 社区目前已经支持微信、Whatsapp、企业微信、飞书等常见流行即时通讯工具，并且能够通过多语言 SDK (比如 Python Wechaty) 进行调用。QQ 是国内和微信并列的两大聊天软件。我们在本次 Summer 2021 的项目中，Wechaty希望可以实现对 QQ Chatbot 的支持。通过 Wechaty Puppet 的接口，可以将 QQ 进行 RPA 封装，使其成为 wechaty-puppet-oicq 供 Wechaty 开发者方便接入 QQ 平台，使其成为 Wechaty 可以使用的社区生态模块。 方案描述: 使用 https://github. com/wechaty/wechaty-puppet-mock 项目作为模版，参考社区其他的 Wechaty Puppet Provider 代码模块，对 QQ 进行规划、RPA 选型、原型测试，和最终的代码封装。构建一个 Wechaty Puppet Provider 模块。 在初期开发中，能够实现文本消息的接收和发送，即可完成原型验证 POC。 项目技术栈:  TypeScript programming language Git RPA时间规划:  第一阶段（7月-8月）         7. 1-7. 10（已如期完成）     先和导师沟通，并观看Wechaty Puppet Provider 的 workshop 视频，熟悉Wechaty Puppet Provider的业务流程，并对自己目前还没有掌握的nodejs、npm、typescript等内容进行快速的了解和学习，对时间安排做好具体的规划           7. 11-8. 15（已如期完成）     开始正式进行代码的prototyping，先完成基础的功能，完成通过 Wechaty 加载 wechaty-puppet-oicq 模块，并通过oicq项目实现的qq协议，实现文本消息的收发功能。每周协同导师进行功能的开发和完善          第二阶段（8月-10月）   在现有基础上，滑动验证码登陆、设备锁、qq登陆风控等问题进行调研和排查          8. 16-8. 30     完成期中 Demo Day 视频和wechaty. js. org上的中期报告           9. 1-10. 30（即将完成）     继续完善功能，将消息接收，扩展到群聊天消息、图片消息等领域。       项目进度: 已完成部分:  wechaty. js. org的博客的配置 npm项目包的安装 typescript开发环境的熟悉 github pull request使用的全流程 wechaty-puppet-oicq模块的ding dong的完成（扫码即可运行QQ机器人，发送ding给机器人，即可收到dong的消息）完全按照有计划顺利进行，还略有加快。 遇到的困难与解决:    中途实习繁忙和生病导致拉下两周进度   虽然中间有生病，拉下两周，但也已经通过提高效率，重点攻克项目难点，成功赶上进度，并略有提前。     wechaty消息处理链路相对复杂，难以理解`   通过咨询项目导师和wechaty飞书机器人负责人等途径，观看社区livecoding视频，对消息处理进行快速学习，并通过编码实践，最终成功将oicq的事件和消息格式转换为了wechaty的messageRawPayload，也加深了对框架架构设计的理解。     遇到QQ风控 通过途径弄到了一些QQ小号方便测试。  后续工作安排: 按照原计划继续进行，并且尽可能对图片消息、语音消息等增加支持，使wechaty-puppet-oicq成为事件和API支持非常详细的机器人协议提供端。 项目成果: 项目仓库: https://github. com/wechaty/wechaty-puppet-oicq live coding视频：: {% include iframe. html src=”https://youtu. be/FY4U2JPZjxE” %}  国内版：http://www. iqiyi. com/v_gqyz7g94fw. html PPT展示视频：: {% include iframe. html src=”https://youtu. be/pT16CnFhTPQ” %}  国内版：http://www. iqiyi. com/v_1ixjchyr7yw. html 项目PPT：: {% include iframe. html src=”/assets/2021/08-ospp-mid-term-qq-puppet/qq-puppet. pdf” %} 联系我们:  导师：李佳芮 Wechaty co-creator, Founder &amp; CEO of Juzi. BOT (rui@chatie. io) 导师：李卓桓 Wechaty creator, Tencent TVP of Chatbot (huan@chatie. io) 学生：naivebird(github)：20210240029@fudan. edu. cn 项目链接：https://github. com/wechaty/summer/issues/81"
    }, {
    "id": 53,
    "url": "https://wechaty.js.org/2021/08/30/ospp-mid-term-wechaty-puppet-lark/",
    "title": "OSPP 2021-期中报告-基于开放 API 封装 Wechaty 接口下的飞书聊天机器人",
    "body": "2021/08/30 -  Code: wechaty-puppet-lark “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 本项目 [基于开放 API 封装 Wechaty 接口下的飞书聊天机器人] 系 暑期2021 支持的开源项目。 [基于开放 API 封装 Wechaty 接口下的飞书聊天机器人]信息:  导师：范蕊 学生：马田慧 项目介绍：https://github. com/wechaty/summer/issues/38 项目名称：基于开放 API 封装 Wechaty 接口下的飞书聊天机器人 方案描述：目前，飞书 Puppet 已经完成了初步开发，目前主要实现的功能有:消息收发（文字、文件、图片）,部分群组相关操作（创建群、修改群名、删除群成员等），部分企业相关操作（查看企业内成员等），接下来需要对照飞书开放平台和 Wechaty 接口，完善该项目。 时间规划：     熟悉wechaty         7. 14 - 7. 17     使用wechaty     了解飞书api          更新api版本         7. 18 - 7. 24          实现之前未实现的函数阶段         7. 25 - 8. 8     分两阶段完成，期间注重与导师交流          连接Contact、Message、Room等类         8. 9 - 8. 21          撰写文档，examples         8. 22 - 8. 28          项目完善         8. 29 - 9. 5     代码重构     发布npm包          项目进度:  已完成工作：     更新api版本，熟悉飞书api和wechaty。   实现之前未实现的函数   连接Contact、Message、Room等类，尝试实现复用   撰写文档、example   发布npm包    遇到的问题及解决方案：在环境配置上出现版本不匹配等问题，通过搜索+与导师沟通解决；在撰写相关文档提交时，出现格式不匹配问题，通过熟读规范与多次修正得到解决；一个大的项目往往规范是很重要的，wechaty-puppet构建了良好的生态，我从学习到了专业性与规范性，感谢在这里遇到的导师和小伙伴，他们的耐心与认真给了我很深的印象。 后续工作安排：前面任务按时完成，今后继续执行原计划。项目成果: 项目仓库: https://github. com/wechaty/wechaty-puppet-lark live coding视频: {% include iframe. html src=”https://youtu. be/fAIZS9lgxjo” %}国内链接：https://v. qq. com/x/page/j32711k0nfg. html PPT展示视频: {% include iframe. html src=”https://youtu. be/IwMA8VJZZqE” %}国内链接: https://v. qq. com/x/page/r3271wjg08q. html 项目PPT: {% include iframe. html src=”/assets/2021/08-ospp-mid-term-wechaty-puppet-lark/mid-term-ppt. pdf” %} 联系我们:  项目链接：https://github. com/wechaty/wechaty-puppet-lark               联系方式：+86 18660817606     email：2741102314@qq. com          "
    }, {
    "id": 54,
    "url": "https://wechaty.js.org/2021/08/30/ospp-mid-term-matrix-wechaty/",
    "title": "OSPP 2021-期中报告-基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善",
    "body": "2021/08/30 - “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 本项目 Matrix AppService Wechaty 系 暑期2021 支持的开源项目。 Matrix AppService Wechaty项目信息:  导师：李卓桓，yswtrue 学生：林宇靖，张瑞宁   项目介绍：https://github. com/wechaty/summer/issues/59   项目名称：基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善 方案描述：通过 Matrix-Appservice-Bridge 桥接 Wechaty 和 Matrix 的消息，使我们能在 Matrix 收发 Wechaty 消息，即收发来自微信，飞书等的消息。 时间规划：https://github. com/wechaty/summer/issues/59#issuecomment-882246195项目进度:  已完成工作：     在自己的服务器上部署Matrix和 Matrix-Wechaty，体验功能做出开发计划   实现图片和附件消息的收发   实现虚拟用户昵称和头像的展示   设计实现一套可以快速部署Matrix和Matrix-Wechaty的方案，并发布到github上   部署社区 Matrix 服务器    遇到的问题及解决方案：     遇到过一个puppet无法启动的问题。一开始定位问题后为了避免修改他人源码和和快速解决问题，自己使用反射方法强制修改了运行时的CPU架构。李卓桓导师提出该方式会对今后开发留下隐患，并引导我在其他项目上提出PR解决该问题。这让我体会到了开源项目的优势，我们不仅可以在自己的开源项目开发，同时能在使用开源项目时发现其他项目的不足，甚至做出修改，请求合并。同样的我们项目的使用者也可以在使用后对我们的项目提出修改意见。另外，我也更加清楚地认识到，编程开发是一件自由度很高的事情，但一个合格的程序员不仅要能根据需求实现项目功能，还应该考虑代码维护的便利，在合适的地方做出自己的修改。    后续工作安排：     后续工作安排及可能的调整会在https://github. com/wechaty/summer/issues/59#issuecomment-882246195中同步更新，同时它也能反映项目进度。   项目成果: 项目仓库: matrix-appservice-wechaty，easy-matrix-wechaty live coding视频: {% include iframe. html src=”https://youtu. be/qFqrAqmSrQ8” %}  国内链接：https://www. bilibili. com/video/BV12A411c7Nz/ PPT展示视频: {% include iframe. html src=”https://youtu. be/FgGFc_f_-oM” %}  国内链接：https://www. bilibili. com/video/BV1q3411B7qi/ 项目PPT: {% include iframe. html src=”/assets/2021/08-ospp-mid-term-matrix-wechaty/report-ppt. pdf” %} 联系我们:  项目链接：https://github. com/wechaty/summer/issues/59 联系方式：     林宇靖：lprintf@qq. com   张瑞宁：3134191406@qq. com   "
    }, {
    "id": 55,
    "url": "https://wechaty.js.org/2021/08/30/ospp-mid-term-5g-chatbot-puppet/",
    "title": "OSPP 2021-期中报告-开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块",
    "body": "2021/08/30 - “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 本项目 [开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块] 系 暑期2021 支持的开源项目。 [开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块]信息:  导师：[李佳芮 康嘉 李卓桓] 学生：[张瑞宁 邵琦] 项目介绍：https://github. com/wechaty/summer/issues/74 项目名称： 开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块 方案描述：     使用5g Chatbot接口，把收发消息测通   使用 https://github. com/wechaty/wechaty-puppet-official-account 项目作为模版，将其中的微信公众平台调用全部封装为RCS模块的调用   发布 Git Repo wechaty-puppet-5g-msg，实现文本消息的发送和接收   进行测试，完善项目文档   配置 GitHub Actions 实现自动化测试（可选）    时间规划：     使用5g Chatbot接口，把收发消息测通         7/12 - 7/18     配置好服务器，测通相关接口          使用 https://github. com/wechaty/wechaty-puppet-official-account 项目作为模版，将其中的微信公众平台调用全部封装为RCS模块的调用         7/19 - 8/10     学习现有源码，学习RCS的相关知识。     接入wechaty，进行代码整合，提高代码质量。          项目中期总结         8/11 - 8/15     实现阶段性目标，总结项目阶段性成果。          发布 Git Repo wechaty-puppet-5g-msg，实现文本消息的发送和接收         8/16 - 8/31     提供一个 examples/ding-dong-bot. ts ，完成“接收到文字消息ding时，自动回复消息dong”的功能          项目完善优化         9/1 - 9/15     撰写整个项目过程的总结博客。配置 GitHub Actions 实现自动化测试，增加单元测试等。          项目结项         9/16 - 9/30     总结项目成果，项目经验，准备结项材料。          项目进度:  已完成工作：     熟悉开发工具，了解硬核桃和Wechaty接口技术规范   配置好服务器，测通5G消息上下行接口，成功进行接受和发送消息的测试   学习平台目前Wechaty调用其他其他平台RCS源码方案   学习typescript    遇到的问题及解决方案：     Q：不清楚如何配置服务器   S：与康嘉老师线上视频请教服务器配置方案，成功解决   Q：不熟悉git的PR流程   S：参考github Action相关文档以及Wechaty社区提供的博客完成    后续工作安排：     尽快熟悉已有项目的源码https://github. com/wechaty/wechaty-puppet-official-account   继续补充完善项目功能,如：通过 5G Chatbot / RCS 底层，实现文本消息的收发功能，提供一个 examples/ding-dong-bot. ts ，接收到文字消息ding时，自动回复消息dong，添加收发图片和文档等功能 。   进行项目测试并提交pr。   完善项目文档。   项目成果: 项目仓库: https://github. com/zrn-fight/wechaty-puppet-walnut live coding视频：: {% include iframe. html src=”https://youtu. be/qGl0zXtDL4s” %} PPT展示视频：: {% include iframe. html src=”https://youtu. be/vCV0ijD0R9g” %} 项目PPT：: {% include iframe. html src=”/assets/2021/08-ospp-mid-term-5g-chatbot-puppet/5g-chatbot-ppt. pdf” %} 联系我们:  项目链接：https://github. com/wechaty/summer/issues/74 联系方式：     张瑞宁：3134191406@qq. com   邵琦：shaoqichn@qq. com   "
    }, {
    "id": 56,
    "url": "https://wechaty.js.org/2021/08/29/wechaty-story-generation/",
    "title": "对话故事生成，创造自己的无限世界",
    "body": "2021/08/29 - 对话故事生成，创造自己的无限世界: 如果可以，你最想穿越到哪部电影，小说里？ 这次利用 paddlenlp 中提供的 GPT2 和 wechaty 库展开对话故事续写，与 AI 互动共同创造剧情 预先设置你想交互的世界场景，比如面对三体人的进攻，发挥你的脑洞输入你想到的任何动作或者剧情大纲，模型的续写保证让你赞(hei)不(ren)绝(wen)口(hao) 项目介绍: 灵感来源:  无限恐怖 [AI Dungeon] (https://play. aidungeon. io/main/home): 在地牢2中，玩家将接触到一个完全自由的虚拟世界。整个游戏世界，都将围绕着玩家的输入展开与续写，可谓真正的 Everything is in my hands 。效果展示:    AIStudio链接     B站链接  安装依赖: pip install --upgrade paddlepaddle -i https://mirror. baidu. com/pypi/simplepip install --upgrade paddlehub -i https://mirror. baidu. com/pypi/simplepip install paddlenlp=2. 0. 7pip install sentencepiece=0. 1. 92注意事项: 本 github 中代码直接使用了 paddlenlp 提供的预训练模型 gpt-cpm-small-cn-distill 在 AI Studio 中按照教安装 paddlenlp==2. 0. 0rc14 然后引入 gpt2-base-cn 可以体验更好的生成效果。 注：在新版本的 paddlenlp 2. 0. 7 中已经找不到 gpt2-base-cn 模型，本地运行还是推荐使用代码中的 gpt-cpm-small-cn-distill（阿巴阿巴），只有400M，加载迅速适合体验学习。 测试对话系统: 只运行world. py，可以用命令行测试对话效果 python world. pywechaty网关: 如果 token 是 padlocal 模式， 请先安装 docker 再按如下步骤启动网关 # docker下载 wechaty/wechaty 镜像docker pull wechaty/wechaty# 确保gateway. sh中是自己的token， 服务器对外开放相关端口sudo . /gateway. sh如果 token 是其他类型， 可以直接跳过上面步骤， 访问此链接返回ip地址和端口，确认启动成功 https://api. chatie. io/v0/hosties/xxx你的token 启动wechaty: 网关启动成功并扫码登录之后，运行自己写的逻辑代码，监听聊天消息 请先把 main. py 中的 msg. talker(). name 改成自己的微信昵称，不然收到任何消息都可能被模型回复 # 安装wachatypip install wechaty# 确认main. py中环境变量替换成了自己的token，并且修改了发送者的用户昵称，然后启动python main. pyenjoy it ！ "
    }, {
    "id": 57,
    "url": "https://wechaty.js.org/2021/08/29/ospp-mid-term-wechaty-itchat-puppet/",
    "title": "OSPP 2021-期中报告-基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet",
    "body": "2021/08/29 - “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。官网：https://summer. iscas. ac. cn/ 本项目 [基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet] 系 暑期2021 支持的开源项目。 基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet信息:  导师：吴京京、李卓桓 学生：肖良玉   项目介绍：https://github. com/wechaty/summer/issues/75   项目名称：基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet 方案描述：     L0阶段：         预期效果：熟悉 Itchat 的各项 API ；熟悉 Wechaty Puppet 的开发流程；创建 python-wechaty-puppet-itchat 的 repository 。     实施方案：阅读 Itchat 文档，了解 Wechaty Puppet。          L1阶段：         预期效果：完成 python-wechaty-puppet-itchat 的登录与初始化部分的实现；完成 ding-dong-bot 的实现。     实施方案：了解 python-wechaty-puppet-service 是如何通过 gRPC 与远程服务器通讯的，并结合 Itchat 的设计模式，对比二者异同，思考如何将 Itchat 的函数封装进 wechaty-puppet ，思考 wechaty-puppet 的哪些代码对于该项目而言是不必要的，并完成对 Itchat 中 auto_login 函数的封装。 在此基础上深入了解 Itchat msg_register 函数的实现方法，并在此基础上封装进 wechaty-puppet ，同时完成发送消息函数的封装。同时参考其他 wechaty-puppet 完成 ding-dong-bot. py 并使其能正常运行。          L2阶段：         预期效果：配置 GitHub Action 实现 python-wechaty-puppet-itchat 自动发布到 Pypi 并完成自动化测试。     实施方案：了解 Pypi 的发布流程，并在参考已有 GitHub Action 配置文件的基础上完成自动发布的流程，同时完成自动化测试。          L3阶段：         预期效果：使用 Itchat 的 API 为 python-wechaty-puppet-itchat 实现 User 和 Room 部分的功能。     实施方案：在该阶段，我计划深入了解 Itchat 关于 User 部分的 get_contact 等函数的实现，封装为 Wechaty 的 User 相关模块的功能。同时将 Itchat create_chatroom 等函数封装为 Wechaty Room 模块的功能。          L4阶段：         预期效果：为 python-wechaty-puppet-itchat 实现 Itchat 的其他功能。     实施方案：在该阶段，我计划将 Itchat 剩余的接口根据 Wechaty 的代码风格封装进 python-wechaty-puppet-itchat 。          *L5阶段：         预期效果：完善 python-wechaty 文档。     实施方案：在了解 python-wechaty 的基础上，我计划在 python-wechaty 原有文档的基础上进行完善和补充。           时间规划：     第一阶段（7月-8月）         L0阶段开发 5天     L1阶段开发 10天     L2阶段开发 20天     中期验收          第二阶段（8月-10月）         L3阶段开发 10天     L4阶段开发 15天     L5阶段开发 15天     结项验收          项目进度:  已完成工作：     L0阶段：已完成（PR：init code by python wechaty puppet service #1）；   L1阶段：已完成对收发消息接口的封装，可以正常发出文字或图片消息， Puppet 已经可以收到消息，但 Wechaty 层由于部分原因，在事件触发上还存在问题（PR：添加scan/login事件 #4 和 Debug emit problem #6）；   L2阶段：已完成 CI/CD 配置（PR：Add CI/CD #7）和 PyPi 打包发布：https://pypi. org/project/wechaty-puppet-itchat/；   L3阶段：已完成对获取联系人列表和获取群列表接口的封装，剩余接口的封装工作待二期完成（PR：Debug emit problem #6）；    遇到的问题及解决方案：     困难1：对 CI/CD 中的各项工具不熟悉，推代码时遇到困难。   解决方案：根据导师推荐的资料，学习 GitHub Action 、 MakeFiles 、 pre-commit 等工具的用法，并配置 GPG key 等。   困难2：在 Wechaty Puppet 中无法正常使用 Itchat 的函数。   解决方案：根据导师的建议，深入了解了 Python 协程，将 Itchat 函数全部改为异步函数后得以解决。    后续工作安排：     0815-0820：解决当前关于 AsyncIOEventEmitter 与 Itchat 事件顺序混乱的问题；   0821-0831：完成 Itchat 中 create_chatroom 、 set_chatroom_name 等关于 User 和 Room 部分接口的封装；   0901-0915：完成单元测试和代码优化；   0916-0930：考虑实现 Wechaty 接口中存在，但 Itchat 中没有的几个接口；   1001-1025：时间精力充足的情况下，完成对 Itchat 的重构工作，并在重构代码上修改 python-wechaty-puppet-itchat 的代码   项目成果: 项目仓库: https://github. com/wechaty/python-wechaty-puppet-itchat live coding视频:  国内链接：https://www. bilibili. com/video/BV15P4y1p7JN/ {% include iframe. html src=”https://youtu. be/hce3c4WZylo” %} PPT展示视频:  国内链接：https://www. bilibili. com/video/BV1Ef4y1G7hE {% include iframe. html src=”https://youtu. be/gjg1EW30pOw” %} 项目PPT: {% include iframe. html src=”/assets/2021/08-ospp-mid-term-wechaty-itchat-puppet/itchat. pdf” %} 联系我们:  项目链接：https://github. com/wechaty/summer/issues/75 联系方式：lyle@hdu. edu. cn"
    }, {
    "id": 58,
    "url": "https://wechaty.js.org/2021/08/29/ospp-mid-term-club-managment/",
    "title": "OSPP 2021-期中报告-开发基于微信实现微俱乐部会员&活动管理的微信小程序",
    "body": "2021/08/29 - 暑期2021: “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 官网：https://summer. iscas. ac. cn/#/homepage 本项目 [开发基于微信实现微俱乐部会员&amp;活动管理的微信小程序] 系暑期2021支持的开源项目。 项目信息:    导师：鲁玉超     学生：陈婧     项目介绍：https://github. com/wechaty/summer/issues/78   项目名称：开发基于微信实现微俱乐部会员&amp;活动管理的微信小程序   方案描述:本项目需要基于wechaty开发一个能进行会员和活动管理的小程序。小程序的核心内容为报名服务，WeChat机器人作为服务之一完成接收信息，并响应入库的工作。本程序意在为使用者提供更方便快捷的管理成员及管理活动的功能。   时间规划：     阶段一         完成时间：7月20日     计划描述：引入聊天机器人，整理基础适用/开发生产环境/用户协议，绑定用户数据到俱乐部，使用微信开放平台实现“关键词回复”功能。          阶段二         完成时间：8月15日     计划描述：实践“群主发布活动”功能，实践“群主管理活动”功能，实践“成员标签活动”功能，完善以上功能块进行调试。          阶段三         完成时间：9月5日     计划描述：实践“活动相册”功能、“帮助”功能（将关键词与操作关联，要求提高容错性），如果有空余时间，设计自定功能。          阶段四         完成时间：9月30日     描述计划：实践自设定功能，收集中出现的问题，针对程序运行程序功能，小整体优化升级（用户数据处理）。          项目进度:  已完成工作：     基本理解服务和响应的区别   设计小程序界面显示   设计小程序基本框架   实现微信机器人引入   学习微信云开发技术   学习UI组件功能，初步引入    遇到的问题及解决方案：     之前的开发学习主要集中于前端部分，对于连接服务、后台响应等概念较为不清晰         方案：项目导师定期开会为我解答疑惑，同时我也在网上搜索了大量相关资料，将几个服务间的关系理清，为后续构架框架打下基础。          微信开发小程序语法处于不断更新的过程，比如今年就出现用户授权方式的大更改，因此学习起来有很强的时效性，哪怕以前可运行的代码现在也要慎重考虑         方案：遇到障碍第一时间查资料，遇到真假莫辨的信息寻求老师的帮助，同时也跟开发小程序的同学保持交流，以获取最新的资讯。同时不能停下其他工具的学习，从不同代码语法中寻找共同点，也很有利于理清代码间的关系。           后续工作安排：     根据自己的页面设计做出具体的交互型页面，加快组件的学习引入，实现群主&amp;群成员操作功能块、互动操作功能，提高小程序的实用性、容错性。   项目成果: 项目仓库: https://github. com/mangguo188/wechaty-club-management live coding视频：: {% include iframe. html src=”https://youtu. be/MoNLKnT2rJ8” %}  国内链接：https://www. bilibili. com/video/BV14M4y1V7GD/ PPT展示视频：: {% include iframe. html src=”https://youtu. be/oYcoOLfbgdE” %}  国内链接：https://www. bilibili. com/video/BV1wL4y1Y7cM/ 项目PPT：: {% include iframe. html src=”/assets/2021/08-ospp-mid-term-club-managment/mid-term-ppt. pdf” %} 联系我们:  项目链接：https://github. com/mangguo188/wechaty-club-management 联系方式：1017137803@qq. com"
    }, {
    "id": 59,
    "url": "https://wechaty.js.org/2021/08/26/wechaty-bot-of-coins/",
    "title": "基于python-Wechaty的微信群虚拟币报价机器人",
    "body": "2021/08/26 - 本项目基于python-wechaty库，通过几行代码就能实现微信机器人的基础功能。项目地址:coins_market_push 实现功能: 群聊中加密货币的报价  检索群聊中的加密货币币种关键词 币种匹配成功，从网络获取加密货币行情，目前支持三种平台 在群聊中发送加密货币行情信息，并@发送者效果展示: 使用步骤: 1、项目配置: class Notice:  EVENT_NAME = 'notice_python'  TOKEN = '{your IFTTT TOKEN}'  KEY = '{your notice key}'class Zengr:  APP_CODE = '{your app code}}'class PATH: # fxh币种列表  PATH_JSON = path_root + '/coin_list. json'class WECHAT: # wechaty token的配置  TOKEN = '{your wechaty token}'class CoinGK: # CoinGeCko的币种列表  PATH_JSON = path_root + '/conin_list_cgk. json' Notice: 通过IFTTT发送通知到手机(仅测试了iphone)，这里可以配置IFTTT的token Zengr：加密货币行情提供商，新用户有免费次数，目前收集的币种不多，不推荐 CoinGK：提供免费API可以获取行情，但免费版功能受限，能满足基本要求本项目默认使用非小号网站数据，不需要token，注意使用时要自律目前我们使用的wechaty token是官方的免费版，仅7天试用期。如果要使用长期版本的话，您可以成为wechaty的贡献者，或者花钱购买。毕竟钱能解决的事情，都不算事情。还有一种方式，就是使用UOS的web协议登陆，参考使用免费Web协议 2、主要代码:  talk is cheep, show you the code wechety. py async def on_message(msg: Message):  text: str = msg. text()  room: Optional[Room] = msg. room()  if text. startswith('@Robot'):    rev_str = text. replace(' ', '')    symbol = rev_str. split(' ')[-1]  else:    symbol = text  talker = msg. talker()  if get_conin_seq(symbol) &gt; 0:    await room. say(get_price(symbol), mention_ids=[talker. contact_id])这里是消息处理入口，get_price(symbol): symbol为币种，get_price()函数返回币种行情。get_conin_seq函数用于检查是否支持symbol币种。 def get_price(symbol):  symbol = symbol. upper()  idx = get_conin_seq(symbol)  result = get_coin(idx)  ret =  '\n' \      '【名称】 ' + result['data'][0]['fullname'] + '-' + result['data'][0]['name'] + '\n' \      '【USD价格】 ' +'$' + str(result['data'][0]['current_price_usd']) + '\n' \      '【CNY价格】 ' +'¥' + str(result['data'][0]['current_price']) + '\n' \      '【全球市值】 ' + '$' + str('%. 2f' % (result['data'][0]['marketcap']/100000000)) + '亿\n' \      '【24H涨幅】 ' + str(result['data'][0]['change_percent']) + '%\n' \      '【24H换手】 ' + str(result['data'][0]['turnoverrate']) + '%\n\n' \      + str(time. strftime( %Y-%m-%d %H:%M:%S , time. localtime()) ) + '\n' \      '数据来源：非小号'  return ret这里是get_price的具体实现，目前支持非小号前500个币种。 3、运行: python wechat/wechaty. py扫码登录后，其他用户在添加了机器人的群中直接发送币种（symbol），例如（btc、eth等），稍后机器人便会发送此币种行情到微信群中，并@发送者查收。 注意: 要注意一下，对于个人账户来说，币价查询访问不要太频繁，容易被服务器检测。  作者: 刘小龙，默默无闻的嵌入式工程师 "
    }, {
    "id": 60,
    "url": "https://wechaty.js.org/2021/08/26/ospp-mid-term-wechaty-puppet-oa/",
    "title": "OSPP 2021-期中报告-基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善",
    "body": "2021/08/26 - 暑期2021: “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。官网：https://summer. iscas. ac. cn/ 本项目 [基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善] 系 暑期2021 支持的开源项目。 项目信息:  导师：吴京京 学生：zzzyer 项目介绍：https://github. com/wechaty/summer/issues/82 项目名称：基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善 需求介绍：     申请开发专用测试公众账号   架设 wechaty-puppet-official-account 并可以进行微信公众账号的正常文本消息收发   Wechaty Puppet Official Account 的功能进行试用，分析其当前的功能，然后列出需要完善的功能列表，以及欠缺的功能列表，并作出开发计划   在初期开发中，能够实现图片消息的接收和发送，即可完成原型验证 POC。    模块列表：     文本消息收发模块   图片   音频消息收发模块   小程序消息收发模块   项目时间规划：: 时间：2021. 07. 01-2021. 07. 21:  申请微信公众平台测试账号 阅读Wechaty Puppet Official Account代码 成功运行Wechaty Puppet Official Account相关样例（ding-dong-bot） 与导师讨论得出要开发的功能模块时间：2021. 07. 21-2021. 08. 15:  完成文本消息收发的功能完善 完成图片消息的简单收发时间：2021. 08. 15-2021. 09. 30:  完善中期开发之前的功能模块 完成音频消息的收发模块 完成小程序消息的收发模块项目进度:  已完成工作：     文本消息收发模块   图片消息收发模块      遇到的问题及解决方案：   Q&amp;A1:在使用localtunnel进行内网穿透时，使用流程不太了解，在导师的仔细指导下完成了localtunnel内网穿透，对微信测试账号接口进行配置。   Q&amp;A2：在进行图片消息收发的时候，对整个数据的上传下载过程不了解，通过仔细阅读微信公众平台的接口文档了解整个交互机制。   后续工作安排：     音频消息收发模块   小程序消息收发模块   项目成果: 项目仓库: https://github. com/wechaty/wechaty-puppet-official-account live coding视频: {% include iframe. html src=”https://youtu. be/acEAgTdApQc” %} Bilibili link: https://www. bilibili. com/video/BV1zv411w7w6/ PPT展示视频: {% include iframe. html src=”https://youtu. be/iazpyB54PwU” %} Bilibili link：https://www. bilibili. com/video/BV1L44y1h7RR/ PPT: {% include iframe. html src=”/assets/2021/08-ospp-mid-term-wechaty-puppet-oa/wechaty-puppet-oa-midterm-ppt. pdf” %} "
    }, {
    "id": 61,
    "url": "https://wechaty.js.org/2021/08/26/ospp-mid-term-wechaty-piggy-bro/",
    "title": "OSPP 2021-期中报告-基于 Wechaty 开发开源的二师兄社群逗乐机器人",
    "body": "2021/08/26 - 暑期2021: “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。官网：https://summer. iscas. ac. cn/ 本项目 [基于 Wechaty 开发开源的二师兄社群逗乐机器人] 系 暑期2021 支持的开源项目。 项目信息:  导师：韩磊、鲁玉超、王玉丹 学生：井维嘉   项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/83     项目名称：基于 Wechaty 开发开源的二师兄社群逗乐机器人     方案描述   本项目需要基于Wechaty开发一个多功能群聊机器人。   该机器人的核心功能是编写并配置拦截器来实现对消息的响应。拦截器是一种固定传入参数和返回值类型的函数，通过编写拦截器的逻辑，可以拦截消息或放行消息给下一个拦截器，同时做出一定的响应。   本项目预置了若干功能，如查天气、讲笑话、成语接龙、猜字谜等以供使用和参考。同时，本项目希望能够允许用户自行添加功能，所以用户可以通过自己编写拦截器的方式，来为机器人添加功能。   本项目也将提供一个二师兄后花园页面，作为扩展的帮助文档、状态查询和日活功能使用。     时间规划：      开发可扩展式开发框架（7. 1-7. 7）         熟悉Wechaty开发模式     搭建二师兄开发脚手架          具体功能实现（7. 8-7. 30）         初步实现要求中的具体功能，可能包括且不限于：讲笑话、看热搜、查天气、成语接龙、猜图片、猜歌名     初步编写相关功能API的注册与部署文档          设计二师兄Logo及形象（8. 1-8. 7）         为二师兄的Logo和形象做出初步描述     Logo及形象定稿          开发二师兄后花园（8. 8-8. 30）         设计后花园功能和页面布局     搭建二师兄后花园服务及页面          编写文档与完善功能（9. 1-9. 30）         编写使用、部署及开发文档     整理代码并完善功能          项目进度:    已完成工作   目前已经完成了机器人基本框架的全部搭建，并且提供了讲笑话、看热搜、查天气、搜音乐、成语接龙、猜字谜的预置功能。   二师兄的Logo已基本定稿。     遇到的问题及解决方案   目前的主要问题是不能很好地应对自然语义的复杂环境。   由于设计上希望响应尽可能快速、高效，目前提供的示例插件均使用正则表达式来检查功能触发、解析参数。这样做有两个缺点：          正则表达式的覆盖虽广，却也不全面。     例如查天气功能中，预设了两种触发方式：“二师兄，查xx天气”和“二师兄，xx天气如何/怎么样”。但事实上问天气不止有这些问法，还有如“xx的天好不好”、“xx在下雨吗”等问法。这些特殊的问法并不能被正则表达式解析。           正则表达式对参数的提取不是非常好。     依旧以查天气功能距离，“二师兄，xx天气如何”这句话，关键在于提取出地名。但是由于“二师兄”这一触发词后面就是参数，所以提取地名就稍显困难。另外就如上一条举例，“xx在下雨吗”这类问话中，用户还表达了xx是否在下雨这一含义，这时更符合自然语言的应答应该是“xx在下雨”或“xx没有在下雨”。正则表达式暂时还做不到这些。        关于这一问题的解决方案，有一种是接入微信开放平台的语境检测API，这样可以较为准确地识别语义。另外也可以考虑使用jieba库分词来解决语义分析和参数提取的问题。     后续工作安排   后续工作与计划基本一致，优先考虑完成计划清单上的任务。   另外，计划着手对于拦截器的逻辑做进一步优化，允许开发者为功能配置预检和帮助文本。   关于自然语义识别这方面将会视产能而定。、  项目成果: 项目仓库：https://github. com/ReiKohaku/piggy-bro Live Code视频: {% include iframe. html src=”https://www. youtube. com/embed/i1AhcgQzQHw” %} PPT展示视频: {% include iframe. html src=”https://www. youtube. com/embed/VQ56QFz69Ek” %} 项目PPT: {% include iframe. html src=”/assets/2021/08-ospp-mid-term-wechaty-piggy-bro/mid-term-ppt. pdf” %} 其它:    项目链接：https://github. com/wechaty/summer-of-wechaty/issues/83     联系方式：   微信：ReiKohakuE-mail：hbsjzjwj@163. com  "
    }, {
    "id": 62,
    "url": "https://wechaty.js.org/2021/08/26/ospp-mid-term-cli/",
    "title": "OSPP 2021-期中报告-基于 Blessed 的 Wechaty 命令行文本客户端软件",
    "body": "2021/08/26 - “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 本项目 [基于 Blessed 的 Wechaty 命令行文本客户端软件] 系 暑期2021 支持的开源项目。 [基于 Blessed 的 Wechaty 命令行文本客户端软件]信息:  导师：李卓桓 学生：刘靖   项目介绍：https://github. com/wechaty/summer/issues/80   项目名称：基于 Blessed 的 Wechaty 命令行文本客户端软件 方案描述：     仿照 Linux 命令行终端的 IRC 文本客户端，实现一个基于 Wechaty 的即时通讯客户端，通过 Wechaty 支持所有现有的 Wechaty Puppet Providers，比如微信、企业微信、飞书、Whatsapp 等。   利用 Blessed 和 blesssed-contrib 提供的组件，绘制终端图形界面程序   监听消息接收和键鼠点击等事件，动态调整组件的内容，提供接近一般聊天软件的交互体验   使用 react-blessed、RxJS 和 Redux 重构代码    时间规划：     第一阶段（7. 1 - 8. 14）对接后端事件，选择恰当的架构与技术栈完成数据的存储、展示与更新         自行探索做出 demo             7. 1 - 7. 14       实现简单的消息接收和联系人列表展示       与导师沟通架构设计和需使用的技术栈                军训期间，项目暂缓             7. 15 - 7. 29       时间有限，学习前端相关知识或抽空实现较简单的功能                改进代码结构，重点推进数据的存储与状态的管理             8. 1 - 8. 14       实现消息内容按来源存储与查看       联系人与群聊信息的缓存       撰写中期报告                     第二阶段（8. 15 - 9. 30）重点完善前端交互，持续改进用户体验         提供更多的交互选项和管理功能             8. 15 - 8. 30       根据未读消息数量对联系人进行状态管理和智能排序                实现消息的发送             9. 1 - 9. 14                完善文档，编写样例代码和测试             9. 15 - 9. 30                     项目进度:  已完成工作：     所有消息的接收和存储   联系人与群聊信息的展示与缓存   GitHub CI/CD 和 NPM 包的发布   按当前聊天对象显示相应对话记录   选中群聊时显示其所有成员   消息的发送    遇到的问题及解决方案：     首先是技术上的问题，主要是 Blessed 长期无人维护，使用者也少，缺乏可参考的文档和资源。为了解决组件使用中遇到的 bug，常常需要深入阅读源码，为此我学习了使用 VS Code 调试 Node. js 程序的方法，成功找到了一些问题的原因并解决，还在导师的鼓励下向社区博客投稿。不过由于终端环境本身的限制和不同平台的兼容问题，Blessed 在渲染能力和交互性等方面确实不尽如人意，部分预想的功能可能终究难以实现。   还有就是架构选型和时间规划上的问题，在本身就缺乏独立开发经验的情况下，我一开始执着于架构的选择，企图从一开始就确定好所有方案，浏览了相关项目后反而更迷茫，转而开始实现功能后才发现 Blessed 有诸多预想之外的问题，还是要自己亲自实践逐一踩坑，软件开发没有银弹。   最后就是开源项目维护上的问题，在导师的帮助下，使用 Issue 来细分任务并管理进度，利用 GitHub Actions 进行 CI/CD，发布 NPM 包    后续工作安排：     目前基本的聊天功能已粗略实现，联系人和群聊管理还要和导师讨论以何种形式呈现   考虑到 blessed 和终端的特性，一般聊天软件的设计（如新对话置顶）可能无法照搬   在保证可用性的情况下，使用 React 和 Redux 重构项目   项目成果: 项目仓库: https://github. com/wechaty/cli live coding视频: {% include iframe. html src=”https://www. youtube. com/watch?v=1U0ONeHV7z8” %}  国内链接：https://www. bilibili. com/video/BV1L3411q72g/ PPT展示视频: {% include iframe. html src=”https://www. youtube. com/watch?v=xPsAwLglVdM” %}  国内链接：https://www. bilibili. com/video/BV1PQ4y1a7pM/ 项目PPT: {% include iframe. html src=”/assets/2021/08-ospp-mid-term-cli/mid-slides. pdf” %} 联系我们:  项目链接：[https://github. com/wechaty/cli] 联系方式：liuchinggg@gmail. com"
    }, {
    "id": 63,
    "url": "https://wechaty.js.org/2021/08/26/gdg-community-talk-google-season-of-docs/",
    "title": "Wechaty 开源社区文档协作 Google Season of Docs 实践分享",
    "body": "2021/08/26 - Google Season of Docs （GSoD）是 Google 自 2019 年发起的一项面向全球开源社区的文档支持计划，目标是为开源社区提供资金、指导完善他们的开源项目文档，并且通过了解开源社区的文档协作情况，帮助更多开发者习得专业的技术文档写作方法。 入选的 GSoD 的开源项目，除了可以得到 5000-15000 元美金的资金资助以外。组织会帮助开源项目一起对现有技术文档进行重新设计，创建新的文档体系，优化技术文档的生产流程，以创作出更优质的技术文档内容。 在今年的 GSoD 中，全球共有 30 个项目最终入选 GSoD，其中作为中国首位入选的中国开源项目 Wechaty，获得了广泛的关注。在项目期间，共有 12 位技术文档专家共同参与、协作，完成了对 Wechaty 技术文档的优化与完善。 Wechaty 作者李卓桓（谷歌机器学习开发者专家）将通过社区说的直播，和大家一起分享这一段实践经验。  谷歌开发者专家 (Machine Learning) TensorFlow. js 布道师 《Chatbot 从 0 到 1》《简明的 TensorFlow 2》联合作者 GitHub 万星开源 Conversational SDK Wechaty 作者 PreAngel 天使投资人，专注 AI/Chatbot 领域创业团队和项目Wechaty 开源社区文档协作实践分享: {% include iframe. html src=”https://youtu. be/6sTGgH9qsl0” %}  YouTube: https://youtu. be/6sTGgH9qsl0  0:00 社区说活动开场：GDG 主持人袁衮衮介绍 5:10 Huan 自我介绍 7:54 Wechaty 对话式交互SDK简介 14:48 Documentation System 介绍 54:03 介绍 Google Season of Docs (GSoD) 46:28 Wechaty 的 GSoD 体验：与全球13位 Tech Writer 进行文档协作 54:02 Demo 演示: Wechaty Ding/Dong Bot 1:08:53 互动问答Slides: {% include iframe. html src=”https://docs. google. com/presentation/d/e/2PACX-1vQV8hJWS97ga10fhfaC3wwEmwBWRoC9csmv3tQOspRzBFb-PAwfEC6azXubXabBZ8gb4SkzQHMg40ba/embed?start=true&amp;loop=true&amp;delayms=3000” %} Wechaty Google Season of Docs Slides is hosted on Google Slides(Docs) at here Blogs:  Hello Wechaty GSoD’21 Technical Writers!, @huan, May 08, 2021 Google Season of Docs ❤️ Wechaty, @huan, Apr 30, 2021 Google Season of Docs 2021 proposal关于社区说: 「社区说」是由谷歌开发者社区 (Google Developer Group) 与谷歌开发者专家计划 (Google Developer Expert) 联合推出的社区项目。每周四晚 8 点到 9 点，与热爱技术的开发者们一同交流技术，进行代码直播、讨论产品、分享心得的小型线上会议。 活动将由不同的谷歌开发者社区举办并邀请来自国内的不同技术方向的谷歌开发者专家以及对技术有热情、愿意分享的嘉宾，一起来聊一聊最近做的项目，最近写的代码，或者三五技术好友互相探讨聊天。  Source: 听 Google Season of Docs 入选项目谈文档协作 "
    }, {
    "id": 64,
    "url": "https://wechaty.js.org/2021/08/21/super-interstellar-terminal/",
    "title": "<x 世纪星际终端>基于 wechaty 的 AR+LBS 漂流瓶轻社交游戏",
    "body": "2021/08/21 - 基于微信聊天的 结合增强现实技术（AR）+LBS(暂时基于图像） 的星际漂流瓶 的轻社交游戏。重新认识你身边的世界，或许我们早已与外星生命共同生活着。 A. 项目介绍: A. 1 项目模块：:  项目由下面的模块组成，每个模块都可以单独使用，也可组合使用，如：直接按需就调用图像生成外星人、外星生物、外星植物、外星建筑       简要   具体描述   项目中的代码及模型         1. 基于 LSGAN 的外星生物生成，利用爬虫与 GAN 生成我们想要的东西的过程   请跳转到本页中的 C. 1   Train. zip       2. 快速调用PaddleSeg的cityscapes模型，进行18类常见物体的分割   请跳转到本页中的 C. 2   CityscapesModule. py +PetModel文件夹       3. OpenCV的seamlessClone实现图像融合，呈现各种AR效果,遮挡关系等   请跳转到本页中的 C. 3   alienPetModule. py       4. 外星人换脸，外星人脸与地球人脸融合效果的优化   请跳转到本页中的 C. 4   alienHeadModule. py       5. YUV颜色空间实现颜色图案迁移，基于CV技术生成外星植物   请跳转到本页中的 C. 5   vegetateModule. py       6. PaddleHub的msgnet实现图像迁移，基于深度学习生成类流沙或沙画效果   请跳转到本页中的 C. 6   sandModule. py + msgnet文件夹       7. Wechaty漂流瓶游戏，微信漂流瓶及通过开发者模式控制整个流程   请跳转到本页中的 D   bot文件夹    A. 2 太空漂流信息:  你可能收到来自一个未知星域发过来的漂流瓶，你也可以把你想抒发的情感发向星际中    嗨，别来无恙啊，此刻的你是否有些孤独，别怕，此时此刻，在浩瀚宇宙中，总有与你相似的灵魂，你们或许来自不同的星球，有着不同的文明，但你们仍然可以通过太空漂流瓶去表达内心的情感，快来开启你的太空漂流瓶之旅吧。     用户可以在加本官方微信好友后，向本官方微信发出包含文本与图片的漂流瓶。也可以主动接收漂流瓶。     甚至，在一个你意想不到的时刻会收到想象之外的漂流瓶信息。发送与接收漂流瓶都可以提升等级噢！  A. 3 增强现实技术（AR）+位置服务（LBS）的游戏:  接收漂流瓶任务，或主动出击，寻找身边潜藏的外星人、外星生物（宠物）、外星植物、外星建筑    基于微信聊天中的图片及文本聊天。通过文本接受到任务或主动触发。     可能是让用户帮忙寻找它丢失的某个外星宠物（外星生物），或者帮它找到急需用于治疗的外星植物，也可能是让你帮忙找到正在被通缉的外星人囚犯。  A. 4 体验视频：（建议全屏观看）: {% include iframe. html src=”https://player. bilibili. com/player. html?bvid=BV1hL411E79M” %}    欢迎小伙伴推荐地点及地点图片或直接加入本项目，可以先star或Fork跟踪更新进度   github地址：https://github. com/kevinfu1717/SuperInterstellarTerminal     扫码加群，按群公告操作即可体验     B. 故事背景:    地球并不只是人类的天下，其实有数万名外星人及其外星低等生物生活在我们当中，他们有的因为母星被毁有的因为星际战乱而选择到地球避难。     银河星际移民局则管理并协调着他们在地球的生活。借助超高级科技，他们隐藏原来的外观，装扮成是普通地球人，我们根本分辨不出来，说不定，站在你旁边的就是一位外星友人。     同时，他们也带来了外星的低等生物及外星植物，通过超科技把他们隐藏起来，装扮成地球物种或我们完全看不到。    C. 项目中的技术功能介绍: C. 1 AI寻找你身边的外星生物: 建立外星人图鉴，让我们看一下AI预测的外星人形象是怎样的: 先看一下AI预测的外星生物矢量图： a. 训练素材:    从百度爬取“外星人”的图片，但因为外星人搜出来的图太杂乱。所以改变思路，用关键词“外星人 矢量”来进行搜索爬取。搜出来的外星人图片相对没那么杂乱。勉强可以用来训练。勉强是有1/5左右是白底，有1/5左右是PS中那种透明图的格子底图或水印的，有1/5是背景各种颜色的图，还有1/5是多个外星元素组成的图。大概数据见下图：    b. 数据处理与增广:  尝试过用midars模型或CV来提取单个外星生物，但效果都不是很好。所以，最终只使用水平翻转，增加了一倍的数量。尽管可以爬取来增加这个数量，但越到后面，爬取的图片质量越差。所以还是通过水平翻转来处理。c. 模型:    训练文件：见项目中 Train压缩包下 TrainAlienPet. ipynb     模型文件：见项目中 Train压缩包下 generator0725. params     搜索了一下GAN的模型，结合可训练性与生成效果，选择了LSGAN。基于项目aistudio上“独楼望天涯”大佬的项目 https://aistudio. baidu. com/aistudio/projectdetail/1936908进行修改。     在其基础上，每个epoch执行更多的Generation，以及修改了超参数（ 偶尔判别器loss高时，会有些完全不像的图）。     训练过程：Epoch 0 ~ Epoch 999 的LOSS及效果见下面动图：       具体训练项目地址见：   Paddle2. 0-通过LSGAN让我们看看AI预测的外星人长什么样子     不足：          大概在200epochs就已经差不多，再训练到1000epochs反而效果还下降了。loss方面，判别器可以达到0. 02，但生成器只能到0. 8。这方面还可以优化           最终会有不少彩色的杂点           生成的外星生物矢量图有些还保留训练图的方格背景之类的。           生成的外星生物可能有部分过拟合，为有些很向原来的。       d. 后处理:    在叠加到现实图像中做AR效果时，使用cv处理优化这部分（具体见3-d中的描述）     为外星生物配上背景介绍，定义他们出现的位置，建立外星生物图鉴   生物图鉴：AI生成的外星生物 C. 2 识别现场环境——CityscapesModule. py: a. 模型: PaddleSeg 中基于cityscapes数据集的SOTA模型 PaddleSeg训练了一个在cityscapes数据集上SOTA的模型。却很低调，只是放在contrib中，仅有个英文的介绍。里面的介绍还主要针对训练的，如果只是想要体验SOTA的cityscapes的效果是怎样的却很麻烦。本项目中化简了相关的代码，一行代码体验cityscapes分割。效果真的对得起SOTA的！ b. 相关文件:    目录结构（单独使用本模块，只需修改CityscapesModule. py中的 im_path ）：   . ├── CityscapesModule. py└── PetModel  ├── modelCityscape. pdparams  ├── pretrainedCityscape. pdparams  └──mscale_ocr_cityscapes_autolabel_mapillary_ms_val. yml      pretrainedCityscape. pdparams下载地址：https://bj. bcebos. com/paddleseg/dygraph/cityscapes/ocrnet_hrnetw48_mapillary/pretrained. pdparams     modelCityscape. pdparams下载地址：https://bj. bcebos. com/paddleseg/dygraph/cityscapes/mscale_ocr_hrnetw48_cityscapes_autolabel_mapillary/model. pdparams     mscale_ocr_cityscapes_autolabel_mapillary_ms_val. yml 为PaddleSeg模型的yml文件  c. 功能/作用: 让AI能感知环境里有哪几样物品，同时可以定位到其在图片中的具体位置。具体识别的物品如下： (PS:注意真实返回的ID是从0开始的，所以是trainId-1，如sky实际返回的id是10 not 11）： d. 使用:    运行CityscapesModule. py脚本,设置待处理图片的路径，将返回大小于原图片大小一样的二维数组pred，其取值是从0~18。     可以拿这个二维数组作为mask，例如用np. where(mask == index, 1, 0)来截取自己感兴趣的区域，index取值为上表中实际返回ID ,也即 trainID -1。     CityscapesModule. py中把pred ×10后保存成图片，见右下图（图片像素的灰度值从0~180）。    C. 3 寻找隐藏在环境中的外星生物（外星宠物）——alienPetModule. py: a. 准备:    配合LSGAN生成的外星生物的形象，为起配置喜好，所在环境等，写入到ConfigPet. py中。     ConfigPet. py中每个dict就是一种外星生物，该外星生物的id就是那个dict的key。     ConfigPet. py中的areaIndex对应的就是cityScapes返回的物体ID，例如，areaIndex=10，则代表此生物是出现在天空中。  b. 作用: 实现对应位置的叠加AR效果。如：天空中出现飞在天上的外星生物，树丛中会出现喜欢在树上的草食性外星生物。 c. 步骤: c. 1. 准备基于LSGAN生成的外星生物矢量图。配置其参数，如：名字、大小、常出现的位置，习性描述、是否需要遮罩等。 c. 2. 选择先判断alienIndex是0（随机生成），还是-1（不生成），或者是&gt;0（生成id等于alienIndex的外星生物）。 c. 3. 定位基于分割模型得到的mask区域，按照外星生物可存在的位置判断是否出现外星生物，及其出现位置。具体见关键技术点说明。 c. 4. 合成根据外星生物的特性使用cv2. seamleClone，参数选用MIXED_CLONE或NORMAL_CLONE。具体见关键技术点说明。 d. 关键技术点: d. 1 cv2. seamlessClone三种图像合成效果# 会把src图的边缘进行模糊化，同时整个src图的色彩融合到dst中-&gt;需要src图较清晰，dst背景较简单，可以接受src图周边边缘模糊的场景cv2. seamlessClone(src, dst, src_mask, center, cv2. NORMAL_CLONE)# 基于透明度的融合，src图中白色的区域会显得透明度高，看起来叠加的颜色比较透-&gt;适合dst背景较复杂，但对src图清晰度要求不高，src图背景是白色的场景cv2. seamlessClone(src, dst, src_mask, center, cv2. MIXED_CLONE)# 会把src图变成灰度图合成到dst中-&gt;暂时看不到什么好用途cv2. seamlessClone(src, dst, src_mask, center, cv2. MONOCHROME_TRANSFER)借用别人的图，懒得生成了，左中右分别是：NORMAL_CLONE，MIXED_CLONE，MONOCHROME_TRANSFER： 简单背景： 复杂背景： 效果好坏于背景图dst及前景图src都有关系 d. 2 结合mask的优化版seamlesClone图像合成效果——代码见alienPetModule. py中的maskOfWhiteBG()，roiAreaCheck()      把src的外星生物图转成HSV格式，通过V通道，V大于200得到二值化的mask。HSV的V分量可以当作是亮度，在本次LSGAN生成的外星人中基本都是白色底的，可以抠处白色底         二值化的图进行开运算。去除LSGAN中生成的一些彩色噪声点，得到外星生物的mask，宁愿漏也不要去多了。因为合成时有个渐变，自然就把杂点淡化了。          把2中的二值化图进行边缘裁切，使mask图的四个边都有白色区域接触。这可能是seamlessClone的一个bug，若白色区域不接触图像边缘，其合成时的位置是按白色区域的中心点位置，不是mask图像的中心点位置，切记！         根据裁切后的mask，重新计算中心点左边center=(x,y)。seamlessClone的center参数是src的中心点在dst图中的位置。   d. 3 结合cityScapes分割的AR定位——代码见alienPetModule. py中的erode2LeftTop（），leftTop2Center()      利用cityScapes返回的pred图中，获取画面中某个物品的mask。利用np. where(pred==areaIndex, 1, 0)生成二值化mask。          根据用户图片dst的大小，及外星宠物的scaleRatio参数，调整外星宠物图片的大小。大小设置为dst图像长边scaleRatio，再有一个（0. 8~1）倍的随机         对二值化mask图4个边缘的值都设置0。相当于mask图边缘多了一个黑色的框，方便待会腐蚀时，可以从边缘也腐蚀。否则，贴着边缘值为1的点待会都不会倍腐蚀         以调整后的外星宠物图像的边长d，对二值化mask图像进行opencv的腐蚀操作。腐蚀后，值为1的点则为可选的外星宠物图像进行seamlessClone的center点。腐蚀相当于我们的卷积，当该点腐蚀后仍为1，则证明其腐蚀前周围值为1的点能组成一个d×d的形状          若腐蚀后，mask图都为0，则缩小腐蚀的kernel为原来的0. 6，再重复4的步骤。步骤4完成后没能找到mask中为1的点则证明，没有足够位置完全把外星宠物图像放进去，我们缩小要求，要求某区域只要有60%的外星宠物的大小则继续融合进去         若4或5步骤后，mask中有值为1的点，则满足条件,可进行图像合成   d. 4 前后关系   有外星人又则怎能少了外星飞碟呢。外星飞船要逼真需要又遮挡关系，我们可以利用cityscapesModule识别出的天空区域。     一句代码实现遮挡：   【伪代码】 np. where(mask=天空的index, 已叠加飞船的图，原图）    C. 4 外星人显形——alienHeadModule. py: a. 模型: Paddlehub landmark模型 landmark的68个人脸关键点模型具体介绍请见官方介绍：https://gitee. com/PaddlePaddle/PaddleHub/tree/release/v2. 1/modules/image/keypoint b. 作用: 实现外星人换脸 c. 步骤: c. 1. 准备   找到一张外星人正面的照片与侧面的照片，扣出其形象保存图片。     我们需要手动用labelme的keypoint为其标上68个关键点，大概就好，不用太精确。landmark数据按labelme格式保存到json中。     配置外星人的人脸参数到ConfigHead. py中。  c. 2. 对齐   对用户发来的图片，利用PaddleHub的landmark模型获取图片中的人脸特征点。     正脸使用正脸的外星人照片的，侧脸用侧脸的预处理照片。若角度太偏则不进行处理。然后，使用landmark中脸颊的特征点求中点进行人脸图像位置上的对齐。并根据用户图片的人脸对外星人人脸进行大小调整  c. 3. 融合粘贴   截取外星人人脸，生成一个上到下的渐透明的遮罩图。用cv2. seamlessCloned的NORMAL_CLONE复制到原人脸位置，但因为seamlessClone没法调参数的，外星人形象融在背景里面，不太明显不清晰。     截取外星人人脸及颈部及上半身，生成一个上到下的渐透明的遮罩图。用cv2. addWeight把外星人脸与1中所述的人脸进行透明度融合。  d. 关键技术点: d. 1 问题分析直接把外星人脸贴到用户图上边缘会很硬，如上图中的左图。 d. 2 单方向渐变遮罩使用从上到下的遮罩，可以有效渐变过度到身体。上到下的渐变mask生成见CVTools. py中的gradientMask()。只用上到下的渐变，是因为外星人头会比正常人头大，本身过渡要求不高，所以上，左，右方向的融合过渡，依靠seamlessClone则可较好处理。剩下 下 这个方向是连接颈部或身体的需要渐变遮罩过渡。（见下图） d. 3 双重图片叠加融合   只是使用seamlessClone融合，会因为seamlessClone算法影响，把贴上去的外星人图颜色变得较多，算法只为让其融合到附近环境。原图是这样的：       cv2. seamlessClone没有参数调节，使得整个外星人头的颜色都变了。见下图左。  双重图片叠加融合，效果见下图右。       双重图片叠加融合步骤：（具体代码为项目中：alienHeadModule. py)               生成head的渐变mask。使用d2所述的方法生成头部的渐变遮罩。                   hard paste head。使用直接粘贴替换的方式，把外星人的head粘贴到用户的图的适当位置。                   生成Body的渐变mask。把外星人头及颈部或身体上半部 对齐head的位置，使用d2所述的方法生成mask。                   seamlessClone Body。使用3所述的mask图，把外星人身体上半部seamlessClone到用户的图中，需要保证粘贴后头的位置是跟步骤2一样的。                   合成。使用cv2. addWeight实现透明度叠加步骤2与步骤4的图。 cv2. addWeighted(src1, alpha, src2, beta, gamma)，根据不同外星人的皮肤深浅调节alpha，beta。最终效果见上图。          C. 5 寻找生长在地球的外星植物——vegetateModule. py: a. 准备: 找一些外星植物的图片，实现非深度学习的基于图像技术的颜色纹理迁移。也可以是一些想要的风格的图，如下图中的任意一种 b. 作用: 把环境中的植物变换成外星风格的植物 c. 步骤: c. 1. 准备基于这些外星植物，在ConfigVegetae. py中配置其参数，如：名字、常出现的位置，习性描述等 c. 2. 选择先判断vegetateIndex是0（随机生成），还是-1（不生成），或者是&gt;0（生成id等于vegetateIndex是0的外星植物）。 c. 3. 定位基于分割模型得到的mask区域，按照外星生物可存在的位置判断是否出现该外星植物，及其出现位置。 c. 4. 合成根据外星植物的特性使用yuv颜色通道合成。具体见关键技术点说明。 d. 关键技术点: d. 1 YUV颜色区间   比较熟悉CV的同志们可以忽略此节     我们使用CV的方法进行处理时，通常不会再RGB颜色空间处理，而是转到HLS/HSV 也有 YUV颜色空间进行处理。这样作的好处是 其中的H 通道在一定程度上可以表示其颜色。通过这样来选择特定的颜色，S代表饱和度，V代表亮度。而YUV中 Y是亮度，U,V分别是 蓝 红 通道。     YUV具体介绍可见：https://zhuanlan. zhihu. com/p/95952096  d. 2 YUV颜色融合   我们也可以通过Y通道融合亮度，保留外星的U,V通道，即保留其颜色。当两个图片融合时，通过调节融合的Y通道的权重，控制合成出来的颜色亮度。   # 把图片style，content转到yuv空间yuv = cv2. cvtColor(np. float32(style), cv2. COLOR_BGR2YUV)y, u, v = cv2. split(yuv)yuv2 = cv2. cvtColor(np. float32(content), cv2. COLOR_BGR2YUV)h, j, k = cv2. split(yuv2) # 根据ratio这个比例来合成 style 与 content两张图hy = np. array((h * ratio + y * (1 - ratio)), 'uint8')# hy = np. clip(hy, 0, 255) # 两张图进行合成content = np. dstack((hy, u, v))content = cv2. cvtColor(np. float32(content), cv2. COLOR_YUV2BGR)   C. 6 寻找被外星人隐藏起来的外星建筑——sandModule. py: a. 准备: 使用Msgnet迁移训练的沙画模型，实现基于深度学习的风格迁移。 大家可以对比一下5中的外星植物的效果，那是基于CV技术的迁移 b. 作用: 把环境中的建筑变成像流沙组合起来的建筑 c. 步骤: c. 1. 定位基于分割模型得到的mask区域，定位areaIndex==2,即building的区域。 c. 2. 图像迁移把建筑转成灰度图，然后用msgnet迁移成流沙的风格。 C. 7 使用ImgGenerateModule 建立Alien Server或直接调用: a. 直接调用函数: ImgGenerateModule可以单独使用或app. py也可单独建立flask的图像生成服务供其他用途使用    初始化函数定义各个模型文件夹及图片素材的位置   imgGenerator = ImgGenerator(  debug=False,  ymlPathSeg='PetModel/mscale_ocr_cityscapes_autolabel_mapillary_ms_val. yml',  #cityscapes分割模型的yml  modelPathSeg='PetModel/modelCityscape. pdparams',  #cityscapes分割模型文件  modelPathSand='msgnet',  #沙画模型文件夹  picPathHead='HeadPic/',  #外星人头素材  picPathPet='PetPic/',  #外星生物素材  picPathVeg='VegPic'  #外星植物及外星建筑素材)      调用函数生成   输入是图片路径：   rc, img, des = imgGenerator. run(  dstPath,  alienHeadIndex=0,  vegetateIndex=0,  environmentIndex=0,  alienPetIndex=0)    输入直接是图片：   rc, img, des = imgGenerator. runImg(  img,  alienHeadIndex=0,  vegetateIndex=0,  environmentIndex=0,  alienPetIndex=0)      参数说明               参数名     必选     类型     说明                   img/dstPath     是     string     待处理图片或待处理图片的地址             alienHeadIndex     否     int     是否进行换外星人头，-1为不处理，0为随机，&gt;0为指定index为该值的外星人             vegetateIndex     否     int     是否添加外星植物，-1为不处理，0为随机，&gt;0为指定index为该值的外星植物             environmentIndex     否     int     是否生成外星建筑外墙，-1为不处理，&gt;0为生成             alienPetIndex     否     int     是否进行添加外星生物，-1为不处理，0为随机，&gt;0为指定index为该值的外星生物             返回说明               参数名     类型     说明                   result_code     dict     { 返回结果代号 ：返回结果描述}，result_code参数具体见代码中说明，200为正常生成             img     numpy array     生成的图片或原图片(没有适合的位置生成时返回原图片)             dis     dict     包含生成外星人/生成外星植物/生成外星建筑/生成外星宠物的参数的字典. 没有进行处理则为空字典          b. 建server，访问图像生成接口 (本项目中使用的方式）: 不确定什么原因，以前Wechaty都可以在AI Studio的脚本任务跑，现在好像不可以了，从AI Studio脚本任务无法访问外网的端口了，可以ping通外网。所以，需要另外找自己的主机作深度学习这部分的图片推理生成，因此直接把上述功能再弄到flask中，弄了个接口。    接口代码见：项目中的app. py脚本     接口文档说明见showdoc：https://www. showdoc. com. cn/1525661816374166/7370335053618085     并发问题：flask接口默认允许并发，即可能很短时间内或同一时间调用里面的函数的，但鉴于我们的运算都是GPU的，不支持并发调用。所以，使用了gevent来设置阻塞的服务。即会一个处理完再调用处理下一个，中间还没处理的会等待。  C. 8 识别图像的拍摄位置: a. 前提条件（需同时满足下面条件）:    用户是在微信中，用原图发送照片给我们     照片拍照时，其拍照设置中打开了保存地理位置信息  b. 背景情况介绍:    若用户满足上述2条件，则保存的照片里将含有exif信息。该EXIF信息，可在Windows中图片的属性中看到，GPS，拍照日期等信息：       EXIF的详细介绍可见，这里不详细叙述了:   http://www. 360doc. com/content/18/0303/07/7793103_733844932. shtml  c. 获取经纬度——exifModule. py:    python中有pip库可以直接获取照片的exif信息， 具体代码可见项目工程中的exifModule. py     本脚本中提取了最关键的经度与纬度信息，还有拍照日期可供调用  d. 获取具体位置——geoModule. py:    具体代码可见项目工程中的geoModule. py     步骤：把获得的经纬度信息去请求开放的地图api，获取具体地址. 这个方法的名称为：逆地址编码     横向比较了： 百度，腾讯，高德地图，发现高德给出的个人免费调用量有 3W/日，其他两家只有几k。最终选用了高德的api     高德api获取地址步骤（非常简单）：               序号     高德流程     备注                   1     注册     需要支付宝扫码实名             2     新建应用     按默认点确定即可             3     复制那个应用的key进行调用     调用代码见geoModule. py，请使用自己的gaode_key测试             详细图文描述可见：https://zhuanlan. zhihu. com/p/371682461  D. 上手及部署指南: D. 1 配置要求: 图像部分，因为用了PaddleSeg需要一台6G显存以上的主机，4G显存的没测试过，可以尝试调小 ImgGeneratorModule 中的 inputSize, 在DL处理前先缩小图片。 D. 2 部署方案: 建议选择方案一    方案一：一台显存6G，内存16G电脑（部署整个项目）     方案二：一台普通云端服务器（1核2G之类的）+ 一台有外网IP的显存6G，内存16G电脑(部署图像部分：ImgGenerateModule)     方案三：一台有GPU的云端服务器  D. 3 模型下载: 需下载以下模型：    简化后的PadlleSeg的cityscapes的SOTA模型（CityscapesModule. py需要）   AI Studio数据页：https://aistudio. baidu. com/aistudio/datasetdetail/102892     流沙效果/沙画效果模型（sandModule. py需要）   AI Studio数据页：https://aistudio. baidu. com/aistudio/datasetdetail/102698     PaddleSeg（CityscapesModule. py需要）   AI Studio数据页：https://aistudio. baidu. com/aistudio/datasetdetail/102136   或直接去GitHub：git clone https://github. com/PaddlePaddle/PaddleSeg   或者去Gitee：git clone https://gitee. com/PaddlePaddle/PaddleSeg     生成外星人矢量图模型（非必需，若要自己新增生成外星生物才需要）   AI Studio数据页：https://aistudio. baidu. com/aistudio/datasetdetail/103316  D. 4 部署过程:    申请Wechaty Token    具体请访问Wechaty官网: https://wechaty. js. org/     快速上手   请参考@Lovely-Pig的文章: 教你用AI Studio+Wechaty+阿里云白嫖一个智能微信机器人     云服务器          本项目用到了阿里云的云服务器ECS，链接: 云服务器ECS           购买实例后登录控制台，实例名称和主机名可以自行更改，记住公网IP           有任何不明白的请访问: 云服务器ECS官方文档          云数据库          本项目用到了阿里云的云数据库RDS MySQL版，链接: 云数据库RDS MySQL版           购买实例后登录控制台，创建一个数据库，名为 super-interstellar-terminal .           创建一个普通账号，授权数据库填写super-interstellar-terminal，权限为读写（DDL+DML），记住用户名和密码           在左侧数据库连接处找到外网地址，小本本记下来           设置白名单，将云服务器实例的公网IP加入白名单           有任何不明白的请访问: 云数据库RDS官方文档          云存储          本项目用到了阿里云的对象存储OSS，链接: 对象存储OSS           开通后登录控制台，创建一个Bucket，名为super-interstellar-terminal.           登录RAM控制台，创建一个用户，访问方式选择编程访问，记住AccessKey ID和AccessKey Secret.           有任何不明白的请访问: 云存储OSS官方文档          开启数据库server   # 以任何一种你喜欢❤的方式远程登陆到阿里云的云服务器# 克隆本代码仓库cd ~/git clone https://github. com/kevinfu1717/SuperInterstellarTerminal. git# 安装MySQL客户端sudo apt install mysql-client-core-8. 0# 开启数据库servercd ~/SuperInterstellarTerminal/bot/python3 -m pip install -r requirements. txtnohup python3 server/database. py &gt;/dev/null 2&gt;&amp;1 &amp;      开启图像处理server   # 远程登陆到一台很牛逼的服务器（不是阿里云的云服务器）# 克隆本代码仓库cd ~/git clone https://github. com/kevinfu1717/SuperInterstellarTerminal. git# 开启图像处理servercd ~/SuperInterstellarTerminal/python3 -m pip install -r requirements. txtnohup python3 app. py &gt;/dev/null 2&gt;&amp;1 &amp;      设置环境变量   OSS_ENDPOINT的设置可参考: 访问域名（Endpoint）   export WECHATY_PUPPET= wechaty-puppet-service export WECHATY_PUPPET_SERVICE_TOKEN= &lt;your wechaty token&gt;   # wechaty的tokenexport DB_USER= &lt;your database user name&gt;   # 云数据库账号的用户名export DB_PASSWORD= &lt;your database password&gt;   # 云数据库账号的密码export DB_DATABASE= &lt;your database name&gt;   # 云数据库的数据库名，填写为super-interstellar-terminalexport DB_SERVER_HOST= &lt;your database server host&gt;   # 开启数据库server的服务器地址，一般是云服务器的公网IPexport ACCESS_KEY_ID= &lt;your AccessKey ID&gt;   # RAM用户的AccessKey IDexport ACCESS_KEY_SECRET= &lt;your AccessKey Secret&gt;   # RAM用户的AccessKey Secretexport OSS_BUCKET_NAME= &lt;your oss bucket name&gt;   # 云存储的Bucket，填写为super-interstellar-terminalexport OSS_ENDPOINT= &lt;your oss endpoint&gt;   # 云存储的访问域名export IMG_SERVER_HOST= &lt;your img server host&gt;   # 开启图像处理server的服务器地址export DEVELOPERS= &lt;your developer cipher&gt;   # 给予开发者特权的暗号      运行bot   cd ~/super-interstellar-terminal/bot/python3 -m pip install -r requirements. txtnohup python3 bot. py &amp;   E. 总结: E. 1 展望: a. 让心在宇宙漂流: 此项目结合了轻社交的星际漂流瓶，让大家可以抒发一下想对着太空说的话。也可以惊喜地看到别人写的漂流瓶。 b. 来个更逼真的LBS+AR游戏: 后续希望可以从用户拍的图片获取到地点或经纬度，或者用户发送定位来，从而实现更准确的LBS定位。叠加上AI图像能力，说不定能比PokemonGo更棒噢！ 起码普通伊布是不应该在水面出现的噢 @任天堂。 看到这个项目，要不要也一起合作来把AI融到游戏里啊 @任天堂 （JUST JOKING. DON’T TAKE IT SERIOUSELY. ) c. 来更多脑洞一起创作玩法与剧本吧！: 希望更多有兴趣的脑洞，一起想想我们可以怎么玩，让我们玩得更high一点吧！ E. 2 期盼: 希望更多小伙伴能贡献一下自己的脑洞，基于此项目，觉得还可以优化的游戏方式或游戏剧本。希望留言或评论。感谢！ 希望小伙伴们觉得此项目不错的点个赞（Star）和Fork。能从头看到这里的很不容易了。非常感谢！！ E. 3 Reference/参考内容:    阿里云官网     Wechaty官网     python-wechaty     python-wechaty-getting-started     教你用AI Studio+Wechaty+阿里云白嫖一个智能微信机器人     通过LSGAN以及WGAN-GP实现128*128大小的喀纳斯风景图片     Paddle2. 0-通过LSGAN让我们看看AI预测的外星人长什么样子  E. 4 致谢:  感谢百度爸爸的算力及技术支持 感谢Wechaty与Mixlabs 感谢Reference中列到的所有作者 感谢其中用到的所有开源项目的作者及维护者 感谢Teammate@Lovely-Pig，感谢过程中所有提供鼓励与帮助的百度人员 致敬为拓展人类的宇宙梦而奋斗的所有技术工作者 Respect！!!"
    }, {
    "id": 65,
    "url": "https://wechaty.js.org/2021/08/15/gsod-2021-eighth-meeting/",
    "title": "GSoD'21 Eighth Meeting",
    "body": "2021/08/15 - Google Season of Docs’21 Eighth meeting: Meeting Summary: It was the eighth meeting of the GSoD’21 participants. Firstly every participant gave one’s weekly summary and informed the communityabout their plans for the upcoming week, volunteers and tech writers discussed while tech writers were giving their week summaries. Later we discussed comments and questions of the participants, and they all were regarding getting reviews, feedback, &amp; help, andat last, we took a lovely group photo. In the end I would like to stress upon the need of faster reviewal and merging of the PRs,after listening everyone at the meet. {% include iframe. html src=”https://youtu. be/zLtLp5i0MD8” %} Attendees: Total 10 attendees attended the meeting. They are:  Rohitesh Jain, Volunteer (UTC + 5:30) Sajen Sarvajith, Reconstruct Landing page writer (UTC + 5:30) Abhishek Jaiswal, How-to-guide section writer (UTC + 05:30) Mukosa Joseph Mawa, Introductions and Explanations section writer (UTC +03:00) Shraddha, Improve References section writer (UTC + 5:30) Rajiv Ranjan Singh, Improve the gRPC and OpenAPI ecosystem writer, rajivperfect007@gmail. com, (UTC+05:30) Shwetal Soni, Create easy to learn tutorials for beginners users writer (UTC +05:30) Vasvi Sood, How to guides, contactvasvisood@gmail. com writer (UTC + 5:30) Chris Estepa, Introduction and Explanations sections writer (UTC +08:00) Soumi Bardhan, Improve References section writer (UTC + 5:30)Note: Meeting started on schedule and Simin, Souvik, and Arnab Saha weren’t able to make it up to the meeting.  Agendas:  00:00 0. Introduction &amp; Welcome 01:01 1. Discussion with Tutorials team 04:31 2. Discussion with Introduction and explanation team 07:52 3. Discussion with Landing page team 10:25 4. Discussion with References section team 11:17 5. Discussion with gRPC team 12:17 6. Questions/commentsYou can learn more from our meeting notes. Meeting Outcomes:  The community got to know about the progress and plans of the members Community got to know the follow-up actions for the mentors and volunteersMeeting Follow-ups:  Merge PRs in this list Tutorials team is in stalemate position, as they await for these issues to be resolved, #1200,1199, 1193,1176, 1119, and apart from this,they need answers to some questions in here Create tutorial pages for some of the bots mentioned on the Showcases page (need feedback from the community members). The introduction team has already mentioned these bots here. Is it required to be added in tutorials also Merge #865 as it blocking progress of the Reference teams Review upon landing page video How to guides, gRPC, and Introduction teams are preparing their final project reports and expecting faster reviews on their PRs"
    }, {
    "id": 66,
    "url": "https://wechaty.js.org/2021/08/13/wechaty-face-carton/",
    "title": "Wechaty卡通P图插件，18行代码帮你实现变脸功能 ",
    "body": "2021/08/13 - Wechaty 人像转换插件，让你的 Wechaty 机器人实现照片卡通化，年龄变化，性别变化等功能。之前有看到过一些机器学习视频，可以把照片漫画化，感觉很有意思，就想着能不能结合 Wechaty 做一个可以自动返回动漫化照片的机器人。经过一番资料查找，发现腾讯有个人脸变换的功能，经过测试后，发现就是我想要的功能，而且效果还不错，关键是每个月有 1000 次的免费额度，这就很香了。三种转换模式就是 3000 次，白嫖不香么 😏，白嫖腾讯这就更香了，哈哈。 如果你说你的微信没法登陆网页版微信，没关系wechaty-puppet-wechat协议是基于 UOS 桌面版的，新账号也可以用的。 实现功能：: 私聊和群内都可以实现照片特效  多轮交互式对话实现     人脸照片动漫化   人脸年龄变化   人脸性别转换   效果展示: 准备腾讯云账号: 开通照片转换功能: 登录腾讯云账号，没有就直接 QQ 登录，直接点击管理控制台开通即可，不用付费，也不用选资源包，开通后自动有每个月 1000 次的免费额度，如果自己和朋友玩完全足够了。如果你是想活跃社群或者土豪，就随便充值了 获取腾讯的 secretid 和 secretkey: 访问此页面https://console. cloud. tencent. com/cam/capi获取你的secretid和secretkey,配置插件的时候需要用的到 使用步骤: 1、初始化项目: node环境需要自己配置一下，node&gt;=14，。新建一个文件夹face-carton，在文件夹内部执行npm init，一路回车即可 2、安装头像转化插件和 Wechaty: 这里说明一下，头像转化插件wechaty-face-carton就是我这次做的主要功能，已经开源在github，由于已经发布到npm，所以这里你只需要安装就可以使用了，对于不关心代码的童鞋，直接安装使用就行了。如果想知道代码怎么实现的，可以到github仓库查看一下源码。 配置 npm 源为淘宝源（重要，因为需要安装 chromium，不配置的话下载会失败或者速度很慢，因为这个玩意 140M 左右） npm config set registry https://registry. npm. taobao. orgnpm config set disturl https://npm. taobao. org/distnpm config set puppeteer_download_host https://npm. taobao. org/mirrorsnpm install wechaty wechaty-face-carton wechaty-puppet-wechat --save3、主要代码（不超过20行）: index. js import { Wechaty } from 'wechaty'import WechatyFaceCartonPlugin from 'wechaty-face-carton'const name = 'wechat-carton'const bot = new Wechaty({ name, puppet: 'wechaty-puppet-wechat' })bot . use(  WechatyFaceCartonPlugin({   maxuser: 20, // 支持最多多少人进行对话，建议不要设置太多，否则占用内存会增加   secretId: '腾讯secretId', // 腾讯secretId   secretKey: '腾讯secretKey', // 腾讯secretKey   allowUser: ['Leo_chen'], // 允许哪些好友使用人像漫画化功能，为空[]代表所有人开启   allowRoom: ['测试1'], // 允许哪些群使用人像漫画化功能，为空[]代表不开启任何一个群   quickModel: true, // 快速体验模式 默认关闭 开启后可直接生成二维码扫描体验，如果自己代码有登录逻辑可以不配置此项   tipsword: '卡通', // 私聊发送消息，触发照片卡通化提示 如果直接发送图片，默认进入图片卡通化功能，不填则当用户初次发送文字消息时不做任何处理  }) ) . start() . catch((e) =&gt; console. error(e))参数说明:       参数名   必填   默认值   说明         maxuser   否   20   支持最多多少人进行对话，建议不要设置太多，否则占用内存会增加       secretId:   是   ’’   腾讯 secretId       secretKey   是   ’’   腾讯 secretKey       allowUser   否   []   允许哪些好友使用人像漫画化功能，为空[]代表所有人开启       allowRoom   否   []   允许哪些群使用人像漫画化功能，为空[]代表不开启任何一个群       quickModel   否   false   快速体验模式 默认关闭 开启后可直接生成二维码扫描体验，如果自己代码有登录逻辑可以不配置此项，如果是单独使用此插件，建议开启       tipsword   否   ‘卡通’   私聊发送消息，触发照片卡通化提示。如果直接发送图片，默认进入图片卡通化功能，不填则当用户初次发送文字消息时不做任何处理，建议填写触发关键词   4、运行: node index. js扫码登录后，给小助手发送图片，即可转化图片，对于不能转化的图片，小助手会给出原因 docker运行: 1、新建Dockerfile: 如果遇到过多的环境问题让你非常苦恼，你也可以在以上第三步完成后，根目录新建一个Dockerfile文件，里面填入内容，对！就一行就行！ FROM wechaty/onbuild2、build镜像: 完成后就可以直接build镜像 docker build -t wechaty-carton . 3、运行镜像: build完成后就可以直接run后扫码了 docker run wechaty-carton注意: 要注意一下，不要把额度用超了，用超了就不能用了。  历史文章  wechaty-web-panel可视化插件 三步教你用Node做一个微信脱单神器，小白可上手 重磅：使用UOS微信桌面版协议登录，wechaty免费版web协议重放荣光 作者: Leo_chen，全栈工程师，喜欢使用node做各种项目 "
    }, {
    "id": 67,
    "url": "https://wechaty.js.org/2021/08/13/gsod-mid-term-how-to-guide-blog/",
    "title": "GSoD 2021-Mid-Term-How-to-guide-Blog",
    "body": "2021/08/13 - This is the Mid-term Blog for Wechaty How-to-guide documentation for which we are working as a part of Google Season of Docs 2021. We have reached half a way and it’s time to celebrate and describe our past experience. Team members: Vasvi Sood: I am a sophomore at NIT, Hamirpur. I am a Tech enthusiast and a story writer. For me combining technology with my writing skills is a natural match. I am passionate about blockchain technology. I am also into competitive programming these days. Email: contactvasvisood@gmail. com&lt;/br&gt;Github Handle: https://github. com/vasvi-sood&lt;/br&gt;Medium: https://vasvisood1. medium. com/ Abhishek Jaiswal: Myself Abhishek Jaiswal,a CSE sophomore UG student currently pursuing my B. Tech from IIIT Bhubaneswar. It’s now been more than 8 month, I started writing technical blogs,tutorials,documentation and reviews. I have published many technical with medium and Analytics Vidhya, Devtutorials and Hashnode. I want to learn, build, grow my network, and want to transform open innovation projects into powerful real-world services. Email: abhishek. iiitbbsr@gmail. com&lt;/br&gt;Github Handle: https://github. com/abhishek-iiit&lt;/br&gt;Medium: https://abhishek-iiit. medium. com/&lt;/br&gt;Hashnode: https://abhishek-iiit. hashnode. dev/ Abstract: How to Guide is important because it guides us through the steps involved in addressing key problems and use-cases. They are more advanced than tutorials and assume knowledge of how the product works. On an average 45 - 50% of developers refer to How to guide. It contains instructions on how to use the program, its features and other inbuilt applications as well. Proposed Timeline: The detailed structure for the timeline can be found here. Below are the some of the highlights: Week 1:  Concentrate on community bonding.  Chalk out a blueprint.  Add a README file to GitHub. Week 2:  Add about Bot: Adding brief introduction to the bot and its various use cases and functionalities with images. Week 3:  Add Events to your bot: Define what an event is. Provide code snippets along with a brief paragraph about when to use an event. Include code snippets and examples. Week 4:  Add more functionality to your bot: Dealing with messages.  Manage Contacts. Week 5:  Add more functionality to your bot: Manage Rooms.  Send and Accept Friend Requests. Week 6:  Add more functionality to your bot: Sending and Receiving files. Proposal Mid-term Video Presentation: {% include iframe. html src=”https://www. youtube. com/watch?v=2yDwsntWTQc” %} Work Done: We kick-off with the community bonding and getting familiar with the project. Also, if someone want’s to contribute we had a README file to help future contributors understand how to contribute to the How-to-guide page. We then restructured the How-to-guide section, and added various sub-sections. Some of them are:  Adding Events and customising the bot with providing code snippet for better understanding and its purpose Install wechaty and run the most famous messaging app through it Step by step guide to get familiar with deals with messages Introduction to managing contacts and its use cases Step by Step guide to get familiar with manage contacts Step by Step guide to get familiar with send and accept friend requests Introduction to sending and receiving files and its use casesLesson learned: Working with Wechaty under Google Season of Docs has been an amazing and rewarding experience. It has provided me a chance for learning and self improvement. Here are some of the lessons we have learnt:    Became more familiar with Git, Github and open source culture and software development in general. Also learnt several md, mdx commands and their best practices.     Routine code submission, discussion and review by mentors helped to complete the task in short time and in directed manner.     We learned a great deal about working with the Docusaurus documentation system.  Follow-up work: In the next half, we will be looking for the:  Deployment section where we will have the integration with various IM platfrom like WhatsApp, WeChat, Gitter, Lark, WeChat Official Account.  Deployment with containers where we will have it running in Heroku and Docker.  Review up all the PR and improve the documentation as suggested. Acknowledgment: We are extremely grateful to our mentors Rohitesh and Simin for helping us out at various stages throughout this summer. Special thanks to Huan and Rui, for facilitating the Summer Program. Sincere gratitude to Google for offering me this great opportunity. "
    }, {
    "id": 68,
    "url": "https://wechaty.js.org/2021/08/12/the-matrix-server-of-wechaty/",
    "title": "The community matrix server is online!",
    "body": "2021/08/12 - About Matrix: Matrix is a secure and distributed open source chat network that can provide us with communication functions similar to most social software. With complete message encryption, identity authentication and other security functions , Matrix also supports cross-server communication; At the same time, the Matrix community also provides multiple sets of clients, as well as plug-ins such as video chat, voice chat, SSO, system monitor, and user management. Matrix is a powerful open source social server, which is very suitable as a communication tool for the open source community. The community matrix server is online: Thanks to Mr. Eric Migicovsky (the founder of Beeper. com) for his support and sponsorship, the Matrix server of the Wechaty community has been launched on August 12, 2021, mainly for community members and Wechaty users communicate online. The server currently supports github account login (recommended), opens the invitation-free registration function, provides basic chat functions and voice and video conversation functions, and supports communication with other matrix server accounts. The Matrix server address is matrix. wechaty. tk, it is recommended to access through the matrix client such as element, you can also log in directly through the web client. Welcome everyone to pay attention to the matrix-appservice-wechaty project of our community, this project can help users accept the message from various social applications (such as WeChat, Wecom, Lark, etc. ) supported by wechaty in a private matrix server， can currently be quickly deployed through the scripts on easy-matrix-wechaty project. We will take every issue raised on these projects seriously. You are also welcome to pay attention to the Beeper. com application, which supports receiving messages from common social applications on the market (such as Whatsapp, Facebook, etc. ) in one application. Matters needing attention:  The home room of the wechaty community is #home:wechaty. tk, welcome the users from other matrix server to join it; The server does not enable Google human verification, please do not use robots to frequently request; The server is prohibited from being used for illegal purposes, and the community reserves the right to monitor unencrypted chat rooms; The community will warn or ban users who violate the rules. Matrix简介: Matrix是一套安全的分布式的开源聊天网络，可以为我们提供和大多数社交软件类似的通讯功能，拥有完善的消息加密，身份认证等安全功能，支持跨服务器通讯；同时Matrix社区还提供了多套客户端，以及视频、语音聊天，第三方登录，系统监控，用户管理等插件。Matrix是一套功能强大的开源社交服务器，很适合作为开源社区的通讯工具。 社区Matrix服务器的上线: 感谢Eric Migicovsky(the founder of Beeper. com)的赞助，Wechaty社区的Matrix服务器已在2021年8月12号正式上线，主要供社区成员及wechaty使用者线上交流沟通使用。 该服务器目前支持github账号登录（推荐方式），开放免邀请的注册功能，提供基本聊天功能和语音、视频会话功能，支持与其他matrix服务器的账号进行交流。 该Matrix服务器地址为matrix. wechaty. tk，推荐通过matrix客户端如element访问,也可通过网页客户端直接登录。 欢迎大家关注社区的matrix-appservice-wechaty项目,该项目可帮助用户在私有matrix服务器中接受各种wechaty能支持的应用的消息（如：微信，企业微信，飞书等），目前可通过easy-matrix-wechaty项目中的脚本快速部署体验。我们会认真对待大家在这些项目中提出的每一个issue。也欢迎大家关注Beeper. com应用，支持在一个应用内接收市面上常见应用的消息（如：Whatsapp，Facebook等）。 注意事项:  社区公共聊天室账号是#home:wechaty. tk，欢迎其他matrix服务器的用户加入我们； 为方便境内网络环境访问，该服务器未开启Google人类验证，请勿使用机器人频繁请求； 该服务器禁止用于非法用途，社区保留对未加密聊天室的监控权利； 社区会对违规用户进行警告或封号处理。"
    }, {
    "id": 69,
    "url": "https://wechaty.js.org/2021/08/10/docker-open-source-program/",
    "title": "Docker Open Source Program ❤️ Wechaty",
    "body": "2021/08/10 - In November, 2020, Docker announced the launch of a special program to expand our support for Open Source projects that use Docker. The eligible projects that meet the program’s requirements (ie. they must be open source and non-commercial) can request to have their respective OSS namespaces allowlisted and see their data-storage and data-egress restrictions lifted.  Tweet: Docker has created a special program for Open Source projects to get continued free access and freedom from restrictions for their communities and their users. (link) Open Source Project Qualification Criteria: To qualify for the Open Source Program status, all the repos within the Publisher’s Docker namespace must:  Be public and non-commercial Meet the Open Source Initiative (OSI) definition (shown here), including definitions for free distribution, source code, derived works, integrity of source code, licensing and no tolerance for discrimination Distribute images under OSI approved open source license Produce Docker images used to run applicationsWechaty joined Docker Open Source Program: The Wechaty open-source project is very glad to announce that we has been accepted by the Docker Open Source Program today, as one of hundreds of non-profit organizations from the four corners of the world in this program, we will be having supported by the Docker and none of the following egress restrictions will apply to any Docker users pulling images from our approved OSS namespaces:  Unauthenticated users will be restricted to 100 pulls every 6 hours Authenticated free users will be restricted to 200 pulls every 6 hoursLetter from Docker to Wechaty:  Welcome to the Docker Open Source Program! We are very excited to have you as a part of our great community.  We have allow-listed your namespace “Wechaty” and this should come into effect in the next week or so. With this allowed-listing, the Docker data pull rate policies that went into effect last November, will not apply to the users pulling images from your namespace.  — Aurelien Suarez, Docker Marketing Team. Through this program, Docker remains committed to providing a platform where the non-commercial open source developers can continue collaborating, innovating and pushing this industry into new directions. Thank you Docker! Related links:  Expanded Support for Open Source Software Projects, Marina Kvitnitsky, Nov 02 2020 Docker Open Source Program Supporting Open Source Projects at Docker"
    }, {
    "id": 70,
    "url": "https://wechaty.js.org/2021/08/08/vscode-debug-nodejs/",
    "title": "使用 VS Code 调试 Node.js 应用",
    "body": "2021/08/08 - 「暑期 2021」活动中，我为 Wechaty 开发命令行环境下的客户端 wechaty-cli，使用 blessed 这个终端图形化组件库可以轻松做出炫酷的仿 IRC 聊天软件，原以为只需调库即可完成任务，但事情远没有那么简单… 在我点击联系人列表时，应用瞬间崩溃，终端上只留下 npm 的常规报错，翻看对应日志也没有任何有效信息，这意味着没有明确的错误关键字可以一步到位地搜索，针对这种问题，我尝试按以下步骤解决：    直接 Google 项目名称和场景，如 “blessed js crash”，但很可惜并没有任何有效结果，翻遍了 Stack OverFlow 上所有 blessed 相关问题都没有和我相同的情况。     浏览 GitHub 原项目的 Issues 和 Pull Requests，比如我用到了 blessed-contrib 中的 Tree 组件，就可以搜索 Tree 相关的讨论，但很可惜仍然没有结果。     尝试 catch 错误并输出，但因为 blessed 相当于在原来的终端之上加了一层， console. log(error) 这种常见做法行不通了，而且我也根本不知道在哪 catch。     找不到报错信息，已经开始怀疑是自己的问题，仔细检查了一遍代码并严格使用 TypeScript 声明了类型，确保与文档描述一致，但错误仍旧。     寻找使用同一个库同一个组件的代码，与自己的代码相比较，尝试从不同之处上找出崩溃原因所在。但全网使用 Tree 组件的项目半只手都数得过来，而且基本就是沿用了样例代码中实现的 File Explorer，找不出代码的问题。     自己实在无法解决，可以在各种网站或交流群提问，但即使能提供详细的上下文信息，也不一定有人能够解答，毕竟终端命令行软件本就是小众领域，使用过 blessed 的人更可以说寥寥无几。  总之，因为 blessed 实在有些冷门而且年久失修，在网络上无法找到所需的信息，我必须要独自面对一个没有人遇到过的问题，可我却连崩溃产生的原因都不清楚。难道我要一行行翻源码，脑补运行过程并人工审计代码？这显然不现实，所以只有通过调试，才能细致入微地理解程序的运行过程，从而找到问题所在。 VS Code 调试简介: VS Code 可能是前端领域现下最流行的开发工具，本文我们就以 VS Code 为例讲解调试的方法。 作为一个文本编辑器，VS Code 也提供了运行和调试的功能，但和其他一键运行的 IDE 不同，编辑器可不知道要运行何种程序，调试的功能也要安装插件来获得，所以自行配置文件是免不了的。即使是同一种编程语言，开发环境和运行方式上也可能会有差异，网上搜索到的现成配置文件不尽相同，盲目照抄往往会出现各种千奇百怪的报错，如果时间允许推荐阅读官方文档。 如果你此前没有进行过调试运行的配置，只需点击上方菜单栏 -&gt; Run -&gt; Add Configuration，并在弹出的框中选择 Node. js，就会自动在工作区内创建 . vscode/launch. json 这个文件并打开，生成如下内容： { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go. microsoft. com/fwlink/?linkid=830387  version :  0. 2. 0 ,  configurations : [ {   type :  pwa-node ,   request :  launch ,   name :  Launch Program ,   skipFiles : [   &lt;node_internals&gt;/**   ],   program :  ${file}  } ]}配置文件是 JSON 格式，鼠标悬浮到键名上会出现相应的提示，不过参数太多也不一定都用得到，这里我们只关注能让项目运行起来的参数，很明显就是 program 制定了文件路径，比如我们如果使用 node index. js 启动项目，那么 program 填 index. js 就可以。 但我的项目是用 ts-node 直接运行的，并没有编译好的 js 文件，直接填写 ts 文件明显会失败，于是我 Google 搜索了 “ts-node debug”，出来的前两条结果中的配置文件都过于复杂，添加了很多参数，其实只需要加上  runtimeExecutable :  ts-node  就够了。 除了这一种配置，VS Code 还为我们提供了许多配置模板，再次点击 Add Configuration 或者在编辑状态按下 “Ctrl+Space”，会出现一长串配置列表，比如 Node. js: Launch via NPM 是通过像 npm start 这样的命令来运行项目的，这样做的好处是具体代码文件位置或名称改动不会影响调试运行。 不过对于某些需要与用户交互的程序，比如使用 blessed 开发的终端图形界面程序，这样启动默认是在 VS Code 内置的 Debug Console 中执行，无法接受输入，需要添加 console 属性设为 integratedTerminal 或 externalTerminal，分别是在 VS Code 自带的 Terminal 中或用户设置的外部 Terminal 中执行，配置文件如下： {  name :  Lanch via NPM ,  request :  launch ,  runtimeArgs : [  start , ],  runtimeExecutable :  npm ,  skipFiles : [  &lt;node_internals&gt;/**  ],  type :  pwa-node ,  console :  integratedTerminal ,}细心的小伙伴可能已经发现，上述配置文件的 request 参数都设置为 launch，这意味着 VS Code 会直接启动程序并调试，和其他一键运行的 IDE 一样方便，不过有些时候我们仅仅需要调试而不想连带着捆绑启动的配置，所以 VS Code 也提供了 attach 模式，是对已经打开的程序进行调试。比如模板中 Node. js: Attach 配置如下： {  name :  Attach ,  port : 9229,  request :  attach ,  skipFiles : [  &lt;node_internals&gt;/**  ],  type :  pwa-node }要调试 Node. js 应用程序，只需执行形如 node --inspect-brk program. js 命令，程序会在默认的 9229 端口等待调试器接入，在 VS Code 中点击开始调试后就会运行。对于用 ts-node 执行的命令，则要以形如 node --nolazy --inspect-brk=9229 -r ts-node/register program. ts 的方式运行。 如果嫌使用 --inspect 参数麻烦，使用模板配置 Node. js: Attach by Process ID 则会自动弹出方框来选择对应正在运行的 Node. js 进程。如果连动动小手选择都不愿意，VS Code 还推出了 Auto Attach 功能，按下 Ctrl+Shift+P 输入 Toggle Auto Attach，选择 smart 模式，则只需在 VS Code 自带终端中执行 Node. js 程序，无需任何配置，VS Code 就会 Attach 你的程序并进行调试了。 栈溢出调试实战: 介绍完了 VS Code 调试的基本配置，就可以来尝试解决文章最初遇到的问题了，直接开始调试并重现崩溃场景，程序退出后 Debug Console 中还能看到错误信息： RangeError: Maximum call stack size exceededat List. focus (cli/node_modules/blessed/lib/widgets/element. js:329:30)at Tree. render (cli/node_modules/blessed-contrib/lib/widget/tree. js:152:52)at cli/node_modules/blessed/lib/widgets/screen. js:738:8at Array. forEach (&lt;anonymous&gt;)at Screen. render (cli/node_modules/blessed/lib/widgets/screen. js:735:17)at reposition (cli/node_modules/blessed/lib/widgets/element. js:968:17)at Tree. _labelScroll (cli/node_modules/blessed/lib/widgets/element. js:972:5)at Tree. _emit (cli/node_modules/blessed/lib/events. js:94:20)at Tree. emit (cli/node_modules/blessed/lib/events. js:117:12)at Tree. scroll (cli/node_modules/blessed/lib/widgets/scrollablebox. js:274:17)at Tree. &lt;anonymous&gt; (cli/node_modules/blessed/lib/widgets/scrollablebox. js:222:8)at Screen. _focus (cli/node_modules/blessed/lib/widgets/screen. js:1680:10)at Screen. focusPush (cli/node_modules/blessed/lib/widgets/screen. js:1620:8)at Screen. focused (cli/node_modules/blessed/lib/widgets/screen. js:1697:15)at List. focus (cli/node_modules/blessed/lib/widgets/element. js:329:30). . . 一下子就找到了问题的根源，应用本身的代码应该没有问题，而是在 blessed 库内部的代码中产生了无限循环，那么就可以在相应位置设下断点，观察代码执行顺序和变量值的变化，耐心地分析无限循环产生的原因。 如图所示，在 tree. js 的 Tree. prototye. render 这一函数中 if (this. screen. focused === this. rows) this. rows. focus(); 这一语句可能导致 Tree. render() 会调用 this. rows. focus()，将鼠标悬浮至 this. screen. focused 发现与 this. rows 为同一对象，这是无限循环上的一个环节，如果注释掉此行再运行便不再有崩溃了。不过此行代码或许起着必要的作用，不敢轻易删除，最终还是更改了应用的代码，在另一处上破坏了循环继续的条件，详情可见 wechaty/cli#13。 扩展阅读:  Introducing Logpoints and auto-attach VSCode 调试中 launch. json 配置不完全指南 NodeJS的代码调试和性能调优 写 Node. js 代码，从学会调试开始 Author:@chinggg "
    }, {
    "id": 71,
    "url": "https://wechaty.js.org/2021/08/03/gsod-2021-mid-term-blog-tutorials/",
    "title": "Google Season of Docs 2021 Mid Term Blog: Tutorials",
    "body": "2021/08/03 - This is the mid term blog for demonstrating all our work that we have done till 8 weeks for creating and improving the Wechaty Tutorials documentation as a part of Google Season of Docs 2021. Team members: Souvik Biswas (email: sbis1999@gmail. com): I am Souvik Biswas, currently pursuing a B. Tech degree in Computer Science and Engineering from IIIT Kalyani in India. I am a freelance technical writer of Codemagic and LogRocket Blog, and a passionate mobile app developer. You can also find some of my articles on Medium, and explore my projects on GitHub. Shwetal Soni (email: sonishwetal704@gmail. com): I am Shwetal Soni, currently pursuing B. Tech in Computer Science and Engineering from NIT Hamirpur in India. I am interested in UI/UX Design, Frontend web development and I’m also learning blockchain development. Currently I’m working as Tezos India Fellow. Mid Term Video Presentation: {% include iframe. html src=”https://youtu. be/STxFTWBHoiw” %} Abstract:  Refactor the overall Tutorials documentation Add / improve the step-by-step instructions Add interactive CodeSandbox Screenshots / GIF of the bot running on a device Add various bots building tutorials to Examples Create the Cheat sheetOverall structure of Tutorials: The overall structure of the Tutorials will be as follows:    OverviewHere we can have all the links for each of the pages present in the Tutorials section along with a brief description. This will help the user to easily navigate through the Docs.   Quick start     Overview (containing a brief introduction to each of the sub pages)   Running on GitPod   Running on Google Cloud Shell   Running Locally    Advanced Usage     Usage with Docker   Usage with Heroku   Using Plugin with wechaty   Using Redux with wechaty   Using Vorpal with wechaty    Examples     Overview (introduction to the different types of bot included in this examples section)   Basic         World’s shortest chatbot     Contact Bot     Ding dong Bot          Advanced         Demo Bot     Busy Bot     Media File Bot     Room Bot     Friend Bot     Gist Bot          Professional         Hot Import Bot     Ctrl C Signal Bot     Monster Bot     Api AI Bot     Speech to Text Bot     Turing Bot     Telegram Roger Bot     Blessed Twins Bot           Cheat sheet     Brief description of a bot   Code snippet to use it   Tech description (in brief)   Example - CodeSandbox (maybe included)   Screenshots / GIFs   Structure for each tutorial page: A proposed structure of the tutorial documentation is as follows:  Introduction (also include the goal of the tutorial) Try out the bot (CodeSandbox) Requirements (tools required to follow the tutorial)   Getting started   Quick introduction to the required tools and how to setup their development environment to get started building the bot     Building the bot   Step-by-step guide for building the bot, with a CodeSandbox at the end having minimal code and TODO steps where users can try building the bot by themselves directly on the documentation page without installing any tools on their local system     Running the bot   Commands for running the bot locally     Bot demonstration   Commands that they can use with the bot, and maybe a GIF showing the invocation of some of the commands on WeChat or WhatsApp   Conclusion ReferencesTasks Completed:  Total PR’s: In total we have submitted 25 PR’s out of which 21 are weekly PR’s as per our weekly tasks. Remaining 4 are minor improvements and bug related PR’s. Shwetal’s PR’s:  Running locally #888: Added tutorial for running ding-dong bot locally Overview #935 #934: Added overview for tutorials and getting started Gitpod #923: Added tutorial for running ding-dong bot on gitpod Plugins #969: Added tutorial for QR code terminal plugin Redux #989: Added overview for using redux with wechatySouvik’s PR’s:  Vorpal page #779 #780 #791 #882 - Step-by-step guide &amp; CodeSandbox Installation page #905 - Tools required for running Wechaty Google Cloud Shell page #922 - Improve the guide Plugins section #957 #963 #985 - Overview, EventLogger &amp; Heartbeat plugin Using Redux with Wechaty #1126 - Guide for Wechaty Redux plugin in Ducks proposal styleChallenges:  Understanding git version control Building the first bot using Wechaty     Knowledge about NPM projects   Using plugins   Running bot   Interacting with the bot from the connected device    Understanding how to build CodeSandboxes Errors in some bot example codesTasks todo: In upcoming weeks, we have to create tutorial for bots under examples/advanced and examples/professional sections. Later we will be preparing a cheet sheet containing some important code snippets and some plugins. At the end we will review our work right from the start and will refactor it wherever it is required. "
    }, {
    "id": 72,
    "url": "https://wechaty.js.org/2021/08/01/gsod-2021-seventh-meeting/",
    "title": "GSoD'21 Seventh Meeting",
    "body": "2021/08/01 - Google Season of Docs’21 seventh meeting: Meeting Summary: It was the seventh meeting of the GSoD’21 participants. Firstly every participant gave one’s weekly summary and informed the communityabout their plans for the upcoming week, volunteers and tech writers discussed while tech writers were giving their week summaries. We discussed contrast levels in the new landing page, and Rajiv helped Sajen troubleshoot an issue. Later we discussed comments andquestions of the participants, and at last, we took a lovely group photo. {% include iframe. html src=”https://youtu. be/gGSVsTww6e8” %} Attendees: Total 12 attendees attended the meeting. They are:  Rohitesh Jain, Volunteer (UTC + 5:30) Sajen Sarvajith, Reconstruct Landing page writer (UTC + 5:30) Abhishek Jaiswal, How-to-guide section writer (UTC + 05:30) Simin Liao, Volunteer (+8:00) Mukosa Joseph Mawa, Introductions and Explanations section writer (UTC +03:00) Rajiv Ranjan Singh, Improve the gRPC and OpenAPI ecosystem writer, rajivperfect007@gmail. com, (UTC+05:30) Souvik Biswas, Create easy to learn tutorials for beginner users writer, sbis1999@gmail. com (UTC +05:30) Shraddha, Improve References section writer (UTC + 5:30) Shwetal Soni, Create easy to learn tutorials for beginners users writer (UTC +05:30) Arnab Saha, Reconstruction of Landing page with value propositions writer (UTC + 5:30) Chris Estepa, Introduction and Explanations sections writer (UTC +08:00) Soumi Bardhan, Improve References section writer (UTC + 5:30)Note: Meeting started on schedule, Vasvi missed the meeting Agendas:  00:00 0. Introduction &amp; Welcome 00:28 1. Discussion with Tutorials team 03:30 2. Discussion with Introduction and explanation team 04:25 3. Discussion with Landing page team 13:42 4. Discussion with References section team 15:50 5. Discussion with How to guides team 16:52 6. Discussion with gRPC team 18:00 7. Questions/commentsYou can learn more from our meeting notes. Meeting Outcomes:  The community got to know about the progress and plans of the members We had a discussion on landing page contrast, and it’s decided that we will increase the contrastMeeting Follow-ups:  Review pending PRs"
    }, {
    "id": 73,
    "url": "https://wechaty.js.org/2021/07/30/walnut-5g-press/",
    "title": "Wechaty 社区 & 硬核桃社区：大学生玩转5G消息？So Easy！",
    "body": "2021/07/30 -  近期 硬核桃社区开展了一场面向在校大学生的开发者活动。硬核桃@钢铁嘉 IronJia、Wechaty@李卓桓、Wechaty@李佳芮一直在活动中指导学生的开发工作。昨天，传来了他们的最新进展—— “可以收到！” 大二学生张瑞宁和邵琦在硬核桃社区的环境中成功发出了他们的第一条5G消息。 他们是“开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）活动中，参与“5G Chatbot项目”开发的两位学生。 他们是如何与硬核桃、5G消息结缘的呢？ 这要从一场大学生暑期活动说起。 01. 大学生暑期活动: “暑期2021”（https://summer. iscas. ac. cn/），由中科院软件所与 openEuler 社区共同举办。 旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。 活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，面向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，中选后可获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取活动奖金和奖杯。 02. ”5G Chatbot项目”: 此次“暑期2021”活动中的“5G Chatbot项目”，是硬核桃5G消息开发者社区(www. 5g-msg. com)与Wechaty社区(wechaty. js. org)首次合作，专为大学生开发者倾力打造的暑期项目。 希望借此机会吸引社会各界关注5G消息行业发展，培养和发掘更多优秀的大学生开发者参与到5G消息行业中来。 “5G Chatbot项目”期间，硬核桃社区与Wechaty社区保持紧密合作，积极关注项目进展，帮助学生解决开发中遇到的问题，邀请技术大牛进行分享。 现阶段，两位大学生开发者已经正式投入“5G Chatbot项目”开发，并成功接入硬核桃5G消息开发环境，进行测试。 两位学生表示，开发中最大的问题就是5G消息在网上的参考资料很少，刚开始上手很难。但是在硬核桃导师 @钢铁嘉 IronJia 的帮助下，问题很快得到了解决。 在谈到对5G消息的认识时，学生张瑞宁说，“我觉得5G消息的功能非常强大，不仅支持纯文本消息，还支持图片、音频、视频、定位等富媒体消息，拓展了传统短信业务的功能，而且使用起来非常便捷。” “我们认为5G消息具有广阔的应用前景，所以共同选择了这个项目。 5G消息是5G时代的生态级应用，基于GSMA RCS和UP标准构建，具备富媒体化、轻量化、交互化等特质。5G消息实现原生消息界面一站式线上业务体验，能形成更高效益的引流转化，是一种集成程度更高、可代替App的全新人机交互服务模式，将给企业客户带来极高的服务价值。”学生邵琦说。 03. 未来，更多的开发者活动: 公示的项目报告显示，两位学生从了解接口技术规范，到接入硬核桃环境进行编码和接口测试，再到最后成功进行接收和发送消息的测试 仅用了短短12天的时间。 “由于我们开始对服务器不熟悉占用了一些时间，而且暑假了嘛，其他活动也比较多，如果说实际的代码时间可能也就2个小时。”学生邵琦表示。 短期内，两位学生计划通过 Wechaty 加载 wechaty-puppet-5g-msg 模块，实现一个“ding/dong”功能，接收到文字消息‘ding’时，自动回复消息‘dong’。 硬核桃导师 @钢铁嘉 IronJia 谈起这次项目过程时说，“学生们对项目非常感兴趣，也非常的积极，技术基础也不错，未来可期。我们也很惊喜，他们可以在这么短的时间内成功使用我们的开发工具，某种程度上也增加了我们对自身产品的信心。希望我们可以帮助更多开发者更好的成长。” 未来，硬核桃社区还会参与和举办更多开发者活动，打造更多服务5G消息开发者的开发工具。 欢迎在校师生、Chatbot技术爱好者、各界研究人员参与到5G消息应用的开发中来，共同促进5G消息行业的发展。 “未来属于青年，希望寄予青年。” 注：5G Chatbot项目，开发支持电信运营商 5G Chatbot/RCS 的 Wechaty 接入 Puppet 模块，简称 5G Chatbot项目，项目ID：210220088  编辑：硬核桃社区Source: 硬核桃 Walnut Hardcore "
    }, {
    "id": 74,
    "url": "https://wechaty.js.org/2021/07/24/newbie-how-to-build-python-wechaty-with-padlocal/",
    "title": "零基础小白HOWTO系列 -- 搭建第一个基于PadLocal的Python-Wechaty应用",
    "body": "2021/07/24 -  写在前面：本HowTo系列用来记录个人在Wechaty的学习和研究过程中的点滴经验，希望能帮助更多人避免我踩过的坑，快速熟悉Wechaty这个工具 背景: 2021年初的时候，在社区上发现了Wechaty项目，由于时间不够充分，没有静下心认真的研究相关内容，加上之前的文档确实不够健全，学习成本很高，一个简单的类似HelloWorld的代码也没有跑通，遂暂时搁置了这个工具的研究。直到最近个人工作上有些需求，需要对公司的微信数据进行管理和社区的自动化运营操作，想起来之前接触的Wechaty工具，就想着再次尝试一下，重新开始学习这个工具。 欢迎大家在实践本HowTo内容的过程中，将遇到的问题及对应的解决方法发送给我 harrison. gyao@gmail. com ，我会在收到信息后，及时更新本文档，以帮助更多的人，谢谢你的反馈~！ 前提要求:    本文阅读的难度不大，按照文中的标准操作，大概率会能够自主的搭建相应的应用服务环境，并完成一个基本功能的实现。但本文要求读者必须具备基本的编程技能，在服务端领域能够知道RPC（Remote Procedure Call)、Docker的相关基本知识，如果对这方面内容不了解，可以查阅 Reference 的相关部分。     在执行本文中提供的 Gateway 服务脚本时，需要提前确保执行机上的 Docker Daemon 是否正常启动，否则shell脚本执行失败。  试验环境:  macOS Ver:11. 5 Python 3. 8 Docker desktop (latest)内容介绍: 本篇Blog会从以下三个方面内容来描述如何快速的能够完成一个最简单的Python-Wechaty应用的搭建，同时对一些过程中可能遇到的问题，进行及时的处理。  必须掌握的基本知识 最简Ding-Dong应用代码 过程中遇到过的问题必须掌握的基本知识:  Wechaty的基本结构 这个结构图例很好的阐述了Wechaty的生态环境架构：  底层是各个IM工具的通讯协议层，未来可以支持更多IM工具的消息传输，并在这个层级上进行相应的扩充即可。 Wechaty Puppet Service Provider 是作为对底层IM协议层的操作控制层作用而设计存在，可以在使用 “Wechaty Puppet Abstract” 通用接口层的设计基础上，忽略底层协议及IM的个性化，提炼共性的操作内容，暴露统一的操作接口给外部调用者。 Wechaty （Python、NodeJS等），是基于gRPC框架基础上，在”Wechaty Puppet Abstract”的接口定义约束条件下，通过gRPC的Stub程序完成对底层Provider的掉用。 Service相关Wechaty 对于底层IM消息解析和处理，是通过Service Provider 控制的协议层程序来完成相关处理，所以对应不同IM的不同协议内容（如：微信的Pad协议、web协议、mac协议等），需要使用配套的Service Provider来完成对底层IM消息的处理。目前已经实现的Service Provider有如下几种： 具体的Service Provider的内容，可以持续关注 provider docs 的最新情况。  关于Token顾名思义，针对微信相关的wechaty服务来说，token需要在Token Gateway的配合下一起使用，是作为当前服务的一个认证接入使用的凭证，用来控制访问准入和时长  关于GateWay也就是 Wechaty Puppet Service Token Gateway，在整体架构过程中，通过该Gateway 利用gRPC协议，将制定的 Wechaty Service Provider 的服务封装并转化为 Wechaty Puppet Service，供更上层的业务应用层面的程序调用和使用。 换句话说，针对与目前版本的 Python-Wechaty ，使用的时候，只能通过Gateway的方式，指定使用 “wechaty-puppet-service” 来完成与业务代码的交互，实现微信数据的操作。 最简Ding-Dong应用代码搭建: GateWay 服务准备: 目前Gateway服务是封装在Docker容器中，使用的时候可以直接创建如下shell脚本完成对应容器服务的初始化。读者可以直接copy以下代码，在本地创建一个shell脚本文件后执行即可。  对应shell脚本```shell script#!/bin/bash export WECHATY_LOG=”verbose” # 如果觉得打印信息太多，可以使用 “error” 级别export WECHATY_PUPPET=”wechaty-puppet-padlocal” # 针对当前例子，我们使用padlocal协议作为 Service Provider使用的底层协议 ，这个部分不能错export WECHATY_PUPPET_PADLOCAL_TOKEN=”puppet_padlocal_xxxxx” # 这里是你自己申请的padlocal Token ，这个部分不能错 export WECHATY_PUPPET_SERVER_PORT=”8788” # Gateway服务在容器中暴露的本地端口export WECHATY_TOKEN=”b74d7f7f-cfd0-4def-1c68f0066254” # 使用：import uuid (回车) print(uuid. uuid4()) 获得的结果 docker run -ti  –name wechaty_puppet_service_token_gateway  –rm  -e WECHATY_LOG  -e WECHATY_PUPPET  -e WECHATY_PUPPET_PADLOCAL_TOKEN  -e WECHATY_PUPPET_SERVER_PORT  -e WECHATY_TOKEN  -p “$WECHATY_PUPPET_SERVER_PORT:$WECHATY_PUPPET_SERVER_PORT”  wechaty/wechaty 以上shell脚本编写完成后，可以直接在本地的Term或Console中进行执行，如果过程中遇到有关docker的问题，请自行 谷歌 寻找相应的解决方法。- 结果检查1. 通过执行 ``` netstat -an |grep 8788 ``` 命令检查相应脚本中8788端口是否已经被监听1. 访问 &lt;https://api. chatie. io/v0/hosties/${uuid4}&gt; 地址（注意：${uuid4} 是一个占位符，实际访问的时候，需要将该位置替换为shell脚本中 WECHATY_TOKEN 环境变量使用的uuid字符串），如果服务**正常**，可以看到类似``` json{   host :  122. 233. 170. 88 ,   port : 8788}的显示内容。  查看服务启动日志信息 正如上面的截图，是首次正确启动service gateway的时候的服务日志，尤其关注截图中红框部分，如果看到 PuppetServer start()以及[PuppetPadlocal] start login with type: QrLogin，说明服务已经正常启动。 经过上面几步的检查，如果没有其他问题，你当前的服务已经启动成功，并完成token的服务注册，可以正常接受业务层传递的操作信息。如果此时查看gateway的日志，找到类似 ```shell scriptOnline QR Code Image: https://wechaty. js. org/qrcode/http%3A%2F%2Fweixin. qq. com%2Fx%2FgYEttTm04jj2_EtvmXmq 信息时，可以直接访问对应的链接，扫码后即可完成微信账号的Pad登录，并且在微信中，可以看到如下图的登录状态显示。![微信登录设备列表](/assets/2021/07-newbie-how-to-build-python-wechaty-with-padlocal/wechat-logged-device-list. webp)### Ding-Dong 代码编写```python# coding=utf-8   # @Licensed : (C) Copyright# @Time   : 2021/7/24 上午11:38# @Author  : Harrison Yao# @FILE   : WechatGroupBot. py# @Version : # @Function : # @Requirements:   import logging,asyncio,osfrom typing import Optional, Unionfrom apscheduler. schedulers. asyncio import AsyncIOSchedulerfrom wechaty import Wechaty, Message, ScanStatus, Contact, Room, Image, UrlLinkfrom wechaty. plugin import WechatyPluginfrom wechaty_puppet import FileBox, UrlLinkPayload, MessagePayload # 发送文件， 发送链接， 消息os. environ['WECHATY_LOG_FILE_KEY'] = '一个日志文件的绝对路径' # 如果不指定，会自动在执行程序的位置生成logs目录和根据日期时间为命名的日志文件LOG_FORMAT =  %(asctime)s - %(levelname)s - %(message)s logging. basicConfig(filename='. . /logs/wechaty_run_server_error. log', format=LOG_FORMAT, level=logging. INFO )class MyBot(Wechaty):  async def on_scan(self, qr_code: str, status: ScanStatus,           data: Optional[str] = None):       监听微信扫码登录, 微信扫码的链接       print( https://wechaty. js. org/qrcode/{} . format(qr_code))  async def on_login(self, contact: Contact):       监听微信扫码登录的用户信息       contact_info = contact. payload    print( 扫码登录的用户信息: {} . format(contact_info. name))  async def on_ready(self, _):    # find by id    # 1. get all of friends           我是在这里读取的好友信息           pass  async def on_message(self, msg: Message):       监听微信消息       print( 监听接受到的消息业务处理: {} . format(msg. text()))    from_contact: Optional[Contact] = msg. talker()    text = msg. text()    room: Optional[Room] = msg. room()    if text. lower() == 'ding':      conversation: Union[        Room, Contact] = from_contact if room is None else room      await conversation. ready()      await conversation. say('[自动回复] dong')      file_box = FileBox. from_url(        'https://ss3. bdstatic. com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/'        'u=1116676390,2305043183&amp;fm=26&amp;gp=0. webp',        name='ding-dong. webp')      await conversation. say(file_box)class BotPlugin(WechatyPlugin):  @property  def name(self) -&gt; str:       get the name of the plugin       return '智能客服'  async def tick(self):       send message plugin scheduler       pass  async def init_plugin(self, wechaty: Wechaty):       init plugin       await super(). init_plugin(wechaty)    scheduler = AsyncIOScheduler()    scheduler. add_job(self. tick, 'cron')    scheduler. start()async def main():       Async Main Entry       bot = MyBot()  bot. _options. puppet =  wechaty-puppet-service  # python-wechaty 只能使用基于gRPC的 service provider  bot. _options. puppet_options. token =  puppet_padlocal_xxxxx  # 使用你自己申请的PadLocal Token  bot. _options. puppet_options. end_point =  127. 0. 0. 1:9001  # 这里一定要注意端口和gateway service启动时指定的端口保持一致  bot. use(BotPlugin())  await bot. start()asyncio. run(main())在使用相关代码前，各位自行安装对应的依赖库，这里就不赘述了。 过程中遇到的问题概览:  本地环境网络代理引发的问题在一开始的尝试过程中，由于本人习惯于系统开机后就自动架梯，以实现随时随地的科学上网需求，所以也没做过太多网络层的关注和检查，在启动Gateway Service时，发现 Wechaty Puppet Service 始终无法完成初始化，无法看到日志中的登录二维码链接地址或用户登录成功的信息，取而代之的是一系列心跳检查和服务状态的切换，情况如下图所示： 过程中，始终只是有心跳检查的日志信息，但没有其他登录成功信息或者初次登录时的扫码信息，所以怀疑是网络层的问题导致部分数据没有正常发送和处理造成，同时联想到以前自己在手机上安装代理软件进行网络抓包时很多应用基于SSL安全双向校验的问题，会导致应用网络请求失败的案例，猜测是否是本机的网络代理设置导致 gateway 与 微信服务 之间的pad协议请求无法正常处理，导致微信服务操作异常，随后关闭本地的代理服务后重新启动gateway服务以及python代码，问题解除。 特别致谢: 本文档所述试验过程中，得到了如下几位同学的支持，再次特别提出感谢：  微信名：秋客 微信名：WyxReference:  RPC科普 Docker科普 https://wechaty. js. org/docs/specs/token https://wechaty. js. org/2021/01/14/wechaty-puppet-service/ https://wechaty. js. org/docs/puppet-services/"
    }, {
    "id": 75,
    "url": "https://wechaty.js.org/2021/07/23/gsod-2021-second-month-evaluation/",
    "title": "GSoD'21 Second Month Evaluation",
    "body": "2021/07/23 - Google Season of Docs’21 second month evaluation: Post Summary: In phase two of the Google Season of Docs’21 program, technical writers have carried the great work they were doing. Few projects are coming towards completion,and each project has made more than 50% progress, which is excellent and up to the mark. Also, we had 3 meetings in this phase to discuss aspects related to the GSoD’21 project.  Wechaty GSoD’21 fourth meeting Wechaty GSoD’21 fifth meeting Wechaty GSoD’21 sixth meetingYou can learn more from our meeting notes. This post gives an overview of the performance of tech writers in the second phase Tutorials for users of Wechaty team: Shwetal Soni is more or less up with her timeline and has completed tasks as per her proposal on time. She also knows how to reporterrors to the mentors in the from issues which is great. She also diligently maintains the follow-up sheet and her Github issue. Souviks’ quality of docs has exponentially improved in the second phase, and his few PRs towards the end of the second phase have been veryfluent and exceptional. Like his teammate, he has also completed most of the tasks as per the timeline. Also, he has been consistent like herteammate in the program, attending every meeting, and committing at a regular frequency. He also fixed a few technical errors. Overall the tutorials team is very dedicated to the project. Both of them did exceptional on their PRs, and also walked the extra mile to make thedocuments more friendly to the users, like adding code sandbox. Besides, we also made some modifications to the structure. A new document aboutthe “starter bot” is added. For the sake of the new document, though some of the documents were finished earlier, they still spent time modifyingthe old documents which are not on their proposal. They have complete about 55% of their GSoD work. Tutorial follow-ups Introduction and Explanation team: Their project should have ended by now, but they have submitted almost everything on time. Mainly they polished and revised their PRs in this phase. We are expecting their final project report in the next phase. Iterations in their PRs are still going on, thanks to Rui for actively reviewing them. They have completed 90% of the work Introduction and Explanation follow-ups Reference Section team: Shraddha has been very consistent and has been regularly committing PRs. She also implements all the suggestions in her PRs. She takes a lot of effort in reviewing other PRs and also helping the community by placing relevant labels. Soumi was out for quite a long period, so she needs some time to catch up on how to do documentation. Her contribution is fine now, but currently,her document style is a bit different from the rest of the team. She is also very hard working now so we expect this would not be a question. Collectively they have completed around half of their work, and Shraddha has completed about 55% of her work. Reference Section follow-ups Reconstruct Landing Page with Value Propositions team: Sajen is always enthusiastic about his work, and he works with utmost seriousness about his project. They are working on both the new landing page and the introduction project video. They are yet to raise the PR for their work butseeing his draft landing page volunteers guess that their project has progressed about 70% We would like to hear more from Arnab in the coming days, and I would like to urge him to be more responsive to emails, most of thereplies come from Sajen, maybe they have divided work like that, but we are looking forward to hearing from his as well. Also, he forgotto fill the 2nd survey form despite being given a reminder. Landing Page follow-ups Improve the gRPC and OpenAPI ecosystem team: He added Swagger UI to Express Route by default, which we believe is a subproject in itself! Although not much docs as we expected in GSoD to be, but he has added enough value to his project by adding code. Another thing wehave seen is a bunch of refactoring PRs from him, we are not sure that we should be that much concerned about pretty printing the code He has diligently maintained the follow-ups this phase. His few PRs can be reviewed by the code contributors only we believe, his PRsinvolving docs and pretty-printing the code have been reviewed by the volunteers. Volunteers believe his work to be 90 % complete follow-ups How-to Guides team: Their PRs have been easy to review, and they have been comfortable with Git this phase. There is great coordination between the team, and they are very organized. The how-to guide’s team is very hardworking, and their improvement is very significant. Their work is about 85% completed follow-ups Suggestions for the upcoming months: Tech Writers want faster PR reviews and merging, so that is an area for us to improve, and we have improved a lot as compared to the previous phase. Special thanks to Simin for adding her evaluations in this post and maintaining the Wechaty follow-ups sheet for tracking timelines of tech writers. "
    }, {
    "id": 76,
    "url": "https://wechaty.js.org/2021/07/22/gdg-shanghai-wechaty/",
    "title": "Wechaty: 6 行代码构建基于 Whatsapp 和个人微信的对话式人机交互界面应用",
    "body": "2021/07/22 - 在本周四晚 8 点的《社区说》中，上海 GDG 社区邀请嘉宾李卓桓（Huan）老师在 B 站直播间与伙伴们畅聊他的聊天机器人SDK：Wechaty 讲师介绍:  李卓桓 谷歌开发者专家（机器学习方向), Conversational SDK Wechaty 作者 TensorFlow. js布道师，Angular爱好者 《Chatbot从0到1》、《简明的TensorFlow 2》联合作者，GitHub万星开源 Conversational SDK Wechaty 作者 PreAngel 天使投资人，专注AI/Chatbot领域创业团队和项目 清华大学本科，中欧国际工商学院EMBA 紫霞 BBS、水木清华 BBS 站长，前优酷网首席科学家。对话式人机交互界面趋势: 李老师讲述在人机交互中，机器如何从“笨”变“聪明”、从打孔磁带到语音助手，交互方式一步步简化，机器越来越能够理解人所传达的指令。 人工智能前沿发展: 李老师介绍了像 GPT-3 和 DALL·E 在自然语言处理上，通过简单的的一句自然语言，让机器生成有一定复杂度的文章或图片组。  关于 Conversation AI, 李老师提到机器人聊天对话应用的种种困难，讲述了AI在提升这类机器人理解能力上的作用，以及人机合作如何在一定程度上改进用户体验。 Wechaty 介绍: 李老师分享到他最初做 Wechaty 的灵感，来源于2014年他的微信消息和好友列表爆满…以至于影响使用效率，于是希望将重复性高的工作整合给机器人完成，实现自动化。 根据 Wechaty 官方介绍，  Wechaty 是一个开源的的对话机器人 SDK，支持个人号微信。它是一个使用 Typescript 构建的 Node. js 应用。支持多种微信接入方案，包括网页，iPad，iOS，Windows， Android 等。同时支持 Linux, Windows, Darwin (OSX / Mac) 和 Docker 多个平台。 Wechaty 帮助开发者实现一个让用户无感知的在 IM (Instant Messaging) 平台与接入的机器人对话或交互。开发者在 IM 平台扫码接入，自由选择底层并设计应用层，最终实现智能对话。 Wechaty 现支持多种即时通讯平台，可用多种编程语言实现：  GitHub Repo: https://github. com/wechaty/wechaty 官网: https://wechaty. js. orgLive Demo: 李老师在直播现场演示如何快速配置一个微信机器人 首先通过指令 git clone git@github. com:wechaty/wechaty-getting-started. git将 wechaty-getting-started 仓库克隆至本地； 然后输入指令 WECHATY_PUPPET=wechaty-puppet-wechat npm start以启动基于微信的 wechaty 机器人， 或者输入指令 WECHATY_PUPPET=wechaty-puppet-whatsapp npm start以启动基于 WhatsApp 的 Wechaty 机器人。 在 Demo 中，个人微信号扫码登陆 web 版微信化身成为机器人，收到带有关键字 “ding” 的消息后，会自动发送 “dong” 作为回复： Wechaty 开源社区自成立来，已获多项荣誉，百万量级的下载量，其开发者群体数量庞大且国内外影响力广，如图展示： 问答环节中同学们针对 Wechaty 的安全性、限制、多轮语义分析等方面提出了精彩的问题，感兴趣的伙伴们可以查看回放： {% include iframe. html src=”https://youtu. be/q7a6x81RLA8” %}  00:00 社区说：主持人介绍GDG社区 06:27 Talk 开场 09:25 李卓桓介绍 11:43 对话式人机交互界面趋势 15:11 人工智能前沿发展 23:00 Conversation AI 场景 26:58 Wechaty 介绍 29:40 Live Demo 45:26 Wechaty 总结 47:46 Chatbot 行业前景 49:45 Q/A Bilibili: https://www. bilibili. com/video/BV13f4y1575J Slides: {% include iframe. html src=”/assets/2021/07-gdg-shanghai-wechaty/wechaty-community-talk-live-demo. pdf” %}  小编认为可以让一个 bot 来做发送文件的事情呢 ^_^ 关于社区说: 「社区说」是一个由谷歌开发者社区 (Google Developer Group) 主导的，与热爱技术的开发者们交流技术，直播代码，讨论产品，分享心得的小型线上会议，每次时长 45 分钟到 1 个小时。 活动将由不同的谷歌开发者社区举办并邀请来自国内的不同技术方向的谷歌开发者专家以及对技术有热情、愿意分享的嘉宾，一起来聊一聊最近做的项目，最近写的代码，或者三五技术好友互相探讨聊天。  编辑：陈君瑶Source: GDG "
    }, {
    "id": 77,
    "url": "https://wechaty.js.org/2021/07/20/milvus-sync-bot/",
    "title": "Wechaty 实现 Milvus 社区群消息同步",
    "body": "2021/07/20 -  作者: shiyu22， 程序媛 Wechaty 实现 Milvus 社区群消息同步: 背景: 首先介绍下开发背景，Milvus 是一个开源的特征向量数据库，本着开源互助的精神，社区一直致力于帮助用户解疑答惑。企业微信聊天群是社区的交流地之一，基于群聊自动扩群功能下，每个群聊的人数上限是 200 人，所以 Milvus 开源一年半以来，累计了十个用户交流群。用户分散在多个群会发生一些交流或管理方面的问题：  旧群交流少：十个交流群中之前的群中交流不多，因为该踩的坑都踩完了，老用户提问的频率不高。 多个群问相似的技术问题：不同的用户在不同的群里问类似的问题，社区人员需要多次重复回答。 社区重复发布新闻等消息：当产品发布新版本时，社区会发布新闻，这时需要在十个群里手动转发。 技术交流覆盖不广泛：当一个群里交流技术难题，其他群的小伙伴无法参与或查看。基于以上的这些问题，社区考虑做一个企业微信群间消息同步的机器人，开发群内的消息同步功能，方便群里用户的沟通与交流。效果展示: 针对前面提到的问题，社区计划实现一个可以同步群消息的机器人，之前了解到 Wechaty 可以实现这个功能，并且 Wechaty 的社区也部署了同步群消息的机器人。Wechaty 是一个开源的的对话机器人 SDK，它是一个使用 Typescript 构建的Node. js 应用。支持多种微信接入方案，包括网页，ipad，ios，windows， android 等。基于 Wechaty 部署的机器人可以同步十个群的消息，效果展示如下面的截图，机器人负责转发其他群的消息，保证每个群可以同步，用户交流群的人就可以跨群交流了。接下来将介绍如何用 Wechaty 部署消息同步的机器人。 Wechaty 的具体实现:  获取 Milvus 用户交流群的列表为了同步多个群的消息，首先获取需要同步消息的群列表，这时主要通过群名来判断，如判断群的前缀是否为 ” Milvus 用户交流群“，此时 Wechaty 会返回一个 Room 列表。async def on_login(self, contact: Contact):  self. ROOM_LIST = ['Milvus用户交流群']  roomlist = await self. Room. find_all()  self. community_list = []  for r in roomlist:    name = await r. topic()    # the group name like 'Milvus用户交流群101'    if name[:-3] in self. ROOM_LIST:      self. community_list. append(r) 收到消息时转发到指定群接下来就判断接受到的消息是否来自 Room 列表，如果是的话就将其转发到剩余的的几个 Room。async def on_message(self, msg: Message):  room = msg. room()  if room:    contact = msg. talker(). name    text = msg. text()    group = await room. topic()      # cheeck if the msg is from ROOM_LIST    if group[:-3] in self. ROOM_LIST:      # send the msg to other rooms and make sure not duplicated.       for community in self. community_list:        if room is community:          continue        community. say(text) 多种类型的信息转发需要注意的是，群里会接收到多种类型的消息，如“文本”，“图片”，“公众号文章”和“小程序”等，那么可以在 Wechaty 中判断信息类型并发出消息。msg_type = msg. type()if msg_type==MessageType. MESSAGE_TYPE_IMAGE:  image: Image = msg. to_image()  hd_file_box: FileBox = await image. hd()  await hd_file_box. to_file(file_path='. /hd-image. jpg', overwrite=True)  image_filebox = FileBox. from_file('. /hd-image. jpg')  await community. say(image_filebox)elif msg_type==MessageType. MESSAGE_TYPE_URL:  content = await msg. to_url_link()  await community. say(content)elif msg_type == MessageType. MESSAGE_TYPE_MINI_PROGRAM:  mini_program = await msg. to_mini_program()   if mini_program:    await community. say(mini_program)else:  if text:    send_text = '[{}@{}]: {}'. format(contact, group[-3:], text)    await community. say(send_text)总结: 最后，十分感谢 Wechaty 开源的 Python SDK 以及开源激励计划，可以十分方便的使用 Token 进行开发。而 Milvus 特征向量数据库同为开源项目，计划在下一版本中利用 Milvus 智能判断广告消息，预防非技术交流人员在群里发布广告等消息，期待下一版本的更新！ "
    }, {
    "id": 78,
    "url": "https://wechaty.js.org/2021/07/18/gsod-2021-sixth-meeting/",
    "title": "GSoD'21 Sixth Meeting",
    "body": "2021/07/18 - Google Season of Docs’21 sixth meeting: Meeting Summary: It was the sixth meeting of the GSoD’21 participants. Firstly every participant gave one’s weekly summary and informed the communityabout their plans for the upcoming week, volunteers and tech writers discussed while tech writers were giving their week summaries. After that, information was given by volunteers regarding the mid and final blog posts, following a discussion was lead by Simin regardingurgent PRs and new PR rules, later we discussed comments and questions of the participants, and at last, we took a lovely group photo. {% include iframe. html src=”https://youtu. be/pLjyGVOmI6M” %} Attendees: Total 13 attendees attended the meeting. They are:  Rohitesh Jain, Volunteer (UTC + 5:30) Sajen Sarvajith, Reconstruct Landing page writer (UTC + 5:30) Abhishek Jaiswal, How-to-guide section writer (UTC + 05:30) Simin Liao, Volunteer (+8:00) Mukosa Joseph Mawa, Introductions and Explanations section writer (UTC +03:00) Rajiv Ranjan Singh, Improve the gRPC and OpenAPI ecosystem writer, rajivperfect007@gmail. com, (UTC+05:30) Souvik Biswas, Create easy to learn tutorials for beginner users writer, sbis1999@gmail. com (UTC +05:30) Shraddha, Improve References section writer (UTC + 5:30) Shwetal Soni, Create easy to learn tutorials for beginners users writer (UTC +05:30) Vasvi Sood, How to guides, contactvasvisood@gmail. com writer (UTC + 5:30) Arnab Saha, Reconstruction of Landing page with value propositions writer (UTC + 5:30) Chris Estepa, Introduction and Explanations sections writer (UTC +08:00) Soumi Bardhan, Improve References section writer (UTC + 5:30)Note: Meeting started on schedule and everyone attended this ! Agendas:  00:00 0. Introduction &amp; Welcome 00:50 1. Discussion with Tutorials team 05:00 2. Discussion with Introduction and explanation team 06:50 3. Discussion with Landing page team 13:50 4. Discussion with References section team 18:20 5. Discussion with How to guides team 20:25 6. Discussion with gRPC team 23:26 7. Info regarding Mid term and final blogs 27:20 8. New PR merging rules 28:45 9. Questions/commentsYou can learn more from our meeting notes. Meeting Outcomes:  The community got to know about the progress and plans of the members Information regarding the mid and final blogs is given.  Urgent PRs have been collected New PR rules have been explained to tech writer A feedback form has been circulatedMeeting Follow-ups:  Merge PRs in this list Help tutorials team, refer #1044,and #1043 Provide Shraddha more information regarding the Wechaty plugin #890 Sajen requires help in the voice of the developers section #912 We will be seeing Tutorial team’s mid blog in the coming weekNotable Meeting Comments:  (Joseph) I will be reaching out to the other teams for more info about challenges they faced so that we add them totroubleshooting sub-section of the explanationNotable Meeting Questions:  Q: (Rajeev) Can we add PRs in the merging list issues? A: (Rohitesh) Rules for adding PRs in merging list are simple : 1) It should pass CI test 2) should have approvalsof both the volunteers 3) your team mate should approve it as well. If your PR is matching this criteria feel free to add. "
    }, {
    "id": 79,
    "url": "https://wechaty.js.org/2021/07/17/ospp-plan-wechaty-puppet-oa/",
    "title": "OSPP 2021-期初报告-基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善",
    "body": "2021/07/17 -  项目名称：基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善 导师：吴京京 学生：zzzyer 模块列表     文本消息收发模块   图片消息收发模块   推送事件    项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/82需求介绍:    申请开发专用测试公众账号     架设 wechaty-puppet-official-account 并可以进行微信公众账号的正常文本消息收发     对 Wechaty Puppet Official Account 的功能进行试用，分析其当前的功能，然后列出需要完善的功能列表，以及欠缺的功能列表，并作出开发计划。  在初期开发中，能够实现图片消息的接收和发送，即可完成原型验证 POC。 项目开发时间计划: 时间：2021. 07. 01-2021. 07. 21:    申请微信公众平台测试账号     阅读Wechaty Puppet Official Account代码     成功运行Wechaty Puppet Official Account相关样例（ding-dong-bot）     与导师讨论得出要开发的功能模块  时间：2021. 07. 21-2021. 08. 15:    完成文本消息收发的功能完善     完成图片消息的简单收发  时间：2021. 08. 15-2021. 09. 15:    完善中期开发之前的功能模块     优化代码结构     如有时间，可与导师商定对功能进行扩展   Author:@zzzyer “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。官网：https://summer. iscas. ac. cn/ 本项目 [基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善] 系 暑期2021 支持的开源项目。 "
    }, {
    "id": 80,
    "url": "https://wechaty.js.org/2021/07/16/ospp-huan-first-meeting-cli-matrix/",
    "title": "OSPP'21 first meeting for CLI & Matrix projects",
    "body": "2021/07/16 - 基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善 #59: Matrix 是一个 open network for secure, decentralized communication, like Pidgin on your Phone. matrix-appservice-wechaty 是一个 WeChat (微信) Matrix AppService for bridging the Matrix user with WeChat user.  It has been officially listed at [Matrix] Bridge Page for Wechaty. 我们在本次 Summer 2021 的项目中，社区希望可以将我们的 matrix-appservice-wechaty 项目进行继续完善，将它对用户、群、消息收发（包括文本、图片、视频等）的基础功能进行完善和支持。 基与 Blessed 的 Wechaty 命令行文本客户端软件（仿IRC） #80: Blessed 是一个 curses-like library with a high-level terminal interface API for node. js. 基于 Blessed 能够快速的完成命令行文本节目的开发： 通过 blessed-contrib 可以快速的 Build dashboards (or any other application) using ASCII/ANSI art and javascript， 达到 Friendly to terminals, ssh, and developers. Extends blessed with custom drawille and other widgets 的使用效果。 我们在本次 Summer 2021 的项目中，Wechaty 希望可以实现对一个基于 Blessed 的 CLI 命令行文本客户端，通过 Wechaty 的基础支持，实现一个能够作为 WeChat, WeCom, Lark, Whatsapp 等所有 Wechaty 支持的 IM 的命令行文本客户端。 Attendees:  Huan, mentor of wechaty/summer-of-wechaty#80 and wechaty/summer-of-wechaty#59 刘靖，student of blessed-based wechaty-cli, liuchinggg@gmail. com 林宇靖, student applying for Matrix AppService Wechaty, 545641826@qq. com, +8 张瑞宁, student applying for Matrix AppService Wechaty, 3134191406@qq. comMeeting zoom recording playback: {% include iframe. html src=”https://youtu. be/waFht2BeKb0” %}  0:00 [Huan] Meeting started 4:00 [Jing LIU] Introducing https://github. com/chinggg/wechaty-cli/ 14:00 [Yujing LIN] Introduce the project progress of Matrix AppService Wechaty 31:00 [Ruining ZHANG] learn how to configure the server https://wechaty. js. org/2021/02/04/matrix-with-wechaty/ 40:00 [Huan] Review &amp; Introducing Wechaty Contributor Program 54:00 Group photo Meeting Notes 关于 Wechaty 社区: Wechaty 社区目前已经支持微信、Whatsapp、企业微信、飞书等常见流行即时通讯工具，并且能够通过多语言 SDK （比如 Python Wechaty） 进行调用。 关于暑期2021: 开源软件供应链点亮计划-暑期2021（以下简称 暑期2021）是由 中国科学院软件研究所 与 openEuler 社区 共同举办的一项面向高校学生的暑期活动，旨在鼓励在校学生积极参与开源软件的开发维护，促进优秀开源软件社区的蓬勃发展。该活动将联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。根据项目的难易程度和完成情况，参与者还将获取 开源软件供应链点亮计划-暑期2021 活动奖杯和奖金。  官网：https://summer. iscas. ac. cn/ Wechaty OSPP’21: https://wechaty. js. org/docs/ospp/2021"
    }, {
    "id": 81,
    "url": "https://wechaty.js.org/2021/07/16/gsod-2021-publish-article/",
    "title": "揭秘：2021Google Season of Docs为何选择Wechaty",
    "body": "2021/07/16 -  感谢点进我的博客，非常荣幸能够和你分享 2021Google Season of Docs 与 Wechaty 的相关发展情况。今年，Wechaty 已经与 Google Season of Docs 达成合作，请求的预算 9500 美元也已经被批准。 GSoD 简介:  GSoD 是Google Season of Docs的简称，是由谷歌组织的年度活动，目的是将技术文档撰写工程师和开源组织聚集到一块，在开源这个空间中共同促进和改善开源的发展。 谷歌的这个活动具有重大意义，开源项目为用户提供的不仅仅是理解学习项目的平台，同样也是一个能够为开源项目做贡献的渠道。在该计划期间，技术文档撰写工程师们花了 3-5 个月时间构建一个新的文档，改进现有文档的结构，开发急需的教程，改进开源组织的贡献流程和指南。Wechaty 简介:  Wechaty 是一个开源的的个人号微信机器人接口，一个使用 Typescript 构建的 Node. js 应用。支持多种微信接入方案，包括网页，ipad，ios，windows， android 等。同时支持 Linux, OSX, Win32 和 Docker 等多个平台。 多年来调查表明，良好的文档对于开发人员如何使用开源方面很重要。 Wechaty 作为30个伟大的开源组织之一，帮助聊天机器人开发者快速搭建聊天机器人的框架，并且支持多个系统平台。 Wechaty 的使命：给聊天机器人的开发者提供一个最好的开源 sdk，给开发者最好的体验。帮助开发者能够更多关注于逻辑应用，把精力集中于编写上层应用的代码，而不是把时间花在与平台的底部对接上。 Wechaty 在 2 月份的时候就开始着手准备 2021 年的 Google Season of Docs。在 Wechaty 于 4 月 16 日正式宣布加入 2021Google Season of Docs 后，联系了多位技术文档撰写工程师，几乎所有的提案都在详细规划和深刻研究。为什么选择 Wechaty:  五年技术沉淀：Wechaty (Conversational RPA SDK) 2016 年发布于 GitHub，是一个基于 Apache-2. 0 许可证的开源项目。经过 5 年多的发展，现在 Wechaty 开源社区已经拥有数十位 Committers，百余位 Contributors ，并被超过一万名 GitHub 开发者 Star。目前，使用 Wechaty 的开发者已覆盖数万人，并拥有基于微信群的数千人活跃开发者群。 用户遍布全球：Wechaty 社区的 Contributors 遍布全球多个国家地区，和各大互联网公司，职业背景从程序员到设计师，从大学教授到创业者。GitHub 上有千余个开源项目基于 Wechaty 构建了聊天机器人，这些开发者用户也极大地促进了社区的活跃和发展。 高效发布代码：Wechaty 自身对代码质量的管理，使用了 GitHub Actions 的 DevOps 工具完成了 CI/CD 工作流，从自动化单元测试到自动打包集成测试，从自动发布 NPM 包到自动构建和发布对应版本的 Docker Image ，实现了全自动的社区代码发布，极大的提高了社区的协同效率。 社区活跃度大：截止 2021 年，Wechaty 已经有近百万次 NPM 安装下载，并由社区自发推动了 Python, Go, Java, Scala, . NET, PHP, Rust 等语言的适配和发布，是国内最活跃的 Conversational AI Chatbot 开发者社区。 信息开放透明：沟通首选渠道是 Gitter, 因为 Gitter 保存了所有的历史沟通记录，即使是刚刚加入社区的开发者，也能追溯第一天社区成员讨论过的内容。次优选的沟通渠道是加入 Mailing List ，保证社区内容开放透明并以邮件存档。 会议规范高效：Wechaty 社区的会议利用专业工具和规范的使用规则，保证会议简洁高效和社区透明，实现了让所有参与者都专注参与，并且获得正向产出。 各项荣誉成就：Google Season of Docs 支持的 30 个全球顶级开源项目之一；被国内顶级开源组织中国开源云联盟评为优秀开源项目；开源项目作者李卓桓入选“中国开源先锋 33 人”；连续入选 2020、2021 年度开源软件供应链点亮计划。 使用安全简单：只切换一个变量，其他代码不变就能登录新 IM；支持常见流行编程语言，API 定义跨编程语言保持一致；多加一行代码就能拥有复杂对话能力。 功能丰富强大：除接收消息，发送消息、添加好友、为好友备注、接受好友请求、发起群聊、加人入群等基本功能外，还能进行消息处理，群管理，自动处理好友请求，智能对话等更多功能。 灵活定制业务：个人号搭建一个微信机器人功能只需要 6 行代码，简单的操作就可对消息做不同的指令，能完成自己想要的逻辑。 兼容各种平台：写一份代码，可在不同的平台上运行，只需切换环境变量。同时支持 Linux, OSX, Win32 和 Docker 等多个平台。支持多种接入方案，包括网页，ipad，ios，windows，android 等。 人才公司复用：行业很多已经正在使用 Wechaty 的开发者和公司，都可以在第一时间成为未来运营商 Chatbot 的高质量供应商。 商业场景复用：使用对商业最为友好的 Apache-2. 0 许可协议。大量开发者和商业公司都可以通过 Wechaty 迅速切入 5G Chatbot 新市场。目前的进程:    下面是按时间进行的进程汇总：   首先向微信邮件列表发送了一封公告:微信 GSoD’21 技术文档撰写工程师注册表已开放   5 月 3 日:向技术文档撰写工程师发送谷歌表格   5 月 8 日:进行了在线会议，在宣布最终评选结果之前进行论。欢迎所有技术文档撰写工程师加入Hello Wechaty GSoD’21 Technical Writers!你也可以了解会议详情   5 月 9 日：宣布了微信 Google Season of Docs’21 技术文档撰写工程师评选结果。   5 月 16 日：进行了 Google Season of Docs 第一周会议,讨论了未来会议日期，做了一周工作总结，介绍下一周计划，并讨论了是否应该延长主要项目的时间表，Simin 介绍了文档结构和样式。后来我们进行了一个问答环节。你也可以了解相关博客和会议详情   5 月 23 日：进行了 Google Season of Docs 第二周会议，每位与会者首先给出了自己的一周总结，报告了他们下一周的计划。一起讨论了一下 Wechaty 的未来愿景，Simin 就 PRs 中经常出现的错误进行了讨论。你也可以了解相关博客和会议详情   6 月 6 日：进行了 Google Season of Docs 第三周会议，每位与会者首先做了一周的总结，并向社区汇报了他们下一周的计划，提出了对大型 PRs 的关注，讨论了 PRs 的范围和规模，对于缺乏每周跟进的团队分别解释了原因。Simin 说明了需要注意的相关事项并向大家进行了演示。进行问答环节，并合影留念。你也可以了解相关博客和会议详情   6 月 20 日：进行了 Google Season of Docs 第四周会议，首先每位参与者都做了一周的总结，并向社区汇报了他们下一周的计划，志愿者和技术作家们在进行一周总结的同时进行了讨论。最后大家进行了问答环节，并拍了一张可爱的合影。你也可以了解相关博客和会议详情   7 月 4 日：进行了 Google Season of Docs 第五周会议，每个参与者都进行了一周总结计划了下一周的工作，志愿者和技术文档撰写工程师们进行了讨论。你也可以了解相关博客和会议详情   7 月 18 日：进行了 Google Season of Docs 第六次会议，同样，每个参与者都对本周工作进行了总结，并对计划了下一周的工作，志愿者和技术文档撰写工程师进行了讨论，最后进行了问答环节，讨论和解决了大家存在的问题。你也可以了解更多的会议详情  参与者: 总共有 12 个参与者，他们是：  Rohitesh Jain, Volunteer (UTC + 5:30) Sajen Sarvajith, Reconstruct Landing page writer (UTC + 5:30) Abhishek Jaiswal, How-to-guide section writer (UTC + 05:30) Simin Liao, Volunteer (+8:00) Mukosa Joseph Mawa, Introductions and Explanations section writer (UTC +03:00) Rajiv Ranjan Singh, Improve the gRPC and OpenAPI ecosystem writer, rajivperfect007@gmail. com, (UTC+05:30) Souvik Biswas, Create easy to learn tutorials for beginner users writer, sbis1999@gmail. com (UTC +05:30) Shraddha, Improve References section writer (UTC + 5:30) Shwetal Soni, Create easy to learn tutorials for beginners users writer (UTC +05:30) Vasvi Sood, How to guides, contactvasvisood@gmail. com writer (UTC + 5:30) Arnab Saha, Reconstruction of Landing page with value propositions writer (UTC + 5:30) Chris Estepa, Introduction and Explanations sections writer (UTC +08:00)Welcome: 非常高兴有你们都加入 Wechaty，更欢迎更多的技术文档撰写工程师加入我们，共同学习共同建设 Wechaty 社区！ "
    }, {
    "id": 82,
    "url": "https://wechaty.js.org/2021/07/15/ospp-plan-wechaty-club-managment/",
    "title": "OSPP 2021-期初报告-开发基于微信实现微俱乐部会员&活动管理的微信小程序",
    "body": "2021/07/15 - 项目信息:  导师：鲁玉超 学生：陈婧 项目地址: https://github. com/wechaty/summer/issues/78项目详情:  阶段列表     设计小程序的基本框架   实现群主&amp;群成员操作功能块   互动操作功能实现   添加功能块&amp;检查改进    计划安排:     阶段一         完成时间：7月20日     计划描述：引入聊天机器人，整理基础适用/开发生产环境/用户协议，绑定用户数据到俱乐部，使用微信开放平台实现“关键词回复”功能。          阶段二         完成时间：8月15日     计划描述：实践“群主发布活动”功能，实践“群主管理活动”功能，实践“成员标签活动”功能，完善以上功能块进行调试。          阶段三         完成时间：9月5日     计划描述：实践“活动相册”功能、“帮助”功能（将关键词与操作关联，要求提高容错性），如果有空余时间，设计自定功能。          阶段四         完成时间：9月30日     描述计划：实践自设定功能，收集中出现的问题，针对程序运行程序功能，小整体优化升级（用户数据处理）。          联系我们:  联系方式：1017137803@qq. com Author:@mangguo188 关于暑期2021: 「开源软件供应链点亮计划-暑期2021」（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动，旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。 官网：https://summer. iscas. ac. cn/#/homepage 本项目 [开发基于微信实现微俱乐部会员&amp;活动管理的微信小程序] 系暑期2021支持的开源项目。 "
    }, {
    "id": 83,
    "url": "https://wechaty.js.org/2021/07/15/ospp-plan-5g-chatbot-puppet/",
    "title": "OSPP 2021-期初报告-开发支持电信运营商5G Chatbot/RCS的 Wechaty接入Puppet模块",
    "body": "2021/07/15 - 开发支持电信运营商5G Chatbot/RCS的 Wechaty接入Puppet模块:    导师：李佳芮,康嘉,李卓桓     学生：张瑞宁,邵琦     项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/74     模块列表      使用5g Chatbot接口，把收发消息测通   使用 https://github. com/wechaty/wechaty-puppet-official-account 项目作为模版，将其中的微信公众平台调用全部封装为RCS模块的调用   发布 Git Repo wechaty-puppet-5g-msg，实现文本消息的发送和接收   进行测试，完善项目文档   配置 GitHub Actions 实现自动化测试（可选）      计划安排：      使用5g Chatbot接口，把收发消息测通         7/12 - 7/18     配置好服务器，测通相关接口          使用 https://github. com/wechaty/wechaty-puppet-official-account 项目作为模版，将其中的微信公众平台调用全部封装为RCS模块的调用         7/19 - 8/10     学习现有源码，学习RCS的相关知识。     接入wechaty，进行代码整合，提高代码质量。          项目中期总结         8/11 - 8/15     实现阶段性目标，总结项目阶段性成果。          发布 Git Repo wechaty-puppet-5g-msg，实现文本消息的发送和接收         8/16 - 8/31     提供一个 examples/ding-dong-bot. ts ，完成“接收到文字消息ding时，自动回复消息dong”的功能          项目完善优化         9/1 - 9/15     撰写整个项目过程的总结博客。配置 GitHub Actions 实现自动化测试，增加单元测试等。          项目结项         9/16 - 9/30     总结项目成果，项目经验，准备结项材料。             联系方式：      张瑞宁：3134191406@qq. com   邵琦：shaoqichn@qq. com      分工合作:      分工：张瑞宁同学需主要负责代码实现和gitlab项目维护，邵琦主要同学负责代码审查和gitlab项目维护。共同撰写中英文文档。   津贴分配：邵琦同学：张瑞宁同学=1:1    Author: @zrn-fight@Sochy 关于暑期2021: “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。 旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 官网：https://summer. iscas. ac. cn/#/homepage 本项目 [开发支持电信运营商5G Chatbot/RCS的 Wechaty接入Puppet模块] 系暑期2021支持的开源项目。 "
    }, {
    "id": 84,
    "url": "https://wechaty.js.org/2021/07/14/ospp-plan-wechaty-puppet-lark/",
    "title": "OSPP 2021-期初报告-基于开放 API 封装 Wechaty 接口下的飞书聊天机器人",
    "body": "2021/07/14 - [基于开放 API 封装 Wechaty 接口下的飞书聊天机器人]具体计划:    导师：范蕊     学生：马田慧     项目链接：wechaty/summer-of-wechaty#38   模块列表     更新api版本，熟悉飞书api和wechaty。   实现之前未实现的函数   连接Contact、Message、Room等类，尝试实现复用   撰写文档、example   发布npm包      计划安排      熟悉wechaty         7. 14 - 7. 17     使用wechaty     了解飞书api          更新api版本         7. 18 - 7. 24          实现之前未实现的函数阶段         7. 25 - 8. 8     分两阶段完成，期间注重与导师交流          连接Contact、Message、Room等类         8. 9 - 8. 21          撰写文档，examples         8. 22 - 8. 28          项目完善         8. 29 - 9. 5     代码重构     发布npm包             项目链接：   https://github. com/remember00000/wechaty-puppet-lark                 联系方式：+86 18660817606     email：2741102314@qq. com           Author: @remember00000Code: wechaty-puppet-lark 关于暑期2021: “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 官网：https://summer. iscas. ac. cn 往期回顾：https://wechaty. js. org/2020/07/20/wechaty-soc-kick-off-meeting 本项目 [基于开放 API 封装 Wechaty 接口下的飞书聊天机器人] 系 暑期2021 支持的开源项目。 "
    }, {
    "id": 85,
    "url": "https://wechaty.js.org/2021/07/14/ospp-plan-wechaty-matrix/",
    "title": "OSPP 2021-期初报告-基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善",
    "body": "2021/07/14 - 基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善:    导师：李卓桓，yswtrue     学生：林宇靖，张瑞宁     项目介绍： https://github. com/wechaty/summer/issues/59   模块列表     架设一套自己的 Matrix 系统   架设 matrix-appservice-wechaty 并整合到 Matrix 系统中   对 Matrix AppService Wechaty 的功能进行分析，然后列出需要完善的功能列表，以及欠缺的功能列表，并完成计划列表中的计划。 在初期开发中，实现图片消息的接收和发送，完成原型验证 POC   进行测试，完善项目文档   配置 GitHub Actions 实现自动化测试（可选）    计划安排:     架设一套自己的 Matrix 系统         7/12 - 7/18     配置好设置好matrix服务器，测通相关接口          架设 matrix-appservice-wechaty 并整合到 Matrix 系统中         7/19 - 7/25     学习现有源码，进行代码整合，提高代码质量          对 Matrix AppService Wechaty 的功能进行分析，然后列出需要完善的功能列表，以及欠缺的功能列表，并完成计划列表中的计划         7/26 - 8/1     熟悉项目功能，根据仓库issue和实际代码列出需要完善的功能     无          实现图片消息的接收和发送，完成原型验证 POC         8/2 - 8/8     添加图片消息的接收和发送模块，使 Matrix AppService Wechaty支持图像消息     无          项目中期总结         8/9 - 8/15     实现阶段性目标，总结项目阶段性成果     无          项目完善         8/16 - 8/31     根据需要完善的功能列表完善群聊用户昵称显示，头像显示     无          项目优化         9/1 - 9/15     添加完善中英文。撰写整个项目过程的总结文章。配置 GitHub Actions 实现自动化测试，增加单元测试等     无          项目结项         9/16 - 9/30     总结项目成果，项目经验，准备结项材料     无           项目链接： matrix-appservice-wechaty 联系方式：     林宇靖：545641826@qq. com   张瑞宁：3134191406@qq. com    分工合作:     分工：林宇靖同学需主要负责项目功能实现和gitlab项目维护，张瑞宁主要同学负责代码审查和gitlab项目维护。共同撰写中英文文档   证书：保证张瑞宁同学证书署名的情况下，尽量加上林宇靖同学的名字   津贴分配：林宇靖同学:张瑞宁同学=3:1    Author:@Rhyme @zrn-fight 关于暑期2021: “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。 旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 官网：https://summer. iscas. ac. cn/#/homepage 本项目 [基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善] 系暑期2021支持的开源项目。 "
    }, {
    "id": 86,
    "url": "https://wechaty.js.org/2021/07/14/ospp-plan-blessed-cli/",
    "title": "OSPP 2021-期初报告-基于 Blessed 的 Wechaty 命令行文本客户端软件",
    "body": "2021/07/14 -  项目名称：基于 Blessed 的 Wechaty 命令行文本客户端软件 导师：李卓桓 学生：刘靖 模块列表     所有消息的实时接收与展示   联系人与群聊列表的获取与展示   右侧群聊成员/联系人详情的展示   消息内容按来源存储与查看，联系人与群聊信息的缓存   未读新消息数量展示与联系人智能排序   私聊与群聊消息的发送   细粒度的联系人、群和对话管理    项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/80详细方案:    任务要求利用 Blessed 和 blesssed-contrib 提供的组件，仿照 Linux 命令行终端的 IRC 文本客户端，实现一个基于 Wechaty 的即时通讯客户端，通过 Wechaty 支持所有现有的 Wechaty Puppet Providers，比如微信、企业微信、飞书、Whatsapp 等。在初期开发中，能够实现文本消息的接收和发送，即可完成原型验证 POC 。     实现方案学习 blessed 和 Wechaty 的使用，并研究 node-facenet 和 console-tg-client 的架构设计，多和导师进行沟通，利用事件绑定或 RxJS 实现文本消息的收发功能和未读状态的提示，并提供一定的联系人和群对话管理功能，达到接近现有 IRC 客户端的完整程度。  设计方案如下图所示： 项目开发时间计划: 第一阶段（7. 1 - 8. 14）: 对接后端事件，选择恰当的架构与技术栈完成数据的存储、展示与更新。    7. 1 - 7. 14自行探索做出 demo，实现简单的消息接收和联系人列表展示，与导师沟通架构设计和需使用的技术栈。     7. 15 - 7. 29军训期间，时间有限，学习前端相关知识或抽空实现较简单的功能。     8. 1 - 8. 14改进代码结构，重点推进数据的存储与状态的管理，实现消息内容按来源存储与查看，以及联系人与群聊信息的缓存，并撰写中期报告。  第二阶段（8. 15 - 9. 30）: 重点完善前端交互，持续改进用户体验。    8. 15 - 8. 30根据未读消息数量对联系人进行状态管理和智能排序，提供更多的交互选项和管理功能。     9. 1 - 9. 14实现消息的发送     9. 15 - 9. 30完善文档，编写样例代码，如有需要还需编写测试。     10月及以后继续维护并优化代码，实现新功能。   Author:@chinggg 关于暑期2021: 「开源软件供应链点亮计划-暑期2021」（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动，旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取「开源软件供应链点亮计划-暑期2021」活动奖金和奖杯。官网：https://summer. iscas. ac. cn/ 本项目 [基于 Blessed 的 Wechaty 命令行文本客户端软件] 系 暑期2021 支持的开源项目。 "
    }, {
    "id": 87,
    "url": "https://wechaty.js.org/2021/07/13/wechaty-puppet-xp-start-up/",
    "title": "全新的Windows puppet项目wechaty-puppet-xp启动",
    "body": "2021/07/13 - 7月13日，周二，我们组织了一个小范围的 Wechaty Contributor 线下聚会。 之前预告的《喜讯：使用Windows微信桌面版协议登录，wechaty免费版协议即将登场》主角诗人老张飞临北京，期待已久的聚会终能成行。 也借由此次相聚，大家期待的wechaty-Windows协议免费wechaty-puppet-xp项目正式启动。 超哥由于打工人的原因，身不由己，在下工后姗姗来迟，赶到时主要议题已接近尾声。直接说议题产出：    @老张介绍了 laozhang-chat-bot开源项目 的缘起，因为工作中的一个自动化通知场景业务需求决定动手自己做了一个wechat bot。后来觉得这个技术对对家有用，开源了出来，目前几个微信群有500+开发者参与讨论和使用。此次能够与wechaty结合来打造一个更加易用、完善的chatbot非常高兴。     @huan介绍了wechaty-puppet的技术实现及演示了基于老张的chat-bot结合wechaty实现ding-dong-bot的demo。     大家进一步聊了新的puppet的规划和发展，并群策群力为我们的“wechaty-puppet-laozhang”取了一个全新的名字wechaty-puppet-xp，未来将由老张主导开启xp项目的完善。       最后大家把酒言欢畅谈技术、生活。    这里也预告一下，第一个版本的wechaty-puppet-xp将于近期发布，让大家尽快能够体验。 同时也欢迎感兴趣的开发者关注和加入wechaty-puppet-xp项目。 与会者介绍: @huan, Huan LI, Creator of Wechaty, Tencent TVP of Chatbot @lijiarui: Full stack developer, serial entrepreneur, Founder &amp; CEO of JuziBot @gaoyuan: Founder &amp; CTO of JuziBot @cixingguangming55555: Wechaty puppet xp @atorber: Groupmaster Wechat Miniprogram "
    }, {
    "id": 88,
    "url": "https://wechaty.js.org/2021/07/13/ospp-plan-wechaty-piggy-bro/",
    "title": "OSPP 2021-期初报告-基于 Wechaty 开发开源的二师兄社群逗乐机器人",
    "body": "2021/07/13 -  项目名称：基于 Wechaty 开发开源的二师兄社群逗乐机器人 导师：韩磊、鲁玉超、王玉丹 学生：井维嘉 模块列表     可扩展式开发框架   讲笑话、成语接龙、猜图片、猜歌名等功能   二师兄Logo及形象   二师兄后花园   使用、部署与开发文档      项目要求：https://github. com/wechaty/summer-of-wechaty/issues/83   项目链接：https://github. com/ReiKohaku/piggy-bro开发方案:  任务要求基于 Wechaty 开发机器人，实现讲笑话、成语接龙、猜图片、猜歌名、查航班、查天气、微博爆款热搜提醒等功能；并设计Logo及形象；开发二师兄后花园。 实现方案利用 Wechaty 特性，实现一个简单的可扩展式脚手架，模块化实现各项功能。之后收集高可用API，实现要求的功能。后花园使用 Node. js + Vue 的开发模式，实现一个简单的小游戏。开发时间计划: 二师兄机器人开发（7月）:    开发可扩展式开发框架（7. 1-7. 7）      熟悉Wechaty开发模式   搭建二师兄开发脚手架      具体功能实现（7. 8-7. 30）      初步实现要求中的具体功能，可能包括且不限于：讲笑话、看热搜、查天气、成语接龙、猜图片、猜歌名   初步编写相关功能API的注册与部署文档   二师兄周边设计（8月）:  设计二师兄Logo及形象（8. 1-8. 7）     为二师兄的Logo和形象做出初步描述   Logo及形象定稿    开发二师兄后花园（8. 8-8. 30）     设计后花园游玩流程及各项数值   搭建二师兄后花园服务及页面   收尾工作（9月）:  编写文档与完善功能（9. 1-9. 30）     编写使用、部署及开发文档   整理代码并完善功能   其它:    联系方式：   微信：ReiKohakuE-mail：hbsjzjwj@163. com   Author: @ReiKohaku 关于暑期2021: “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。官网：https://summer. iscas. ac. cn/ 本项目 [基于 Wechaty 开发开源的二师兄社群逗乐机器人] 系 暑期2021 支持的开源项目。 "
    }, {
    "id": 89,
    "url": "https://wechaty.js.org/2021/07/13/ospp-plan-wechaty-itchat-puppet/",
    "title": "OSPP 2021-期初报告-基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet",
    "body": "2021/07/13 -  项目名称：基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet 导师：吴京京、李卓桓 学生：肖良玉 项目链接：https://github. com/lyleshaw/python-wechaty-puppet-itchat 项目介绍: https://github. com/wechaty/summer/issues/75详细方案:  L0阶段：     预期效果：熟悉 Itchat 的各项 API ；熟悉 Wechaty Puppet 的开发流程；创建python-wechaty-puppet-itchat的repository。   实施方案：阅读 Itchat 文档，了解 Wechaty Puppet。    L1阶段：     预期效果：完成python-wechaty-puppet-itchat 的登录与初始化部分的实现；完成 ding-dong-bot 的实现。   实施方案：了解 python-wechaty-puppet-service 是如何通过gRPC 与远程服务器通讯的，并结合 Itchat 的设计模式，对比二者异同，思考如何将 Itchat 的函数封装进 wechaty- puppet，思考 wechaty-puppet 的哪些代码对于该项目而言是不必要的，并完成对 Itchat 中 auto_login 函数的封装。在此基础上深入了解 Itchat msg_register 函数的实现方法，并在此基础上封装进 wechaty-puppet，同时完成发送消息函数的封装。同时参考其他 wechaty-puppet 完成 ding-dong-bot. py 并使其能正常运行。    L2阶段：     预期效果：配置 GitHub Action 实现 python-wechaty-puppet-itchat 自动发布到 Pypi 并完成自动化测试。   实施方案：了解 Pypi 的发布流程，并在参考已有GitHub Action 配置文件的基础上完成自动发布的流程，同时完成自动化测试。    L3阶段：     预期效果：使用 Itchat 的 API 为 python-wechaty-puppet-itchat 实现User 和 Room 部分的功能。   实施方案：在该阶段，我计划深入了解 Itchat 关于 User 部分的 get_contact 等函数的实现，封装为 Wechaty 的 User相关模块的功能。同时将 Itchat create_chatroom等函数封装为 Wechaty Room 模块的功能。    L4阶段：     预期效果：为 python-wechaty-puppet-itchat 实现Itchat 的其他功能。   实施方案：在该阶段，我计划将 Itchat 剩余的接口根据 Wechaty 的代码风格封装进 python-wechaty-puppet-itchat。    *L5阶段：     预期效果：完善 python-wechaty 文档。   实施方案：在了解 python-wechaty 的基础上，我计划在 python-wechaty 原有文档的基础上进行完善和补充。   项目开发时间计划: 第一阶段（7月-8月）:  L0阶段开发 5天 L1阶段开发 10天 L2阶段开发 20天 中期验收第二阶段（8月-10月）:  L3阶段开发 10天 L4阶段开发 15天 L5阶段开发 15天 结项验收 Author:@lyleshaw 关于暑期2021: “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。官网：https://summer. iscas. ac. cn/ 本项目 [基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet] 系 暑期2021 支持的开源项目。 "
    }, {
    "id": 90,
    "url": "https://wechaty.js.org/2021/07/11/ospp-plan-qq-puppet/",
    "title": "OSPP 2021-期初报告-开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块",
    "body": "2021/07/11 -  项目名称：开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块 导师：李佳芮、李卓桓 学生：anaivebird 模块列表     node. js qq protocol client implement(based on takayama-lily/oicq)   Puppeteer   puppet for qq wrapper   滑块登陆   设备信息存储    项目介绍：https://github. com/wechaty/summer-of-wechaty/issues/81详细方案:    任务要求使用 wechaty-puppet-mock 项目作为模版，参考社区其他的 Wechaty Puppet Provider 代码模块，对 QQ 进行规划、RPA选型、原型测试，和最终的代码封装。在初期开发中，能够实现文本消息的接收和发送，即可完成原型验证 POC 。     实现方案通过对Wechaty Puppet Provider和wechaty-puppet-mock项目等进行了解和学习，并对已有项目进行梳理，多和导师进行沟通，实现通过 Wechaty 加载 wechaty-puppet-qq模块，并包装oicq项目，实现文本消息的收发功能，提供一个 examples/ding-dong-bot. ts ，完成“接收到文字消息ding时，自动回复消息dong”等功能。  项目开发时间计划: 第一阶段（7月-8月）:    7. 1-7. 10先和导师沟通，并观看Wechaty Puppet Provider 的 workshop 视频，熟悉Wechaty Puppet Provider的业务流程，并对自己目前还没有掌握的nodejs、npm、typescript等内容进行快速的了解和学习，对时间安排做好具体的规划     7. 11-8. 15开始正式进行代码的prototyping，先完成基础的功能，完成通过 Wechaty 加载 wechaty-puppet-5g-qq 模块，并通过oicq项目实现的qq协议，实现文本消息的收发功能。每周协同导师进行功能的开发和完善  第二阶段（8月-10月）: 在现有基础上，滑动验证码登陆、设备锁、qq登陆风控等问题进行调研和排查    8. 16-9. 30继续完善功能，完成“接收到文字消息ding时，自动回复消息dong”的功能，不断总结和完善功能列表。     10. 1-10. 30如果还有功能模块未完成则继续优化代码，梳理项目，如果时间充足，可以尝试完成一下配置 GitHub Actions 实现自动化测试的任务。   Author:@anaivebird 暑期2021: “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。官网：https://summer. iscas. ac. cn/ 本项目 [开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块] 系 暑期2021 支持的开源项目。 "
    }, {
    "id": 91,
    "url": "https://wechaty.js.org/2021/07/10/google-season-of-docs-guide/",
    "title": "Google Season Of Docs (GSoD) Guide",
    "body": "2021/07/10 - Google Season of Docs is an annual program organized by Google. Here is the related blog:  Google Season of Docs ❤️ Wechaty, Written By Huan Hello Wechaty GSoD’21 Technical Writers!, Written By Huan GSoD’21 First Month Evaluation, Written By Rohitesh Kumar JainWe have some guide for GSoD like what we did in OSPP - a Chinese clone of Google’s summer of code. All of the tech writers involved in the project are required to complete their weekly work and phased work :  Weekly work     Every workday commit   Wechaty GSoD’21 Weekly Follow-Ups   Weekly Zoom Meeting    Phased work     Proposal blog   Mid-term blog   Final blog   Weekly Work: A volunteer will organize the weekly meeting and write meeting notes &amp; publish blog posts with zoom meeting recording videos on YouTube embedded. Here is the guideline for video-recording/downloading/uploading  Download the recording which has a shared screen along with the gallery view Crop the video at the beginning and the end of the meeting, the video should start to form the beginning of the meeting Add a beautiful thumbnail to the video Highlight the most important agenda of the video by adding timestamps like kick-off meeting recording Refer from: Google Season of Docs 2021 Team Proposal - Volunteering PR Reviewing &amp; Approving Workflow: For writers: Writers who are in the same team are REQUIRED to review each other’s PR, and give “Request changes” or “Approve”Writers are encouraged to give “Request changes”, “Approve”, or “Comment” to any PRs. (please contribute to the whole team by doing it!) For volunteers: Volunteers are REQUIRED to review all PRs created by writers and give “Request changes” or “Approve” Mentors are in charge of reviewing the PR after:  Volunteers create an issue list about the high priority PR PR passed all the CI tests (CLA &amp; unit testings) PR gets approved by all the project team members (if applicable, 0-1 approval) PR gets approved by all volunteers (2 approvals)Phased Work: The three blogs at the beginning, middle and the end should be committed to wechaty. js. org Repo. Before submitting the report, you can read the Wechaty community specifications and know wechaty better:  Introduction of Wechaty Community communication channels Meeting specifications Blog publishing specifications Issue release specification PR release specificationIt is important to note that the blog publishing specifications describe in detail how to submit a blog, how to embed a video in the blog, etc. , which will be used in the mid-term and final reports. The specific requirements for the three reports are as follows. Proposal Blog: All of the tech writers have already finished this part. Here is some specification, if you have time, you can modify the previous blog to make it more beautiful. 1. Personal Profile: Create your contributor profile (if you are a first-time contributor). You can commit to wechaty. js. org Repo’s jekyll/_contributors directory. You can refer to the following developer introduction content writing page:  Rohitesh Kumar Jain, Volunteers Team.  sajen sarvajith, Landing Page Team.  Soumi Bardhan, References Team.  Souvik Biswas, Tutorial Team. 2. Proposal report:  Title: GSoD 2021-Proposal-your_title File name: 2021-XX-XX-gsod-plan-XX Category: gsod Tag(at least include): google,gsod-2021,gsod,docs,plan Content at lease includes as follows:     Team Member   Proposal Video Presentation   Proposal Introduction   Roles and Responsibilities   Team Goal/Deliverables   Proposal Timeline    Google Season of Docs 2021 Team Proposal - Volunteering Google Season of Docs 2021 Team Proposal - TutorialsMid-term Blog: There will be a GSoD Mid-term Demo Day, volunteers can organize this Mid-term Demo Day on a regular weekly zoom meeting. Each writer in the same team should submit a mid-term blog together with the YouTube Midterm demo day video and a summary of the mid-term work. The video needs to be uploaded to youtube, and contact Huan to add it to the playlist of wechaty. Report template as follows:  Title: GSoD 2021-Mid-Term-your_title File name: 2021-XX-XX-gsod-mid-term-XX Category: gsod Tag(at least include): google,gsod-2021,gsod,docs,mid-term Content at lease includes as follows:     Proposal         Team Member     Description/Abstract     Timeline          Proposal Mid-term Video Presentation   Progress         Work Done     Problems encountered and solutions     Follow-up work arrangement          Final Blog: Each writer in the same team should submit a final blog together with the YouTube final video and a summary of the whole work. The video needs to be uploaded to youtube, and contact Huan to add it to the playlist of wechaty. The final Blog is to be written after most of PRs get merged, volunteers will announce the time to write a final blog when it is ready. Report template as follows:  Title: GSoD 2021-Final-your_title File name: 2021-XX-XX-gsod-final-XX Category: gsod Tag(at least include): google,gsod-2021,gsod,docs,final Content at lease includes as follows:     Proposal         Team Member     Description/Abstract     Timeline          Outcome         Links to the added documentation     Proposal Final Video Presentation     Problems encountered and solutions          Voluteer Assessment   Submit Expense: As GSoD Payment Intro showed:  Organizations will receive 40% of the grant after hiring a technical writer. Organizations will receive invitations to submit their first expense starting June 10, 2021.  Organizations will receive the remaining 60% of the grant after successful completion of the Season of Docs program. Organizations will receive invitations to submit their final expense starting December 14, 2021. So for all of the tech writers in Wechaty:  Get the first 40% of the base stipend after submitting the mid-term blog and reviewed by volunteers and mentors.  Get the remaining stipends after they submitting the final-term blog and reviewed by volunteers and mentors. Tech writers can submit expenses on Wechaty-GSod-Opencollective, see more at Opencollective docs about expenses and getting paid Performance: To Be Added in the future. After GSod: After the GSoD’21, tech writers should publish a blog post talking about the whole project of GSoD’21 Wechaty from your perspective "
    }, {
    "id": 92,
    "url": "https://wechaty.js.org/2021/07/07/wechaty-with-paddlepaddle/",
    "title": "AI Chatbot Competition -- Metaverse启动机之重构现世！",
    "body": "2021/07/07 - 硬核ML Chatbot 大赛重磅来袭!由Wechaty、PaddlePaddle和Mixlab联合主办，未来事务管理局作为媒体支持的「AI创造营 ：Metaverse启动机之重构现世」ML Chatbot 大赛正式启动！ Metaverse元宇宙的奥秘，等你来揭晓！我们向所有科幻爱好者发出邀约！期待“你”充分开发自己的脑洞，借助飞桨PaddlePaddle技术，构建未来世界的超级Chatbot。 🌟 惊喜奖品大揭秘!🌟: ✨ 更多比赛福利!✨:  报名即送GPU算力+wechaty token 由PadLocal-Wechaty puppet service provider提供 优秀项目官方送你出道 Paddle &amp; Wechaty工程师1对1指导 PPDE(飞桨开发者技术专家)绿色通道 扫码报名，马上获取比赛福利! 往期作品回顾「AI创造营」:  AI创造营是百度大脑AI Studio平台举办的系列创意赛，目前已成功举办两期，涌现出许多好玩有趣的AI创意项目，精彩内容请往下看！ 《新一代超能力：隔空取物》当前累计star数 248+。有了Paddle Paddle技术的加持，偶像爱豆的照片统统可以“贴”在电脑桌面上，陪你看剧听歌工作。 《未来流浪者》已累计近200 star，是一个基于PaddleHub、Wechaty与彩云小梦的科幻机器人，可以实现未来旅行者跟人类的互动，即时发送位置、照片和游记等。 《BotBay专属机器人小助手》是以生物多样性为命题的机器人赋能平台，采用一入口(微信)，一平台(botPlatform)，多支撑(PaddleWorkers)的模式进行设计与开发，借比赛实现自己的科幻梦想。 《熊猫头表情生成器》是一个可以生成个人专属熊猫头表情包的聊天机器人，个性化聊天内容由你来掌控。! 创意赛直播讲解: 7月13日19:00-20:00，锁定飞桨直播间，飞桨模型教学&amp;Wechaty使用说明&amp;创意思路引导，统统满足你！无论是刚入门人工智能的初阶选手、还是没接触过Wechaty的小白用户都可以大胆参赛！直播最后还有互动交流环节，讲师现场答疑解惑。 线下脑暴创意大比拼:  7月18日：上海场线下脑暴会 7月25日：北京场线下脑暴会现场名额有限，赶快入群获取报名链接吧！ "
    }, {
    "id": 93,
    "url": "https://wechaty.js.org/2021/07/06/gsod-2021-fifth-meeting/",
    "title": "GSoD'21 Fifth Meeting",
    "body": "2021/07/06 - Google Season of Docs’21 fifth meeting: Meeting Summary: It was the fifth meeting of the GSoD’21 participants. Firstly every participant gave one’s weekly summary and informed the community about their plans for the upcoming week, volunteers and tech writers discussed while tech writers were giving their week summaries. Later Simin shared some information regarding the Wechaty follow-ups, and at last, we took a lovely group photo. {% include iframe. html src=”https://youtu. be/WtHPGXxHb5M” %} Attendees: Total 12 attendees attended the meeting. They are:  Rohitesh Jain, Volunteer (UTC + 5:30) Sajen Sarvajith, Reconstruct Landing page writer (UTC + 5:30) Abhishek Jaiswal, How-to-guide section writer (UTC + 05:30) Simin Liao, Volunteer (+8:00) Mukosa Joseph Mawa, Introductions and Explanations section writer (UTC +03:00) Rajiv Ranjan Singh, Improve the gRPC and OpenAPI ecosystem writer, rajivperfect007@gmail. com, (UTC+05:30) Souvik Biswas, Create easy to learn tutorials for beginner users writer, sbis1999@gmail. com (UTC +05:30) Shraddha, Improve References section writer (UTC + 5:30) Shwetal Soni, Create easy to learn tutorials for beginners users writer (UTC +05:30) Vasvi Sood, How to guides, contactvasvisood@gmail. com writer (UTC + 5:30) Arnab Saha, Reconstruction of Landing page with value propositions writer (UTC + 5:30) Chris Estepa, Introduction and Explanations sections writer (UTC +08:00)Note: Meeting Started 15 mins late, as there was some issue at my end. Shwetal missed the first half of the meeting. Soumi wasn’t able to attend the meet due to her other engagements.  Agendas:  00:00 0. Introduction &amp; Welcome 01:23 1. Discussion with Tutorials team 03:30 2. Discussion with Introduction and explanation team 06:25 3. Discussion with Landing page team 08:00 4. Discussion with References section team 08:55 5. Discussion with How to guides team 10:55 6. Discussion with gRPC team 16:07 7. Info about Wechaty Weekly Follow-upsYou can learn more from our meeting notes. Meeting Outcomes:  The community got to know about the progress and plans of the members Order for merging the tutorials PR got discussed An extra week is added in the How to guides timeline It has been notified to the gRPC team to not change timelines without noticing in the organizationMeeting Follow-ups:  Merge PRs for the tutorials team Address questions of the Landing page team, regarding the landing page Provide Shraddha more information regarding the Wechaty plugin Log in to Wechaty weekly follow-ups via the new link sent by SiminMeeting Comments:  (Joseph) I will be reaching out to the other teams for more info about challenges they faced so that we add them to troubleshooting sub-section of the explanation"
    }, {
    "id": 94,
    "url": "https://wechaty.js.org/2021/07/05/puppet-laozhang-wechat-bot/",
    "title": "喜讯：使用Windows微信桌面版协议登录，wechaty免费版协议即将登场",
    "body": "2021/07/05 - 继”wechaty免费版web协议重放荣光“之后，很高兴向大家预告Wechaty免费版Windows协议即将与大家见面，如果之前苦于web协议不能获取准确的wxid、roomid等问题，那么这个更新将会解决你的困扰。 wechaty社区即将迎来一个全新的puppet——wechaty-puppet-laozhang（老张牌puppet，或许后续会更新一个不这么响亮的名字），将支持使用Windows微信桌面版协议登录。 关于wechaty-puppet-laozhang: 该puppet来源另一个开源chatbot项目wechat-bot，由低调的个人开发者老张操刀。与wechaty项目的初衷一样，chatbot为开发者提供开源免费的chatbot工具，并且已累计600+start、190+fork。 wechat-bot能够让开发者在Windows机器上使用微信官方客户端登陆微信，然后使用dll注入方式，获取客户端HOOK，进而开放出websocket和HTTP接口，供业务程序外部调用，在本地接收和发送微信消息。 wechat-bot已开放的常用功能接口: 发送(websocket&amp;http):  客户端发送好友文本消息（支持websocket和HTTP） 客户端获取通讯录好友wxid和名字(支持websocket和HTTP) 客户端发送图片给好友（支持websocket和HTTP） 发送AT消息（支持websocket和HTTP） 发送附件（仅支持HTTP,weboscket) 获取chatroom成员列表(wxid)和昵称（支持websocket和HTTP）接收（websocket）:  文本接收 图片接收（不解密不保存，解密异或即可） 引用消息接收 公众号消息接收 好友请求消息接收客户端支持: Jave、Python、Nodejs、C#、易语言，5种语言的10个客户端可供选用  UoUoio 贡献java客户端 MickeyMi 贡献JAVA客户端 ToBin 共享JAVA客户端 诺阳 贡献C#客户端 昆明-C#-SakuraYuki 贡献C#客户端 Yangself666 贡献java客户端 tsingly 贡献python客户端 qq64161848 贡献易语言客户端 ttc 贡献python客户端 老张亲自贡献的 nodejs客户端wechat-bot与wechaty的优势互补: wechaty提供了一套标准的chatbot接口规范和工具，6行代码实现一个微信机器人，易用、标准。但wechaty项目本身不提供Puppet Services，而是需要Puppet Providers来提供。使用wechaty的第一步——”如何获取token“是开发者经常问到的问题，这在很大程度上阻止了开发者能够快速体验。 而目前唯一免费的web协议wechaty-puppet-wechat，由于协议自身的限制，在获取wxid、roomid存在天然缺陷。 现在两者的结合即将很好的解决上述问题，与wechaty-puppet-wechat类似，wechaty-puppet-laozhang提供一种免token的本地运行puppet，任何Windows用户可以在本地运行puppet获得与web协议同样的免费体验，同时获得与其他Puppet Services同等的接口能力。 什么时间开放: phase1：Q3提供本地化wechaty-puppet-laozhang，wechat-bot项目已开放功能接口全面适配集成到wechaty，开发者可以在本地使用Windows协议体验几乎与收费版Puppet Services同等的接口 phase2：Q4丰富wechaty-puppet-laozhang功能接口，同时准备提供一个商业化的Windows协议Puppet Service 在此之前，开发者依然可以到wechat-bot项目体验目前最好且免费的本地化chatbot。 关于老张: 最后也隆重的向大家介绍wechat-bot项目的作者——老张，微信昵称”老张学技术“，同名微信公众号”老张学技术“，低调、严谨的诗人、业余编程爱好者。 认识老张:  老张的wechat-bot开源项目 历史文章  Wechaty+微信小程序实现群内活动报名 入门：小白如何在wechaty社区发布自己的第一篇博客（一）"
    }, {
    "id": 95,
    "url": "https://wechaty.js.org/2021/07/05/code-like-poetry-bot-like-song/",
    "title": "code如诗，bot如歌，由Wechaty引发的一个小白冒险之旅",
    "body": "2021/07/05 - 非关: 短，分行，如诗。这个世界，除了我喜欢的汉字的堆叠，竟然还有这样美妙的存在。不是偶然。是生命中的不期而遇。更是一世的欣喜！所以，偶有闲暇，我就会拾起手指，在短、分行中，感受内心的律动。当然，我本闲散人，怎会成极客？高山仰止，心向往之，于惴惴中前行，算是对自己的一种安慰。 慢，曲达，如歌。历程不重要。代码不重要。当第一次跑出想要的结果，我拍击的桌面，响彻了……这是无数种我听到的声音中，最动人的，最悦耳的，虽然无人传唱，却在我心回荡！这是那个叫bot的家伙，经由我的指节，它偶尔会破嗓，也偶尔会悠扬…… 缘起: 见过凌晨四点的北京…. . 见过凌晨五点的成都…. . 这是凡尔赛的笔法，据说。我经常必须见，回头见，不见还不散，请问，这是什么赛? 觉悟要高，执行要透。客户经常这样对我说。我默然。然后开始去思考，什么样的觉悟才是高觉悟，什么样的执行才是透了的？ bot这个家伙的萌芽，来自于连续几个通宵之后，和客户在“亲切友好”的气氛中，灵感就这么砰的一声，迸发了出来。客户拍着我的肩膀说，老张，你TMD能不能没事不要骚扰我，我连续好久接你半夜电话，都快成客服了。我说，我TMD可以不骚扰你，你说吧，什么时候可以骚扰。客户的脸笑成朵花，这是我看到的最美的花朵之一。我们一生中，有些花，开的真的很美。 信息的搜集，优先级的排序，时间的设定，发送的机制。在一轮一轮中，终于敲定了方案。客户再次笑了，嗯，觉悟还是够的，赶紧上。 然后真的在友好的氛围中，开始了后面的历程。 历程: 一: 我对度娘没什么好感，相较google而言。但是我最终还是从了度娘，她毕竟，也能给我一些，我想要的温柔，此处应该有掌声兼括号（不要想多了）。github也经常慢如蜗牛。有时候，你得忍，小不忍，则乱大谋。我认，我忍。我就在度娘和github之间不断切换，穷尽了：微信 机器人 wx机器人 微信bot wechat机器人 ……然后把眼睛睁大，注意力集中，在我熟悉的汉字里，我竟然一无所获……那是2017年的8月。 功夫不负舔狗人。舔的时间久了，上天或许会看在你无脑且勤奋的份上，不经意的给你一个惊喜（当然，舔狗始终是舔狗，舔狗要不忘初心）。凭着我蹩脚的英语，和舔狗的执着，我终于发现了：Wechaty! 我印象最深刻的一句话是：五行代码就可以写一个微信机器人（据说是六行，我一直的印象是五行，我天生喜五，看我账号就知道，哈哈）。你们懂的！那种欣喜若狂！你们不懂吗？那种欣喜若狂!反正我懂就可以了！此处有敲击桌子的重响，请不要模仿，以免你的老婆给你来个更重的狮子吼！ 坦率讲，看到扑面而来一屏英文的时候，当时的内心，其实想骂：这TMD全是英文啊？！（TMD是汉字，但不要曲解，意思是：挺萌的）。然后就买了一个腾讯的vps（这又是另外的一种洁癖，我因为微信的原因，喜欢上了腾讯的种种，除了游戏，然后对阿里的各种弃之一隅）。然后各种度娘，各种环境、代码报错。TMD。对，挺萌的。Wechaty这个东东，上报一个问题的规矩居然这么复杂，我把fanyi. baidu. com都折腾烂了，才按照要求，把报错信息提了上去。那是26 Aug 2017，为什么这么清晰，因为我从已经close掉的issue里面，拷贝出来的。然后等待大神的…… 然后终于代码跑通了。机器人发出的第一个信息：Hello World!你好，老张！ 二: 客户和我开始了一段非常甜蜜的时光（大家脑洞不能大开，正经点）。但是，这种友好而亲切的氛围，被两个问题打破：这样白嫖开源，真的好吗？网络安全问题（数据在内网），要关闭向腾讯VPS传递数据的端口。 第一个问题还好，先白嫖吧，大家不都这么干的？所以第一个问题，还是白嫖大法好，至于未来的事情，仿佛可以不管。第二个问题就无解了，只有拖字诀。然后拖无可拖的时候，客户一脸遗憾的告诉我，我们要有觉悟，该关的必须关，该执行透的，一定要不遗余力，执行透彻。2017的农历春节，我们执行透彻，关掉了基于Wechaty，运行得相当开心的微信机器人。遗憾有之，失落更甚！ 然后我利用业余时间，开始学习微信bot相关的一些知识。时间很快就来到了2019。疫情的爆发，忽然就改变了很多：世界的轨迹，生活的轨迹。这些，悉数被纳入新的运转规则里面。在闭关对抗疫情的期间，我开始想，我能不能自己做一个bot？ 或许我从来不曾想过，这样的想法究竟有多冒险？无知者无畏，与其说是对小白的褒奖，不如说是小白的真实写照。自此以后，我一直对这个世界上无数和我一样的小白，保持着崇高的敬意。原因无它，我就是这样的小白，我们需要这样前仆后继的小白（阴险的笑）。 冒险之旅开启。除了无知的勇气外，我竟然面对的是：一入BOT深似海，再回眸时秃顶生。我开始折腾，度娘、github、新发现的B站、翻墙去google。然后，逐渐的，有一些东西，开始有了最初的模样。那模样，至今我一直难忘。 曲达: 开始的版本抄了不少代码，且学之甚浅，以至于一直不敢让这些代码面世。但依然得到了不少的关注。于是在边学，边折腾中，开始了代码的重构。也终于鼓起勇气，把这些代码，放到了github上。于我而言，仍旧对当时的勇气，莫名感怀。 时至今日，势仍曲，事未达，行慢而路遥，仅堪堪迈出小小的一步。行道如水，莫过于斯。而于前行中有关bot的每一种声音，都清晰而嘹亮，如歌洋洋，历久不息。旅程仍长，冒险还在，但心境竟然如常！ 致谢: 致所有无私的人们！这个世界的真神，应该是你们！致所有坚持的人们！你们前行不倦的身影，是最好的明灯！  作者: cixingguangming55555，老张学技术 "
    }, {
    "id": 96,
    "url": "https://wechaty.js.org/2021/07/02/how-to-publish-blog-on-wechaty/",
    "title": "零基础小白在Wechaty社区发表自己的第一篇博客",
    "body": "2021/07/02 - 很开心过去10天里面接触了wechaty社区，两次使用GitHub向wechaty社区提交了博客（虽然提交了很多次才最终通过），但也因此对于书写博客时出现的问题比较了解，对许多问题记忆犹新。今天就和大家分享一下我自己的经验，零基础或有那么一丢丢基础的小白如何在wechaty社区发布自己的第一篇博客。 今天和大家分享一下两个内容：    在wechaty发布博客的准备工作     写完博客后的完善工作  在wechaty发布博客的准备工作: 初学者在有了向wechaty发布博客的想法之后，很快会发现它在用一种「很技术的方式」而非传统的博客方式进行发布。技术到什么程度呢？你需要先进行以下步骤：  注册GitHub 安装vs code 安装git 安装GitHub Desktop 这里我还要推荐一篇对我很有帮助的博客：入门：小白如何在wechaty社区发布自己的第一篇博客说明：  首先阅读博客入门：小白如何在wechaty社区发布自己的第一篇博客，一定要认真阅读，并且按照里面的步骤做，刚开始我就是落下了几步后面出现饿很多错误，修改起来很麻烦。 用markdown书写博客：一个简单的编程语言，基本语法，可以学习一下。 还可以在GitHub Desktop里面建立不同的分支，方便后面把不同的博客上传到不同的分支里面。写完博客后的完善工作: 继续，以我自己的经验（可能因为是刚刚开始接触），修改错误和排版可能比写文章本身更耗费精力。 总共几步:    打开终端   写完博客之后在本地进行本地测试，在本地排查一下错误，首先打开终端,如图       本地测试运行   切换到博客目录，通过 git checkout XXX 切换不同的分支（XXX：是你的分支名字），通过npm run test来运行。之后可能会出现这种情况：       删除所有. DS_Store的文件   mac会出现讨厌的带有. DS_Store的文件，我们需要删除它。 方法：写入 “rm -rf XXX” 的命令(XXX：要删除的文件)。例如，在我的分支里面运行npm run test之后出现了图中这样的情况，写着OK的不用看，写着not ok的可以按照他写的错误进行修改，第一次看到这么多密密麻麻的错误我很害怕，但是你读一读就知道都是最基础的英文，描述也比较清楚详细。 如果这个方法无效的话，可是尝试命令：sudo find / -name “. DS_Store” -depth -exec rm {} \;       上传到自己的分支   方法如图，按照顺序点击               签署CLA   很多开源社区，都会要求贡献者签署CLA，只有签署了CLA的贡献者提供的内容才能被接受。从开源社区角度看，如果没签署CLA，会有风险。       等待审核   等待@wechaty的管理员审核，不久管理员就会邮件通知你结果       修改   还是在这里查看     这里，找到自己刚刚上传的，可能会出现这种情况（一般本地测试过之后，不会再出现这种情况了）     还是按照他写的去修改就好     在你认为一切都改好以后，可以再本地测试一下，再上传PR（pull request）。再等待管理员审核，一切成功之后，就可以看到自己写的博客发布在wechaty了。     上传到云端，发布博客   大功告成！     本地预览   当然我们发表了PR之后，我们就是contributor了，之后我们就可以在本地运行Jekyll来预览博客。 本地写好了代码以后提交到github上，运行: ssh -L 4000:127. 0. 0. 1:4000 gangena@dev. chatie. io 如果需要输入密码，输入本机密码就可以了。进入到服务器里面，输入：cd wechaty. js. org/jekyll 切换到你的分支: git checkout XXXX 拉代码: git pull 运行： make serve 当看到命令行中出现 Server address:http://127. 0. 0. 1:4000的时候，在浏览器中输入地址http://127. 0. 0. 1:4000即可     等待CI都变绿   也就是test&amp;build,他能够能够帮你完成工作的功能，测试你的代码是否有问题；如果有错误，会出现红色的叉，并提示你哪里出错，只需要根据他的提示更改代码，再提交，重复上面的步骤，知道变成绿色对勾就好啦。   作者: juzibot，句子互动 "
    }, {
    "id": 97,
    "url": "https://wechaty.js.org/2021/06/24/wechaty-soc-kick-off-meeting/",
    "title": "Wechaty Open Source Promotion Plan 2021 Kickoff Meeting",
    "body": "2021/06/24 - “开源软件供应链点亮计划-暑期2021”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。 官网：https://summer. iscas. ac. cn 往期回顾：https://wechaty. js. org/2020/07/20/wechaty-soc-kick-off-meeting Wechaty 与暑期2021: Wechaty 作为中国最大的聊天机器人开源项目，与其他数十个中国顶级开源项目一起参与“暑期2021”。Wechaty 合计发布了10个项目，共收到来自上海大学、华东理工大学、长沙理工大学、中国科学技术大学、电子科技大学等高校的几十份申请。此次 Wechaty 从多平台、多功能等多个维度发布了10个项目。发布的11个项目，来自Wechaty社区的导师将和来自高校的学生开发者们一起，在三个月的时间里完成对应的开源项目。 Wechaty 项目列表: Wechaty 在多平台、多功能多个维度上，共发布了 10项任务，并通过 issue 的方式进行每周的更新。全部项目在wechaty/summer-of-code#79中进行汇总。如果你有看到感兴趣的项目，可以直接在对应 issue 下面找到负责对应任务的开发者。 基于开放API封装 Wechaty 接口下的飞书聊天机器人 https://github. com/wechaty/summer-of-wechaty/issues/38:  导师： 范蕊 飞书Puppet作者 （froxanne1024@gmail. com） 学生开发者：梁浩彬，华南农业大学本科生（xilou31@gmail. com）；马田慧（tianhuima01@gmail. com）；许欣瑜（3378374880@qq. com）；张凯（840854995@qq. com）基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善 https://github. com/wechaty/summer-of-wechaty/issues/59:  导师：yswtrue Wechaty contributor （yswtrue@gmail. com），李卓桓 Creator of Wechaty，Tencent TVP of Chatbot （zixia@zixia. net） 学生开发者：林宇靖, 上海海洋大学本科生（545641826@qq. com）；张瑞宁, 长沙理工大学本科生（3134191406@qq. com）开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块 https://github. com/wechaty/summer-of-wechaty/issues/74:  导师：康嘉 硬核桃社区PM （sj-kangj@dimpt. com）；李佳芮 Wechaty co-creator，Founder &amp; CEO of Juzi. BOT （rui@chatie. io） 学生开发者：张瑞宁，长沙理工大学本科生（3134191406@qq. com）基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet https://github. com/wechaty/summer-of-wechaty/issues/75:  导师：吴京京 Python Wechaty creator，Wechaty committer （wjmcater@gmail. com）；李卓桓 Wechaty creator，Python Wechaty maintainer，Tencent TVP of Chatbot （zixia@zixia. net） 学生开发者：肖良玉，杭州电子科技大学本科生（x@lyleshaw. com）开发基于 Wechaty 实现微俱乐部会员&amp;活动管理的微信小程序 https://github. com/wechaty/summer-of-wechaty/issues/78:  导师：鲁玉超 物联网行业产品经、微信小程序群组大师开发者 （atorber@163. com） 学生开发者：陈婧，华东理工大学本科生（1017137803@qq. com）基与 Blessed 的 Wechaty 命令行文本客户端软件（仿IRC） https://github. com/wechaty/summer-of-wechaty/issues/80:  导师：李卓桓 Creator of Wechaty，Tencent TVP of Chatbot （zixia@zixia. net） 学生开发者：刘靖，上海大学本科生（liuchinggg@gmail. com）开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块 https://github. com/wechaty/summer-of-wechaty/issues/81:  导师：李佳芮 Wechaty co-creator，Founder &amp; CEO of Juzi. BOT （rui@chatie. io）；李卓桓 Creator of Wechaty，Tencent TVP of Chatbot （zixia@zixia. net） 学生开发者：胡星武（huxingwu@gmail. com）基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善 https://github. com/wechaty/summer-of-wechaty/issues/82:  导师：吴京京 Python Wechaty creator，Wechaty committer （wjmcater@gmail. com） 学生开发者：左雁茹，中国科学技术大学研究生（zuoyanru@mail. ustc. edu. cn）基于Wechaty 开发开源的二师兄社群逗乐机器人 https://github. com/wechaty/summer-of-wechaty/issues/83:  导师：王玉丹 Wechaty Contributor，AI Chatbot Wechaty x PaddleHub UP主，Wechaty社区大使 （huangaszaq@gmail. com）；鲁玉超 物联网行业产品经、微信小程序群组大师开发者 （atorber@163. com）；韩磊 百度飞桨PPDE，飞桨上海领航团团长 （iregisteru@163. com） 学生开发者：肖诗诗，电子科技大学本科生（me@mrxiao. net）SoC破冰会会议纪实: {% include iframe. html src=”https://www. youtube. com/watch?v=ZcVRxXA5OWc” %}  0:08:39 李卓桓 0:10:07 康嘉 0:13:09 李佳芮 0:14:46 吴京京 0:16:17 鲁玉超 0:17:56 王玉丹 0:19:23 韩磊 0:20:46 肖诗诗 0:21:55 肖良玉 0:23:02 左雁茹 0:24:12 陈婧 0:25:23 沈晨 0:27:41 张瑞宁 0:28:43 刘靖 0:30:03 梁浩彬 0:31:28 林宇靖 1:03:14 刘志辉暑期2021 开发计划: 此次暑期2021活动中，开发者分别需要在Wechaty社区内完成例行交付、向组委会提供两个节点的代码并完成答辩，其所有成果均会以开源的形式向社区开放。 Wechaty 社区交付内容:  每周例行更新：在即日起的每周日前（首次更新最晚时间为7. 18号），学生开发者会在 Wechaty SoC Issues 中，按照下文模板更新每周进度；如果在当周有明确的新进展和学习收获，学生开发者也会以博客形式在 wechaty/wechaty. js. org 中分享。 Plan Blog：学生开发者们会在7. 18号前以博客形式在wechaty/wechaty. js. org进行分享，内容包括：排期规划、对应项目Repo、联系方式等，同时也作为每周进展在例行更新中同步。除blog之外，学生还应另外提供投影片以及视频演讲内容。 POC Blog：学生开发者们会在8. 30号前以博客形式在wechaty/wechaty. js. org进行分享，内容包括：完成的项目核心攻关、后续需要的支持和新的开发排期，同时也作为每周进展在例行更新中同步。除blog之外，学生还应另外提供投影片以及视频演讲内容。 Finished Blog：学生开发者们会在9. 30号前以博客形式在wechaty/wechaty. js. org进行分享，内容包括：完整的项目情况和实现的功能、后续长期的开发展望，同时也作为最后一次每周进展在例行更新中同步。除blog之外，学生还应另外提供投影片以及视频演讲内容。暑期2021组委会交付内容:  中期审核：学生开发者们会在8. 30号前参与完成中期审核工作，届时相关代码链接也会随之呈现。 完整项目提交和汇报：学生开发者们会在9. 30号前完成，届时项目完整代码会向社区开放。欢迎正在阅读的你参与其中: 虽然“暑期2021”的报名已经结束，但Wechaty社区依然欢迎正在阅读本篇内容的你参与到暑期2021的工作中来。以下是几种可能的参与方式：  时刻跟进Wechaty SoC项目的每周例行更新 Issue，并直接与相关负责导师和学生开发者取得联系，和他们交流相关进展。 在 Wechaty 开发者群内，为学生开发者们的Plan Blog、POC Blog和Finished Blog点赞和提出想法。 直接参与已经完成部分工作的项目开发，为学生开发者们负责的复杂项目添砖加瓦。 作者: ninetailskim "
    }, {
    "id": 98,
    "url": "https://wechaty.js.org/2021/06/24/summer-wechaty-guide/",
    "title": "OSPP（开源之夏）指导手册 - 2021",
    "body": "2021/06/24 - 开源软件供应链点亮计划-暑期 2021 的见面会在 ninetailskim的主持下圆满完成，关于开源软件供应链点亮计划的详细内容，详见 Wechaty Summer of Code 2021 Kickoff Meeting 开源软件供应链点亮计划组委会活动里程碑: 注：所有通过结项考核的同学都会收到对应项目的全额奖金，项目是否评为优秀不影响奖金的发放。 组委会官方指南:  学生参与的日程，详见 学生指南 社区导师参与的日程，详见 导师指南 社区参与的日程，详见 社区指南Wechaty 社区工作: Wechaty 的项目 Issue 作为本次同学和导师通知的主要渠道，请所有同学在入选后，务必完成第一件事：在项目清单 Issue 下面，把所有同学和导师需要完成的工作，以 checklist 的形式回复到 Issue 下面，方便后续同学和导师完成相关工作，完成后在 Comment 中打钩确认 Wechaty 社区秉持开源开放的的原则，所有会议记录、在线会议、阶段性报告等视频、文档资料都会对社区完全开放。对自己的视频、文档资料介意开放的同学，请谨慎考虑加入。 参与项目的同学和导师需要分别完成 日常工作 和 阶段性工作：  日常工作     学生每周在 issue 下回复进度报告   导师每周在 issue 下根据学生的进度报告进行评分    阶段性工作     2021. 7. 15 期初报告   2021. 8. 28 期中 Demo Day   2021. 8. 30 期中报告   2021. 9. 30 期末报告   以下是具体的要求、模板以及过往学生的内容参考 日常工作: 日常工作以 OSPP 2020 的优秀学生突出贡献奖获得者江姗姗的周报告和导师总结为例，详见编写一个“每日一句”插件 报告模板: # [项目名称] 进度报告日期：XXXX-XX-XX## 本周完成的成果1. XX 1. XX## 本周遇到的困难和需要配合的地方1. XX## 下周的开发计划和预计成果1. XX## 其他需要说明和同步的事项1. XX导师评分模板: # [项目名称] 导师评分日期：XXXX-XX-XX## 本周进度报告的评分- [ ] 1: Deliverable not acceptable- [ ] 2: Deliverable is below expectations- [ ] 3: Deliverable is OK- [ ] 4: Deliverable is above expectations- [ ] 5: Deliverable is perfect## 其他需要说明和同步的事项XXX阶段性工作: 期初、期中和期末三篇报告要以博客的方式提交到[ wechaty. js. org Repo ]中，在提交报告之前，可以先阅读 Wechaty 社区规范, 至少了解下面内容：  Wechaty 的介绍 社区沟通渠道 会议规范 博客发布规范 Issue 发布规范 PR 发布规范尤其要注意的是在博客发布规范中详细的介绍了如何提交博客、如何在博客中嵌入视频等，在期中、期末报告中会用到。具体三篇报告的要求如下。 期初报告: 学生开发者1. 个人介绍请将自己的介绍以 markdown 的方式提交到 wechaty. js. org Repo 的 jekyll/_contributors 目录下。 可以参考以下的开发者介绍内容编写页：  吴京京, wj-mcat, Creator of python-wechaty 江姗姗, univerone, OSPP 2020的优秀学生突出贡献奖获得者2. 期初报告 标题： OSPP 2021-期初报告-你的标题 文件名： 2021-XX-XX-ospp-plan-XX 报告 category 为：project, ospp 报告 tag 至少包括：summer-of-wechaty,summer-2021,ospp,ospp-2021,plan 报告内容至少包括：     项目名称   合作者介绍   导师   项目介绍   项目计划   提交PR时请注意：为这个 PR 打上 ospp 的标签，并在 PR 中填写自己项目的 GitHub Issue 链接，方便组委会进行审核。 3. OSPP 2020 学生期初报告参考： 暑期2020 为 go-wechaty 设计实现插件体系 计划书 基于python-wechaty的群聊助手机器人 基于开放 API 封装 Wechaty 接口下的飞书聊天机器人：期初 基于Python-wechaty建立一个斗图机器人 暑期2020 编写一个“每日一句”插件 计划书 暑期2020[基于 RPA 封装 Wechaty 接口下的快手聊天机器人]计划书 基于RPA封装的Wechaty接口下的抖音聊天机器人 暑期2020 基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人 计划书 暑期2020 Go-wechaty Github Action optimization 计划书 Wechaty Java 移植组件开发 基于开放 API 封装 Wechaty 接口下的钉钉聊天机器人 具体计划社区导师按照社区博客提交规范，对学生提交的博客进行审核，审核通过后，在 GitHub Approve 这个 PR，然后交由 Wechaty PMC 进行博客审核。注意，社区导师一定要提前、优先 Approve 自己同学的 PR。 期中报告: 期中报告提交之前会有一个 OSPP 的 Mid-term Demo Day， 导师和学生会在线上进行期中汇报。提交的期中报告包括 Mid-term Demo Day 的视频和期中报告内容总结。点击这里查看暑期2020中期路演日（Mid-Term Demo Day）会议实况 学生开发者1. 期中 Demo Day 视频每位开发者需要进行中期的展示，视频将添加至博客、提交到组委会中，并剪辑成完成的路演日视频，向全社区展示，吸引更多的开发者参与到对应的项目中：  提交3-5分钟的、有真人出镜（视频会议软件录制）的、基于PPT的展示。 提交不限时长的、有真人出镜（视频会议软件录制）的 Live Code。学生要在8月26日之前将视频链接回复在对应项目的 Github Issue 下面进行提交，视频由同学们直接上传到Youtube / B站中，并直接将视频的链接和将视频以iframe方式附在各个博客中：  视频需要上传到 youtube 中，并联系 Huan 添加到 wechaty 的 playlist 中。 考虑到国内用户，可以上传到 bilibili 或者腾讯视频中可以参考去年优秀学生突出贡献奖获得者江姗姗的视频：  期中汇报视频 Live Coding 视频2. 期中报告在8月30日前，以Pull Requests形式在wechaty. js. org Repo中提交博客。  标题： OSPP 2021-期中报告-你的标题 文件名： 2021-XX-XX-ospp-mid-term-XX 报告 category 为：project, ospp 报告 tag 至少包括：summer-of-wechaty,summer-2021,ospp,ospp-2021,mid-term，ospp 报告内容至少包括：     项目信息         项目名称     方案描述     时间规划          项目进度         已完成工作     遇到的问题及解决方案     后续工作安排          项目成果         期中汇报的视频，可以参考 使用jekyll include在wechaty博客中快速插入视频     Live Coding/Demo 视频          提交PR时请注意：为这个 PR 打上 ospp 的标签，并在 PR 中填写自己项目的 GitHub Issue 链接，方便组委会进行审核。 可以完整复制本文对应的Markdown作为博客内容模板，但也可添加更多的补充信息。 “[开源软件供应链点亮计划-暑期2021](https://summer. iscas. ac. cn)”（以下简称 暑期2021）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。活动联合各大开源社区，针对重要开源软件的开发与维护提供项目，并向全球高校学生开放报名。 学生可自主选择感兴趣的项目进行申请，并在中选后获得该软件资深维护者（社区导师）亲自指导的机会。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2021”活动奖金和奖杯。本项目 [项目名称] 系 暑期2021 支持的开源项目。## [项目名称]信息- 导师：[导师名称] - 学生：[学生名称] - 项目介绍：[Github Issue 链接，如 https://github. com/wechaty/summer/issues/74] - 项目名称： - 方案描述： - 时间规划： ## 项目进度- 已完成工作：  *根据原定方案和时间规划，描述当前已有的工作成果* - 遇到的问题及解决方案：   *可以侧重描述总结与心得* - 后续工作安排：  *描述是否需要调整工作计划等* ## 项目成果项目仓库: &lt;https://github. com/XX/XX&gt; ### live coding视频:{% raw %} {% include iframe. html src= 视频链接  %}{% endraw %}### PPT展示视频:{% raw %}{% include iframe. html src= 视频链接  %}{% endraw %}### 项目PPT:{% raw %}{% include iframe. html src= pdf链接  %}{% endraw %}## 联系我们- 项目链接：[Github Issue 链接，如 https://github. com/wechaty/summer/issues/74] - 联系方式：3. OSPP 2020 学生期中报告参考： 基于开放 API 封装 Wechaty 接口下的飞书聊天机器人：期中 暑期2020 编写一个“每日一句”插件 POC 成果展示 暑期2020 基于python-wechaty的群聊助手机器人 POC 成果展示 暑期2020 基于 RPA 封装 Wechaty 接口下的快手聊天机器人 中期报告 Wechaty Java 移植组件开发社区导师1. “暑期2021”组委会评审报告08月16日 - 08月22日期间，将评审报告在组委会的 Gitlab 上的 Issue 中提交，并配合组委会进行中期审核。 2. Wechaty 社区中期博客评审在8月30日前以Pull Requests形式在 wechaty. js. org Repo 的学生对应博客下，补充评审结果的相关信息。 同时，按照社区博客提交规范，对学生提交的博客进行审核，审核通过后，在 GitHub Approve 这个 PR，然后交由 Wechaty PMC 进行博客审核。注意，社区导师一定要提前、优先 Approve 自己同学的 PR。 可以完整复制本文对应的Markdown作为博客内容模板，但也可添加更多的补充信息。 ## 评审对象- 评审内容：*中期报告|结项报告*- 提交人：*学生姓名*## 评审结果- 项目完成度：*评价学生是否按照原定方案实施项目，以及完成情况如何*- 学生参与度：*评价学生在项目实施过程中是否积极参与*- 代码贡献量：*评价学生在该项目中，为开源项目贡献的代码量*- 综合评价及建议：*总结性评价，并给出改进建议*- 最终评审结果：“通过” 或者 “不通过” （“不通过” 意为着项目终止，且学生将无法获得相应的奖金）期末报告: 学生开发者1. 期末视频 视频需要上传到 youtube 中，并联系 Huan 添加到 wechaty 的 playlist 中。 考虑到国内用户，可以上传到 bilibili 或者腾讯视频中可以参考去年飞书项目参与学生，今年飞书项目导师范蕊的视频：  SOC-基于开放 API 封装 Wechaty 接口下的飞书聊天机器人-结项汇报 SOC-基于开放 API 封装 Wechaty 接口下的飞书聊天机器人-Demo演示2. 期末报告 标题： OSPP 2021-结项报告-你的标题 文件名： 2021-XX-XX-ospp-final-XX 报告 category 为：project, ospp 报告 tag 至少包括：summer-of-wechaty,summer-2021,ospp,ospp-2021,final 报告内容至少包括：     项目信息         项目名称     方案描述     时间规划          项目总结         项目成果     期末汇报视频     期末汇报 PPT     遇到的问题及解决方案          导师审核         评审对象     评审结果          提交PR时请注意：为这个 PR 打上 ospp 的标签，并在 PR 中填写自己项目的 GitHub Issue 链接，方便组委会进行审核。 3. OSPP 2020 学生期末报告参考： 暑期2020 为 go-wechaty 设计实现插件体系 结项报告 暑期2020 基于python-wechaty的群聊助手机器人 结项成果展示 基于开放 API 封装 Wechaty 接口下的飞书聊天机器人：期末 基于Python-wechaty建立一个斗图机器人 POC 结项博客 暑期2020 编写一个“每日一句”插件 结项报告 基于RPA封装的Wechaty接口下的抖音聊天机器人结项报告 暑期2020 基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人 终结成果展示社区导师1. “暑期2021”组委会评审报告10月1日 - 10月14日期间，将评审报告在组委会的 Gitlab 上的 Issue 中提交，并配合组委会进行结项审核。 2. Wechaty 社区期末博客评审在10月14日前以Pull Requests形式在 wechaty. js. org Repo 的学生对应博客下，补充评审结果的相关信息。 同时，按照社区博客提交规范，对学生提交的博客进行审核，审核通过后，在 GitHub Approve 这个 PR，然后交由 Wechaty PMC 进行博客审核。注意，社区导师一定要提前、优先 Approve 自己同学的 PR。 可以完整复制本文对应的Markdown作为博客内容模板，但也可添加更多的补充信息。 ## 评审对象- 评审内容：*结项报告*- 提交人：*学生姓名*## 评审结果- 项目完成度：*评价学生是否按照原定方案实施项目，以及完成情况如何*- 学生参与度：*评价学生在项目实施过程中是否积极参与*- 代码贡献量：*评价学生在该项目中，为开源项目贡献的代码量*- 综合评价及建议：*总结性评价，并给出改进建议*- 最终评审结果：“通过” 或者 “不通过” （“不通过” 意为着项目终止，且学生将无法获得相应的奖金）OSPP 2020 更多内容介绍:  Wechaty Summer of Code 2020 Kickoff Meeting Middle Term Demo Day 结项     OSPP 项目总结： 今年夏天，Wechaty 社区与 9 位开源后浪的故事   开源软件供应链点亮计划暑期 2020 公布结果：基于 Wechaty 开发的项目斩获突出贡献奖和最具潜力两大奖项！   获奖学生： 一次愉快的南京开源峰会之旅    OSPP 2020 项目介绍、期初、期中、期末报告汇总表OSPP Wechaty Org Admin 工作内容: 工具包：:  社区 Repo: https://github. com/wechaty/summer 社区通知 Issue：https://github. com/wechaty/summer/issues/筹备会中完成后确认的项目清单链接 社区微信群：Summer of Wechaty - SoW 社区 Org Admin 组委会群：Summer of Wechaty Org Admin SoW Wechaty Contributor 群：Wechaty Contributors 所有发布到 Wechaty 的博客需要打上如下标签：     ospp-admin   summer-202X （202X 改为当前的年份）   summer-of-wechaty   ospp   ospp-202X （202X 改为当前的年份）   0. 筹备会:  向 Wechaty Contributor 群中发起号召，号召 Wechaty 的 Contributor 成为当年开源之夏的 Mentor，并让 Mentor 在 Wechaty Summer Of Code Repo 中以 Issue 的方式发布任务。 将所有有意向参加的 Mentor 邀请到 Wechaty OSPP 的官方微信群中： Summer of Wechaty - SoW 在收集完所有的 OSPP 项目后，并发布项目清单 Issue，当年所有的重要通知，都在此 Issue 下以回复的形式通知社区，参考 2021 年的项目清单：OSPP 项目通知 （ “暑期2021” ）- 2021 筹备 OSPP 的报名和相关安排，至少参加(举办)一场会议，参考 2021 年的筹备会内容：     Summer of Wechaty, 我们来啦   OSPP 2021 Project Status    完成当年的 OSPP 指导手册，并发布博客，参考 OSPP（开源之夏）指导手册 - 2021 在项目清单 Issue 下面，把所有 Org Admin 需要完成的工作，以 checklist 的形式复制回复到 Issue 下面，方便后续 Wechaty Org Admin 完成相关工作，完成后在 Comment 中打钩确认1. 期初见面会:  在 Summer of Wechaty Org Admin |SoW 群中和所有 Org Admin 确认期初见面会的时间，并给所有参与的 Org Admin 期初见面会的日历邀请。 组织导师和同学完成见面会，在 Meeting Notes 中创建见面会的会议，并引导同学完成注册，注意要填写姓名、一句话介绍和邮箱，一定要有邮箱！，参考 2021 年的会议信息： Kick off OSPP First Meeting with Students, 同时在见面会中向社区同步至少以下三项信息：     当年的关键时间点，包括组委会报告提交、社区博客提交、社区答辩时间等   OSPP（开源之夏）指导手册   Wechaty 社区开源协作最佳实践指南   每个同学的工作进度，回复到自己项目的 Issue 下方    在 Wechaty OSPP 的官方微信群中 （Summer of Wechaty - SoW）发布公告，往届参与者也可以旁听期初见面会，了解当年项目。 把所有入选的同学邀请到 Wechaty OSPP 的官方微信群中： Summer of Wechaty - SoW 在期初见面会结束之后发布期初博客，参考 Wechaty Open Source Promotion Plan 2021 Kickoff Meeting 推进所有同学提交社区的期初报告博客，并在当年OSPP 项目通知的 issue 下面同步期初博客完成进度，参考 2021 年 OSPP 期初博客进度完成情况。同时可以在对应的微信群中向同学发起接龙。2. 期中答辩（Mid-term Demo Day）:  在 Summer of Wechaty Org Admin |SoW 群中和所有 Org Admin 确认期中见面会的时间，并给所有参与的 Org Admin 期初见面会的日历邀请。 发布期中答辩通知，参考 Wechaty 社区期中答辩（Mid-term Demo Day）通知 要求同学录制期中答辩的视频，包括答辩视频和 Live Coding 两个视频，并将对应的 YouTube 链接和国内视频网站的链接回复在自己项目的 Issue 下面。   推进同学按时提交组委会要求的期中报告，并在 Wechaty OSPP 的官方微信群中 （Summer of Wechaty - SoW）发起接龙，已提交完报告的同学完成接龙，接龙内容参考：   接龙 『暑期2021中期学生报告提交确认』 组委会要求 XX (时间) 之前提交报告。若同学未在截止日期前在系统内提交报告，该项目将被视为自动放弃，组委会将不再支持此项目。 Wechaty OSPP'21 中期需提交内容包括： 1、组委会要求提交的报告 2、Wechaty社区要求提交的博客 请各个项目的同学，在确认已经完成后，接龙确认。（同时更新对应的 GitHub Issue） 例 姓名/项目简称/Issue#    推进导师按时在组委会要求的平台完成期中报告的审核，并在 Wechaty OSPP 的官方微信群中 （Summer of Wechaty - SoW）发起接龙，已提交完报告的导师完成接龙，接龙内容参考：   #接龙 『暑期2021中期导师审核完成确认』 组委会要求 XX（时间）之前完成审核。若导师未在截止日期前在系统内完成评审，该项目将被视为自动放弃，组委会将不再支持此项目。 请各个项目的 mentor ，在确认完成审核后，接龙确认。（同时更新对应的 GitHub Issue） 例 姓名/项目简称/Issue#  推进所有同学提交社区的期中报告博客，并在当年OSPP 项目通知的 issue 下面同步期中博客完成进度，参考 2021 年 OSPP 期中博客进度完成情况   确认所有同学完成 Wechaty 社区要求的两个视频，并在 Wechaty OSPP 的官方微信群中 （Summer of Wechaty - SoW）发起接龙，已在 Issue 下回复完视频链接的同学完成接龙，接龙内容参考：   #接龙 『暑期2021中期 Demo Day 视频完成确认』 [烟花]XX（时间）[烟花] 将会进行 Wechaty 的中期 Demo Day 展示，每个学生进行Wechaty的中期答辩。 期中 Demo Day 视频需要2个视频： 1. 期中汇报视频 （3-5分钟的、有真人出镜的、基于PPT的展示） 2. Live Coding 视频（不限时长的、有真人出镜的 Live Coding） 可以参考去年@范蕊 的视频： 1. 答辩视频：https://www. bilibili. com/video/BV1n54y1U7Fn 2. Live Coding: https://www. bilibili. com/video/BV1v54y1e7LM 视频提交截止日期： [爆竹] XX（时间） [爆竹] 请及时提交，或者会影响项目评分。 各个项目的同学 ，在完成视频录制后，接龙确认。（同时将视频链接更新到对应的 GitHub Issue） 1. 姓名/项目简介/Issue#  组织导师和同学完成期中答辩，在 Meeting Notes 中创建期中答辩会议，并引导同学完成注册，注意要填写姓名、一句话介绍和邮箱，一定要有邮箱！，参考 2021 年的会议信息： Wechaty OSPP(开源之夏) Midterm Demo Day, 同时在 Agenda 中列出每个同学的答辩内容，参考如下：     [同学姓名] 项目名称         答辩视频：https://答辩视频链接     Live Coding 视频：https://在线 Live Coding视频链接           在期中答辩结束之后发布期中博客，参考 暑期2020中期路演日（Mid-Term Demo Day）3. 期末结项答辩（Final-term Demo Day）: TBW 优秀项目评选: 2020年，经过3个月的努力，最终151位同学通过了结项审核，同学们的结项报告及日常研发工作得到了社区及组委会的一致认可。从项目角度（项目完成质量、代码的可读性、文档的完整度使得项目具有可延续性）、社区角度（学生对社区的贡献度、完成项目对社区的重要性等）、学生角度（学生参与活动的进步程度和快速学习能力）、开源角度（学生展现出未来持续贡献开源的潜力和意愿）等多方面综合评审后，得出了暑期2020的最终奖项  Wechaty 社区的 @univerone (江姗姗) 同学荣获暑期2020的优秀学生突出贡献奖！ Wechaty 社区的 @kxz18 (孔详哲) 同学荣获暑期2020的优秀学生最具潜力奖！今年，Wechaty 还会为特别优秀的同学和项目提供如下奖项：  Wechaty 优秀项目奖 结项之后，优质项目将会被 merge 到 Wechaty 官方 org 下。期待在2021年的夏天，你也能在3个月后，顺利通过结项审核，并赢得 OSPP 颁发的优秀奖励！ "
    }, {
    "id": 99,
    "url": "https://wechaty.js.org/2021/06/23/the-wechaty-way/",
    "title": "Wechaty 社区开源协作最佳实践指南",
    "body": "2021/06/23 - Wechaty (Conversational RPA SDK) 2016 年发布于 GitHub，是一个基于 Apache-2. 0 许可证的开源项目。经过5年多的发展，现在 Wechaty 开源社区已经拥有数十位 Committers，百余位 Contributors ，并被超过一万名 GitHub 开发者 Star。目前，使用 Wechaty 的开发者已覆盖数万人，并拥有基于微信群的数千人活跃开发者群。 Wechaty 社区的 Contributors 遍布全球多个国家地区，和各大互联网公司，职业背景从程序员到设计师，从大学教授到创业者，非常多样化。GitHub 上有千余个开源项目基于 Wechaty 构建了聊天机器人，这些开发者用户也极大地促进了社区的活跃和发展。 Wechaty自身对代码质量的管理，使用了 GitHub Actions 的 DevOps 工具完成了 CI/CD 工作流，从自动化单元测试到自动打包集成测试，从自动发布 NPM 包到自动构建和发布对应版本的 Docker Image ，实现了全自动的社区代码发布，极大的提高了社区的协同效率。 在开源社区管理上，Wechaty 遵循 The Apache Way ，拥有 PMC / Committer 管理制度，和完善的 Issue / PR / Release 等管理制度。截止2021年，Wechaty 已经有近百万次 NPM 安装下载，并由社区自发推动了 Python, Go, Java, Scala, . NET, PHP, Rust 等语言的适配和发布，是国内最活跃的 Conversational AI Chatbot 开发者社区。 Wechaty 介绍 PPT：: 通过阅读下面3个PPT，你可以对Wechaty及其发展历程有一个基础的了解。  2016: Wechaty 101: from v0. 0 to v0. 7 2016-2020: Open-source Wechaty: 2016 to 2020 2021: Wechaty 2021社区沟通: Wechaty 社区持续秉承信息开放透明：  首选沟通渠道是 Gitter, 因为 Gitter 保存了所有的历史沟通记录，即使你是刚刚加入社区的开发者，你也能追溯到第一天社区成员都讨论过哪些内容。 次优选的沟通渠道是加入我们的 Mailing List (发送邮件给 wechaty@googlegroups. com 即可加入)，我在 2019 年和 Apache 基金会主席 Craig 聊过： If it didn’t happen on list, it didn’t happen. 保证社区内容开放透明并以邮件存档是一件非常重要的事情，所以我们也非常推荐大家通过 Wechaty 的 Mailing List 来沟通。以下是 Wechaty 的所有沟通渠道：  Gitter Mailing List：发送邮件给 wechaty@googlegroups. com 即可加入 WeChat Room: Wechaty Developers’ Home Discussion Stack Overflow Telegram TwitterWechaty 更多链接: 除了社区沟通的渠道，你也可以在这里了解更多 Wechaty 相关内容。  Blog： 这里是可以看到 Wechaty 的所有博客 Wechaty Contributors： 来这里可以看到所有 Wechaty Contributor 的介绍 Meeting Notes：Wechaty 的每次会议记录的内容。 Branding Guides：使用 Wechaty 的 logo 等素材内容 YouTube： Wechaty 所有的视频清单 Open Collective：为 Wechaty 捐赠的唯一通道 Google Drive： Wechaty 所有的文件存档 Photo Album：Wechaty 活动的精选照片 Hall of Fame：了解 Wechaty 名人堂Wechaty 会议流程最佳实践指南: Wechaty 社区希望每一次会议尽可能让所有参与者都能专注参与，并且获得正向产出，保证会议简洁高效和社区透明，Wechaty 的会议有以下三个重要工具及使用指南。 1. Wechaty Meeting Notes: Meeting Notes 有以下几个价值：  透明：社区开的每一个会都会记录在 Meeting Notes 中，即使你刚刚加入社区，你也可以在 Meeting Notes 里面看到过去的会议内容。 高效：俗话说，“不打无准备之仗”，同样的道理，“不开无准备之会”，做好开会前的准备工作，对开好一个会起到至关重要的作用， 每次开会之前，参会者都要提前在 Meeting Notes 里面写好会议议题，保证参会的人在参会之前明确知道讨论内容，提高开会效率。这是 Meeting Notes 的模板内容(可以在 Meeting Notes 最底部拿到文字版，我这里放了图片方便看格式)： 具体使用流程指南：  组织者在开会之前来 Meeting Notes 写好会议地点和时间，通常情况下，会议都是公开的，任何人都可以通过 Meeting Notes 中的 Zoom 链接视频参会。 参会者要在 Attendees 中注册自己的信息，包括：     姓名   一句话介绍   邮箱（非常重要，因为主持人后续可能会发送邮件到这个邮箱）   时区（Wechaty 作为一个国际型社区，经常会有海外的参会者）    开会之前，参会者要在 Agenda 中写下你的议题，以 [姓名] 内容 的方式写进去，这样可以让参会者知道哪些人有哪些不同的议题 除了会议议题外，你也可以在 Question 的版块写下你的问题，问题同样也可以被其他人评论，填写格式依然是 [姓名] 内容 任何人在都可以任何时候都可以评论其他人的议题，评论方式是在内容下一行，缩进斜体的方式以 [姓名] 内容 的方式填写进去。 我们非常鼓励在开会其他人发表意见的时候，你同步在 Meeting Notes 在议题下发表评论，因为你写的内容大家都会看到，越多的讨论就会有越多的产出。 需要注意的是，Agenda 和 Question 是一定要在会议开始前写进去的，这样保证参会者能提前了解内容； 但是评论是可以在任何时候（会议前&amp;会议中）写进去的，这样保证会议的内容都可被存档。Zoom 会议: 社区在条件允许的情况下，尽可能保证每一次会议都可以线上参与，参与的方式是使用 Zoom 会议，每次zoom会议都会进行视频录制，这样没有参会的人也可以看会议的视频回放。  Zoom 下载地址：Download 参会链接：https://zoom. us/j/6505033788 参会密码：huan会议视频: 为了保证会议的沉淀，重大线上会议会要求的主持者在会议结束后将会议视频上传到 Youtube 同时完成以下内容：  在公开范围里设置成 公开 添加到 wechaty 的 playlist 中（主持人若没有添加权限，可以找 Huan 申请） 撰写视频说明 在视频说明中，通过添加 00:00 等时间的方式，在视频进度条上添加视频章节，具体可以参考：Youtube 如何在进度条上添加章节 章节会将视频拆分为多个部分，方便观看者快速跳转到视频的不同部分。Wechaty ❤️ Google Season of Docs: Kick-off meeting with 20 Technical Writers! 就是一个很好的示例。因为一次会议的时间很长，其他人看视频的时候就可以很容易根据下图介绍知道 视频中 0:01:41 的时候讲的内容是 Introducing the Meeting Agenda， 同时点击 0:01:41 可以快速跳转到视频播放的地方。 上传视频以后，主持人要去社区发布一个会议的博客，并嵌入视频内容，这样就能保证这次会议进行了存档并可以共享个社区的任何开发者。 会议博客: 为了保证社区的每一次会议都能够有内容沉淀，重大会议后需要些会议博客，博客撰写会在下一个小节介绍。 一次会议博客至少要包括下面的内容：  会议背景介绍 会议合影 参会人 Zoom 会议视频 会议议程（不要把Meeting Notes 的会议议程粘进去，而是用 Youtube 中做好的视频切割链接，这样方便读者可以快速的看自己关注的会议内容）会议博客例子: Wechaty 社区组织 Google Season Of Docs 的 Tech Writer 的会议博客 Hello Wechaty GSoD’21 Technical Writers 是一个很好的会议博客案例，完整的包含了上面的要求，建议第一次写会议博客的人先来看下这个案例。 Wechaty 博客发布流程指南: 任何人都可以通过在 wechaty. js. org Repo 下面通过发布 PR 的方式发布博客。  如何发布一篇 Wechaty 博客 Wechaty 博客的撰写指南 本地测试保证博客内容没有问题 本地预览在博客中插入视频: 下面是在会议博客中嵌入视频的代码的简单案例，作为include标签的src参数传入视频链接即可。 {% raw %} {% include iframe. html src= https://www. youtube. com/watch?v=hTkM_XPpFfU  %}{% endraw %} univerone 写了一篇非常详细的博客使用jekyll include在wechaty博客中快速插入视频，介绍了如何优雅的在博客中插入视频，有兴趣的同学也可以深入博客研究。 小白入门发布博客: 如果你是完全小白，可以参考 atorber 的这篇博客: 入门：小白如何在wechaty社区发布自己的第一篇博客（一） 通过大量的截图一步一步告诉你如何发布Wechaty博客。 Wechaty Issue 发布流程指南: 社区希望遇到任何代码问题，都通过 issue 进行交流。 强烈反对把代码截图或者日志截图直接发到微信群里，问大家为什么运行不了，或者直接问这事什么错误。一个截图是无法给出全面信息的，而且非常不利于归档传播给更多的开发者。当你提出一个有价值的 issue 的时候，实际上可以极大的避免其他开发者踩坑。 当然，在发布 issue 之前，也强烈建议你在 issue 列表中进行搜索，看这个 issue 是不是别人已经提过了，甚至已经有人给出了很好的解决办法。 发布 issue 的时候，建议按照 issue 模板发布 issue， 这样方便社区里的人更好的为你提供帮助。issue 分为3个类别： 1. 报 Bug: 模板内容见：Bug Report 报 Bug 最重要的事情是复现，只有可复现的bug，才可被解决。具体来讲，至少需要你给出以下的信息：  Wechaty 版本号、使用了哪一个 wechaty puppet、node 的版本和操作系统 详细的描述这个bug 明确的复现步骤 按照你的步骤操作后，期待出现的现象 按照你的步骤操作后，实际出现的现象 相关的完整日志2. 提新需求: 模板内容见：Feature Request 当你提出希望社区增加一个新的功能的时候，你需要详细的描述出为什么需要，以及你期待的这个需求具体的样子。你描述的越详细，越容易得到其他开发者的支持。被其他开发者支持的多的需求，越容易被提到更高的优先级上。 3. 问问题: 模板内容见：Question 社区不希望你在 issue 中提问，最好的方式是去 StackOverflow 上提问。 Wechaty 的 Contributor xpt 在 StackOverflow 有超过 10K 的 reputation, 他专门为 wechaty 创建了 tag，所以你在 StackOverflow 上通过搜索 wechaty 是能看到所有关于wechaty的问题的。同时，也建议开发者去 StackOverflow 提问并打上 wechaty 的标签，方便其他开发者搜索相关问题。 Wechaty PR 发布流程指南: 如果你不是 PR 一个博客，在 wechaty PR 之前一定要新建一个 issue，说清楚你要解决的问题，然后再发一个 PR， 并在这个 PR 中关联对应的 issue 链接，这样做的目的是明确告诉大家你提这个 PR 在解决什么问题，而不是只是提交一堆代码。 此外，开发者在提交 PR 之前一定要按照 PR 模板的要求：  明确这是一个新功能开发还是一个bug修复 为这次提交的内容增加了测试用例 通过 CI 测试，展示形式是 Github Action 变绿了 完成 CLA 的签署 关联相关的 Issue 链接 Wechaty RFC: 如果是一个比较大的提案，建议先提一个 proposal，描述一下你要干什么、为什么要干这个事情、它能带来什么收益、方案是什么以及分析备选方案的优缺点等，我们会让你提个 Issue 进行讨论，最后以讨论后的 proposal 为基础，开始后面的开发。 如这是 Wechaty Commiter 高原 发布的提案： 进阶，了解 Apache Way，知道如何更好的参与开源项目: 最后，在这里为大家推荐一系列 Apache Way 的资料，让你更好的理解开源项目的运作，也欢迎你以 Apache Way 的方式参与到社区的建设中。 官方内容:  孵化场的地址 生命周期佳芮推荐：:  Apache 介绍 什么是 Apache Way，Apache Way 是指 Apache 管理和运营项目的方法 什么是 Incubator PMC 什么是 Infrastructure Team 视频-ASF是如何运营的以及他的价值 视频-如何高效管理开源项目"
    }, {
    "id": 100,
    "url": "https://wechaty.js.org/2021/06/22/gsod-2021-fourth-meeting/",
    "title": "GSoD'21 Fourth Meeting",
    "body": "2021/06/22 - Google Season of Docs’21 fourth meeting: Meeting Summary: It was the fourth meeting of the GSoD’21 participants, first after the monthly evaluation, before the start of the meeting we received the sad news that the Chirs has fallen sick and Soumi due to her other engagements won’t be able to attend the meetup In this meeting, firstly every participant gave one’s week summary and informed the community about their plans for the upcoming week, volunteers and tech writers discussed while tech writers were giving their week summaries. Later we had a suggestions/Q&amp;A session, in which Vasvi raised her concerns and at last, we took a lovely group photo. {% include iframe. html src=”https://youtu. be/h4EX9vkoIVo” %} Attendees: Total 11 attendees attended the meeting. They are:  Rohitesh Jain, Volunteer (UTC + 5:30) Sajen Sarvajith, Reconstruct Landing page writer (UTC + 5:30) Abhishek Jaiswal, How-to-guide section writer (UTC + 05:30) Simin Liao, Volunteer (+8:00) Mukosa Joseph mawa, Introductions and Explanations section writer (UTC +03:00) Rajiv Ranjan Singh, Improve the gRPC and OpenAPI ecosystem writer, rajivperfect007@gmail. com, (UTC+05:30) Souvik Biswas, Create easy to learn tutorials for beginner users writer, sbis1999@gmail. com (UTC +05:30) Shraddha, Improve References section writer (UTC + 5:30) Shwetal Soni, Create easy to learn tutorials for beginners users writer (UTC +05:30) Vasvi Sood, How to guides, contactvasvisood@gmail. com writer (UTC + 5:30) Arnab Saha, Reconstruction of Landing page with value propositions writer (UTC + 5:30) Agendas:  0:00:48 1. Discussion with Tutorials team 0:18:46 2. Discussion with Introduction and explanation team 0:20:30 3. Discussion with Landing page team 0:21:55 4. Discussion with References section team 0:23:50 5. Discussion with How to guides team 0:28:45 6. Discussion with gRPC teamYou can learn more from our meeting notes. Meeting Outcomes:  The community got to know about the progress and plans of the members Many small issues got discussed and resolved in the meeting Volunteer got to know the grievances of Sajen and VasviMeeting Follow-ups:  Review the new landing page design"
    }, {
    "id": 101,
    "url": "https://wechaty.js.org/2021/06/22/gsod-2021-first-month-evaluation/",
    "title": "GSoD'21 First Month Evaluation",
    "body": "2021/06/22 - Google Season of Docs’21 first month evaluation: Post Summary: It has been one month since the start of the Google Season of Docs’21 program, and so far 11 technical writers working on 6 projects have shown great progress, they raised 48 PRs combined and the projects are going more or less as planned. Also, we had 3 meetings in this phase to discuss aspects related to the GSoD’21 project.  Wechaty GSoD’21 first meeting Wechaty GSoD’21 second meeting Wechaty GSoD’21 third meetingYou can learn more from our meeting notes. This post gives an overview of the performance of tech writers so far Tutorials for users of Wechaty team: Shweta Soni’s documentation quality is good, she had a bit of trouble in one of her PR, but she rectified that with the help of volunteers. Her performance and PR quality are improving each time. She responds to the feedback given and is always ready to accept enhancements in her PRs. Souvik Biswas has been contributing for a month before the start of the program so he is well aware of Wechaty ecosystem, and how to run bots. He has been really hard working and is paying great details to the documentation and in general, his documentation is good, his one documentation was a bit verbose. Overall as the main documentation for Wechaty, they really did a great job as the leading role and could definitely represent Wechaty documentation. Tutorial follow-ups Introduction and Explanation team: The experience of Chris and Joseph is visible in the documentation that they have pushed for review. Their documentation quality is excellent, volunteers don’t know who has written which parts, but they have ensured that there is a fair division of work between Chris and Joseph. Apart from excellent documentation their PRs are easy to review and the team has a very good knowledge of git and they get out most of the GitHub. They both have been very punctual in the meetings, and have shown great sincerity and professionalism in their work. Also, they have delivered everything on time and were slightly ahead of the timeline. They both proactively interact in the meetings. They have mostly delivered their deliverables so that’s great as well. Chris is very proactive and responsible for her job, the topics she documented are quite new to her, but she contacted Simin often to discuss how to do it better. Joseph’s documentation is always great and on time. Introduction and Explanation follow-ups Reference Section team: Shraddha is on time with her deliverables, and her documentation content is accurate as well, but, she makes a lot of typos and grammatical errors, which should be improved. She has been proactive in the community in terms of reviewing PRs of other writers and introducing new useful labels. She missed a meeting but that’s acceptable for her as her project has a diluted timeline of 17 weeks. She is doing good in general and has been active in the meeting that she had attended. She raises clean PRs which are easy to review. Soumi Bardhan has completed her deliverable ahead of time, but she raised quite a big PR, our suggestion to her is to raise atomic PRs like her teammate. Her documentation quality is good. She has also attended all the meetings so far. The reference team is rather new to documentation, but they are very responsive and learn quickly. Their documentation quality is getting better now, just still need to pay attention to minor typos. Reference Section follow-ups Reconstruct Landing Page with Value Propositions team: The team is going according to the timeline. There has been some delay but that wasn’t their fault. They have completed the value propositions of Wechaty by listing it out and they have made a perfect slogan for the Wechaty new landing page and also a great design with attractive CTAs, delivering Unique Selling Point (USP) to the Wechaty users in the new landing page and many more. They have completed the full prototype of the new landing page with value propositions as per their timeline. Apart from the new landing page project, they are also working on the introduction video team for the Wechaty community and they are syncing it and making sure that the introduction video and the new landing page are delivering the same value propositions and other things in common for the users. Sajen is very sincere and proactive. He is working really hard and has been active in the weekly meetings. Arnab is a bit shy and has missed one meeting, volunteers am looking forward to hearing from him in future meetings. Landing Page follow-ups Improve the gRPC and OpenAPI ecosystem team: His project is a bit intricate for volunteers to review, so PRs are yet to be reviewed. His projects involve both documentation and coding, probably he has churned more code than documentation. Considering that he is working alone on his project he is actually working very hard. He is doing extra work apart from his timeline that is appreciable. The concern is that he isn’t strictly following his timeline, and we would like him to suggest first deliver deliverables according to the timeline then work on other PRs. follow-ups How-to Guides team: How to guide team is very meticulous, they are very hardworking and sincere about their work. Also, they take feedback very seriously and try to implement the given changes as soon as possible. They did some mistakes in git commit, but they admitted that they made a mistake and have rectified the errors. They have learnt a lot about Git in this process as well. Their documentation is clear and to the point which is good. They have shown good determination since the start of the program. They have attended all the meeting so far, and they also take part in conversations. It’s good that Vasvi raises concerns about her team in meetings and on emails. The how-to guide’s team might not be the most professional in documenting, but they are very organized. We really appreciate that they have set a clear timeline and strictly follow it. For project management, it is best to have teammates like them that report their work to us actively and clearly. follow-ups Suggestions for the upcoming months: Almost every tech writer feels that PRs need to be reviewed faster, so that is one of the areas that we should improve upon in the upcoming months. It’s also holding back the progress of few teams. Special thanks to Simin for adding her evaluations in this post and maintaining the Wechaty follow-ups sheet for tracking timelines of tech writers. "
    }, {
    "id": 102,
    "url": "https://wechaty.js.org/2021/06/17/wxrobot-backend-management/",
    "title": "基于Nodejs+Wechaty开发微信机器人管理平台",
    "body": "2021/06/17 - 微信机器人开源库调研，GitHub 找到以下 3 个开源作品：  itchat     itchat 是一个开源的微信个人号接口，使用 python 调用微信   使用不到 30 行的代码，你就可以完成一个能够处理所有信息的微信机器人    wechaty     wechaty 是适用于微信个人的 Bot SDK ，可以使用 6 行 js 创建一个机器人   具有包括 linux，Windows，MacOS 和 Docker 在内的跨平台支持，基于 Node. js    vbot     vbot 是基于微信 web 版的接口，使用 http 协议 以及轮询方式实现   亮点在于通过匿名函数，能够实现多种有趣的玩法   通过 API，更方便的打造属于自己的网页版微信，基于 PHP   初识 wechaty: Wechaty 是一个开源的的对话机器人 SDK，支持 个人号 微信。它是一个使用 Typescript 构建的 Node. js 应用。支持多种微信接入方案，包括网页，ipad，ios，windows，android 等。同时支持 Linux, Windows, Darwin(OSX/Mac) 和 Docker 多个平台。 先看一下官方文档：  wechaty-github wechaty中文文档只需要 6 行代码，你就可以 通过个人号 搭建一个 微信机器人功能 ，用来自动管理微信消息。 import { Wechaty } from 'wechaty'Wechaty. instance(). on('scan',    qrcode =&gt; console. log('扫码登录：' + qrcode)). on('login',    user  =&gt; console. log('登录成功：' + user)). on('message',   message =&gt; console. log('收到消息：' + message)). on('friendship', friendship =&gt; console. log('收到好友请求：' + friendship)). on('room-invite', invitation =&gt; console. log('收到入群邀请：' + invitation)). start()更多功能包括：  消息处理：关键词回复 群管理：自动入群，拉人，踢人 自动处理好友请求 智能对话：通过简单配置，即可加入智能对话系统，完成指定任务 … 请自行开脑洞好了，文档齐全 &amp; api 丰富，完全满足我的需求，就选这个库了。 首先跑一个示例看看 wechaty-getting-started。下载完之后先 npm install &amp; npm start 一顿操作，然后运行就有了登录二维码，拿出手机扫码，然后 GG。 wechaty-puppet: 使用 wechaty-puppet-padplus 一套基于 ipad 协议的包。 目前 wechaty-puppet-padplus 已弃用，后续使用 wechaty-puppet-service。 不过天下没有免费的午餐，需要申请 token，见 Wechaty Token 申请及使用文档和常见问题。 聊天机器人 API: 目前网络上有许多非常好的智能聊天机器人，这里找了6个目前使用很广泛的：  海知智能 功能很强大，不仅仅用于聊天。需申请 key，免费 思知对话机器人 注册很简单，调用也很简单，而且完全免费 图灵机器人 需要注册账号，可以申请 5 个机器人，未认证账户每个机器人只能回 3 条/天，认证账户每个机器人能用 100 条/天 青云客智能机器人 无须申请，无数量限制，但有点智障，分手神器，慎用 腾讯闲聊 需要注册和申请，还需要加密处理 天行机器人 白嫖用户绑定微信后有 10000 次永久额度，之后 1 元 10000 次搭建微信机器人平台: 项目初始参考 wxbot 搭建机器人后台管理。 项目介绍:  控制台     绑定机器人   登录   自动通过好友验证关键词设置，当有人添加机器人时，关键词匹配后直接通过   好友验证通过自动回复   退出    自动回复     普通消息         针对好友/某个群聊/所有群聊 设置关键词自动回复          加群邀请         机器人回复群聊列表，好友可以选择性进群          踢人指令         机器人识别指令，自动把成员移出群聊           我的好友     单独对某个好友送消息    我的群聊     群聊列表，管理所有群聊   设置群聊名称，发布公告，发送群消息   设置群聊基本信息，入群欢迎语，成员违规次数上限，是否受机器人控制    定时任务     针对好友/某个群聊/所有群聊设置定时任务，机器人在指定时间会触发消息推送    智能聊天     低智商对话   成语接龙，查天气，查酒店，歇后语…    技术构成:  服务端 Node. js SSR框架 NuxtJS 前端框架 Vue UI组件 Ant Design of Vue 持久化 MongoDB 协议 wechaty-puppet-service这里就直接介绍下机器人模块 |-- server/|———- /lib|------ FriendShip. js  # 友谊关系，好友添加监听|------ Login. js    # 机器人登录退出|------ Message. js   # 消息监听处理|------ Room. js     # 加群，退出群聊|------ Task      # 机器人定时任务|———- index. js     # 入口文件快速开始: 准备条件:  安装 Node. js (v10 以上版本)、MongoDB。 推荐安装 cnpm安装依赖: cnpm i启动服务:  开发模式npm run dev 生产模式先编译项目 npm run build再启动服务 npm start打开浏览器，访问 http://localhost:3000/ 系统配置: 根据实际情况修改 config. js 配置文件，修改后需要重启服务才能生效。参数说明： hostString 类型，主机名，配置为 0. 0. 0. 0 表示监听任意主机。 portNumber 类型，端口号。 mongoUrlString 类型，MongoDB 链接。 secretString 类型，JWT 秘钥。 tianApiKeyString 类型，天行数据秘钥 线上部署: 使用PM2: 推荐使用 pm2 进行 Node. js 的进程管理和持久运行。 安装cnpm i -g pm2启动pm2 start pm2. config. js --env production踩坑: 1. Wechaty Token 申请及使用文档和常见问题  Wechaty 开源激励计划2. 0 申请表 填写项目信息 Wechaty Token 申请及使用文档和常见问题2. tianApiKey 申请及天行机器人配置  首先，去 天行数据 注册账号，申请 APIKEY 其次，申请 天行机器人 接口，用于机器人自动回复 最后，别忘记配置 机器人身份设置，否则在机器人回复中会有奇怪的代码串，如 {robotname}3. 部署中执行 sudo pm2 报错 command not found 问题  原因是没有将 pm2 加至环境变量中，先找到 node 的目录 可以用 whereis node 来查找，然后查找 whereis pm2，再使用 ln 建立软连接 参考文章 Linux下使用pm2部署node以及安装后command not found解决4. 部署中执行 sudo pm2 报错 permission denied 问题  原因是项目会动态生成中 logs 目录中的文件，报错权限不足，即 permission denied 参考文章 解决 pm2 中的 permission denied 问题4. Ubuntu MaxReports 报错问题  安装报错依赖关系问题 参考文章 Ubuntu16. 04 由于已经达到 MaxReports 限制，没有写入 apport 报告5. Ubuntu 安装 node-canvas 以及中文乱码/自定义字体的问题  首先 sudo apt-get install build-essential libcairo2-dev libpango1. 0-dev libjpeg-dev libgif-dev librsvg2-dev 安装完成后 npm install canvas 中文乱码/自定义字体的问题解决方案：①安装 sudo apt-get install ttf-wqy-microhei #文泉驿-微米黑 ②注册 registerFont(‘/usr/share/fonts/truetype/wqy/wqy-microhei. ttc’, { family: ‘WQY’ }) ③使用 ctx. font = ‘bold 22px “WYQ”’ 参考文章 node-canvas6. CentOS 安装 better-sqlite3 报错的问题  首先执行 sudo yum install centos-release-scl-rh，sudo yum install devtoolset-8-build 这两个方法 安装相应的gdb，sudo yum install devtoolset-8-gdb 同样，也可以安装相应版本的 gcc 和 g++，sudo yum install devtoolset-8-gcc devtoolset-8-gcc-c++ yum安装完后，原来的gcc不覆盖，所以需要执行enable脚本更新环境变量，sudo source /opt/rh/devtoolset-8/enable 可以通过加入到profile里面开机自动source, vim /etc/profile, 跳到最后一行加入以下内容，source /opt/rh/devtoolset-8/enable 参考文章 better-sqlite3感谢:  感谢 beclass 的开源项目 wxbot，这是一套优秀的微信机器人平台。 感谢 Wechaty 团队提供微信机器人 SDK，让开发者可以专注于业务代码。 感谢 句子互动 提供的 pad 协议版 token。 作者: zwlCode: Github "
    }, {
    "id": 103,
    "url": "https://wechaty.js.org/2021/06/17/puppet-simplepad-hello/",
    "title": "New Wechaty Puppet Service: SimplePad",
    "body": "2021/06/17 - 大家好,我是SimplePad的开发者,也是之前小丸子项目的开发者,群里的”银河飞车”. 之前也在我们Wechaty群内宣传(搔扰)过几次大家,可能有些同学已经见过或者使用过了. Wechaty-Puppet我们大家已经很熟悉了,得益于Wechaty精巧合理的接口设计和高度抽象的模型,让我们在使用Puppet的时候得心应手的同时又能十分方便的在各种Puppet中切换自如. 在我们享受SDK这种模式给我带来的便捷的同时,可能偶尔也会因此受到一些困扰:    依赖冗余. 例如你的项目里只是想用Bot发送一些简单的文本内容,但是不得不引入整个SDK生态来达到这一个目的.   使用受限. 得益于社区的发展,现在除了官方Node版本的Wecahty外,已经有了python-wechaty和go-wechaty等其他语言项目. 但如果你使用的是其他语言,就只能选择自己开发一个对应语言的Wechaty或者学习一门已有Wechaty实现的语言.   调试不易. 如果我们使用的SDK中出现问题,只能研究其中的源码实现来做本地临时修正,或者提交一份PR,更或者只能联系(等待)开发者修复. 这样会影响我们的开发进度,增加额外的排错时间.   功能冗余. 比如你的机器人只想发送一些简单的文本信息,但是必须购买完整功能的Token,这在我看来并不是最佳的使用体验.  好在Wechaty社区也考虑到了这些问题,并且提供了一个正在开发的方案WechatyOpenAPI,提供一个网关来对接目前的Wechaty-Grpc-Service,而对外提供一整套Restful形式的Http接口来解决我上面说的问题. 我说这么多可能大家心里会想:那这些和SimplePad又有什么关系? 我想说的是,有关系而且关系还挺大. 在开发SimplePad之前我也调查了目前市场上的Wechaty方案,意识到了前面说的几个痛点,为了解决上面说的几个问题,已经先开发了一套Http协议调用形式的协议系统,而SimplePad反而是之后才进行开发的. 所以自然而然,整个SimplePad的API部分也是完全使用了这套系统的接口. 对于我们互联网开发工作者而言,Http是使用最多也是最熟悉的协议方案,协议清晰易懂,调试方便,这也是SimplePad名称的由来和核心意义. 希望给大家提供一个方便使用,调试简单的Puppet. 开发者在拥有Token后可以选择使用Puppet,也可以选择直接调用Http协议的形式来实现相应的操作. 这里我为大家画了一个简单的流程图. 所以对于上面说的几个问题,SimplePad提供的方案更为灵活.  没有第三方库的依赖 也没有开发语言的限制 调试更为简单直观,可以使用开发者常用的Postman,也可以使用我在后台提供的API调试工具 按需使用(为了保证基本使用流程通畅,会有一些必须选择的接口). 开发者可以自由选择需要的接口,按需付费.  提供一个完善功能的后台,可以方便调试接口和管理自己的Token. 以上就是SimplePad开发的初衷和由来,以及我在解决目前社区痛点问题上的思路和一些小小的优势,更深入的使用和体验欢迎大家来探索. 也期望大家能够和我积极交流反馈,我会尽最大努力让开发者们获得最优的使用体验. "
    }, {
    "id": 104,
    "url": "https://wechaty.js.org/2021/06/11/ospp-startup-discussion/",
    "title": "OSPP 2021 Project Status",
    "body": "2021/06/11 - 临近OSPP2021项目最终审核，需要与各位导师确定一下项目的状态以及安排接下来两周的任务，故有了此次的线上会议。  由于截屏现场异常，没有拍到会议合照，争取下次不会出现这样的异常情况。 Attendees:  wj-Mcat, nlp master, 吴京京 Huan, SRE (Site Reliability Engineer), zixia@zixia. net, PNP Rui, founder of Juzi. Bot Hao, CMO of Juzi. Bot Valerie{% include iframe. html src=”https://www. youtube. com/watch?v=_WmEry_yl0Y” %}  13:10 Project Application Statistics 20:25 How to work with students at Github ? 28:31 Kick off First Meeting with Students 43:42 Summer of Wechaty Admin 53：44 Volunteer/Prize of Wechaty 1:06:04 Milestone: Kick off Meeting for students 1:06:53 Milestone: Mid-Term Delivery 1:07:45 Three Blogs requiredAgenda: [wj-Mcat] Project Application Statistics:  (难度：低）开发基于 Wechaty 实现微俱乐部会员&amp;活动管理的微信小程序 @atorber 【已确定】 (难度：中）基于 Itchat 为 Python Wechaty 实现社区首个 Python 语言的本地 Puppet @wj-Mcat【已联系，未确定】 (难度：中）开发支持电信运营商 5G Chatbot / RCS 的 Wechaty 接入 Puppet 模块, @lijiarui, @IronConrad【已联系，未确定】 (难度：低）基于开放 API 封装 Wechaty 接口下的飞书聊天机器人 @Roxanne718【已联系，未确定】 (难度：高) 基于 WeChatExtension-ForMac 为 Wechaty 实现Mac版本Puppet @MustangYM @wj-Mca【已联系，未确定】 (难度：中) 基与 Blessed 的 Wechaty 命令行文本客户端软件（仿IRC）, @huan【已联系，未确定】 (难度：高) 基于 Matrix AppService Wechaty 项目的用户、群与消息等基础功能的完善, @huan, @yswtrue【未联系】 (难度：中) 开发支持 QQ 聊天软件的 Wechaty Puppet Provider 模块， @lijiarui 【已联系，未确定】 (难度：中) 基于 Wechaty Puppet Official Account 项目的用户与消息等基础功能的完善, @wj-Mcat【已确定】 (难度：中) 基于Wechaty 开发开源的二师兄社群逗乐机器人, #83 @Valerieeeee @atorber @ninetailskim【已联系，未确定】[wj-Mcat] How to work with students at Github ?:  Create a Repo in Org     [Huan] +1   [Rui] Create a Repo under the student’s account    Every Feature should be expanded with issue &amp; pr through OSPP2021     [Huan] +1   strict CI &amp; CD are required After Mid-Term   [Huan] +1 GitHub Actions   …   [wj-Mcat] Kick off First Meeting with Students:  Project Online sharing     Milestones   Pages   Wechaty Introduction Huan LI (李卓桓)   One Page PPT Self Introduction   Every attendee students self-introduction (30 seconds)   Project Sharing (5 - 15 MIN)   Ordered by issue #   Q/A (1 - 3 MIN)   Students Self-Introduction                  [wj-Mcat] Summer of Wechaty     OSPP 2021              Time: 6. 19 20:00~ 21:00   @Agravity   [Rui] Wechaty Summer of Code 2020 Kickoff Meeting   [Rui] Wechaty 社区 “暑期2020” 项目启动会, July 15, 2020    Next rotating chair: @Agravity Rotating bi-weekly More admins are wanted     Backup:         valeriewyd@gmail. com     Juzi. BOT Ricky Yin          Milestones:  Kick off Meeting for students     Time: 6-19 20:00 21:00   Organizer: @Agravity    Mid-Term Delivery     Add master protection   Add CI &amp; CD    Final-Term Delivery [Huan] 3 Blog posts required (DRAFT)     1st: Project proposal blog post: before 30, June, with slides (pdf) and embed video presentation (YouTube), with camera on   2nd: Mid-term report blog post: before 30, Aug, with with slides (pdf) and embed video presentation (YouTube) with camera on, with live coding   3rd: Final project report: before 30, Sep, with with slides (pdf) and embed video presentation (YouTube) with camera on, with live demo   "
    }, {
    "id": 105,
    "url": "https://wechaty.js.org/2021/06/08/introduction-to-grpc/",
    "title": "Introduction to gRPC",
    "body": "2021/06/08 - Overview: In gRPC, a client application can directly call a method on a server application on a different machine as if it were a local object, making it easier for you to create distributed applications and services. As in many RPC systems, gRPC is based around the idea of defining a service, specifying the methods that can be called remotely with their parameters and return types. On the server-side, the server implements this interface and runs a gRPC server to handle client calls. On the client-side, the client has a stub (referred to as just a client in some languages) that provides the same methods as the server.  gRPC clients and servers can run and talk to each other in a variety of environments - from servers inside Google to your desktop - and can be written in any of gRPC’s supported languages. So, for example, you can easily create a gRPC server in Java with clients in Go, Python, or Ruby. In addition, the latest Google APIs will have gRPC versions of their interfaces, letting you easily build Google functionality into your applications. Working with Protocol Buffers: By default, gRPC uses Protocol Buffers, Google’s mature open source mechanism for serializing structured data (although it can be used with other data formats such as JSON). Here’s a quick intro to how it works. If you’re already familiar with protocol buffers, feel free to skip ahead to the next section. The first step when working with protocol buffers is to define the structure for the data you want to serialize in a proto file: this is an ordinary text file with a . proto extension. Protocol buffer data is structured as messages, where each message is a small logical record of information containing a series of name-value pairs called fields. Here’s a simple example: message Person { string name = 1; int32 id = 2; bool has_ponycopter = 3;Then, once you’ve specified your data structures, you use the protocol buffer compiler protoc to generate data access classes in your preferred language(s) from your proto definition. These provide simple accessors for each field, like name() and set_name(), as well as methods to serialize/parse the whole structure to/from raw bytes. So, for instance, if your chosen language is C++, running the compiler on the example above will generate a class called Person. You can then use this class in your application to populate, serialize, and retrieve Person protocol buffer messages. You define gRPC services in ordinary proto files, with RPC method parameters and return types specified as protocol buffer messages: // The greeter service definition. service Greeter { // Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply) {}}// The request message containing the user's name. message HelloRequest { string name = 1;}// The response message containing the greetingsmessage HelloReply { string message = 1;}gRPC uses protoc with a special gRPC plugin to generate code from your proto file: you get generated gRPC client and server code, as well as the regular protocol buffer code for populating, serializing, and retrieving your message types. You’ll see an example of this below. To learn more about protocol buffers, including how to install protoc with the gRPC plugin in your chosen language, see the protocol buffers documentation. Protocol buffer versions: While protocol buffers have been available to open-source users for some time, most examples from this site use protocol buffers version 3 (proto3), which has a slightly simplified syntax, some useful new features, and supports more languages. Proto3 is currently available in Java, C++, Dart, Python, Objective-C, C#, a lite-runtime (Android Java), Ruby, and JavaScript from the protocol buffers GitHub repo, as well as a Go language generator from thegolang/protobuf official package, with more languages in development. You can find out more in the proto3 language guide and the reference documentation available for each language. The reference documentation also includes a formal specification for the . proto file format. In general, while you can use proto2 (the current default protocol buffers version), I will recommend that you use proto3 with gRPC as it lets you use the full range of gRPC-supported languages, as well as avoiding compatibility issues with proto2 clients talking to proto3 servers and vice versa. Service definition: Like many RPC systems, gRPC is based around the idea of defining a service, specifying the methods that can be called remotely with their parameters and return types. By default, gRPC uses protocol buffers as the Interface Definition Language (IDL) for describing both the service interface and the structure of the payload messages. It is possible to use other alternatives if desired. service HelloService { rpc SayHello (HelloRequest) returns (HelloResponse);}message HelloRequest { string greeting = 1;}message HelloResponse { string reply = 1;}gRPC lets you define four kinds of service method:  Unary RPCs where the client sends a single request to the server and gets a single response back, just like a normal function call. rpc SayHello(HelloRequest) returns (HelloResponse); Server streaming RPCs where the client sends a request to the server and gets a stream to read a sequence of messages back. The client reads from the returned stream until there are no more messages. gRPC guarantees message ordering within an individual RPC call. rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse); Client streaming RPCs where the client writes a sequence of messages and sends them to the server, again using a provided stream. Once the client has finished writing the messages, it waits for the server to read them and return its response. Again gRPC guarantees message ordering within an individual RPC call. rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse); Bidirectional streaming RPCs where both sides send a sequence of messages using a read-write stream. The two streams operate independently, so clients and servers can read and write in whatever order they like: for example, the server could wait to receive all the client messages before writing its responses, or it could alternately read a message then write a message, or some other combination of reads and writes. The order of messages in each stream is preserved. rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);FAQ: What is gRPC?: gRPC is a modern, open-source remote procedure call (RPC) framework that can run anywhere. It enables client and server applications to communicate transparently and makes it easier to build connected systems. Read the longer Motivation &amp; Design Principles post for background. What does gRPC stand for?: gRPC Remote Procedure Calls. Why would I want to use gRPC?: The main usage scenarios:  Low latency, highly scalable, distributed systems.  Developing mobile clients which are communicating to a cloud server.  Designing a new protocol that needs to be accurate, efficient, and language independent.  Layered design to enable extension eg. authentication, load balancing, logging, and monitoring, etc. Who’s using this and why?: gRPC is a Cloud Native Computing Foundation (CNCF) project. Google has been using a lot of the underlying technologies and concepts in gRPC for a long time. The current implementation is being used in several of Google’s cloud products and Google externally facing APIs. It is also being used by Square, Netflix, CoreOS, Docker, CockroachDB, Cisco, Juniper Networks and many other organizations and individuals. Which programming languages are supported?: See Officially supported languages and platforms. How do I get started using gRPC?: You can start with the installation of gRPC by following instructions here. Or head over to the gRPC GitHub org page, pick the runtime or language you are interested in and follow the README instructions. Which license is gRPC under?: All implementations are licensed under Apache 2. 0. Where is the documentation?: Check out the documentation right here on grpc. io. What is the road map?: The gRPC project has an RFC process, through which new features are designed and approved for implementation. They are tracked in this repository. What is the gRPC versioning policy?: See the gRPC versioning policy here. When do gRPC releases happen?: The gRPC project works in a model where the tip of the master branch is stable at all times. The project (across the various runtimes) targets to ship checkpoint releases every 6 weeks on the best effort basis. See the release schedule here. How can I report a security vulnerability in gRPC?: To report a security vulnerability in gRPC, please follow the process documented here. Can I use it in the browser?: The gRPC-Web project is Generally Available. Can I use gRPC with my favorite data format (JSON, Protobuf, Thrift, XML)?: Yes. gRPC is designed to be extensible to support multiple content types. The initial release contains support for Protobuf and external support for other content types such as FlatBuffers and Thrift, at varying levels of maturity. Can I use gRPC as a service mesh?: Yes. gRPC applications can be deployed in a service mesh like any other application. gRPC also supports xDS APIs which enables deploying gRPC applications in a service mesh without sidecar proxies. The proxy less service mesh features supported in gRPC are listed here. How does gRPC help in mobile application development?: gRPC and Protobuf provide an easy way to precisely define a service and auto-generate reliable client libraries for iOS, Android, and the servers providing the back end. The clients can take advantage of advanced streaming and connection features which help save bandwidth, do moreover fewer TCP connections, and save CPU usage and battery life. Why is gRPC better than any binary blob over HTTP/2?: This is largely what gRPC is on the wire. However, gRPC is also a set of libraries that will provide higher-level features consistently across platforms that common HTTP libraries typically do not. Examples of such features include:  interaction with flow-control at the application layer cascading call-cancellation load-balancing &amp; failoverHow do you pronounce gRPC?: Jee-Arr-Pee-See. "
    }, {
    "id": 106,
    "url": "https://wechaty.js.org/2021/06/08/how-to-get-a-weixin-chatbot-with-python-wechaty-and-paddlehub-and-aliyun/",
    "title": "手把手教你用python-wechaty+paddlehub+阿里云白嫖一个智能微信机器人",
    "body": "2021/06/08 - 这绝对是全网最细教程，没有之一 项目展示: 1. 搞定云服务器部分: 我这里是用的阿里云的云服务器，你也可以用其他的比如腾讯云的、华为云的等等。 1. 1 注册一个阿里云账号并完成实名认证: 阿里云官网: https://account. aliyun. com/  1. 2 点击底部的”免费试用”: 1. 3 点击右下角”了解试用”: 1. 4 选择一款产品: 1. 5 选择操作系统为Ubuntu, 点击”立即购买”: 1. 6 接下来打开控制台: 1. 7 找到左边的云服务器ECS打开: 1. 8 进入我们刚才创建的实例: 1. 9 点击”安全组”: 1. 10 点击”配置规则”: 1. 11 点击”手动添加”, “目的”栏填入8080/8080, “源”栏填入0. 0. 0. 0/0, 点击”保存”: 1. 12 回到刚才的页面, 点击”远程连接”: 1. 13 点击”立即登录”: 1. 14 要输入密码, 我们之前没有设置密码, 所以我们返回刚才的页面去设置密码: 1. 15 点击”重置实例密码”: 1. 16 设置新密码完成后, 再次进入远程连接:  1. 17 我们就进入到终端里面了: 1. 18 在终端里输入以下指令: 免费token申请地址: http://pad-local. com (温馨提示: 免费的token有效期为7天，如需使用有效期更长的token，请访问wechaty官网: https://wechaty. js. org/) 或者使用UUID，链接: https://www. uuidgenerator. net/version4 &gt;&gt;&gt; apt update&gt;&gt;&gt; apt install docker. io&gt;&gt;&gt; docker pull wechaty/wechaty:latest&gt;&gt;&gt; export WECHATY_LOG= verbose &gt;&gt;&gt; export WECHATY_PUPPET= wechaty-puppet-wechat &gt;&gt;&gt; export WECHATY_PUPPET_SERVER_PORT= 8080 &gt;&gt;&gt; export WECHATY_TOKEN= your_token_at_here &gt;&gt;&gt; docker run -ti --name wechaty_puppet_service_token_gateway --rm -e WECHATY_LOG -e WECHATY_PUPPET -e WECHATY_TOKEN -e WECHATY_PUPPET_SERVER_PORT -p  $WECHATY_PUPPET_SERVER_PORT:$WECHATY_PUPPET_SERVER_PORT  wechaty/wechaty:latest 1. 19 检查是否运行成功:  输入网址: https://api. chatie. io/v0/hosties/your_token_at_here，例如我输入的地址就是这个: https://api. chatie. io/v0/hosties/puppet_padlocal_ef0c112ddf9b49fdaa8242b87b83b030 如果返回了服务器的ip地址以及端口号，比如{“host”:”121. 43. 228. 90”,”port”:8080}，就说明运行成功了，如果返回的是{“host”:”0. 0. 0. 0”,”port”:0}，就说明没有运行成功1. 20 运行后会输出一大堆东西，这时候我们找到一个Online QR Code的地址点击进去: 1. 21 就会出现下面这个二维码，用微信扫码即可(温馨提示: 用哪个微信号扫二维码哪个微信号就是机器人): 1. 22 点击”登录”，”继续登录”:  1. 23 会看到最上面有一个”桌面微信已登录”就说明成功啦: 2. 在AI Studio上跑一个简单的ding-dong机器人: AI Studio官网地址: https://aistudio. baidu. com/aistudio/index 2. 1 创建一个脚本项目(温馨提示: 在notebook的终端里跑不起来): 2. 1. 1 点击”下一步”: 2. 1. 2 填好项目名称，项目标签，项目描述，点击”创建”: 2. 1. 3 进入项目: 2. 2 在run. sh文件中写入以下内容: pip install --upgrade pippip install wechaty# 设置环境变量export WECHATY_PUPPET=wechaty-puppet-serviceexport WECHATY_PUPPET_SERVICE_TOKEN=your_token_at_here# 运行python文件python run. py2. 3 在run. py文件中写入以下内容: import asyncioimport loggingfrom typing import Optional, Unionfrom wechaty_puppet import FileBox, ScanStatus # type: ignorefrom wechaty import Wechaty, Contactfrom wechaty. user import Message, Roomlogging. basicConfig(level=logging. INFO)log = logging. getLogger(__name__)class MyBot(Wechaty):       listen wechaty event with inherited functions, which is more friendly for  oop developer       def __init__(self):    super(). __init__()  async def on_message(self, msg: Message):           listen for message event           from_contact = msg. talker()    text = msg. text()    room = msg. room()        # 不处理群消息    if room is None:      if text == 'hi' or text == '你好':        conversation = from_contact        await conversation. ready()        await conversation. say('这是自动回复：机器人目前的功能有：\n1. 收到 ding ，自动回复 dong dong dong \n2. 收到 图片 ，自动回复一张图片')      if text == 'ding':        conversation = from_contact        await conversation. ready()        await conversation. say('这是自动回复：dong dong dong')      if text == '图片':        conversation = from_contact        # 从网络上加载图片到file_box        img_url = 'https://images. unsplash. com/photo-1470770903676-69b98201ea1c?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1. 2. 1&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80'        file_box = FileBox. from_url(img_url, name='xx. jpg')                await conversation. ready()        await conversation. say('这是自动回复：')        await conversation. say(file_box)  async def on_login(self, contact: Contact):    print(f'user: {contact} has login')  async def on_scan(self, status: ScanStatus, qr_code: Optional[str] = None,           data: Optional[str] = None):    contact = self. Contact. load(self. contact_id)    print(f'user &lt;{contact}&gt; scan status: {status. name} , '       f'qr_code: {qr_code}')bot: Optional[MyBot] = Noneasync def main():     doc     # pylint: disable=W0603  global bot  bot = MyBot()  await bot. start()asyncio. run(main())2. 4 运行任务: 2. 4. 1 启动命令填sh run. sh, 点击”提交”: 2. 4. 2 选择任务运行环境(双机四卡它不香吗): 2. 4. 3 任务要排队，等一小会儿看到在执行中了就可以点击”查看日志”了: 2. 4. 4 如果看到下面的这种情况就说明机器人已经跑起来啦，赶紧去给你的机器人发信息试一试吧: 3. 接入paddlehub模型使机器人更智能: paddlehub官网地址: https://www. paddlepaddle. org. cn/hub 模型库地址: https://www. paddlepaddle. org. cn/hublist 3. 1 在paddlehub找一个你需要的模型，这里我以图像生成模型作为演示: 模型地址: https://www. paddlepaddle. org. cn/hubdetail?name=animegan_v2_shinkai_33&amp;en_category=GANs 3. 2 修改run. sh文件: pip install --upgrade pippip install wechaty# 下载模型hub install animegan_v2_shinkai_33# 设置环境变量export WECHATY_PUPPET=wechaty-puppet-serviceexport WECHATY_PUPPET_SERVICE_TOKEN=your_token_at_here# 设置使用GPU进行模型预测export CUDA_VISIBLE_DEVICES=0# 创建两个保存图片的文件夹mkdir -p imagemkdir -p image-new# 运行python文件python run. py3. 3 修改run. py文件: import cv2import asyncioimport loggingimport paddlehub as hubfrom typing import Optional, Unionfrom wechaty_puppet import FileBox, ScanStatus # type: ignorefrom wechaty import Wechaty, Contactfrom wechaty. user import Message, Roomlogging. basicConfig(level=logging. INFO)log = logging. getLogger(__name__)# 定义paddlehub模型model = hub. Module(name='animegan_v2_shinkai_33', use_gpu=True)# 将图片转换为动漫风格def img_to_anime(img_name, img_path):  # 图片名保持不变  img_new_name = img_name  # 图片路径改变  img_new_path = '. /images-new/' + img_new_name  # 模型预测  result = model. style_transfer(images=[cv2. imread(img_path)])  # 将新图片存储到新路径  cv2. imwrite(img_new_path, result[0])  return img_new_pathclass MyBot(Wechaty):       listen wechaty event with inherited functions, which is more friendly for  oop developer       def __init__(self):    super(). __init__()  async def on_message(self, msg: Message):           listen for message event           from_contact = msg. talker()    text = msg. text()    type = msg. type()    room = msg. room()    # 不处理群消息    if room is None:      if text == 'hi' or text == '你好':        conversation = from_contact        await conversation. ready()        await conversation. say('这是自动回复：机器人目前的功能有：\n1 收到 ding ，自动回复 dong dong dong \n2 收到 图片 ，自动回复一张图片\n3 收到一张图片，将这张图片转换为动漫风格并返回')      if text == 'ding':        conversation = from_contact        await conversation. ready()        await conversation. say('这是自动回复：dong dong dong')      if text == '图片':        conversation = from_contact        # 从网络上加载图片到file_box        img_url = 'https://images. unsplash. com/photo-1470770903676-69b98201ea1c?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1. 2. 1&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80'        file_box = FileBox. from_url(img_url, name='xx. jpg')                await conversation. ready()        await conversation. say('这是自动回复：')        await conversation. say(file_box)      # 如果消息类型是图片      if type == Message. Type. MESSAGE_TYPE_IMAGE:        conversation = from_contact        await conversation. ready()        await conversation. say('这是自动回复：正在飞速处理中. . . ')        # 将msg转换为file_box        file_box = await msg. to_file_box()        # 获取图片名        img_name = file_box. name        # 图片保存的路径        img_path = '. /images/' + img_name        # 将图片保存到文件中        await file_box. to_file(file_path=img_path, overwrite=True)        # 调用函数，获取图片新路径        img_new_path = img_to_anime(img_name, img_path)        # 从文件中加载图片到file_box        file_box_new = FileBox. from_file(img_new_path)        await conversation. say(file_box_new)  async def on_login(self, contact: Contact):    print(f'user: {contact} has login')  async def on_scan(self, status: ScanStatus, qr_code: Optional[str] = None,           data: Optional[str] = None):    contact = self. Contact. load(self. contact_id)    print(f'user &lt;{contact}&gt; scan status: {status. name} , '       f'qr_code: {qr_code}')bot: Optional[MyBot] = Noneasync def main():     doc     # pylint: disable=W0603  global bot  bot = MyBot()  await bot. start()asyncio. run(main())3. 4 像之前一样提交任务就可以啦: 后记: 机器人目前还不太完善的地方:  只要收到一张图片就会自动去转换 可能会在图片转换的时候卡住，然后就处理不了其他信息了 只有这一个功能，更多功能等你自己去发掘啦更多功能:  请访问我的GitHub仓库: https://github. com/Lovely-Pig/paddlehub-wechaty 如果GitHub打不开的话，我在AI Studio上也准备了一个相同的仓库: https://aistudio. baidu. com/aistudio/projectdetail/1886330 觉得不错的话给我一个Star哦🎉🎉🎉参考资料:  AI Studio官网: https://aistudio. baidu. com/aistudio/index PaddleHub官网：https://www. paddlepaddle. org. cn/hub python-wechaty: https://github. com/wechaty/python-wechaty python-wechaty-getting-started: https://github. com/wechaty/python-wechaty-getting-started 教你用python-wechaty和web协议开发机器人 作者: Lovely-Pig，一只努力学习的可爱小猪 "
    }, {
    "id": 107,
    "url": "https://wechaty.js.org/2021/06/08/design-and-document-apis-with-swagger/",
    "title": "Design and document APIs with Swagger",
    "body": "2021/06/08 - What is Swagger and OpenAPI?: Swagger is a tool for designing, building, documenting, and mocking APIs. It uses the OpenAPI specification (yaml or json files) to describe requests, responses, and any other details about your RESTful APIs. Using this spec you can then generate documentation and even create a mock server. Setting up Visual Studio Code: Microsoft’s free Visual Studio Code provides a great set of tools to create, edit, and verify your OpenAPI spec files. After installing VSCode you should install these Extensions (unsurprisingly using the Extensions button on the left):  YAML (link) Swagger Viewer (link) OpenAPI Swagger Editor (link) Swagger Snippets (link, optional)Once you create a yaml (or json) file and add the basic OpenAPI structure, the API icon will appear on the left and you’ll have the option to preview the documentation using Shift+Option+P.  Create and edit your OpenAPI spec files: First off, create a *. yaml file. (I will be demonstrating examples in YAML, but JSON is also supported if you are more comfortable with that standard. ) Although you can browse through the specs, it’s probably best to start with a simple example — this describes a fictional API for the ubiquitous “Todo app”: openapi: 3. 0. 0info: title: Example Task Manager Project description: An example API documentation for a task manager.  version: '1. 0'servers: - url: 'https://example. com/taskmanager/'components: schemas:  Task:   type: object   properties:    title:     type: string     example: 'Buy eggs'     description: 'The description task to be done. '    completed:     type: boolean     example: true     description: 'True or false to mark whether the task has been completed. '    id:     type: integer     example: 3     description: 'A unique identifier for this task. ' responses:  error:   description: ERROR   content:    application/json:     schema:      type: object      properties:       message:        description: Describes the error in a human-readable format.         type: string        example: Permission denied.  parameters:  task:   name: id   in: query   required: true   description: The identifier of the task at hand.    schema:    type: stringpaths: /tasks:  get:   summary: Get tasks   description: Get a list of tasks   responses:    '200':     description: OK     content:      application/json:       schema:        type: array        items:         $ref: '#/components/schemas/Task' /task:  post:   summary: Create a task   description: Creates a new task   parameters:    - name: title     in: query     description: The new title of the task. Leave out if you don't want to change it.      schema:      type: string      example: Take the dog for a walk   responses:    '200':     description: OK     content:      application/json:       schema:        type: object        properties:         message:          description: Returns the id of the new task.           type: integer          example: 23    '500':     $ref: '#/components/responses/error'  put:   summary: Update a task   description: Modify the task's title or its completed status.    parameters:    - $ref: '#/components/parameters/task'    - name: title     in: query     description: The new title of the task. Leave out if you don't want to change it.      schema:      type: string      example: Take the dog for a walk    - name: completed     in: query     description: The completion status of the task. Leave out if you don't want to change it.      schema:      type: boolean      example: true   responses:    '200':     description: OK    '500':     $ref: '#/components/responses/error'  delete:   summary: Delete a task   description: Removes a task completely.    parameters: [$ref: '#/components/parameters/task']   responses:    '200':     description: OK    '500':     $ref: '#/components/responses/error'OpenAPI allows you to specify in detail the requests, endpoints, responses, and data types of your API. You can also define reusable components that you can then reference several times in your specs (to limit repeating yourself). Generate documentation: Undoubtedly your yaml files are beautiful, but ultimately the goal (or rather one of the goals) is to generate documentation that the less-geeky members of your team can read. In addition, you can live-preview your yaml changes which can aid you a lot while writing the specs. Though there are a number of different ways to generate documentation, I prefer using a command-line tool for generating a dependency-free (and nice-looking) HTML via redoc-cli. First, install redoc-cli with npm (here’s how to install npm in case you don’t have it yet): npm install -g redoc-cliNow you can generate a full HTML documentation from your OpenAPI specs. You can also start a server that watches for yaml file changes (super useful while you create the specs). Here’s how: # Generates the spec into a zero-dependency HTML fileredoc-cli bundle -o ~/desired/path/for/output/index. html ~/path/to/your/openapi. yaml# Starts a server with spec rendered with ReDoc. Supports SSR mode (--ssr) and can watch the spec (--watch)redoc-cli serve ~/path/to/your/openapi. yaml --watchYou can also automatically generate documentation using your CI — if you use Gitlab, then you can set it up easily so that docs are generated and published to Gitlab Pages using Gitlab’s shared runners.  What’s next: Other features of Swagger:  You can use Swagger CodeGen to generate code stubs for your server and client-side.  On the other hand, if you have existing code you wish to document you can follow solutions, stories, and tips for generating OpenAPI specs from existing APIs.  If you use Gitlab, then your docs can be generated and published to Gitlab Pages using Gitlab’s shared runners. "
    }, {
    "id": 108,
    "url": "https://wechaty.js.org/2021/06/06/gsod-2021-third-meeting/",
    "title": "GSoD'21 Third Meeting",
    "body": "2021/06/06 - Google Season of Docs’21 third meeting: Meeting Summary: It was the third meeting of the GSoD’21 participants, some grievances were to be resolved in the meeting, and they got resolved as well. In this meeting, firstly every participant gave one’s week summary and informed the community about their plans for the upcoming week. After that, I raised my concern regarding big PRs and we had a discussion about the scope and size of the PRs, next I asked for an explanation from the teams which had lacked to maintain the Wecahty Weekly follow-ups. Following that Simin gave a presentation on things you should remember when you are documenting. Later we had a suggestions/Q&amp;A session, in which Vasvi and Sajen raised their concerns and at last, we took a lovely group photo. {% include iframe. html src=”https://youtu. be/GE4Kq0JSdYE” %} Attendees: Total 12 attendees attended the meeting. They are:  Rohitesh Jain, Volunteer (UTC + 5:30) Sajen Sarvajith, Reconstruct Landing page writer (UTC + 5:30) Abhishek Jaiswal, How-to-guide section writer (UTC + 05:30) Simin Liao, Volunteer (+8:00) Mukosa Joseph mawa, Introductions and Explanations section writer (UTC +03:00) Rajiv Ranjan Singh, Improve the gRPC and OpenAPI ecosystem writer, rajivperfect007@gmail. com, (UTC+05:30) Souvik Biswas, Create easy to learn tutorials for beginner users writer, sbis1999@gmail. com (UTC +05:30) Soumi Bardhan, Improve References section writer (UTC + 5:30) Shwetal Soni, Create easy to learn tutorials for beginners users writer (UTC +05:30) Chris Estepa, Introduction and Explanations sections writer (UTC +08:00) Vasvi Sood, How to guides, contactvasvisood@gmail. com writer (UTC + 5:30) Arnab Saha, Reconstruction of Landing page with value propositions writer (UTC + 5:30)Notes:  Shraddha maybe had a network issue, everyone else was present. Agendas:  0:00:20 1. Week Summaries 0:15:10 2. Discussion about the scope and size of PRs 0:19:07 3. Explanation for not updating the Wechaty follow-ups 0:20:25 4. Presentation by Simin on things you should remember when you are documenting 0:29:00 5. Questions &amp; CommentsYou can learn more from our meeting notes. Meeting Outcomes:  The community got to know about the progress and plans of the members PRs would be more atomic (single PR will deal with a single task) Wechaty Weekly Follow-ups would be updated strictly Simin made it clear what should one remember while documenting Volunteer got to know the grievances of Sajen and VasviMeeting Follow-ups:  See what codes snippets are required by Vasvi and her team Review the new landing page design"
    }, {
    "id": 109,
    "url": "https://wechaty.js.org/2021/06/05/summer-2021-open-source/",
    "title": "Open Source 大咖说开源--wechaty的开源之路",
    "body": "2021/06/05 - 自我介绍: 高原：句子互动联合创始人&amp;CTO，开源项目Wechaty commiter，前亚马逊，Expedia工程师，Bot Friday联合发起人。 Wechaty开源之路直播纪实: {% include iframe. html src=”https://www. youtube. com/watch?v=0UMLAA1Pa-s” %} Agendas议程:    0:04:52 自我介绍     0:05:55 什么是wechaty     0:12:58 如何使用wechaty     0:22:18 wechaty的开源之路     0:39:39 基于wechaty的开源项目  1. 什么是Wechaty:  官方介绍：A Conversational RPA SDK for Wechat which can help you create a bot in 6 lines of javascript, with cross-platform support including Linux, Windows, Darwin(OSX/Mac) and Docker. 也就是帮助聊天机器人开发者快速搭建聊天机器人的框架，并且支持多个系统平台。Wechaty的使命：给聊天机器人的开发者提供一个最好的开源sdk，不断优化sdk，给开发者最好的体验。帮助开发者更多关注于逻辑应用，而不是与平台的底部对接上，只需关乎自己写上层应用的代码就可以了。开发者们的评价：腾讯的软件工程师，著名小程序vp框架的作者。在管理社区时用到了wechaty。并评价：”Wechaty is a great solution, I believe there would be much more users recognize it. ”谷歌工程师，好室友项目的创始人，创建了帮助留学生找房的平台，所有交互在微信群内，基于wechaty搭建了平台，并服务了5000左右的活跃用户。他评价：”太好用，好用的想哭”。Wechaty越来越受欢迎，从2016年的330star到现在的10000+star很难得，因为在GitHub上超过10000star的并不多。开发者遍布全球各地，来自不同的互联网公司：微软、腾讯、谷歌、阿里巴巴、百度等等。Contributor来自各个大厂的开发者，在使用wechaty时为我们贡献了代码，Wechaty已经被854个开源项目引用了，了解到还有许多非开源项目也在使用wechaty，真正使用的数量庞大。2. 怎样使用Wechaty:  用typescript举例子：  引入wechaty和二维码的包  创建新的bot并给他命名，加入：登陆事件，扫码事件（用到二维码的包），message的信息（在bot上收到message的情况）  六行代码实现聊天机器人  一个简单的叮咚的机器人：有人说叮，机器人会说咚大家可以去实现自己想要的任何逻辑，进行不同操作，获取消息后，对消息做不同的指令，做自己想要的逻辑，感兴趣的可以自己下载，随意玩一玩。 3. wechaty的开源之路: 大家应该知道怎么用了，现在开始讲一讲开源之路上面经历了哪些事情。 Wechaty始于chatbot爱好者：李卓桓，他是一个很懒又聪明的人，在2016年，微信还没有500人的上限，他的微信里有12859个联系人，数百个百人群，有1000+未读消息，而他会写程序会开源，希望自动化处理微信里的消息，过滤不必要的消息，抽取筛选重要信息并处理。 2016年的wechaty:支持微信、Web接入，当时只有300star。 到了2018年，微信网页版限制登录，一大部分用户无法使用，社区出现非网页版接入方案；为了开发者无缝切换方案，运行稳定，提升效率，实施了新的策略，实现方式和代码都不同，对wechaty进行了一次重大的重塑，引入Puppet概念，puppet是自动化测试的框架，相当于一个适配器。 绿色部分：为上层，是开发者直接接触到的部分，为不同的类，像刚刚例子中用到的，都是开发者在写业务逻辑时需要频繁调用使用的。红色部分（puppet）：抽象的概念定义好了与wechaty对接的抽象接口，下面的实现需要按照要求去实现，只要底层实现符合标准，就会无缝的对接到wechaty上面。底层实现会对接到不同的平台上，去做数据的交互，再提交到上层的wechaty上面。Puppet巨大的好处：不改动任何业务逻辑代码，切换环境变量即可切换底层实现；让开发者无需关注底层接入实现，只关心自己的业务逻辑；社区里不同的底层实现可以无缝交付到开发者手里，为后续的更多IM实现奠定了坚实的基础；就有更多的开发者愿意做底层接入，与上层开发者有更好的配合。 2019年，有趣的wechaty项目开始大量的出现。微信上的讨论无法在邮件列表中存档，也无法通过永久地址进行访问特定讨论内容，交流讨论内容多基于中文，对国际开发者不友好，阻碍了跨越国界的理解和互动，为了解决以上问题而出现了OSS. CHAT，OSS. CHAT的功能是：当用户在 GitHub 上发布 issue 或者评论 issue 的时候，对应的微信群内会收到消息；群主引导用户将重要信息在 GitHub 的 issue 中进行回复讨论，正常群内闲聊内容在群中讨论；发布的中文issue 会被自动翻译成英文。大家若感兴趣，加入方式如下： Getting Started Tutorial (video) GitHub Repo Community Meeting Notes 2020年，加入 2020 开源软件供应链点亮计划，极大程度的扩展了 Wechaty 支持的 IM 接入数量，多语言版本的 Wechaty，更多非 Javascript 语言的开发者涌入社区Wechaty 支持 Plugin 系统，写一份代码，可以在7个不同的主流平台上运行，只需要切换一下环境变量就可以。 2021年，参加了 Google Season of Docs，加入 2021 开源软件供应链点亮计划，Wechaty 主项目的 Star 数突破一万，网页版重新回归接入wechaty，更多新的有意思的IM的接入推进中。有很多来自全球各地的typewriter帮我们项目来优化我们的文档，目前还在推进中，大概有10个左右的typewriter在写。 终点和目标我们已经在一定程度上实现了我们的使命，现在的开发者已经可以很大程度上的只关注业务上的实现了，不必关注底层的实现，wechaty不敢说是做的最好的，但从开发者的反馈来看，我们已经是很成功的项目。 4. 基于wechaty的开源项目: 算卦机器人 https://wechaty. js. org/2020/06/28/build-divination-yibot/: 诗歌搜索机器人 https://wechaty. js. org/2020/07/07/wechat-poem-robot/: 聚会娱乐机器人 https://wechaty. js. org/2020/06/06/wechaty-game-bot/: 外卖机器人 https://wechaty. js. org/2019/12/23/wechaty-north-america-ricepo/: 中文学习助理 https://wechaty. js. org/2020/06/19/archyshuo-anki-assistant/: 奇绩创坛机器人 https://wechaty. js. org/2020/08/08/qijibot-sales-automation/: 工作日报机器人 https://wechaty. js. org/2020/07/11/wechaty-daily-report/: 若感兴趣，还有更多：https://wechaty. js. org/blog/ 最后，欢迎大家加入wechaty的社区，项目、文档、博客的地址。 项目：https://github. com/wechaty/wechaty文档：https://wechaty. js. org/v/zh/博客：https://wechaty. github. io/ 欢迎正在阅读的你参与其中: 如果有人有兴趣一起加入，一起来在企业级的scrm软件上面为营销过程提效的话，欢迎大家联系我，我们一起聊一聊能否一起合作。  作者:windmemory "
    }, {
    "id": 110,
    "url": "https://wechaty.js.org/2021/05/30/wechaty-local-forums-and-past-events/",
    "title": "Wechaty local forums and past events",
    "body": "2021/05/30 - Timeline: 2016:  【Talk】Node Party：Talk about chatbot     event intro: https://wechaty. js. org/2016/12/07/beijing-nodejs-meetup-party/   video: Wechaty 101 - from v0. 0 to v0. 7   blog: https://wechaty. js. org/2017/01/06/wechaty-101-presentation/   2017:  【Meetup】Wechaty Contributor First Dinner     blog: https://wechaty. js. org/2017/04/21/wechaty-meeting-dinner/   video: Wechaty Contributor Dinner (for Issue #4)    【Meetup】The First Wechaty WWDC Party in 2017     blog: https://wechaty. js. org/2017/06/06/the-first-chatie-wwdc-party/   video: I think @李卓桓 have the video, we can looking for him adding this to the list    【Talk】How to build chatbot using wechaty     event intro: https://www. itdks. com/index. php/Act/apply_upgrade/id/1453/mUid/12576. html   blog: https://wechaty. js. org/2017/07/13/how-to-build-a-chatbot/   video: https://www. itdks. com/Home/Course/detail?id=1318   panel talk: https://www. itdks. com/Home/Course/detail?id=1262    【Meetup】Shanghai WWDC - Wechaty Worldwide Developers Conference     blog: https://wechaty. js. org/2017/08/28/wechaty-shanghai-meetup/    【Talk】GDG(Google Developer Group) DevFest 2017 Beijing     event intro: https://www. itdks. com/Home/Act/apply?mUid=3049982&amp;id=1855   blog: https://wechaty. js. org/2018/01/25/how-to-build-face-blinder-bot/   video: https://www. itdks. com/Course/detail?id=7379    【Talk】Kubernetes Meetup     event intro: https://www. kubernetes. org. cn/3174. html   blog         http://rui. juzi. bot/presentation/2017-11-17-docker. html​- https://zhuanlan. zhihu. com/p/32290407​- https://blog. csdn. net/ghostcloud2016/article/details/80132999          video: http://2050. itdks. com/Course/detail?id=7751   2018:  【Meetup &amp; Workshop】Wechaty Contributor Dinner with Data Girls     event intro: https://www. huodongxing. com/go/techiefestival2018   blog:​- https://wechaty. js. org/2018/01/09/all-you-need-to-know-about-chatbot/​- https://wechaty. js. org/2018/01/14/wechaty-contributor-dinner-data-girl/​- https://wechaty. js. org/2018/01/29/girl-techie-festival/​- https://wechaty. js. org/2018/02/06/techie-festival-faq/   video: Wechaty Contributor Dinner - Jan 14, 2018    【Meetup】Wechaty Country Wide Developer Conference     blog: https://wechaty. js. org/2018/09/15/country-wide-developer-conference/   video: Wechaty Contributor Dinner - Sep 15, 2018    【Workshop】Build Wechaty Chatbot at OpenSource Factory     video：伊婷：动手实现微信聊天机器人    【Workshop】Build Chatbot Using Luis&amp;Wechaty at Intumit at Shanghai Microsoft Tech Summit 2018     event intro: https://mp. weixin. qq. com/s?__biz=MzU3OTk2MzA1Nw==&amp;mid=2247485042&amp;idx=1&amp;sn=c5561242099fda2269476240d6686d89   blog: https://wechaty. js. org/2018/10/21/microsoft-tech-summit-chatbot-quick-started/   2019:  【Interview】Microsoft Online Tech Forum     blog: https://wechaty. js. org/2020/04/17/microsoft-tech-forum-rui-interview/   video: https://www. youtube. com/watch?v=VnI2jl71-Y8    【Talk】Connect to Wechat: Bot Builder Adapter for Wechat Individual Account     blog：https://www. bot5. club/talks/botbuilder-wechaty-adapter/   event intro： https://www. bot5. club/events/seminar-minutes-6/    【Meetup】Frist WWDC in Silicon Valley     blog: https://wechaty. js. org/2019/08/31/wechaty-wwdc-in-silicon-valley/    【Talk】Wechaty in Peking University     blog: https://wechaty. js. org/2019/10/18/wechaty-pku-lecture/    【Talk】Global AI Bootcamp     event intro: The Global AI Bootcamp is a free one-day event organized across the world by local communities that are passionate about artificial intelligence.          Global AI Bootcamp: https://globalai. community/global-ai-bootcamp​- Global AI Bootcamp Beijing: https://globalai. community/global-ai-bootcamp/china-beijing          blog: https://wechaty. js. org/2019/12/20/microsoft-ai-global-training-camp-ends-in-beijing   video: Global AI Bootcamp 2019 - Beijing - How to build chatbot from zero to one   2020:  【Talk】Open-source Wechaty in Python, Go, and Java     video: BOT5. Club: Open-source Wechaty in Python, Go, and Java 2020#07   blog: I think we need a blog for this event on the meeting note. if anyone interested in doing this…    【Meetup】Wechaty Multi-language Developers Meetup     video: Wechaty Multi-language Developers Meetup - May 9, 2020   blog: I think we need a blog for this event based on the meeting note. if anyone interested in doing this…    【Talk】Microsoft Azure Show: Wechaty Story 2016 - 2020     video: 開源故事(第一期)- HuanLi   blog: https://wechaty. js. org/2020/05/19/open-source-wechaty-huan-2020/    【Talk】Microsoft Azure Show: How to build a chatbot deal with investors     video: 從零開始(第一期)-Rui Li   blog: https://wechaty. js. org/2020/05/19/qnamaker-juzi-bot-for-investors-rui/    【Event】Wechaty Plugin System Launch Event     event intro: https://mp. weixin. qq. com/s/8ISuUUGO1rZMYOJmpRpKUQ   video: Wechaty Plugin 插件系统发布会 (May 30, 2020)   blog: https://wechaty. js. org/2020/07/22/wechaty-plugin-milestone/    【Event】Wechaty Summer of Code 2020 Talk     event intro:​- https://isrc. iscas. ac. cn/summer2020​- http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html   video: Wechaty 开源点亮计划暑期2020 宣讲直播（June 8, 2020）   blog: We may need a blog if someone interested in this, you can refer this slides   Slides: https://docs. google. com/presentation/d/1ZLH37rQyRgChGqFCUDjA5rbVgBuRkVM4Tys-_ls0gs0/edit#slide=id. g88410f616d_1_20    【Talk】Multi Language Wechaty Beta Release Announcement!     blog: https://wechaty. js. org/2020/06/19/multi-language-wechaty-beta-release/   video: BETA Release: Multi-language Wechaty Announcement Event (June 19, 2020)    【Talk】Microsoft Global AI Bootcamp: How to build a chatbot on WeChat from zero to one.      video: How to build a chatbot from zero to one on WeChat - 佳芮 李(Jiarui Li)   intro: https://sessionize. com/s/rui/how_to_build_a_chatbot_from_zero_to/22836   blog: We need a blog…    【Talk】Multi-language Wechaty Meeting: Mocking, Code Quality, Puppet, and Restful API     video: Wechaty Developers’ Meeting - Puppet, Mock, and Restful API (Jul 5, 2020)   blog: https://wechaty. js. org/2020/07/05/multilanguage-meeting-notes/    【Meetup】Wechaty Summer of Code 2020 Kickoff Meeting     video: Wechaty 社区 “暑期2020” 项目启动会, July 15, 2020   blog: https://wechaty. js. org/2020/07/20/wechaty-soc-kick-off-meeting/    【Talk】Using Wechaty and Wechat Openai make a chatbot     event intro: https://mp. weixin. qq. com/s/6HyEZlwWbuRGY9T_KotXEw   video: 用「Wechaty」和「微信对话开放平台」做个助理 - WWC线上分享 July 16, 2020   blog: https://wechaty. js. org/2020/07/20/wechaty-openai-agent/    【Workshop】Wechaty Workshop for Puppet Makers: How to make a Puppet for Wechaty     video: Wechaty Workshop for Puppet Makers (Aug 4, 2020)   blog: https://wechaty. js. org/2020/08/05/wechaty-puppet-maker/    【Meetup】Wechaty in Guangzhou     blog: https://wechaty. js. org/2020/08/04/wechaty-guangzhou-gathering/   【Meetup】 Wechaty Contributor Meetup – Shenzhen   blog: https://wechaty. js. org/2020/08/09/wechaty-shenzhen-meetup/    【Event】Wechaty SoC Midterm Demo Day     video: Wechaty SoC Midterm Demo Day (Aug 22, 2020)   blog: We need a blog based on the meeting note for this event…    【Event】Wechaty Opensource in Nanjing Opensource Summit     video         [VLOG] Wehcaty社区南京开源峰会之旅     开源软件供应链2020峰会-李卓桓-Wechaty的开源之路     开源软件供应链 2020峰会-吴京京-Multi-Wechaty SDK for Chatbot          blog         https://wechaty. js. org/2020/12/31/summer-2020-student-developers/     https://wechaty. js. org/2020/12/08/python-wechaty-open-source-journey/     https://wechaty. js. org/2020/11/14/summer-2020-wechaty/     https://wechaty. js. org/2020/11/14/summer-2020-summit-talks/     https://wechaty. js. org/2021/02/17/summer-wechaty-nanjing-summit-journey/           【Meetup】2020 Wechaty 666: 6 lines of code, 6 platforms, and 6 languages     blog: https://wechaty. js. org/2020/12/30/wechaty-2020-dinner-666/   video: 2020 Wechaty 666 Developers Meetup, Beijing, Dec 30, 2020    【Talk】OSS. Chat, a bridge to the Apache Way in China     blog: Call for a blog… Refer OssChat Github , Meeting Notes , and the doc   intro: A presentation from ApacheCon @Home 2020 https://apachecon. com/acah2020/ The mission of the OSS. Chat project is to bridge the three-way communication and translation barriers between WeChat and other social platforms (future) and GitHub Issues and mailing lists to the open source development community, making ASF’s cultural, technical, and collaborative processes acceptable quickly and easily, rather than stumbling from the start. With Chatbot, an automated process mechanism, developers can more easily share and communicate information about the development of open source projects. In particular, the archiving and secondary induction of open information to the community is one of the things that we think is very meaningful. Through OSS. Chat project, we hope to further promote, disseminate, and even optimize the culture, technology, and collaboration of the Apache project community.    video:   OSS. Chat - A bridge to the Apache Way in China   OSS. Chat - A bridge to the Apache Way in China, by Huan, Oct 2020   Introducing OSS Bot: Sync GitHub Issues with WeChat Groups for Open-source Projects    【Event】Wechaty won opensouce award     blog: https://wechaty. js. org/2020/12/31/open-source-award-wechaty/    【Event】Wechaty author Huan won 2020 Year 33 opnesouce pioneer     blog: https://wechaty. js. org/2020/12/23/open-source-pioneer-huan/   2021:  【Meetup】Wechaty Summer of Code 2021 Kickoff Meeting     blog: https://wechaty. js. org/2021/03/14/summer-2021-kick-off-meeting/   video: Kick off meeting for Summer of Wechaty 2021, Feb 18, 2021    【Meetup】Wechaty GSoD’21 Technical Writers Meetup     video: Wechaty ![❤] Google Season of Docs: Kick-off meeting with 20 Technical Writers!    blog:     https://wechaty. js. org/2021/05/08/gsod-2021-selected-technical-writers/​   https://wechaty. js. org/2021/04/30/google-season-of-docs/    【Meetup】Wechaty Contributor Beijing Meetup     blog: https://wechaty. js. org/2021/04/05/wechaty-contributor-meetup/    【Event】Paddle Paddle &amp; Wechaty AI Chatbot     blog: https://wechaty. js. org/2021/04/22/wechaty-with-paddlepaddle/    【Talk】Opensource Wechaty     intro: https://www. startupgrind. com/events/details/startup-grind-beijing-presents-we-are-hosting-jiarui-li/   blog: We need a blog…   Reference:  Wechaty Blog Photo Album Wechaty Youtube Playlist Meeting Notes Brief Workshop Open Source Wechaty Slides Wechaty Commiters Talk"
    }, {
    "id": 111,
    "url": "https://wechaty.js.org/2021/05/30/simin-documentation-structure/",
    "title": "Documentation Structure",
    "body": "2021/05/30 - Documentation Structure: While documenting a software, the first thing you come across is how to structure the documentation. Similar to building a house, you begin by drawing the architecture of the building. With good documentation structure, the software will be more accessible. Users no longer have to undergo the “trial and error” phase, and could easily find the correct topic for their questions. In Wechaty project, the structure follows the Documentation system and is separated into four sections:  Tutorials How-to guides Explanation Reference      type   Tutorials   How-to guide   Reference   Explanation         oriented to   learning   a goal   information   understanding       must   allow the newcomer to get started   show how to solve a specific problem   describe the machinery   explain       its form   a lesson   a series of steps   dry description   discursive explanation       analogy   teaching a small child how to cook   a recipe in a cookery book   a reference encyclopaedia article   an article on culinary social history   According to the table, the first two sections (tutorials and how-to guide) focus more on practical steps. They provide clear instructions for the users to follow. On the other hand, the latter two sections (explanation and reference) focus more on theoretical knowledge. They provide background information about the software. Tutorials: Tutorials teach users how to implement the software step by step. The target audience are those with no experience to the software. The users are passive, and they are waiting for you to feed them the knowledge they need to know when they are trying to use the software.  From the picture above, the left side with bulleted points is detailed guidance for documenting tutorials. By following the notice, you can avoid writing out of scope. The right side is the drafted structure proposed by team tutorials (Souvik Biswas and Shwetal Soni) in week 1. The topics that need to further discussed are highlighted in red. The three highlighted topics under Quick start are similar to the topics proposed in project Explanation. In order to prevent overlapping, writers from team tutorials and team explanation will discuss about this part and refine their structures. For the five highlighted topics under Advanced Usage, they more or less contradict the guides no distraction and inspiring confidence mentioned on the left side. For example, Usage with Docker aligns with Usage with Heroku. The users need to figure out which platform they are going to use first, and then select the corresponding topics. This step requires more prerequisites than using Wechaty requires. The users may be frustrated and give up learning Wechaty at the end. Documents in tutorials should take proactive actions. Instead of providing a lot of information, you should arrange the lessons with just engough knowledge for your readers. How-to guides: The how-to guides is like a general Q&amp;A. It acts as a supporting role, so each topic in this section is independent. The target audience are not expected to follow the sequence and should have enough knowledge to look for the guides they need.  You can see the picture above. The left side with bulleted points provides information on how to write better how-to guides. With special emphasis on addressing a specific question or problem, topics in how-to guides can avoid overlapping with other sections, especially tutorials and reference. The right side is the drafted structure proposed by team how-to guides (Vasvi Sood and Abhishek Jaiswal) in week 1. The topics that need further discussion are highlighted in red. The first two topics Creat a bot and Add more functionality to your bot seemed okay at first glance. However, the two topics violates addressing a specific question. Instead of addressing particular problems, the two topics are too general and are actually explaining concepts. They are better to be categorized as tutorials. The rest of the topics highlighted in red are similar to the first two topics: they seemed perfect at first glance, but have to be carefully handled. In topics about messages, contacts, or rooms, writers will easily falling into the trap of listing down all functions, and try to explain as many as possible. This is out of scope. Instead of providing as many functions as possible, and telling users the software is very comprehensive, how-to guides are to fix specific questions. You don’t need to advertise or provide a dictionary here. The encyclopaedia thing should go into reference guides section. Reference guides: You can view the reference guides as an encyclopaedia, or wiki. The users will not follow everything in the contents, and will only look for what they need. Therefore, the organization and accuracy of reference guides become very important. You need to make sure that users can easily find the information themselves quickly, and will not get bored and give up during searching.  You can see the picture above. Same as the previous two sections, the left part with bulleted points tells you how to better construct reference guides, and avoid duplicated information with other sections. The right side is the drafted structure proposed by team reference guides (Shraddha Vasant Prasad and Soumi Bardhan) in week 1. The topics that need to pay more attentions are highlighted in red. The highlighted topics under API reference should be careful when you are documenting. People might tend to do too much and provide instructions in these topics. In how-to guides, they also mentioned similar topics but with steps on teaching users how to do. Reference guides should stay on “do nothing but describe”. Leave out other opinions or explanations that could only be a distraction, and focus on clear and complete description. Explanation: Explanation provides the background information of the software. The topics in here are not directly related with Wechaty, but are very helpful if you want to really master this software.  Just like the previous three sections, the guidelines of documenting explanation are listed in bulleted points on the left part. Focusing on providing the context, explanation section helps users to better understand what Wechaty is and the concepts of it. With the help of this section, users can not only know what they are doing, and also why they are doing. The topics highlighted in red on the right side need to be tackled carefully. There are also similar topic names in tutorials. You should not mix these two sections together. Tutorials provide instructions on how to run the three topics while explanation explains them. Only three topics are highlighted because this section is rather unique. You don’t have to be so worry about as long as you don’t try to teach users how to do things. "
    }, {
    "id": 112,
    "url": "https://wechaty.js.org/2021/05/24/how-to-build-a-panda-face-generator-with-paddlepaddle/",
    "title": "如何用paddlepaddle及wechaty制作熊猫头表情生成机器人",
    "body": "2021/05/24 - 很高兴能分享前段时间折腾的小项目，一只熊猫头表情生成机器人。因为本熊是个很热爱meme文化的人，而在聊天过程中，我总是需要表情包来支撑起我匮乏的语言表达能力以及抒发我无法通过文字表达的感情。这次使用wechaty和paddlepaddle制作了一个根据人像生成对应熊猫头的表情包制作机器人。经本人不正经的测试，本表情包制作机器人可以给你的对话增加更多的乐趣，聊天室内外充满了快活的空气~ 你可以在这里看到大致的效果{% include iframe. html src=”https://www. bilibili. com/video/BV1NK4y1N7m5” %} 项目介绍和使用: 项目的github仓库地址在刚想到将wechaty与paddlepaddle结合的时候，其实是有很多的想法的，除了这个表情包生成器，还有游戏，交互写故事等想法，最后选择先做了这个表情包生成器，因为它足够简单却有趣，作为第一个试水作品最合适了。简单介绍这个机器人的功能：1. 接收到人脸照片/视频会提取人脸,制作对应的熊猫头表情包2. 输入文字会给表情包的底部加上想要的文字 本项目使用的是没有使用token的网页登录的方式。因为一些个人原因整个项目分为两个大部分，一个是js端，用于分类消息类型，并向服务器端发送请求，这部分为wechaty的使用；另一个是django服务器端，负责处理js端发来的请求，制作表情包并返回结果，这部分则为paddlepaddle的使用。本项目基本上是采取解决不了问题就躲开问题的处理方式，所以有些地方的处理为了快速实践出功能，而采取了一些“非人类”的解决方法，还请大佬们见谅嘿嘿。 JS端，wechaty-getting-started目录下：set WECHATY_LOG=verboseset WECHATY_PUPPET=wechaty-puppet-wechatnpx ts-node examples/advanced/Panda-Face-bot. js Django端，PDjango目录下：python manage. py runserver 0. 0. 0. 0:8080 框架图 wechaty部分: 前面说的“个人原因”其实是因为python版本的wechaty我一开始没搞定，所以不得已采用“非人类”方式将整体架构拆开为两部分。当熟悉python版本后，完全可以把整个项目用python实践出来。Wechaty端,我直接魔改的官方的advance例子中的media-file-bot. js文件,增加了两个模块:1. 网络请求模块,因为我需要调用自己的django服务器,所以写了这一个模块,给自己的端口上发请求,然后处理返回的结果,返回表情包,或者告诉用户我没有在你发送的图片/视频中发现人脸网络请求部分，为一个get请求。用于发送文本和图像信息。因为wechaty端和django端都部署在了本地，所以图像的信息只是图像在本地的保存地址。对于get请求响应的处理则更简单，django端在顺利处理图像后同样会返回图片的本地地址，wechaty端只需构建filebox，然后发送即可。 2. 保存文字的模块,要针对不同的信息发出者,保存其对应的文字,结果保存在一个sender. json文件中这个部分是为了给我们的表情包加上文字。即是当一个用户发送一个文本消息时，则将用户id和这个文本作为一个键值对保存起来，在收到图片消息后，根据图片消息的id来找到其对应的文本消息，将这两者打包发送给django服务器端。但是这里遇到的一个问题：这个请求不太好解析中文字符。服务端受到的text会变成乱码，所以这里的“非人类”的处理方式是当收到文本消息时将键值对保存到json文件里。而在发送请求时，则发送用户的id（用户的id是没有中文字符的）；在服务端则根据id从json文件里查找id对应的文本。 服务器端部分: django的部分非常的简单,在view中添加一个处理get请求的方法就好,这部分处理一下请求中的数据,根据数据去调用pandaFace脚本就好。下面主动点讲一下pandaFace脚本。 pandaFace脚本则是处理图像的主文件,提供了处理图片和视频的方法. 大致的流程如下：1. 熊猫头表情包的人脸去除和人脸定位这里需要使用paddlehub中的两个模型，一个是ace2p，一个是face_landmark_localization。通过这两个模型来获取作为模板的原表情中“人脸”的位置，我们之后处理用户发来的人脸，要根据这个标准来缩放，并绘制到指定位置上。2. 接收到的图片的人脸的提取和缩放,处理到灰度图,适当添加对比和亮度同样使用上述的两个模型处理用户发来的肖像照，然后进入我花费时间最长的步骤——调整颜色。因为光照等原因，把图像转为灰度图的任务始终无法达到理想的效果。这里尝试了亮度、对比度、直方图等统一的方式做了一些处理，大家也可以进行测试。另外我觉得最可行的方法是直方图匹配，这方面值得继续改进。亮度调节对比对比度调节对比gamma方式调节histogram调节对比这部分试了很多个参数,但是对于不同的图片不太好做到统一,所以想到了直方图匹配(histogram match),但是这部分实验的图找不到了,之后补上,直方图匹配的代码也在脚本中提供了,但是默认并没有开启。直方图匹配的方法可以把人脸映射到和原版的表情包大概同一个色调,但是缺点是,直方图匹配的方式会损失细节,这样会出现跃迁式的像素变化,很丑,所以可能采用直方图匹配之后要做更多的处理。 3. 把2中的人脸根据1中的定位,贴到1中的熊猫头上opencv的简单操作，嘿嘿~4. 添加文字针对文字的方面,也通过归一化图片尺寸和一定的规则即可简单的添加在图片上。 总结+改进完善方向: 最终版本中没有开启直方图匹配(提供了这部分的代码,只是没有开启),但是还是可以尝试,直方图匹配后的结果图像”质量”更差,但是表情包的精髓不就是糊吗?糊到一堆水印,糊到满是包浆。最后统一采用了2. 2的对比和3的亮度,如果要改进的话,应该还是可以提升一下直方图匹配的效果。除了人脸处理模块,其他的部分需要改进的大概是舍弃掉这种js+django服务器的模式,这样的效果有点慢。在熟悉wechaty的python版本后，则可以直接抛弃这一方法。在频繁给django发送请求后,server端的cpu和内存”爆炸”,这部分不确定是django的问题还是Paddlehub的问题,目前这个问题似乎没有再出现(真是让人迷惑)。  作者: ninetailskim，始于兴趣 陷于技术 忠于瞎搞 "
    }, {
    "id": 113,
    "url": "https://wechaty.js.org/2021/05/23/gsod-2021-second-meeting/",
    "title": "GSoD'21 Second Meeting",
    "body": "2021/05/23 - Google Season of Docs’21 Week 1 meeting: Meeting Summary: It was the second meeting of the GSoD’21 participants, everyone has started their work and have pushed more than one PRs on GitHub. In this meeting, firstly every participant gave his week summary and informed the community about their plans for the upcoming week. After that, we had a bit of discussion about the vision for the Wechaty. Following that Simin led a discussion about style mistakes that are being frequently made in the PRs, next she introduces us to a follow-up checklist. Later we had a suggestions/Q&amp;A session, and at last, we took a lovely group photo. {% include iframe. html src=”https://youtu. be/rnpf520OTyI” %} Attendees: Total 13 attendees attended the meeting. They are:  Rohitesh Jain, Volunteer (UTC + 5:30) Sajen Sarvajith, Reconstruct Landing page writer (UTC + 5:30) Abhishek Jaiswal, How-to-guide section writer (UTC + 05:30) Simin Liao, Volunteer (+8:00) Mukosa Joseph mawa, Introductions and Explanations section writer (UTC +03:00) Rajiv Ranjan Singh, Improve the gRPC and OpenAPI ecosystem writer, rajivperfect007@gmail. com, (UTC+05:30) Souvik Biswas, Create easy to learn tutorials for beginner users writer, sbis1999@gmail. com (UTC +05:30) Soumi Bardhan, Improve References section writer (UTC + 5:30) Shraddha Vasant Prasad,Improve References sectio writer (UTC + 5:30) Shwetal Soni, Create easy to learn tutorials for beginners users writer (UTC +05:30) Chris Estepa, Introduction and Explanations sections writer (UTC +08:00) Vasvi Sood, How to guides, contactvasvisood@gmail. com writer (UTC + 5:30) Arnab Saha, Reconstruction of Landing page with value propositions writer (UTC + 5:30)Notes:  Arnab Saha joined a bit late but, everyone attended the meeting. Agendas:  0:00:18 1. Week Summaries 0:10:15 2. Discussion about the vision of Wechaty 0:13:15 3. Style mistakes frequently made 0:18:13 4. Follow-up Checklist 0:19:55 5. Questions &amp; CommentsYou can learn more from our meeting notes. Meeting Outcomes:  The community got to know about the progress and plans of the members Chris and Joseph need more time for coming up with a vision, it’s decided that they will come up with a vision soon Simin made tech writers aware of their style mistakes Tech writers received information about the follow-up checklist It’s clear that tech writers have no doubts regarding the performance bonus Simin will be coming up with a blog post regarding the documentation styles, guidelines &amp; rules Feedback has been collected for the next volunteers meeting"
    }, {
    "id": 114,
    "url": "https://wechaty.js.org/2021/05/18/win10-use-docker-build-web-protocol-server-develop-bot/",
    "title": "Win10通过Docker搭建Web协议服务开发机器人",
    "body": "2021/05/18 - 介绍: 背景介绍: 最近本人在自学编程，选择的是python语言，自学一段时间后，自我感觉理论知识良好，需要找项目实践。然后找到python-wechaty这个项目，并加入微信群。在四月底听到群里说web协议复活后，决定亲手尝试一下。在尝试的过程中，遇到不少困难，最终在群友们的指点下顺利的走通整个流程。也就是说顺利的执行了ding-dong-bot。考虑到群里可能也有和我一样的小白，所以决定记录一下自己开发的过程，并发表出来，希望能帮助和我之前有一样困惑的朋友，节约他们的摸索时间。 本文读者: 如果您不是和我一样的小白，那么这篇文章很可能就不适合您了。本文面向的读者是和我一样，在win10开发环境下，想用docker来搭建免费web协议服务，通过python-wechaty来开发机器人的小白或零基础的朋友。 开发环境: 本人的开发环境如下，win10系统版本号1909，Docker Desktop版本3. 3. 1，Pycharm版本2020. 3，python3. 7。 不同的版本环境下，可能会有兴许差异，请自我查验。 正文: 通过免费web协议服务来开发python-wechaty微信机器人分为两个步骤 docker启动web服务: 首先我们需要在docker启动web协议服务容器，启动docker容器之前，我们对其进行简单配置，考虑到我的系统是windows，所以并不支持export指令。在windows下，用set替代export。但是最后结果并不理想，容器在启动之后立马又关闭了，所以就不细说了。 经过对比启动docker其他的容器，并没用出现问题，因此我判断docker软件本身没有问题，最后在群友的帮助下，采用一条指令顺利启动docker容器，打开cmd。输入指令，指令如下 docker run -ti --name wechaty_puppet_service_token_gateway --rm -e WECHATY_LOG= verbose  -e WECHATY_PUPPET= wechaty-puppet-service  -e WECHATY_PUPPET_SERVER_PORT= 30001  -e WECHATY_TOKEN= e9b50dd4-e24d-409e-98aa-53e686101f0c  -p  30001:30001  wechaty/wechaty:latest 如果有朋友想复制使用的话，请全部复制，这是一条完整指令。简单介绍：wechaty_puppet_service_token_gateway 就是我们启动的容器的名字。WECHATY_PUPPET_SERVER_PORT= 30001 是指端口设定为30001。这个可以根据需要自己设定其他的数字。WECHATY_TOKEN= e9b50dd4-e24d-409e-98aa-53e686101f0c 绑定token到web协议服务，这个token是我用uuid自动生成的。在启动之前，请通过python脚本生成所需token。脚本如下： import uuidprint(uuid. uuid4())生成的token记录保存下来，请根据自己的需要，修改自己的token。 这样我们就成功的启动了一个端口在30001的docker容器。启动后cmd立马可以看到如下： 打开docker也可以看到容器已经顺利启动。 启动python脚本链接docker容器: 启动容器之后，接下来我们就需要用python脚本去链接这个容器， 脚本如下： import osimport asynciofrom wechaty import (  FileBox,  Wechaty,  Contact,  Message,  Room,)os. environ['WECHATY_PUPPET_SERVICE_ENDPOINT'] = '127. 0. 0. 1:30001'os. environ['WECHATY_PUPPET_SERVICE_TOKEN'] = 'e9b50dd4-e24d-409e-98aa-53e686101f0c'class MyBot(Wechaty):  async def on_message(self, msg: Message):           listen for message event           from_contact: Optional[Contact] = msg. talker()    text = msg. text()    room: Optional[Room] = msg. room()    if text == 'ding':      conversation: Union[        Room, Contact] = from_contact if room is None else room      await conversation. ready()      await conversation. say('dong')      file_box = FileBox. from_url(        'https://ss3. bdstatic. com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/'        'u=1116676390,2305043183&amp;fm=26&amp;gp=0. jpg',        name='ding-dong. jpg')      await conversation. say(file_box)asyncio. run(MyBot(). start())代码的主要部分来源于官方文档，我们需要做的就是两个事情，一个绑定web协议服务端口，因为我的docker容器是本地运行的，所以os. environ['WECHATY_PUPPET_SERVICE_ENDPOINT'] = '127. 0. 0. 1:30001' ，指定端口到本地的30001端口。第二个就是token进行一个绑定os. environ['WECHATY_PUPPET_SERVICE_TOKEN'] = 'e9b50dd4-e24d-409e-98aa-53e686101f0c'，如果不进行这个操作，执行程序就会报错，token不存在。这个token必须和我们之前配置docker容器的token保持一致，否则就无法执行。 代码写好后，执行代码，会出现一个二维码，要求我们扫码登录。 目前会有一个问题就是二维码太大了，无法扫描。不过官方很贴心的给了一个链接，点击链接就会跳转到一个可以扫描的二维码页面出了，扫码登录即可。 扫码登陆微信后就可以验证，发送ding，机器人会自动回复dong。 补充内容: 更改docker镜像位置，否则立马占满空间: 程序运行一晚上后，我发现我的C盘可用空间急速下降。通过调查发现，docker的镜像默认位置就是C盘，所以我需要通过更改docker镜像位置来避免C盘可用空间不足导致的程序崩溃。首先将docker镜像导出：我这里将镜像文件导入到e盘。 wsl --export docker-desktop-data e:\wsl2\docker\docker-desktop-data. tarwsl --export docker-desktop e:\wsl2\docker\docker-desktop. tar然后卸载之前的镜像： wsl --unregister docker-desktopwsl --unregister docker-desktop-data导入镜像文件： wsl --import docker-desktop e:\wsl2\docker\docker-desktop e:\wsl2\docker\docker-desktop. tar --version 2wsl --import docker-desktop-data e:\wsl2\docker\docker-desktop-data e:\wsl2\docker\docker-desktop-data. tar --version 2最后删除压缩文件： del e:\wsl2\docker\docker-desktop. tardel e:\wsl2\docker\docker-desktop-data. tar重新启动docker服务，就可以了。 多开docker容器，达成多开机器人的目的: 能不能同时启动多个机器人呢？我这边测试了一下是可以的。 首先需要再打开一个docker容器，给新的容器自定一个新的名字，同时指定不同的端口和token，新python脚本绑定的端口与token要与新开的docker容器一致。 然后启动docker容器，再启动python脚本，扫码登录后，测试结果如下： 关闭睡眠状态，保持程序的持续运行: 在中午离开电脑吃饭的时候，我发现机器人并没有回应我发送的ding，查看日志发现，因为电脑断网，虽然docker容器还在运行，python脚本也在运行，但是已经失去了网络连接，python脚本在请求重新扫码。后面分析，win10系统带有的自动睡眠功能会自动断网。导致程序运行失败。为了可以持续运行我的机器人，我选择暂时关闭睡眠功能。打开win10设置，选择系统，选择电源和睡眠，选择睡眠，设置成从不。这样你的程序就可以一直运行，而不会因为断网停掉。 特别提示：必须使用已经开通了微信支付的微信号扫码登录，否则登录失败，提示开通微信支付。 以上就是我本次尝试ding-dong-bot所遇到的一些情况的分享。 鸣谢: 感谢wechaty社区的辛苦工作，为我提供了可以免费使用的工具，也感谢python-wechaty社区，提供了python可用的测试脚本。 最后感谢Polygplot Wechaty Home微信群内小伙伴们的指点，否则我一定还需要更多的时间才能走通这个ding-dong机器人流程。  感谢您的阅读，考虑到本人水平极其有限，文章难免有差错，若读者发现文中错误，欢迎指正，或联系我修改。 参考链接：:  教你用python-wecahty和web协议开发机器人 Puppet Service: DIY 使用免费Web协议 How To Post a Blog"
    }, {
    "id": 115,
    "url": "https://wechaty.js.org/2021/05/18/gsod-2021-proposal-to-improve-the-grpc-and-openapi-ecosystem/",
    "title": "GSoD 2021 proposal to Improve the gRPC and OpenAPI ecosystem",
    "body": "2021/05/18 - About me: I considered myself a Polymath. I believe in rigorous and intuitive learning. Spend the majority of the time exploring different types of algorithms and contributing to open source. My interest lies in the fields of Algorithms, Computational Science, and Distributed Computing. Introduction: This is the project proposal for Improve the gRPC and OpenAPI ecosystem on which I will be working as a part of Google Season of Docs 2021. I have proposed my timeline to complete this work during a span of 9 weeks. The user docs site is designed to assist end-users in using a product or service. The excellent user docs site is significant because it provides an avenue for users to learn how to use the software, its features, tips, tricks, and resolve common problems encountered when using the software. It also reduces support costs and is part of the corporate identity of the product. The excellent user docs site is a sign of the healthiness of the product, the developer team. Without a good user docs site, a user may not know how to do the above things effectively and efficiently. User docs site can play a pivotal role in ensuring a product’s success because excellent communication is and will always be at the heart of any business or development. Fantastic documentation takes that communication and puts it in a manageable framework that everyone can access for success. Wechaty has two subsystems for providing the gRPC support: one is wechaty/wechaty-grpc and the other is wechaty/openapi. The related docs page is mainly at Polyglot/OpenAPI as well as other pages that have some OpenAPI associated docs. However, the Wechaty user documentation for gRPC and OpenAPI is currently outdated and incomplete. Therefore, there should be an improvement in both code and documentation. Project Goals:    Improving Polyglot/OpenAPI documentation in Wechaty docs website:      Improving Wechaty OpenAPI docs.    Adding a blog about both gRPC and OpenAPI.    Updating the History section and fetching all contents of the CHANGELOG. md file from wechaty/openapi repository using a script.    Adding learning resources section.       Improving repository documentation for both wechaty/wechaty-grpc and wechaty/openapi:      Generating and adding CHANGELOG. md file for both wechaty/wechaty-grpc and wechaty/openapi repository.    Removing the HISTORY section part from README for both wechaty/wechaty-grpc and wechaty/openapi repository.    Adding issue and pull request templates for wechaty/wechaty-grpc and wechaty/openapi repositories.    Adding CONTRIBUTING. md file for both wechaty/wechaty-grpc and wechaty/openapi repository.    Improving contributing guidelines of wechaty. js. org.    Adding and organizing learning resources section about third parties library and frameworks like gRPC, gRPC-Gateway, and Protocol Buffers, etc in both wechaty/wechaty-grpc and wechaty/openapi repository.    Creating logo for wechaty/wechaty-grpc repository.    Refactoring and breaking the READMEs for both wechaty/wechaty-grpc and wechaty/openapi repository into sub-section like Usage, Installation, Contributing, and Resources, etc.       Miscellaneous:      Adding Open Graph image metadata in the Docusaurus site of wechaty. js. org.    Adding Progressive Web Application support for the Docusaurus site and Jekyll blog.    Adding Swagger UI to Express Route by default in wechaty/openapi repository.    Format files that are necessary using Prettier for both wechaty/wechaty-grpc and wechaty/openapi repository.    Checking and fixing indentations, grammatical errors, typographical errors, and broken links across all the files, including previous and new documentations.    Project Timeline: Community Bonding (May 8 - May 17, 2021):  Zoom meeting schedule agreed.  Focus in the first two weeks before the start of the project will be on working through existing documentation and noting gaps areas. Doc Development Phase: Week 1 (May 18 - May 24, 2021):  Getting familiar with Wechaty projects.  Going through all the existing contents and documentation based on gRPC and OpenAPI.  Adding Progressive Web Application support for the Docusaurus site.  Adding Progressive Web Application support for the Jekyll blog. Week 2 (May 25 - May 31, 2021): In Polyglot/OpenAPI documentation in Wechaty docs website:  Adding Open Graph image metadata in the Docusaurus site of wechaty. js. org.  Adding more details in the Getting Started section.  Adding a blog about both gRPC and OpenAPI. Week 3 (June 1 - June 7, 2021): In Polyglot/OpenAPI documentation in Wechaty docs website:  Updating the History section and fetching all contents of the CHANGELOG. md file from wechaty/openapi repository using a script.  Adding learning resources section. Week 4 (June 8 - June 14, 2021):  Generating and adding CHANGELOG. md file for both wechaty/wechaty-grpc and wechaty/openapi repository.  Removing the HISTORY section part from README for both wechaty/wechaty-grpc and wechaty/openapi repository. Week 5 (June 15 - June 21, 2021):  Adding issue and pull request templates for wechaty/wechaty-grpc and wechaty/openapi repositories.  Adding CONTRIBUTING. md file for both wechaty/wechaty-grpc and wechaty/openapi repository.  Improving contributing guidelines of wechaty. js. org. Week 6 (June 22 - June 28, 2021):  Adding Swagger UI to Express Route by default in wechaty/openapi repository. Week 7 (June 29 - July 4, 2021):  Adding and organizing learning resources section about third parties library and frameworks like gRPC, gRPC-Gateway, and Protocol Buffers, etc in both wechaty/wechaty-grpc and wechaty/openapi repository.  Creating logo for wechaty/wechaty-grpc repository. Week 8 (July 5 - July 11, 2021):  Refactoring and breaking the READMEs for both wechaty/wechaty-grpc and wechaty/openapi repository into sub-section like Usage, Installation, Contributing, and Resources, etc.  Format files that are necessary using Prettier for both wechaty/wechaty-grpc and wechaty/openapi repository.  Checking and fixing indentations, grammatical errors, typographical errors, and broken links across all the files, including previous and new documentations. Project Finalization Phase: Week 9 (July 12 - July 18, 2021):  Finalizing the project deliverables and refactoring the code, if any, based on the feedback.  Making the project report.  Finalizing and submitting the project report. "
    }, {
    "id": 116,
    "url": "https://wechaty.js.org/2021/05/16/gsod-2021-week1-meeting/",
    "title": "GSoD'21 Week 1 meeting",
    "body": "2021/05/16 - Google Season of Docs’21 Week 1 meeting: Meeting Summary: It was the first meeting of GSoD’21 participants after the selection announcement, I was excited to meet them all, I am glad that I got a chance to host this wonderful meeting. In this meeting, firstly we had a discussion to set up a day and a time for future meetings, after that every participant gave his week summary and told us about their plans for the upcoming week. After that, we discussed whether we should stretch the main project’s timeline or not. Next Simin leads a discussion about documentation structure and style. Later we had a suggestions/Q&amp;A session, and at last, we took a lovely group photo. {% include iframe. html src=”https://youtu. be/y2APh819H1U” %} Attendees: Total 13 attendees attended the meeting. They are:  Rohitesh Jain, Volunteer (UTC + 5:30) Sajen Sarvajith, Reconstruct Landing page writer (UTC + 5:30) Abhishek Jaiswal, How-to-guide section writer (UTC + 05:30) Simin Liao, Volunteer (+8:00) Mukosa Joseph mawa, Introductions and Explanations section writer (UTC +03:00) Rajiv Ranjan Singh, Improve the gRPC and OpenAPI ecosystem writer, rajivperfect007@gmail. com, (UTC+05:30) Souvik Biswas, Create easy to learn tutorials for beginner users writer, sbis1999@gmail. com (UTC +05:30) Soumi Bardhan, Improve References section writer (UTC + 5:30) Shraddha Vasant Prasad,Improve References sectio writer (UTC + 5:30) Shwetal Soni, Create easy to learn tutorials for beginners users writer (UTC +05:30) Chris Estepa, Introduction and Explanations sections writer (UTC +08:00) Vasvi Sood, How to guides, contactvasvisood@gmail. com writer (UTC + 5:30) Arnab Saha, Reconstruction of Landing page with value propositions writer (UTC + 5:30) Agendas:  0:00:14 1. Requesting participants to join the Wechaty mailing list 0:00:50 2. Discussion for fixing the day and the time for future meetings.  0:03:40 3. Week Summaries &amp; plans of the participants 0:13:35 4. Discussion for resolving timeline conflicts 0:15:20 5. Discussion about documentation structure and style 0:41:00 6. Questions &amp; CommentsYou can learn more from our meeting notes. Meeting Outcomes:  Everyone joined the Wechaty mailing list Sunday has been voted as the day for the weekly meetings Future meetings will be scheduled on 19:00 UTC + 8 The main project’s timeline got stretched from 12 to 17 weeks It’s decided that the project overlaps will be resolved by the next Friday (21 May) We will be using PR’s for documentation review It’s decided that there will be no mid review week Tech writers got to know how they are supposed to contact volunteer(s) based on their preferences which are written in the communication section of the volunteer proposal"
    }, {
    "id": 117,
    "url": "https://wechaty.js.org/2021/05/13/gsod-2021-improve-introduction-and-explanation-project-joint-proposal/",
    "title": "Google Season of Docs 2021 Team Proposal - Introduction and Explanation",
    "body": "2021/05/13 - This is the joint project proposal for Improve the Introduction and Explanations secondary project under Google Season of Docs 2021. It is estimated that this project will take approximately 06 weeks. Technical writers: Mukosa Joseph Mawa: I am a self-taught web developer and technical writer with a passion for open source software. I have published a number of beginner friendly technical articles on dev. to and freeCodeCamp. Before transitioning into tech, I was a high school teacher. One of my core responsibilities as a teacher was simplifying and sequencing text written in complex technical language for learners to easily understand. I have also been a frequent contributor to a couple of open source software. Notable ones are ocaml. org and disease. sh. Chris Estepa: Currently, I am a full-time technical writer supporting users how to use their applications by creating how-tos, video tutorials, training materials, FAQs, and requirement analysis documents, among others. I love technical writing because it being a combination of communication and technology allows me to write and provide support to users, especially newbies. I know the pain and frustration of not getting the information that the users need and now, I am here to help users through my writing. Through GSOD and Wechaty, I will be able to engage more users to have a wonderful experience with their Wechaty chatbots. Proposal Video Presentation: {% include iframe. html src=”https://youtu. be/HghT9K8JNSI” %} Project title: Improve the Introduction and Explanations sections of wechaty. js. org. Project scope: The scope of this project is limited to improving the Introduction and Explanation sections of the wechaty. js. org website. Project goal: Our goal is for users not to lose interest upon landing on the Wechaty site. We plan to make the Introduction section succinct and engaging by also showing them what they are looking for and what they will be getting when they start creating their very own chatbots. More useful information will be shown in Explanations, to help users further understand and appreciate what Wechaty can do for them. We aim to have a strong documentation that would stand the test of time. Analysis of the Introduction and Explanations sections of wechaty. js. org: After the analysis of the Introduction and Explanations sections, the following issues have been identified:  There are irrelevant content which are not suitable for the introduction.  There are missing and incomplete pieces of information.  Provided explanations are not comprehensive and incoherent.  The sections are poorly structured.  There are lots of typos and grammatical errors.  The section is too long for an introduction.  The sections are too nested and as a result, hiding certain information which should be on the front page.  Some pages lack visual representation that would be comprehensive to users.  Some information may not be understood easily by non-technical users.  Some pages need a more straightforward explanation. Some descriptions in the explanations are not comprehensiveThere are many blank and orphaned pages. Purpose of Introduction section of wechaty. js. org: The introduction section of wechaty. js. org serves the following purposes:  Help technical and non-technical people understand what Wechaty is.  Help potential individual and institutional users of Wechaty understand some of the business challenges/problems they can solve by using Wechaty.  Help total beginners understand how to start using or learning Wechaty.  Helps the user understand why and what sets Wechaty apart from other chatbot makers. Purpose of explanation section of wechaty. js. org: The explanation section of wechaty. js. org serves the following purposes:  Describe other concrete pieces of information which have not been covered in other areas of the documentation in an easy manner understood by all types of users esp. non-technical users.  Deepen and enrich users’ knowledge of Wechaty by providing alternative/contrary viewpoints and approaches than what has been presented in other sections of the documentation.  Educate users and arouse their interest by showing the technical, non-technical and business side of Wechaty which have not been covered in other sections of the documentation. Project approach: This is a brief overview of how we intend to approach the project in an attempt to solve the identified problems. This plan will change as feedback is sought from the stakeholders. We propose the current Introduction section to be replaced by the following content. This however will mostly depend on the final decision on how the entire wechaty. js. org is to be designed, or structured since there are quite a number of technical writers writing proposals on how to improve the different sections of wechaty. js. org. Proposed content for Introduction section: It is proposed that the following questions should be used as guide when writing the introduction section: What is Wechaty?: This section should include the following:    Brief introduction to what Wechaty is   This must be written for both technical and non technical audiences. Meaning of acronyms such as IM, SDK, etc. should be made explicitly clear by linking to their full versions. Thus, whoever is not familiar with it can look it up and understand what is being talked about.     Who are the People/Companies behind Wechaty?   Who are the original creators of Wechaty? When was it created? Are there companies, individuals, government, and entities supporting the development of Wechaty? Are there companies who have supported the development of Wechaty in the past or planning to provide support in the future?     How many releases have been made since its creation?   What is the current stable version of Wechaty? How many releases have been made since its creation? Are there plans for another major release? Are there ongoing major projects around Wechaty at the moment?     Original motivation for creating Wechaty   What was the story behind Wechaty? Every software project must seek to provide a solution to a business or societal problem. What were the founders of Wechaty seeking to solve by starting Wechaty? This area will need a lot of input from the creators of Wechaty.     The long term Vision and Mission of Wechaty   This must be well thought of because it will give a sense of confidence to users of Wechaty about long term support and development. A person who wishes to solve a business problem using Wechaty should feel confident that there are visionary people committed to the long term development of the software their business runs on. This area will also need a lot of input from the creators of Wechaty.  What can you do with Wechaty?: This section should comprehensively cover the following:    What problems can businesses/ individuals solve with Wechaty?   This section will give a Wechaty user the motivation to learn and use Wechaty if it is properly articulated. It gives users a sense of purpose if they notice that Wechaty is capable of solving a business challenge that they are facing.   What business problems have been solved by using Wechaty? How has Wechaty solved the problems of people/businesses?Who is using Wechaty?: In this section, we need to get testimonials from people/businesses who have used Wechaty before and how they find Wechaty. What are they saying about Wechaty? How has Wechaty solved their problem?This section should seek to comprehensively answer the following questions:  Which companies/individuals are using Wechaty? Are there testimonials from users of Wechaty on the value it has delivered to their businesses? Here, we also need to provide links to the live Projects built using Wechaty. Proposed content for Explanations section: The Explanation section is primarily for broadening the documentation’s coverage of the different topics therefore its content will very much depend on the other sections of the documentation. The outline below is not cast in stone. Some items might be removed or added as the different projects evolve. It is proposed that the following should be used as guide when writing the Explanation section:    Overview   This will be discussed based on a high level perspective but in a way that most users (esp. newbies) would understand. This page will let users know other information that they have to know. In order to do this, we will need more information from the subject-matter experts.     Lifecycle   A concise explanation on the typical phases in the development (including some activities and deliverables being done) of Wechaty to inform users, sponsors, and investors about what is happening with the project.     Architecture   A short but thorough chatbot architecture must be explained here. A diagram would also make the explanation clearer.     Alternatives   In this section we shall present alternatives to Wechaty.     Testing   An overview on how we perform testing is imperative so that users would know what is being tested, what to expect and not to expect, and learn more about the bugs and defects that we encounter while using Wechaty. Other types of issues can be discussed here, including the types of actions and expected output or solutions. Triaging of bugs and issues may be clearly specified here, by highlighting the issues and the bugs that need intensive testing. Priorities may also be established including the severity of the bugs, whereby the Wechaty team would know what the problems are and how to deal with them.     DevOps CI/CD   We can explain how Wechaty uses and benefits from DevOps and CI/CD processes. Some information is needed from the SMEs to expound this.     Software Development Kit (SDK)   Conversational and Robotic Process Automation SDK information will be discussed here.     Troubleshooting   In this section, we will determine and pinpoint the most difficult and most common problems that users encounter. On the spot solutions are provided here to enable users to learn what to do first hand upon encountering issues.  Proposed solution: We propose to improve the structure and documentation approach of the Introduction and Explanations sections. These are critical sections that any user must read to fully understand what Wechaty is all about. Other to-dos or suggestions:  Include a diagram, workflow, or any other visual representation to make the sections more comprehensive and informative.  Include Other Related Pages links for better and easier navigation.  Include a Contact Us page that contains some support links or a form where users can write their questions and suggestions.  Include testing and friction logs that will serve as good references in the future. Things to pay attention to while writing the introduction and explanations sections:  Use simple English that a non-native speaker can easily understand without having to look for the meaning of words or phrases.  Avoid long sentences.  Minimize use of acronyms and initialisms.  Avoid unnecessary long paragraphs which might confuse beginners.  Use formal language.  Be gender-sensitive. Gender neutral language is better.  Pay attention to grammar and spelling.  Pay attention to technical accuracy. Proposed timeline: It is estimated that this project will take six weeks. Below is the estimated timeline and the subtasks which will be accomplished. It is worth pointing out that the processes below are not linear. They are iterative, cyclical, and can change whenever feedback is received from different stakeholders and therefore, incorporated in the project.    Week 1: Hiring process      Refining proposal to meet stakeholder needs/expectations      Week 2: Introduction      What is wechaty section   What can you do with wechaty section   Who is using Wechaty section   Integrating feedback from stakeholders   Miscellaneous      Week 3: Introduction      Getting started with Wechaty   Main concepts in Wechaty      Week 4: Explanation      Life Cycle   Architecture   Testing   Troubleshooting      Week 5: Explanation      DevOps CI/CD   SDK   Troubleshooting      Week 6: Project Evaluation      Project Evaluation   Project budget: The project budget is 1000USD which will be shared equally between the two technical writers "
    }, {
    "id": 118,
    "url": "https://wechaty.js.org/2021/05/12/gsod-2021-volunteering-proposal/",
    "title": "Google Season of Docs 2021 Team Proposal - Volunteering",
    "body": "2021/05/12 - GSoD’21 Project Proposal for Volunteering: Read more about the volunteers in their individual project proposals  Rohitesh’s individual project proposa Simin’s individual project proposaProposal Video Presentation: {% include iframe. html src=”https://www. youtube. com/watch?v=q2Q5eFCa7dQ” %} Roles and Responsibilities of Rohitesh:  Write Final project report Draft case study and other docs for Google.  Create a monthly evaluation post.  I will Organize weekly meetings with Wechaty meeting notes, and make sure the meeting is on time and everyone is on the same page.  I will write meeting notes &amp; publish blog posts with zoom meeting recording videos on YouTube embedded.  Help org complete three follow-up surveys which will be held in 2022.  I Will create my own WhatsApp bot using Wechaty and give feedback on the current state of documentation. Deliverables:  13 weekly meeting posts 1 case study and 1 final project report 3-4 monthly evaluation blog posts Organize 10-11 meetings and maintain their notes, along with their YT videos. Roles &amp; Responsibilities of Simin:  Give suggestions and feedback on the delivered documentation and review PRs within 2-3 days.  Edit and proofread documents according to Google Standard before merging them.  Make sure tech writers are following their respective timelines and report to Huan if they are trailing behind.  Read the existing documentation and reconstruct or tell where the documentation is lacking. Deliverables:  Review PRs of all the tech writers Make sure everything is on time and take actions if somebody is trailing behind Give suggestions about documentation Proofread documentationCommon Responsibilities:  Collaborate with other volunteers and org members.  Audit the final performance of the tech writers.  Notify the other volunteer by email to the Wechaty mailing list when, we can not be on duty, and take the responsibilities from the other when they can not be on duty by accident. Communication:  The two volunteers have set up their private communication channel on WhatsApp we will have a private zoom meeting if felt necessary.  Wechaty Community Zoom Address:     http://zoom. us/j/6505033788   Passcode: huan   Rohitesh  I will be in touch with the org via mailing list, Gitter and GitHub.  I will be happy to reply to personal messages on Gitter, Gmail and Whatsapp (+91 8882232063)Simin  I will be in touch with the org via mailing list, Gitter, and GitHub, and you could find me through Gmail, WhatsApp, or WeChat (ID: siminmin1128). Project Budget: Budget: $500 (each) Additional Notes: Guidelines for video-recording/downloading/uploading:  Download the recording which has shared screen along with the gallery view Crop the video at the beginning and at the end of the meeting, video should start form the beginning of the meeting Add a beautiful thumbnail to the video Highlight the most important agenda of the video by adding timestamps like kick-off meeting recordingThanks for reading our post. Cheers! Best, Volunteers "
    }, {
    "id": 119,
    "url": "https://wechaty.js.org/2021/05/12/gsod-2021-reconstruct-landing-page-team-proposal/",
    "title": "Google Season of Docs 2021 Team Proposal: Reconstruct Wechaty landing page with value propositions",
    "body": "2021/05/12 - Team Members: Name : sajen sarvajith k, Arnab Saha Email : (Sajen) sajenjeshan1222@gmail. com, (Arnab) arnabsaha285@gmail. com GitHub : (Sajen) https://github. com/sajenjeshan1222,(Arnab) https://github. com/encodeArnab Telephone : (Sajen) +91 9150165487, (Arnab) +91 9625511367 Time Zone : Asia / Kolkata (GMT+5:30) - IST Proposal Video Presentation: {% include iframe. html src=”https://youtu. be/y1DBcSEu0b4” %} Motivation (sajen sarvajith): My passion in deep learning, Natural Language Processing and documentation and my interest to work for an internationally reputed open source organisation made me apply for this Wechaty project. Ideally this project will allow me the opportunity to utilize my experience gained as an Wechaty GSoD intern. I believe that there is no better place to continue my coding and documentation skills through this platform. I consider it a vibrant experience to get the opportunity to meet mentors from all over the world and learn about new technologies. I am a very diligent and highly motivated student, and I am certain to push through with dedication. I have always worked to accomplish my goals and gain more knowledge and insight into quantum neural networks, deep learning and documentation. I will be able to contribute to this community in the best way I can. Project Title:  Reconstruct Wechaty landing page with value propositions  Synopsis:  Abstract Structure for the proposed documentation Task Expected Results Implementation/Approach Timeline Conclusion Additional IdeaAbstract: Most of the new users come to wechaty website by landing on the landing homepage. Unfortunately, the landing page is too simple and lacks enough information for new users, especially no value proposition. This problem leads to losing lots of new users, or making new users take more time to understand what wechaty can do and why we are the best. In online marketing, landing pages are used to drive visitors towards conversion by getting them to click through to specific action. That action could be anything from encouraging users to make purchases on an online store or in our case to make use of wechaty or countless other actions. Whatever it is, there should be just one, clearly-defined CTA (call-to-action). As opposed to being a full-blown professional website, a landing page is a single page with a highly specific target: getting visitors to click through to our end goal. This project aims to improve/reconstruct the wechaty homepage completely with value propositions. I think that landing page is the key of wechaty to attract more users because everytime when a user comes the first thing they see about wechaty is the landing page, so the landing page should be well designed, attractive and explain about the wechaty in a short, sweet and uncluttered manner. Structure for the proposed documentation:  The proposed Structure of the Landing page is as follows: Introduction Section: Describe about Wechaty and various products and services it offers. It will also contain value propositions. Wechaty helps in creating a bot with just 6 lines of code! This is a strong point for attracting users to Wechaty.  Recent Blogs: The section should include 2-3 recent highlighted blogs.  User Experience: The landing page should contain a section for testimonials of the customers of Wechaty, so that customers are attracted. It can act as a powerful tool for persuasion.  Use Cases: A section to demonstrate the various use cases to excite the developers and encourage them to try the product .  Consist of a navbar to navigate to various sections. This is an example design for Wechaty Landing Page (as per available insights and can be changed based on mentor and community suggestions) Complete Design can be viewed here Task:  To reconstruct landing page with value propositions Identify all the benefits of wechaty offers Describe what makes these benefits valuable Identify our new users main problem Connect this value to our users problem Differentiate wechaty as the preferred provider of this valueExpected Results:  A clean and a well constructed landing page with value proposition This will have reconstruction plan and other details that is provided here Provide high-quality content that inspires confidence Make it easy to convert Have a flawless design Have a clear call to action Create eye catching headlines Contain engaging copy Make it about the visitors Make use of videos where appropriate Should be easy to scan at a quick glance Contain relevant, quality images Look gorgeous and act classy Broadcast users trust signals Have been through many rounds of testing Have conversion tracking turned onImplementation / Approach: Below explanation regarding the significant steps for this landing page with value proposition Set Campaign Goal:  Every great landing page starts with a clear and measurable goal. This will help to figure out what element we need on wechaty landing page, how to write a copy, and the template we should use. Write a Copy:  While most folks are eager to jump ahead and get designing, It's usually better to start with a copy first and I have planned to start with a copy. The unbounce conversion intelligence machine learning model has proven that landing page copy is twice as important to conversion rate as design. Nail the Headline:  We've got less than 15 seconds to grab a visitors attention on our landing page this means headline is probably the most important thing I will make sure that it's memorable, clear, and solves the problem of wechaty visitors care about the mostFocus on Benefits:  Visitors want to hear about how wechaty solves its problems, how wechaty product will help make their lives easier, and why this will be benefit them.  I will think think from the ideal visitor's perspective and list all the benefits of wechatyKeep Simple:  In general, landing pages tend to convert better when they are easy to read and not overlay long I will built this landing page by complicated business jargon, keep the sentence short and try to cut out the unnecessary bits that wechat new visitors don't actually need on the pageCraft CTA:  The CTA (or call to action) is what we want our visitors to actually do on our landing page. This can take the shape of a form or a click-through button. Take some time to decide what action our visitors to take and the best we can do is convince them to take it.  Make it specific     While CTA buttons like  Learn More  or  Get Started  can work and they're also pretty vague. Visitors won't know what to expect when they click a button like that.    I will be more specific and descriptive to get better results.     Make it Simple     All the things, words and explanations should be simple and clear to make wechaty users to understand easily    Make it Singular     The advantage of landing mage is that it eliminates all the other distractions we find on websites.    I will give wechaty users only one path forward to take. Avoid featuring navigation links to other pages, headers, footers, or any other calls or action.    Select Images:  I will work on the visuals of the landing page. Start out by selecting what images we want to feature and check whether those are wechaty bot working images or custom illustrations Choose a Great Image     The landing pages start out with big, beautiful images to show visitors what the wechaty is all about.     Go for contributors over product     I will include real photographs of our major contributors, people using wechaty and enjoying the wechaty on our landing page.    These will help visitors connect with wechaty on a more personal and emotional level which will also make them more likely to convert   This will make new users to make use of wechaty    Visualize the benefits of wechaty     I will look for more images to support the rest of our landing page   Most visitors won't actually read every work that we write so i will be creative with different wechaty product and uses images or custom illustrations to help tell a visual story on the pages as well   Design Landing Page:  Start with the provided template. I will start constructing and add the necessary details that huan said in the blog post proposal The design of the page will focus on supporting the wechaty objective and nothing else. This also means that the web design will be clean and simple, so as to ensure a smooth browsing experience and not to compete for the viewers attentionTest and Optimize:  I will see what other improvements we can make. It's easy to test and optimize for a high conversion rate by seeing the results Duplicate the page     Once the landing page is finished the heavy lifting is done. I will scale-up the production by duplicating the page and cheating a new variant and compare other variants then look for which is good and better    Test New Elements     I will try out different versions of our landing page headline. Switch up the images on our landing page   Swap out a new CTA button. Each variant can help to test a new element in our wechaty landing page   Wechaty New Reconstructed Landing page:  In the terms of content, the new wechaty landing page has one simple message to convey. It promotes the desired action and sticks to explaining the benefits of performing this action.  The ultimate goal of the new wechaty landing page is to make site visitors use wechaty, understand and click. Both the design and the text of the page need to reflect that, so i will make sure that all buttons are labeled with clear microcopy and that they stand out against the page's background This landing page is made up of one single page. Users can divide it into separate sections, but i will be stick to just one page that preferably isn't too long so that users can see and learn about wechaty easily Headers, subheaders buttons and images will be represented in a powerful and effective way, while ensuring that all elements remain cohesive. Creating New Wechaty Landing Page:  Define the goal. I will pinpoint what our LP want to achieve and stay consistent throughout every detail of our wechaty site Create visual hierarchy. I will decide which elements are the most important and make them stand out.  Generate action with a CTA. I will make it clear to our LP visitor what they should do. I will provide some call-to-action examples to our community members, mentors and volunteers then discuss about which look good Craft a captivating design. I will engage our wechaty site visitors with an eye-catching design that will make them want to click and discover more. I will also opt for a strategic layout. Note :-  Most users don't scroll all the way to the bottom of the landing page. To make this landing page more effective and create the best user experience, I will place the design and content above the fold :  Write killer copy. I will keep the text succinct and informative, with enticing headers that will give our wechaty visitors to read on Utilize images. I will set the tone and charm our visitors with impactful visuals. These can also help illustrate about wechaty in a clear way Highlight the value. I will let wechaty visitors know how clicking on the CTA will benefit them. Eg: like what will they get out of it ?Short checklist for making new wechaty landing page:  Select a landing page template or design from scratch (I will design the template for the wechaty new LP so that it will be more efficient and new TW can improve our LP in future) Give the wechaty landing page an attractive name Add unique content Include striking images Include the value propositions and use eye catchy words for attraction Make sure all our wechaty link and CTAs are working Complete the meta description and SEO title Publish! New wechaty landing page with value propositionExtra Tip:- One of the greatest advantages of landing pages is that they are relatively easy to make. Since this is easy to make I will create more than one landing page and test the performance of multiple designs. This technique will take our wechaty new landing page to a much more professional level. It can teach a lot about our wechaty audience and help us to focus on delivering a next level landing page for our wechaty users. Conclusion:  An reconstructed landing page for wechaty with value proposition This will also have the reconstructing plan and other details that must be added in the new wechaty landing page as said here Make it one page     I can divide wechaty landing page into separate sections, but stick to a single page.     Prioritize above-the-fold content     Because most visitors won't scroll all the way to the bottom of a landing page, place important content - such as our CTA - above the fold.     Be clear and direct     Include a strong headline across the top of the page. Visitors should understand within seconds what wechaty is offering, why it benefits them    Focus on the 'how'     I will make our landing page about our wechaty audience not just about wechaty. I will go beyond simply explaining what wechaty offering, instead I will focus on how wechaty benefit users    Use strong CTA copy     I will choose a short, direct, action-oriented phrase that tells visitors exactly what our visitors should do next    Choose an eye-catching CTA button     Make our website CTA visually prominent by placing it on a button. To instantly draw the eye of our visitors, opt for colors that make the button stand out from the rest of the content on the page    Keep navigation to a minimum     I will not overwhelm our wechaty visitors with multiple navigation choices because it may miss converting our users if we give them too many options.    Instead all points on our landing page will lead to the same place of our CTA    Use powerful visuals     By using this I will grab our audience's attention with enticing and memorable visual elements, such as images and video    Embrace with space     While strategic visuals are key to a strong landing page, steer clear of packing in too many images, words, boxes, buttons, icons, clips art, videos and more.    I will leave plenty of breathing room around the elements on our wechaty landing page to make content easy to read and digest    Add social share buttons     I will include social share buttons on our landing page to encourage visitors to spread the message and wechaty.    Share button give additional exposure when our visitors repost our page on their own media feeds    Include code of conduct of wechaty Thank you visitors sectionsAdditional Idea: Making our wechaty new landing page more effective In order for the landing page to fulfill its purpose, we need to drive traffic to it. This can be done in a few different ways:  Utilize the power of email marketing to send landing page to our wechaty subscribers via email Post a link to our LP on social networks like instagram or twitter Add a link to the LP within a blog post whenever someone add the blog post to our wechaty Optimize the wechaty landing page for search engines, by implementing advanced SEO features that can help wechaty website to boost the chance for getting found by organic (non-paid) search Create a PPC ad campaign on search engines and link to the landing page (If needed)Timeline: This is the proposed timeline and can be modified by the mentor. Week 1 (May 18 - May 24):  This week we will take suggestions from the members and mentors to get various insights.  Working on the initial designs of the projects and seeking suggestions.  Before the project timeline begins we will set up our development environment so that we can start the project as soon as possible this helps to provide a professional and improved quality of landing pageWeek 2 (May 24 - May 31):  Making a draft for the landing page based on suggestions.  Creating a landing page as per designs by using HTML, CSS and JavaScript and other UI/UX tools We will combine and make a effective, attractive and eye catching designWeek 3 (June 1 - June 7):  Continue working on the landing page.  Creating all the sections for the landing page.  Making the landing page responsive. Week 4 (June 8 - June 14):  Proofreading the existing website Create visual hierarchy Design and craft the CTAs accordinglyWeek 5 First Month Evaluation (June 15 - June 21):  Submitting the works done in the previous week Making and joining CTA to do action Crafting a captivating designWeek 6 (June 22 - June 28):  Designing and utilizing powerful and attractive images/GIFs Highlighting the value and key benefits of wechaty Making value propositions and eye catching wordsWeek 7 (June 29 - July 5):  Adding navigation and keeping it minimum Making visuals and value propositions more powerful Including code of conduct of wechaty Prioritizing above the fold content Adding the voice of our contributors and other necessary things as explained in the blog post here Including the upcoming work and the needed design/things as we explained in detail in our implementation/approach section of this proposal. Week 8 (July 6 - July 12):  Making headline and sub-headline more attractive and effective Describing the value of wechaty benefits in the landing page Differentiate wechaty as the preferred provider of this valueWeek 9 Second Month Evaluation (July 13 - July July 19):  Submitting the work done in previous weeks Fixing minor typos and making changes to the webpage.  Work on improvements suggested by the mentor Finishing the project completely and submitting the final results In the upcoming week we will be attached to the community and we will analyse/monitor the website traffic and if there is any improvements must be done or any suggestion we will do it and improve the quality of the work even more. Biographical Information (sajen sarvajith): I am a sophomore undergraduate student majoring in Computer Science from India. I have acted as a resource person on topics like ML, DL and orientation on online course awareness in colleges and universities. I have also organised and taken a few webinars regarding machine learning during COVID-19 pandemic. I am passionate about making interactive tutorials, documentation and deep learning. I have worked on projects regarding R-CNN, LSTM and deep learning in my university. I am familiar working with JS/typescript and popular frameworks like angular, react, node. js, django and flask, I will also do UI development and documentation and I have writing experience by working in paper publications. I am good with popular machine learning libraries like TensorFlow, PyTorch, keras, SciKit Learn, pandas, numpy, matplotlib. I have cracked the qualifier round of google code jam 2020, completed the Google Code-in competition in 2017 and completed hacktoberfest 2020 which are regarding open source. I have worked on two paper publications regarding anomaly detection and quantum machine learning algorithms. I am going to publish in Elsevier and ICLR journals respectively due to this pandemic. I am unable to go to my university AI lab to complete my final tests so my publications have been paused for now. Biographical Information (Arnab Saha): This is Arnab Saha, currently living in Noida, Uttar Pradesh, India. I am a Sophomore undergraduate student pursuing Electronics and communications engineering from NIT, Hamirpur. I am a front-end developer and a graphics designer. These are the designs I have made for various projects (I have also developed complete websites for most of them). Prijour- The project was a website that consisted of a digital diary, an emotion predictor quiz and a happiness predictor model. Website Link: here Handouts - This project is a decentralised website for NGO crowdfunding. Kurakoo - This project was a general purpose question and answer website. Real Estate Corp - This is the landing page for a real estate organisation. "
    }, {
    "id": 120,
    "url": "https://wechaty.js.org/2021/05/12/gsod-2021-how-to-guide-team-proposal/",
    "title": "Google Season of Docs 2021 Team Proposal: How-to Guides",
    "body": "2021/05/12 - This is the project proposal for Wechaty How-to-guide documentation on which we will be working as a part of Google Season of Docs 2021. We have proposed our timeline so as to complete this work during a span of 09 weeks. Team members: Vasvi Sood (email: contactvasvisood@gmail. com): I am a sophomore at NIT, Hamirpur. I am a Tech enthusiast and a story writer. For me combining technology with my writing skills is a natural match. I am passionate about blockchain technology. I am also into competitive programming these days. Github Handle: https://github. com/vasvi-sood&lt;/br&gt;Medium: https://vasvisood1. medium. com/ Abhishek Jaiswal (email: abhishek. iiitbbsr@gmail. com): Myself Abhishek Jaiswal,a CSE sophomore UG student currently pursuing my B. Tech from IIIT Bhubaneswar. It’s now been more than 8 month, I started writing technical blogs,tutorials,documentation and reviews. I have published many technical with medium and Analytics Vidhya, Devtutorials and Hashnode. I want to learn, build, grow my network, and want to transform open innovation projects into powerful real-world services. Github Handle: https://github. com/abhishek-iiit&lt;/br&gt;Medium: https://abhishek-iiit. medium. com/&lt;/br&gt;Hashnode: https://abhishek-iiit. hashnode. dev/ Proposal Video Presentation: {% include iframe. html src=”https://www. youtube. com/watch?v=tlOc-ZllV3c” %} Abstract: How to Guide is important because it guides us through the steps involved in addressing key problems and use-cases. They are more advanced than tutorials and assume knowledge of how the product works. On an average 45 - 50% of developers refer to How to guide. It contains instructions on how to use the program, its features and other inbuilt applications as well. Current State: Currently, the introduction page is available on its official website. It is obsolete, incomplete and misses information, and does not cover the example images of the steps involved that one needs to get when landing on the How to Guide section. Analysis: Huan and we(Vasvi and Abhishek) had a conversation about the changes that are to be made with the current How-to-Guide section. He said that the community expects to improve and have a new overall structure of this section. The links he shared with us can be found here. Why is your proposed user documentation an improvement over the current one?: The proposed How to Guide page will be structured to improve and ensure efficiency, consistency, and peace of mind for any end user. It will contain all the information about how to use the bot and its associated images, including its details and some little explanations on how to use each feature of the Wechaty. It will be kept up to date and have notes to follow inorder to learn by doing. Proposed Changes:  No overview section: It is theoretical and can get boring for the users to go through an entire page just containing an Overview.  Add events to your bot: Explaining what an event is, emphasising how it can add more value to the bot functionality (adding various use cases as well) Add more functionality to your bot (All the work that can be automated with the bot): Dealing with messages: Step by step guide on writing code for dealing with messages giving a short but clear example.  Manage Contacts: Step by step guide on writing code for managing contacts giving a short but clear example.  Manage Rooms: Define a room. Step by step guide on writing code for managing rooms giving a short but clear example.  Send and Accept Friend Requests: Step by step guide on writing code for sending and accepting friend requests giving a short but clear example.  Sending and Receiving files: Step by step guide on writing code for sending and receiving files(data) giving a short but clear example.  Testing your bot: Step by step guide on writing code for testing the bot giving a short but clear example. Puppet Mocker &amp; Starter Template are included in this section.  Deploying: A short introduction to Wechaty puppet. This should include a step by step guide to deploy the bot on various instant message systems: Wechat Whatsapp TikTok Deploy with Docker Deploy with Heroku FAQ: Answer to all those questions that might hinder users from using its functionalitiesProject Goals:  Get the user familiar with Wechaty by this Guide Build a step by step how-to guide, without emphasizing on abstract concepts Include various use cases Add numerous examples and images Translate to English and add code snippets wherever necessary Make sure that the how to guide page works all the time Ensure the user sees results immediately by integrating it with webapp Focus on concrete steps, not abstract conceptsTimeline: Week 1:  This week we will concentrate on community bonding and get familiar with the project with the help of mentors.  We will chalk out a blueprint for carrying out the complete project.  Add a README file to GitHub to help future contributors understand how to contribute to the How-to-guide page. Week 2:  Install Wechaty: It will link to Wechaty’s starter github template and will have a step by step guide on cloning and running instructions.  Add the missing parts (TBW) to different programming languages.  Add Related Image to each section to make it more interactive and more engaging.  Verify working of the code in each programming language. Week 3:  Add Events to your bot: Define what an event is. Provide code snippets along with a brief paragraph about when to use an event. Include code snippets and examples.  Add Related Image to the section to make it more interactive and more engaging.  Add the missing parts (TBW) to different programming languages.  Verify working of the code in each programming language. Week 4:  Add more functionality to your bot: Dealing with messages: Step by step guide on writing code for dealing with messages giving a short but clear example.  Manage Contacts: Step by step guide on writing code for managing contacts giving a short but clear example.  Add Related Image to each subsection to make it more interactive and more engaging.  Add the missing parts (TBW) to different programming languages.  Verify working of the code in each programming languageWeek 5:  Add more functionality to your bot: Manage Rooms: Define a room. Step by step guide on writing code for managing rooms giving a short but clear example.  Send and Accept Friend Requests: Step by step guide on writing code for sending and accepting friend requests giving a short but clear example.  Add Related Image to each subsection to make it more interactive and more engaging.  Add the missing parts (TBW) to different programming languages.  Verify working of the code in each programming language. Week 6:  Add more functionality to your bot: Sending and Receiving files : Step by step guide on writing code for sending and receiving files(data) giving a short but clear example.  Testing your bot: Step by step guide on writing code for testing the bot giving a short but clear example. Puppet Mocker &amp; Starter Template are included in this section.  Add Related Image to each subsection to make it more interactive and more engaging.  Add the missing parts (TBW) to different programming languages.  Verify working of the code in each programming language. Week 7:  Deploying : A short introduction to Wechaty puppet. This should include a step by step guide to deploy the bot on various instant message systems: Wechat Whatsapp TikTok Deploy with Docker Deploy with Heroku Add Related Image to each subsection to make it more interactive and more engaging.  Add the missing parts (TBW) to different programming language Verify working of the code to each programming language(Code for other IM systems also to be included if required) Week 8:  FAQ : Answer to all those questions that might hinder users from using its functionalities.  Proofreading the existing tutorials.  Fixing typos and making minor changes to the documentation, if required.  Work on improving the existing topics if required. Week 9:  Adding various images and screenshots,wherever possible.  Request the mentor feedback Work on improvements suggested by the mentor.  Submit a project report for evaluation to the mentors Write and submit a report of our experience as participants’ in Season of DocsTeam Goals:  Have a weekly open discussion about the project.  Make strategories/plan for the upcoming week together.  Examine each other’s work and help out each other. Proposed Budget: For the How-to-guide section, we have an overall budget of 1000 USD which we intend to divide equally. "
    }, {
    "id": 121,
    "url": "https://wechaty.js.org/2021/05/11/shraddhavp-soumi-combined-reference-proposal/",
    "title": "Google Season of Docs 2021 Team Proposal - References",
    "body": "2021/05/11 - PROPOSAL STATEMENT: Team members: Name: Shraddha Vasant PrasadEmail: (shraddhavp. 1js16cs094@gmail. com)Name: Soumi BardhanEmail: (soumibardhan10@gmail. com) PROFESSIONAL INFORMATION: Shraddha Prasad: I am Shraddha Vasant Prasad currently working as a Software engineer at American Express with a great passion towards open source and technical writing. I would describe myself as “A creative person by nature and a developer by passion” Writing Samples  Blog on Blockchain My other articles during my tenure as a Technical Content Writer at Girlscript foundationSoumi Bardhan: I am Soumi Bardhan, a CS Junior at IIIT Kalyani. I love solving real world problems with deep learning and AI. I document my experiences through technical articles on medium. Checkout my medium for my technical articles and my Youtube for some video explanations. Project title: Improve the References page of wechaty. js. org Project scope: References contain the technical reference for APIs and other technical aspects of the Wechaty machinery. It describes how it works and the way it works. The scope of this project is limited to improving the References section of the wechaty. js. org website. Current state of References Page: After analysis of the introduction section, following issues were seen:    The references page is difficult to understand for first time users technically.     It is incomplete and abstract.     Many information is given in Chinese language and hence difficult for users to understand.  Proposal Video: {% include iframe. html src=”https://www. youtube. com/embed/82rFox9Vq14” %} Purpose of References section of wechaty. js. org: The references section of wechaty. js. org will serve the following purposes :    Describe what actually is Wechaty for all the users be it technical or non-technical in simple and comprehensible English     Describe the technical aspects of Wechaty in an easy and understandable manner.  The proposed structure is as follows :  API ReferencesAdd use cases for API references ,also add code snippets for it and also add details about user classes that can be used.  PolyglotAdd code snippets with easy to understand examples for first time users in different programming languages.  Puppet ProvidersAdd separate modules for each of the messaging apps and add necessary code snippets  Puppet ServicesInclude all the puppet services offered by Wechaty PROJECT TIMELINE: (This timeline is tentative it might change after discussion with the community)The tasks will be divided each week after personal call discussions       WEEK   TASKS PLANNED   ASSIGNED TO         Week 1 ( May 18 - May 24)   Community bonding Discussion meetings on the outline with community Add readme for future contributors to contribute to References section           Week 2 (May 24 - May 31)   Restructuring the API - wechaty - both Define a structure in this page, or better, create subsections for the topic with different pages for each topic. The page has a lot of information. Main bot code Puppet name Wechaty Options           Week 3 (29th May - 4th June)   API - Message- create subsections. Small pages with code easy to read and understand. API - contact - Restructure           Week 4 (5th June - 11th June)   API - Room : Again here I think we can have separate pages for all the functions like we have for most libraries. API - Room Invitation           Week 5 (12th June - 18th June)   API -Friendship Puppet Services : Index. This page looks too long. Maybe we can split it up into clean readable sections.            Week 6 (19th June - 25th June)   Puppet Service WX work - Improve, restructure Puppet Services - Padlocal           Week 7 ( 26th June- 1st July)   Puppet Services - Paimon Puppet Services - Donut Puppet Services - Puppet Service Compatibility : Add subsections for English and Chinese instead of too much text in the same page.            Week 8 (2nd July- 8th July)   Puppet Services - DIY Specifications - Overview           Week 9 (9th July- 15th July)   Specification - Wechaty - restructure (Polyglot Wechaty) - TBW Specification - Plugin           Week 10 (16th July-22July)   Specifications Puppet - Create smaller subsections Specifications Service - Create smaller subsections           Week 11 (23rd July- 29July)   Specifications Token - TBW Deprecations Timeline           Week 12 (30th July- 5th August )   Add Polyglot - Index Add more detailed and structured document for Polyglot- OpenAPI Typescript Python Go           Week 13 ( 6th August-12th August)   Polyglot- Java Scala PHP . Net           Week 14 (13th August-19th August)   Ployglot- RUST DIY           Week 15 (20th August-26th August)   Puppet providers- Index (Detailed ) Create a separate page for each of the Puppet Providers Add Related Image to each subsection to make it more interactive and more engaging.            Week 16 ( 27th August-2nd September)   Puppet Services -Index Create dedicated sections for each services Final proofreading and submission after discussion with the community           Week 17 ( 3rd September -9th September)   Adding various images and screenshots,wherever possible. Request the mentor feedback Wok on improvements suggested by the mentor. Submit a project report for evaluation to the mentors Write and submit a report of our experience as participants’ in Season of Docs       Project Goals:  Make a neat index to search through the references section with ease Building a step by step guide for references Add snippets wherever possible with appropriate images to make it look more attractive.  Include more use cases Add English translations to already existing Chinese language information Focus on concrete steps At end of our project tenure we will definitely make the Reference page perfect &amp; top-notchTeam Goals:  Weekly phone calls with each other for discussion Also setup a personalized channel for small discussions Check each other’s work and help out Set weekly goals together during the phone callsProposed budget: The proposed budget for the entire project is 1000 USD as decided by the organisation which we intend to divide equally. "
    }, {
    "id": 122,
    "url": "https://wechaty.js.org/2021/05/11/gsod-2021-team-proposal-tutorials/",
    "title": "Google Season of Docs 2021 Team Proposal - Tutorials",
    "body": "2021/05/11 - This is the project proposal for creating and improving the Wechaty Tutorials documentation on which we will be working as a part of Google Season of Docs 2021. We are looking forward to completing this work during a span of 12 weeks (or, 3 months). Team members: Souvik Biswas (email: sbis1999@gmail. com): I am Souvik Biswas, currently pursuing a B. Tech degree in Computer Science and Engineering from IIIT Kalyani in India. I am a freelance technical writer of Codemagic and LogRocket Blog, and a passionate mobile app developer. You can also find some of my articles on Medium, and explore my projects on GitHub. Shwetal Soni (email: sonishwetal704@gmail. com): I am Shwetal Soni, currently pursuing B. Tech in Computer Science and Engineering from NIT Hamirpur in India. I am interested in UI/UX Design, Frontend web development and recently I’m also exploring the field of Technical Writing. Recently I have only written one technical blog on writing smart contracts on Tezos Blockchain. You can check it out here Medium. You can also find my projects on Github. Proposal Video Presentation: {% include iframe. html src=”https://youtu. be/aYlHgGFJoJM” %} Abstract: Current State of Wechaty Tutorials:  Users come to Wechaty website seeking how to use Wechaty to build a chatbot application for solving their problems. Unfortunately, the learning curve is not friendly to our users, they always struggle with setting up their development environment, can not get started with the simplest example source code, and find it hard to know what they can do with our API. This problem leads to us losing lots of new users, increased number of questions asked in the community, and lowered user satisfaction.  The current version of the Wechaty Tutorials is not properly structured.  The tutorials on the website need improvement, and should be beginner friendly. Proposed Work: Update the Tutorials to include a step-by-step guide (easy for beginners to follow) for achieving the final goal of building a bot. The Tutorial project should:  Allow the user to learn by doing Get the user started Make sure that the tutorial works all the time Ensure the user sees results immediately Make the tutorial repeatable Focus on concrete steps, not abstract concepts Provide the minimum necessary explanation Focus only on the steps the user needs to take Work with the contributor team to update the documentation on the Wechaty site.  Add easy to follow video tutorialsThe current overall structure of the Tutorials documentation is a bit confusing, so uses might find it difficult to find their relevant information for which they came to the Docs. We have proposed a revised structure of the Tutorials section. Each of the documentation pages should be structured in a particular format (so that users get familiarized with the format and would be much easier to follow). And, each of the tutorial pages for building a bot should contain an interactive CodeSandbox at the end (consisting of minimal code and TODO steps) where they can apply the knowledge that they gained by following the tutorial, and build a bot totally by themselves! We have included a detailed structure (further down the article) of each documentation page that we propose to be followed for every bot building tutorial. One more thing that we noticed in the Tutorials is the lack of a defined goal that the user should expect to achieve at the end of that step-by-step guide. So, there should be a clear description of the goal in the introduction of each tutorial. Overall structure of Tutorials: The overall structure of the Tutorials will be as follows:    Overview   Here we can have all the links for each of the pages present in the Tutorials section along with a brief description. This will help the user to easily navigate through the Docs.     Installation   A guide for installing the development tools required for running Wechaty bot on any user system.   Quick start     Overview (containing a brief introduction to each of the sub pages)   Running on GitPod   Running on Google Cloud Shell   Running Locally    Advanced Usage     Usage with Docker   Usage with Heroku   Using Plugin with wechaty   Using Redux with wechaty   Using Vorpal with wechaty    Examples     Overview (introduction to the different types of bot included in this examples section)   Basic         World’s shortest chatbot     Contact Bot     Ding dong Bot          Advanced         Demo Bot     Busy Bot     Media File Bot     Room Bot     Friend Bot     Gist Bot          Professional         Hot Import Bot     Ctrl C Signal Bot     Monster Bot     Api AI Bot     Speech to Text Bot     Turing Bot     Telegram Roger Bot     Blessed Twins Bot           Cheat sheet     Brief description of a bot   Code snippet to use it   Tech description (in brief)   Example - CodeSandbox (maybe included)   Screenshots / GIFs    We think the Video tutorial section is not required as a separate topic. Currently the contents of this page are just two quick start videos (in chinese), so that can be included in the Quick Start: Overview section. Structure for each tutorial page: A proposed structure of the tutorial documentation is as follows:  Introduction (also include the goal of the tutorial) Try out the bot (CodeSandbox) Requirements (tools required to follow the tutorial)   Usage* (can be renamed as Quick Start)   Code snippet - for users who may be searching for how to use the bot in their project, and doesn’t want to go deep into the step-by-step tutorial.      One more suggestion: These are like quick start code snippets, so we think it should be moved to the Cheat Sheet section which will look more appropriate.     Video tutorial (optional)*   Getting started   Quick introduction to the required tools and how to setup their development environment to get started building the bot     Building the bot   Step-by-step guide for building the bot, with a CodeSandbox at the end having minimal code and TODO steps where users can try building the bot by themselves directly on the documentation page without installing any tools on their local system     Running the bot   Commands for running the bot locally     Bot demonstration   Commands that they can use with the bot, and maybe a GIF showing the invocation of some of the commands on WeChat or WhatsApp   Conclusion References *Require some feedback from the community members Project Goals (Timeline): Week 1:  Start by adding missing content to one of the tutorials (maybe Vorpal first as I have already started contributing to that page) Try out the bot (CodeSandbox - already added: #779) Update the step-by-step guide to have more technical details on how to build the bot, adding brief explanation of each function used Add a CodeSandbox at the end with the TODO (as explained above)Week 2:  Structure the tutorial properly as per the proposed structure given above Add an Installation page for guiding the users to install the tools required for running the Wechaty bot on their local system.  Update the Tutorials: Overview page by adding information about what are the different types of tutorial available that then can go through (keep updating this as new tutorials are added to the docs) In the Getting started overview page add information about what are the different ways that can get started with Wechaty bots. Week 3:  Include the CodeSandbox of the Ding Dong bot to the Quick start page, so that users can try out the bot directly.  Short videos may be included for running the Ding Dong bot using GitPod and Google Cloud Shell.  Update the page with screenshots or GIF of the Ding Dong bot running on a device (WeChat / WhatsApp). Week 4:  Splitting Quick Start into two different pages, separate page for Running on Gitpod and same for Running on Cloudshell. (Removing the unnecessary information) Create a subtopic under Tutorials called “Deploying Wechaty”.    Keep the Usage with Docker page and the Usage with Heroku page as sub sections.      NOTE: The Deploying Wechaty section may be included to the How-to guides section     If the Docker and Heroku page is included in the How-to guides then add respective links to the page. Week 5:  The Using Plugin with Wechaty page can be divided into several sub-sections each consisting of a tutorial for one Wechaty Plugin Contrib Package.  Adding information and step-by-step tutorial for each plugin. Week 6:  Include a CodeSandbox in order to try out the bot to the Using Plugin with Wechaty page.  Add screenshots and GIFs where necessary. Week 7:  Add proper introduction to the Using Redux with Wechaty along with a defined goal for following this tutorial.  Structure the page properlyWeek 8:  Include code explanation and interactive CodeSandbox to Using Redux with Wechaty.  Add screenshots or GIFs (if necessary)Week 9:  Work on the Examples Basic section Update content of the Examples: Overview section.  Improve the bots that are already added: Ding Dong bot &amp; Contact bot Add content to the World’s shortest Chatbot page. Week 10:  Work on the Examples Advanced section Add content to the Room bot, Busy bot, Friend bot Include CodeSandBox to these pages Fix sandbox QR code of Friend botWeek 11:  Work on the Examples Advanced section Add content to the Demo bot, Media file bot, Gist bot Include CodeSandBox to these pagesWeek 12:  Work on the Examples Professional section Add content to the Hot-import bot, Ctrl-C bot, Monster bot Include CodeSandBox to these pagesWeek 13:  Work on the Examples Professional section Add content to the API AI bot, Speech-to-text bot, Tuling bot Include CodeSandBox to these pagesWeek 14:  Work on the Examples Professional section Add content to the Telegram Roger bot, Blessed Twins bot Include CodeSandBox to these pagesWeek 15:  Start working on the Cheat Sheet which would consist of the following:     Brief description of a bot   Code snippet to use it   Tech description (in brief)   Example - CodeSandbox (maybe included)   Screenshots / GIFs   Creating the cheat sheet will take time (most probably two weeks). Week 16:  Continue with the cheat sheet.  Create short video tutorials for some of the most used bots (if necessary).  Create tutorial pages for some of the bots mentioned on the Showcases page (need feedback from the community members). Week 17:  Add getting started examples for Polyglot Wechaty (multi-language) as per the conversation here.  Update the page structure and include CodeSandbox for the bot (if necessary).  Add screenshots / GIFs to this page.  Device screenshots / GIF after running the bot. This is an estimated project goal, changes might be done if suggested by mentors and community members. Communication: We will be communicating with the organization through the mailing list, Gitter &amp; GitHub. We have set up our personal communication through WhatsApp and email. Stipend: As suggested by the organization the following structure is to be followed:  Each writer will get a base stipend of $2000 The other $1000 is a performance stipend. It will be voted by the volunteers and mentors after the project has been finished. (as suggested by organization, maybe changed later)"
    }, {
    "id": 123,
    "url": "https://wechaty.js.org/2021/05/08/gsod-2021-selected-technical-writers/",
    "title": "Hello Wechaty GSoD’21 Technical Writers!",
    "body": "2021/05/08 - It’s a great honor for Wechaty to participate in Google Season of Docs 2021as one of the great top 30 open-source sponsored projects all over the world！ The most important thing is,the GSoD program helps Wechaty organization to start collaboratingwith many great technical writers all over the worldfor improving the documentation of Wechaty project.  If you have read our blog postGoogle Season of Docs ❤️ Wechaty, @huan, Apr 30, 2021,then you must known that we have 15 technical writers have sent proposals before our deadline May 1st. After that, before we have the kickoff zoom meeting on May 8,we have been contacted by total 24 technical writers,which is the most powerful writers team I have ever seen before! Technical writer selection: According to the timeline from GSoD’21,we need to hire the technical writers for our organizationbefore May 17, 2021 at 18:00 UTC. In order to select the most suitable writers for the Wechaty organization,we have lots of conversations between the mentors and the candidatesin our Gitter channeland Mailing list. After reviewing the proposal and having conversation with all the participants,we decided to splict the GSoD’21 to one primary project and five secondary projectsfor the Wechaty GSoD’21 program:  Create easy to learn tutorials for beginner users of Wechaty (the primary project) Improve the How-to guides section Improve the References section Improve the Explanations (and Introduction) sections Reconstruct Wechaty homepage(landing page) with value proposition Improve the gRPC and OpenAPI ecosystemAs well as we will have two volunteer for helping mentorsto manage the project and make sure everything is on track.  Attendees: There are total 20 attendees on our meeting. They are:  Huan, Creator of Wechaty, UTC+8 Rui, Co-creator of Wechaty, UTC+8 Rohitesh, GSoD’20 participant &amp; interested in Volunteering for GSoD’21, UTC +5:30 Jaya Gupta Vasvi Sood Ahmed Essam, GSoD’21 participant, GMT+2 Sajen Sarvajith K, GSoD’21 participant,, UTC+05:30 Soumi Bardhan, GSoD’21 participant, UTC+5:50 Abhishek Jaiswal,GSoD’21 participant, UTC+05:30 Simin Liao, GSoD’21 participant and volunteer, UTC+8 Shwetal Soni, GSOD’21 participant, UTC+05:30 Mukosa Joseph Mawa, GSOD’21 participant, UTC +03:00 Rufai Mustapha, GSOD’21 participant, UTC +01:00 Souvik Biswas, GSoD’21 participant, UTC +05:30 Shraddha Prasad , GSoD’21 participant, UTC +05:30 Anirudh T. P. V. S, GSoD’21 participant, UTC+8 Chris Estepa, GSoD’21 participant, UTC +8 David Atanda, GSoD’21 participant, UTC +1 Arnab Saha,GSod’21 participant(landing pages) Rajiv Ranjan Singh, GSoD 2021 participant, (UTC+05:30)The Zoom Meeting: We have great conversations with our GSoD’21 participants,and after the deadline of receiving proposals April 30,we organized a zoom meeting with all our technical writers. In this meeting,all the GSoD’21 participants introduceed theirselvesand presented their proposalsfor the projects that they applied. Huanand Ruiintroduced the Wechaty project and community to the writer team. The following YouTube video is the 3 hours recordingof our great kick-off meeting of Wechaty GSoD’21 program: {% include iframe. html src=”https://www. youtube. com/watch?v=hTkM_XPpFfU” %} Agendas:  0:01:41 1. Introducing the Meeting Agenda 0:03:08 2. Self-introduction: Huan 0:06:15 3. Self-introduction: Rui 0:09:15 4. Self-introducing: Technical Writers 0:24:53 5. Introducing Wechaty 0:29:37 6. Introducing GSoD Project List 0:41:46 7. Introducing Received Proposals 0:44:41 8. Primary Project: Tutorial 0:45:33 8. 1 Tutorial Proposal from Souvik Biswas 0:49:24 8. 2 Tutorial Proposal from Shwetal Soni 1:00:19 9. Landing Page Proposal from Sajen Sarvajith K 1:12:00 10. Introduction &amp; Explanation Proposal from Mukosa Joseph Mawa 1:23:44 11. 1. How-to Guides Proposal from Vasvi Sood 1:27:38 11. 2. How-to Guides Proposal from Abhishek Jaiswal 1:33:05 12. References Proposal from Shraddha Vasant Prasad 1:41:00 13. Volunteer Project 1:43:00 13. 1 Volunteer Proposal from Rohitesh Jain 1:45:42 13. 2 Volunteer Proposal from Vicky Liao 1:57:49 14. Budget Plan for Stipends 2:05:28 15. Webmaster Tools 2:06:33 16. Q&amp;AYou can learn more from our meeting notes. Documentation style guide: We should always follow theGoogle developer documentation style guide,which provides for anyone writing developer documentation. Learn more from Google technical writing resources Documentation system: Wechaty documentation has been adapted to the documentation system by @huan on Mar 25, 2021. We should always follow the documentation system by strictly aligning our docs to the following chart: Learn more from:  Documentation System Official Website YouTube: What nobody tells you about documentation, Daniele Procida, 2017, PyCon AUGSoD’21 projects brief: The project 1-4 is strictly defined by the documentation system, and they must follow the do not go out of scope rule:  Credit: Documentation system: Introduction Project 1: Tutorials: Tutorials are lessons that take the reader by the handthrough a series of steps to complete a project of some kind. They are what your project needs in order to show a beginner thatthey can achieve something with it. They are wholly learning-oriented, and specifically,they are oriented towards learning how rather than learning that. You are the teacher,and you are responsible for what the student will do. Under your instruction,the student will execute a series of actions to achieve some end. The end and the actions are up to you,but deciding what they should be can be hard work. The end has to be meaningful,but also achievable for a complete beginner. Learn more from Documentation system: tutorials Project 2: How-to guides: How-to guides take the reader through the steps required to solve a real-world problem. They are recipes, directions to achieve a specific end. For examples:  how to create a web form; how to plot a three-dimensional data-set; how to enable LDAP authentication. They are wholly goal-oriented. How-to guides are wholly distinct from tutorials and must not be confused with them:  A tutorial is what you decide a beginner needs to know.  A how-to guide is an answer to a question that only a user with some experience could even formulate. Learn more from Documentation system: how-to guides Project 3: Reference: Reference guides are technical descriptions of the machinery and how to operate it. Reference guides have one job only: to describe. They are code-determined,because ultimately that’s what they describe:  key classes functions APIsand so they should list things like:  functions fields attributes methodsand set out how to use them. Reference material is information-oriented. By all means technical reference can contain examples to illustrate usage,but it should not attempt to explain basic concepts,or how to achieve common tasks. Reference material should be austere and to the point. Learn more from Documentation system: reference Project 4: Explanation: Explanation, or discussions, clarify and illuminate a particular topic. They broaden the documentation’s coverage of a topic. They are understanding-oriented. Explanations can equally well be described as discussions;they are discursive in nature. They are a chance for the documentation to relax and step back from the software,taking a wider view,illuminating it from a higher level or even from different perspectives. You might imagine a discussion document being read at leisure,rather than over the code. Learn more from Documentation system: explanation Project 5: Landing page with value proposation: We has been planning to reconstruct Wechaty landing page with value propositions for a long time. The Value Proposition is a statement that answers the ‘why’ someone should do business with you. It should convince a potential customerwhy your service or product will be of more value to themthan similar offerings from your competition. You know why your company is great,but do your potential customers know what sets your brand apart? It must tell your audience:  How your product or service solves/improves problems What benefits customers can expect Why customers should buy from you over your competitorsIt introduces you to prospective buyers and helps youmake a strong first impression. That’s why it is so important to have a powerful one. Learn more about the value proposition from this great article:The 31 Best Value Proposition Examples You Wish You Had Project 6: gRPC and OpenAPI ecosystem: Wechaty has two subsystems for providing the gRPC support: one is wechaty/wechaty-grpc, the other is wechaty/openapi. The related docs page mainly is at Polyglot/OpenAPI as well as other pages that have some OpenAPI related docs. What we are planning to do is:  Improve all OpenAPI related documentationfrom our docs website https://wechaty. js. org/docs/,especially Polyglot/OpenAPI.  Improve READMEs from bothwechaty/wechaty-grpcand wechaty/openapi Improve the code when necessary for improving the docs in the repository wechaty/wechaty-grpc and wechaty/openapiProject 7: Volunteering: Volunteers are in charge of helping the organization mentors to manage the GSoD’21 program, which means that the volunteer team has been authorized to mentor the technical writers on behalf of the mentors as long as the decisions are made by the volunteer team, to improve our GSoD’21 outcome for our community. The most important roles for the volunteers are:  Make sure we are following the Google Developer Documentation Style Guide Make sure we are following the Documentation System Make sure we are following the Organization administrator guide and performing Organization administrator responsibilities Organize team activities as usual (review/approve/meetings/blogs/evaluations/reports) Make decisions on behalf of mentors when necessary for goodGrants: The grants from Google will be split as following:  Tutorials: $5k How-to guides: $1k References: $1k Explanations: $1k Landing page with value proposition: $1k gRPC and OpenAPI ecosystem: $1kThe volunteers will get stipends $500 for each. 1. Base grant: The base grants will be the 80% of the each grant. 2. Performance grant: The performance grants will be the 20% of the each grant. It will be voted by the writer themselves (who is in the same team)with the volunteers after the project has been finished. The rule is that everyone has 10 pointswhich can be used to vote for the performance grant. 3. Example: performance grant voting: Two writers A and B are working together share a $1k project. The base grants will be $1,000 * 80% = $800,A and B will share $800 equally,which means that A will get $400 and B will get $400 as wellfor their base grants. The performance grants will be $1,000 * 20% = $200. According to the performance grants caculating formula,if we assuming the following vote result,then we will get the following distributing result:  Vote from A: A:4 B:6 Vote from B: A:7 B:3 Final percentage result:     A: (4+7)/20 * 100% = 55%   B: (6+3)/20 * 100% = 45%    Final distributing result:     A: 55% * $200 = $110   B: 45% * $200 = $90   In our practice we need to add C and D which is our volunteers, that’s it! 4. Thank-you bonus: The “Thank-you bonus” is for those GSoD’21 technical writerswho has not been selected in the year 2021and meet the following requirements:  has submitted qualified proposal before the deadline (May 1st) has submitted PR for improving the Wechaty docs and has been merged. For those technical writers, we have prepared $20for thank you for the interest in participating in Wechaty GSoD’21,and we hope you will join us in the coming GSoD’22. The Thank-you bonus will be distributedafter we have submited the final report to Googleand received the second grants from GSoD’21. We will prepare a Google Form for collecting the payment information,so please stay tuned and remember to come back to us then! 6. Performance bonus: The performance bonus is an additional $1,000. 00 bonuswhich is for everyone from our technical writer team! The rule is simple:  Wechaty organization will make a budget of $1,000. 00for this performance bonus Everyone in our team will have 10 pointsto vote other teams (skip their own team) Volunteers and mentors will vote with the same rule All team share $1,000. 00 by the points they getFor example, we have two team A and B:  Vote from A: A:4 B:6 Vote from B: A:7 B:3 Vote from Volunteer 1: A:4 B:6 Vote from Volunteer 2: A:7 B:3 Vote from Mentor 1: A:4 B:6 Vote from Mentor 2: A:7 B:3 Final percentage result:     A: (4+7+4+7+4+7)/60 * 100% = 55%   B: (6+3+6+3+6+3)/60 * 100% = 45%    Final distributing result:     A: 55% * $1,000 = $550   B: 45% * $1,000 = $450   In our practice we need to add C, D, and Ewhich are all of our projects(volunteers team will be included as well). That’s it! Wechaty GSoD’21 selected technical writers: Here we’d like to announce that the Wechaty GSoD’21 selected technical writers, they are:  Souvik Biswas and Shwetal Soni for Create easy to learn tutorials for beginner users of Wechaty (team proposal) Vasvi Sood and Abhishek Jaiswal for Improve the How-to guides section (team proposal) Shraddha Vasant Prasad and Soumi Bardhan for Improve the References section (team proposal) Mukosa Joseph Mawa and Chris Estepa for Improve the Explanations (and Introduction) sections (team proposal) Sajen Sarvajith k and Arnab Saha for Reconstruct Wechaty homepage(landing page) with value proposition (team proposal) Rajiv Ranjan Singh to Improve the gRPC and OpenAPI ecosystem (proposal) Rohitesh Kumar Jain and Simin Liao (廖思閔) for Volunteering (team proposal)Welcome the above 13 technical writers onboarding, it’s so great to have you all in our Wechaty organization community, cheers! "
    }, {
    "id": 124,
    "url": "https://wechaty.js.org/2021/05/06/vasvi-applicant-for-technical-writer-gsod/",
    "title": "Vasvi Sood: 2021 Google Season of Docs Application",
    "body": "2021/05/06 - Sophomore,NIT Hamirpur Hi there👋, I’m Vasvi Sood a GSOD applicant: I’m currently pursuing my Bachelor’s in Electronics and Communication Engineering from National Institute Of Technology, Hamirpur. I have applied for the position of Technical writer in Webchatty. Let’s connect: My Experience 😇: The Wechaty organization is very welcoming for the first time open source contributors. I faced no issues while making my first pull request to the GitHub repository. The best part was the transparent and interactive the application process. The mentors were very supportive and offered information that was crucial for beginners like me. Why did I apply 🖋️: Comming from a technical background I am well aware about various technologies and developer tools . Story writing has always been my favorite hobby. For me, combining technologywith my writing abilities is a natural match. I share Wechaty’s vision of using simple and descriptive language in documentation to attract developers. My Proposal "
    }, {
    "id": 125,
    "url": "https://wechaty.js.org/2021/05/05/shraddhavp-interactive-wechaty-tutorial/",
    "title": "Shraddha Vasant Prasad: 2021 Google Season of Docs Technical Proposal",
    "body": "2021/05/05 - I am Shraddha Vasant Prasad, 2020 graduate and currntly working as a Software Engineer At American Express, I describe myself as “Developer in the making and a Blogger by passion” Technical writer Details:  Name: Shraddha Vasant Prasad Github: https://github. com/shraddhavp Linkedin: https://www. linkedin. com/in/shraddha-v-prasad/ Blog: https://medium. com/@anitha. shraddha Location: Bangalore,Karnatak,India Time Zone: (UTC + 05:30)Project name: Create easy to use tutorial for Wechaty Project length: Standard length (3 months) PROJECT PROPOSAL GSOD 2021: User Doc is the most important integral part of any software be it paid or open source. The user docs site is designed to assist end-users to use a product or service. The good user docs site is very important because it provides an avenue for users to learn how to use the software, its features, tips, tricks and also resolve common problems encountered when using the software. It also reduces support cost and is part of the corporate identity of the product. The good user docs site is a sign of healthiness of the product, the developer team. Without good user docs site, a user may not know how to do the above things effectively and efficiently. My personal ideas to the product would be that I will definitely create a new tutorial page which gives a detailed and structured introduction to the software from installation to the end-user usage. the below are my personal ideas on the project:  Markdown: - So that technical writers don’t have to worry about installation. They can write simply in the . md file. Anyone can click on edit button shown on the website (new feature) and contribute making it better. This will engage users to add new content or edit content to improve it.  Documentation Search: - User should be having a search box so that they can easily and quickly find out relevant contents.  Comments Section: - User may have the option to comment and share their views on posts and tutorials. They can able to read other people views on project documentation.  New Release Notes and Blogs: - The website should be updated with new blog posts and news about current development and roadmap. Let me now, give a detailed description of the new website look Wechaty User Guide Page:  Installation guide.  Quick start with Wechaty.  Wechay Developer Guide Page:-Development Guide, Contribution guide, Git setup, Code of Conduct, Documentation setup About Wechaty Page:-List of all the contributors should be present in team sections Quick links and release notes, latest blogs will be added to engage the user to make them read about the latest Wechaty versions or so. Also read the uses of Wechaty Blogs, Release Notes and Tutorials Page:-The tutorial page will contain some popular talks and articles that clarify Wechay concepts. Contributors can add their tutorial links in the tutorial page. WHY AM I THE RIGHT PERSON FOR THIS PROJECT: I am the right person for the project because  I have past experience of using Github and also been contributing to open source for more than an year now I have been top open-source contributor in many open-source contributions like Hackincodes and Girlscript Summer of Code.  I have also been technical writer in GlobalCert Singapore and Girlscript summer of code for 2 months each I am also Medium blog writer and also at LoginRadius(My blockchain blog became rally famous) I am really interested in this project as it creates value for people and new bees who want to use Wechaty and also for the dedication with which I work in my current company my leaders are really happy and appreciate the dedicated work I do.  I am also interested in working for Introduction ,Landing Page or References Page with a team memberLinks to some of my Technical Writing works:  https://www. loginradius. com/blog/async/Blockchain-the-new-technology-of-security-trust/ https://drive. google. com/drive/folders/1_g8lDR-Q0RXHTSj0vc3d4vvTXkrX2Ei0"
    }, {
    "id": 126,
    "url": "https://wechaty.js.org/2021/05/04/rohitesh-applicant-for-volunteering-gsod/",
    "title": "Hi I'm Rohitesh interested in volunteering",
    "body": "2021/05/04 - GSoD’21 Project Proposal for Volunteering: Create easy to learn tutorials for beginner users of Wechaty: Name: Rohitesh Jain Region: New Delhi, India (UTC + 5:30) Email: thekumarjain@gmail. com GitHub: https://github. com/Rohitesh-Kumar-Jain LinkedIn: https://www. linkedin. com/in/rohitesh-jain-490b2b188/ Phone Number: +91 8882232063 Preferred Method of Contact: Email Development Environment: I use macOS with a virtual box installed for working with other OS. About Me: I am a technical writing enthusiast and I always used to do the documentation part of any project my group was assigned (apart from the project of course!), I am also a past participant of Google Season of Docs’20. I am a Bachelor of Engineering undergrad pursuing Computer Science and Engineering from Guru Gobind Singh Indraprastha University. I have a working proficiency in English. I am comfortable with reStructuredText, Sphinx, Git, and writing technical documentation. Prior Experience: I have worked on an open-source project as a participant in the Season of Docs program, I completed my project and delivered more deliverables than originally planned in the accepted proposal. Here’s a link to my final project report. Project Request: I have no responsibilities other than college this summer, if given a chance I can spend 5 hours or more on average a week on volunteering this project. I am the perfect third volunteer for this project as I am a complete alien to Wechaty and chatbots in particular. During the project, I will try to make my chatbots, using the documentation and hence will be able to point out what exact difficulties new users are facing, and will give a detailed analysis of the documentation which will benefit tech writer understand what exactly documentation is lacking and what should the writer improve. I am probably the intended user as I know basic coding and have never used Wechaty to create bots. If can make chatbots comfortably at the end of the program using the documentation, that will also be an indication that the project got completed successfully. Roles &amp; Responsibilities:  Read the existing documentation Proofread the documentation that will be delivered by tech writers Give suggestions and feedback on the delivered documentation Make chatbots and will point out where the documentation is lacking Suggest what else can be done to improve the learning curve of users based on my own learning curve Organize Zoom meeting every week     Prepare the agenda before meeting   Make sure everyone get synced   Make sure meeting happens every week and everyone is attending it    Publish a meeting minutes blog after each meeting     Publish meetings on YouTube   Send blog post url to our mailing list    Write and publish monthly report for Wechaty GSoD’21 Draft case study and final project evaluation for the Wechaty organizationCommunication: The frequency of contact will be dependent on a discussion with other mentors and tech writer(s). I prefer regular communication — my suggestion is once every week to receive updates and to give feedback on the work done so far. However, this is flexible depending on their preferences as well. Project Budget &amp; Availability: Availability: I will devote 4-5 hours per week from May to November 30. Will be available on: weekly Zoom video conferences, Gitter, Github &amp; Gmail. Budget: $500 Shared Google Doc : https://docs. google. com/document/d/1YnUrU2-7gxn2e3t4HevDQbUYg3CqKRvMp_l2HFOioug/edit#heading=h. clazfnq2fnz0 Thanks for reading my post, Cheers! Best, Rohitesh, a docs &amp; open source enthusiast "
    }, {
    "id": 127,
    "url": "https://wechaty.js.org/2021/05/04/gsod21-simin-proposal/",
    "title": "Google Season of Docs 2021 Volunteering Proposal",
    "body": "2021/05/04 - Google Season of Docs 2021 Volunteering Proposal: Personal Information:  Technical writer: Simin Liao Academic Background: BA from National Taiwan University Current job: Technical Writer Location: Taiwan (GMT +08:00) Language: English, ChineseAbstract: User documentation is one of the ways that introduces users to its functions. If the documentation is complete and well-constructed, discrepancy between users and developers will reduced significantly. The users will be more easily to use the software, its functions and be able to resolve the common issues themselves. They would not need to ask questions frequently. A complete and clear user documentation could benefit the organization in several ways. First, it increases users— interest to use the software. As we all know, the beginning of doing anything is always the hardest, with clear instruction at hands, a user could break into the field more smoothly and will be less likely to give up during the process. Second, it reduces cost of managing questions that are frequently asked and could focus on more productive feedback in the community. Last but not least, it serves as an icon of the product and the development team. A well-constructed documentation demonstrates that it has a well-organized development team. Professional Background: I am a full-time in-house technical writer from an International company. For documentation, I am trained in two ways: to use simple words and to write for novice. It may be a common myth that we should use the most accurate and the most beautiful words to write the steps, but we forget that most of the users are ESL (English as Second Language) speakers. Instead of writing an essay, the most important thing for a documentation is to deliver the correct instructions to the users. That includes not using the words that are too uncommon and rare. My company follows the rules of Simplified Technical English (ASD-STE100), so I am very familiar with the level of English words and I know which are more appropriate than others for non-native speakers. In addition, in order to eliminate ambiguity, I am also trained to use specific user-friendly syntax, which is based on the feedback of our internal experienced technical writers and documentation users. On the other hand, writing for novice is one of the things that is often ignored by many people. In my previous experience working with engineers, since they are already very experienced and familiar with the process, they often jump too fast. One of my job is to slow them down, break their ideas down into small steps and explain the specific terms. Apart from in-job trainings, I also studied technical writing reference guide from Google, Microsoft and some parts of Red Hat. I acquired their writing style and will apply to this project. I hold a bachelor degree in linguistics and literature from National Taiwan University. Throughout four-year training, I was immersed in words and sentences that I have written many term papers about semantics and syntax. My academic practice gave me an advantage of working with people from engineering background. A great development team is always consists of smart engineers, and I am the one who captures their fabulous ideas, in a simple and transferable way. This is my calling. Current Issue: Tutorials are not properly structured: At the beginning when I was trying to find out how to use Wechaty and where to start, it took me a very long time. I found that the pages are not really consistent to each other. For example, if the the information in this page is not what I was looking for, I would have problem getting to the correct location. Furthermore, normally when the users are looking for tutorials, they sometimes could not fully explain their questions and were trying to seek for some possible solutions. Even worse, if they are looking for some specific functions and they could not get answers from the handbook, they would tend to think that Wechaty is not comprehensive and does not meet their needs. Information is scattering: Currently there are four ways we could find information about this project: tutorial, video, GitHub or in the Wechaty community. They are not properly linked or labeled, so once the users need some help, they needs to go back and forth in the four places, which is very time-consuming and the users may give up during the process. Information is not sufficient: In the community, we could see many people asking simply questions everyday. The main reason is because the users cannot find the answer they need. The documentation is not comprehensive and does not cover the topic. Besides, no one is maintaining the Frequently Asked Questions, so the current tutorial is always outdated. Syntax is not consistent: This is kind of the hardest part for the ESL speakers. The user documentation is maintained by too many people, with different writing styles and different writing tone. Unlike writing essays, we ought to eliminate personal style in writing and create a consistent standard that everyone should follow. Approach: I believe that Wechaty already have many great developers contributing to your project. The biggest problem right now is that all the documentation are independent. Instead of looking for another developer to flourish the documentation, doing the things that you could actually do it yourself, what Wechaty really need now is an experienced technical writer who could make a concrete structure for the documentation. In short, Wechaty needs the foundation first, before adding more cool functions or user interfaces. In the future, since there will definitely be more people contributing to this project, with a well-constructed structure, they could more easily allocate their new documents and the development team could organize the tutorials more comfortable. Responsibilties: As a full time technical writer working with various engineers from different fields, I play an important role in editing the document and coordinating projects. These two are the things that are often ignored when it comes to technical writing, but are actually very crucial to whether the documentation is complete and professional or not. Through my previous on-job and personal training, I will commit in the following two areas: 1. Edit and proofread the documentation:  Make sure all the documents follow Google Developer Documentation Style Guide, including format, syntax and word choice.  Make sure the technical instruction is understandable for a novice. ( I will follow the instructions step by step as if I’m a user to make sure that the document is easy to understand and doable. ) Make sure all the document structures are consistent.  Make sure the language (English) is simple for ESL (English as Second Language) speakers to comprehend.  Edit the documents and review PRs within three days after receiving. 2. Manage each documents:  Make sure that every writer follows the document release schedule and report to Huan if anyone is failling behind.  Make sure that every writer knows the rules of Wechaty documentation.  Collaborate with another volunteer and writers for document release. Proposed Budget: $500 "
    }, {
    "id": 128,
    "url": "https://wechaty.js.org/2021/05/04/gsod-2021-applicant-sbis04/",
    "title": "Google Season of Docs 2021 Applicant: Souvik Biswas",
    "body": "2021/05/04 - I am Souvik Biswas, currently pursuing a Bachelor of Technology degree (2018 - 2022) in Computer Science &amp; Engineering from the Indian Institute of Information Technology Kalyani. Also, a freelance technical writer of Codemagic and LogRocket Blog, and a passionate mobile app developer. I love open source contribution and even have a number of projects of my own which are available on GitHub, you can find them here. Maintainer of the Flutter package video_trimmer. Have contributed to a number of organizations in the past, and had been a part of Hacktoberfest 2018, 2019 &amp; 2020. I have worked on over 70 technical articles having 500K+ views which are published on various platforms including Medium, Codemagic Blog and LogRocket Blog. Apart from that, I have also worked on 2 ebooks which are published by Codemagic. You can connect with me on Twitter or LinkedIn. I am an applicant of GSoD 2021 for the Wechaty organization for improving their tutorial section of the documentation and make it more beginner friendly. GSoD 2021 Project Proposal: Open source organization: Wechaty Project: Create easy to learn tutorials for beginner users of Wechaty  Name: Souvik Biswas Email: sbis1999@gmail. com Website Github Medium Linkedin Project length: Standard length (3 months)Technical Writing Experience: Freelance Technical Writer - Codemagic Blog: Have written over 60+ articles and contributed to 2 ebooks published by Codemagic.  Topics of the articles consists of Android, Flutter, React Native, DevOps, CI/CD Contributed to Flutter Libraries ebook and CI/CD for Mobile App Developers Have written a comprehensive Cheatsheet of Codemagic YAMLFreelance Technical Writer - LogRocket Blog: Started writing articles related to Flutter framework  New concepts introduced by Flutter 2. 0 Integration of Flutter with various services Comprehensive code walkthroughTechnical Writer - Flutter Community: Published various articles, mostly consisting of code walkthroughs. The articles have received over 350K+ views on Medium.  Each article has a supporting sample app open-sourced on GitHub Covered various important concepts in Flutter Testing in Flutter Code-signing and delivering apps to different platformsTechnical Writer - ProAndroidDev: Written articles on various UI and Navigation components used in Android.  Building complex layouts Using Navigation component in Android Kotlin’s new features Code walkthroughTechnical Writer - Journal: Have written article on VR on web  Building VR apps using React360 Integrating React360 VR apps in Flutter Deploying to GitHub PagesResearch Work: I am a part of a research group of our university, working on new post-quantum encryption schemes and Blockchain. We have submitted three research papers for publication which received a very positive feedback from the editors and would be published soon. We are currently working on a new consensus algorithm which would be compatible with IoT devices. Links to some of my most popular articles: I have worked on over 70 articles published across various sites including Medium, Codemagic Blog, LogRocket Blog. Have contributed to 2 ebooks published by Codemagic.  Flutter: Implementing Google Sign In Codemagic YAML cheat sheet Ebook on CI/CD for Mobile Apps Flutter libraries ebook Designing complex UI using Android ConstraintLayout My Journey building a Video Trimmer package for Flutter Flutter VR: Flutter + React 360 + GitHub Pages How to run React Native Detox tests on Codemagic Dart vs Kotlin: detailed comparison How to take advantage of Dynamic Workflows using Codemagic API How to perform text recognition using Firebase ML Kit in Flutter iOS Code Signing and Publishing with Codemagic . yaml fileThese were some of the articles, you can find more here. Apart from this, I have also done a significant amount of contribution to the Codemagic Documentation. Abstract: Current State of Wechaty Tutorials:    Users come to Wechaty website seeking how to use Wechaty to build a chatbot application for solving their problems. Unfortunately, the learning curve is not friendly to our users, they always struggle with setting up with their development environment, can not get started with the simplest example source code, and find it hard to know what they can do with our API. This problem leads to us losing lots of new users, increased number of questions asked in the community, and lowered user satisfaction.     The current version of the Wechaty Tutorials is not properly structured.     The tutorials on the website needs improvement, and should be beginner friendly.  Proposed Work: Update the Tutorials to include a step-by-step guide (easy for beginners to follow) for achieving the final goal of building a bot. The Tutorial project should:  Allow the user to learn by doing Get the user started Make sure that the tutorial works all the time Ensure the user sees results immediately Make the tutorial repeatable Focus on concrete steps, not abstract concepts Provide the minimum necessary explanation Focus only on the steps the user needs to take Work with the contributor team to update the documentation on the Wechaty site.  Add easy to follow video tutorialsEach of the documentation page should be structured in a particular format (so that users get familiarized with the format and would be much easier to follow). And, each of the tutorial pages for building a bot should contain an interactive CodeSandbox at the end (consisting of minimal code and TODO steps) where they can apply the knowledge that they gained by following the tutorial, and build a bot totally by themselves! I have included a detailed structure (further down the article) of each documentation page that I propose to be followed for every bot building tutorial. One more thing that I noticed in the Tutorials is the lack of a defined goal that the user should expect to achieve at the end of that step-by-step guide. So, there should be a clear description of the goal in the introduction of each tutorial. Contributions: Some contributions that I have done to the Wechaty GitHub repo are mentioned below:  Update Getting started - Running locally instructions (#763) Update the vorpal demo screenshot (#780) Add instructions and interactive sandbox for Vorpal (#779) Update vorpal with wechaty doc (#772) Update Getting started - Running locally (#757) Improve Vorpal docs (#791) Update images to use normal Markdown format - Vorpal tutorial page (#802)Project Goals (Timeline): Before May 1:    Familiarize myself with the current version of the user documentation of Wechaty, and identify the parts that require improvements.     Make contributions to the Wechaty repository adding some improvements.  Community bonding:  Set up a communication channel and time (due to timezone difference).  Refine my goals and set expectations on both sides.  Discussing about the structure of each tutorial page in documentation.  Finalize the order of editing the tutorial sections.  Discuss about the best way to add the interactive CodeSandboxesDocumentation Period: Wechaty repository here As per the discussion with the community members, start working on a tutorial page - adding the improvements, properly structuring the pages, adding interactive CodeSandbox, adding video walkthrough (if necessary), adding relevant screenshots and defining a goal in the introduction of the tutorial (so that users have the idea of what they will achieve at the end of the tutorial). A proposed structure of the tutorial documentation is as follows:  Introduction (also include the goal of the tutorial) Try out the bot (CodeSandbox) Requirements (tools required to follow the tutorial) Usage (code snippet - for users who may be searching for how to use the bot in their project, and doesn’t want to go deep into the step-by-step tutorial)* Video tutorial (optional)* Getting started (Quick introduction to the required tools and how to setup their development environment to get started building the bot) Building the bot (step-by-step guide for building the bot, with a CodeSandbox at the end having minimal code and TODO steps where users can try building the bot by themselves directly on the documentation page without installing any tools on their local system) Running the bot (commands for running the bot locally) Bot demonstration (commands that they can use with the bot, and maybe a GIF showing the invocation of some of the commands on WeChat or WhatsApp) Conclusion References *Require some feedback from the community members Week 1 : (1st May - 8th May):  Start by adding missing content to one of the tutorials (maybe Vorpal first as I have already started contributing to that page) Try out the bot (CodeSandbox - already added: #779) Update the step-by-step guide to have more technical details on how to build the bot, adding brief explanation of each function used Add a CodeSandbox at the end with the TODO (as explained above) Structure the tutorial properly as per the proposed structure given aboveWeek 2 : (9th May - 15th May):  Update the Tutorials: Overview page by adding information about what are the different types of tutorial available that then can go through (keep updating this as new tutorials are added to the docs) In the Getting started overview page add information about what are the different ways that can get started with Wechaty bots.  Include the CodeSandbox of the Ding Dong bot to the Quick start page, so that users can try out the bot directly.  Short videos may be included for running the Ding Dong bot using GitPod and Google Cloud Shell.  Update the page with screenshots or GIF of the Ding Dong bot running on a device (WeChat / WhatsApp). Week 3 : (16th May - 22nd May):  Add getting started examples for Polyglot Wechaty (multi-language) as per the conversation here.  Update the page structure and include CodeSandbox for the bot (if necessary).  Add screenshots / GIFs to this page.  Device screenshots / GIF after running the bot. Week 4 : (23rd May - 29th May):  Check any improvements that can be made to the Usage with Docker page, and add any missing section (if required).  Verify the examples run properly on Wechaty Docker.  Make the page consistent and follow the proposed structure.  Add screenshots / GIF of the running Docker instance (if required)Week 5 : (30th May - 5th June):  Add instructions to the Usage with Heroku page.  Structure this page correctly.  Add screenshots while updating the instructions. Week 6 : (6th June - 12th June):  The Using Plugin with Wechaty page can be divided into several sub-sections each consisting of a tutorial for one Wechaty Plugin Contrib Package.  Adding information and step-by-step tutorial for each plugin.  Include a CodeSandbox to try out the bot.  Add screenshots and GIFs where necessary. Week 7 : (13th June - 19th June):  Continue with creating separate pages for each plugin.  Make each page follow the proposed structure Adding information and step-by-step tutorial for each plugin.  Include a CodeSandbox to try out the bot.  Adding screenshots and GIFs where necessary. Week 8 : (20th June - 26th June):  Add proper introduction to the Using Redux with Wechaty along with a defined goal for following this tutorial.  Structure the page properly Include code explanation and interactive CodeSandbox.  Add screenshots or GIFs (if necessary)Week 9 : (27th June - 3rd July):  Create tutorial pages for some of the bots mentioned on the Showcases page (need feedback from the community members).  Build tutorial for OSSChat bot (if approved by community members).  Add CodeSandbox and code explanation.  Add screenshots or GIFs (if necessary)Week 10 : (4th July - 10th July):  Work on creating tutorials for using the RuiBot &amp; Friday BOT Include step-by-step guide and CodeSandbox Add screenshots or GIFs (if necessary)Week 11 : (11th July - 17th July):  Start working on the Cheat Sheet which would consist of the following:     Brief description of a bot   Code snippet to use it   Tech description (in brief)   Example - CodeSandbox (maybe included)   Screenshots / GIFs   Creating the cheat sheet will take time (most probably two weeks). Week 12 : (18th July - 24th July):  Continue with the cheat sheet.  Create short video tutorials for some of the most used bots (if necessary).  Decide what are the things to be included to the Examples page. Week 13 &amp; 14:  Add multi-language support to the tutorials lacking it.  Including content to some of the pages of How-to Guides by discussing with the community members Add content to the Testing page Improve the structuring of the pages (if required - by discussing with the community members).  Get final reviews from the community and finalize the work done. This is an estimated project goal, changes might be done if suggested by mentors and community members. Measuring the project’s success: The project would be considered successful if after publication of the new documentation:  The tutorials page views increase by 50% The visit duration on tutorials increases by 50% (&gt;2 minutes) The bounce rate of tutorials decreases by 30% (&lt;50%)Why am I the right person for this project?: I believe I am the right person for this project because I have previous experience of contributing to documentation and how to structure the modules properly so that it is easier for beginners to follow. I have also worked on a comprehensive cheat sheet in the past, and I am comfortable with Git &amp; GitHub to make the contributions. I have already started contributing to the documentation of Wechaty and would love to work on it as a part of the GSoD 2021. Stipend: Based on work division. If one technical writer is selected - $5000 If work is divided between two technical writers - $2500. In this case, I am open to collaborating with the other technical writer and working as a team. Personal Information:  Name: Souvik Biswas Location: Kolkata, West Bengal, India Time Zone: UTC +05:30 Typical working hours: 7 AM - 2 PM (UTC +05:30)"
    }, {
    "id": 129,
    "url": "https://wechaty.js.org/2021/05/03/sajen-sarvajith-blog-post/",
    "title": "Sajen Sarvajith K: Blog Post for interactive tutorial (Google Season of Docs 2021 Proposal)",
    "body": "2021/05/03 - Biographical Information: I am a sophomore undergraduate student majoring in Computer Science from India. I have acted as a resource person on topics like ML, DL and orientation on online course awareness in colleges and universities. I have also organised and taken a few webinars regarding machine learning during COVID-19 pandemic. I am passionate about making interactive tutorials, documentation and deep learning. I have worked on projects regarding R-CNN, LSTM and deep learning in my university. I am familiar working with JS/typescript and popular frameworks like angular, react, node. js, django and flask, I will also do UI development and documentation and I have writing experience by working in paper publications. I am good with popular machine learning libraries like TensorFlow, PyTorch, keras, SciKit Learn, pandas, numpy, matplotlib. I have cracked the qualifier round of google code jam 2020, completed the Google Code-in competition in 2017 and completed hacktoberfest 2020 which are regarding open source. I have worked on two paper publications regarding anomaly detection and quantum machine learning algorithms. I am going to publish in Elsevier and ICLR journals respectively due to this pandemic. I am unable to go to my university AI lab to complete my final tests so my publications have been paused for now. I have applied to GSoD 21 in wechaty org regarding making an interactive tutorial to make users to understand and learn wechaty in a interactive way: GSod Project Proposal: Contact InformationName: sajen sarvajith k Email: sajenjeshan1222@gmail. com GitHub: sajenjeshan1222 Time Zone: UTC + 5:30 Motivation: My passion in deep learning, Natural Language Processing and documentation and my interest to work for an internationally reputed open source organisation made me apply for this Wechaty project. Ideally this project will allow me the opportunity to utilize my experience gained as an Wechaty GSoD intern. I believe that there is no better place to continue my coding and documentation skills through this platform. I consider it a vibrant experience to get the opportunity to meet mentors from all over the world and learn about new technologies. I am a very diligent and highly motivated student, and I am certain to push through with dedication. I have always worked to accomplish my goals and gain more knowledge and insight into quantum neural networks, deep learning and documentation. I will be able to contribute to this community in the best way I can. Project Title Create easy to learn tutorials for beginner users of wehcaty  Synopsis Abstract Task Expected Results Implementation/Approach Conclusion Additional IdeaAbstract: Users come to Wehcaty website seeking how to use wechaty to build a chatbot application for solving their problems. Unfortunately, the learning curve is not friendly to our users, they always struggle with setting up their development environment, can not get started with simplest example source code, and find it hard to know what they can do with the wechaty API. This problem leads to losing users for wechaty. This project aims to improve the tutorials for wechaty in a way that the new wechaty users can run example source code in the browser and learn how to use wechaty in an interactive way. Task:  To make an interactive tutorial which allow users to learn by doing Get the user started Make sure the tutorial works all the time Ensure the users sees results immediately Make the tutorial repeatable This tutorial is going to focus on concrete steps, not abstract concepts Provide the minimum necessary explanation Focus only on the steps needs to be taken Work with the contributor team to update the documentation on the wechaty siteExpected Results:  An interactive wechaty tutorial by using which the new users can understand easily by doing it live This easy and interactive tutorial helps the new users to get started in wechaty The tutorial will be tested several time and it will be stable once it is deployed When a user interacts by clicking run a code in the new tutorial the results will be shown up immediately without any delay This tutorial is easy to use, interactive and provides necessary explanation to the users to understand quickly and efficientlyImplementation/Approach: Below explanation regarding the significant steps for this interactive and easy to use tutorial Overview Section:  The beginner tutorial has different sections, the first section is overview and in that section new users can find an interactive way of description about the wechaty in general. This is achieved by using JS elements and the webpage intracts to user clicks and other actions rather than a static tutorial or a video tutorial, by this users will understand about the wechaty easily When a user reaches the end of the overview page there will be 2 options for the users, like the webpage will ask the new users that they have understood the above definition or not and the user must have to click it Once the user click anything from the options (understood or not) then 2 operations will take place the first one is the user answers will be saved in a  log  file which we can later use it as an review/survey taken for this tutorial by implementing this, the additional work to take a separate survey from the users about the tutorial is reduced and users can provide their reviews on the spot just by clicking which makes users an easy way to give feedback.  The second operation is that when the user click they understood then it will move on to next section, When a user click don't understand the above overview of the wechaty given in the tutorial then by using JS the web page will refresh with an alternative text which will be more simplified version which explains about the wechaty, then there will be a GIF/videos running in the webpage which helps the user to visualise how the wechaty is working and implemented in different messaging platform like wechat, whatsapp etc. user can choose the messaging platform and they can visualise with a small GIF which demonstrate how the wechaty is working so because of this approach users can understand easily and there will also be an text which explains about the wechaty. Quick Start Guide Section:  This section is a quick start guide section where the new users can get in touch with the wechaty code live directly from the wechaty tutorial page.  In this section there will be a step by step code with editor(terminal) available as well as a simple and clear explanation of what the code does in a beginner friendly way, users can change the code and explore with it by seeing the outputs of the code live from wechaty website without any delay.  This method of tutorials is called learn by doing tutorials which can help beginners to get started with wechaty and understand wechaty easily and quickly. In this tutorial users can interact, understand and use wechaty from the website itself which will help the beginners to grasp how to implement wechaty in real world cases so easily The getting started code for beginners will be available in the new tutorial of wechaty website. The code will be in a sequence where the beginners can find the explanation for the code from how to install wechaty and start wechaty to make it run. All this can be done directly from the website of wechaty without any delay or hassles so that the new users can understand more easily than ever ! The users can also edit the code right from the web page and the can run the code without any issues by doing this users can learn more about wechaty Then when a user understands the basics of wechaty and if the user needs to see the wechaty live in action then this can be done too! Directly from our website.  Once the user finishes going through our interactive tutorial then when a user starts the wechaty with the command that is done in our local machine to start wechaty, this can be done in the website itself now the user can start and run the wechaty from our website without any delay or any issues. When a user start the wechaty and run wechaty in browser then a UI will pop in website where users can interact with the chatbot that they started in the wechaty website and also an output like in terminal will be shown.  This UI is a demo to show the beginner users to see how the chatbot works in real time when implemented in any supported messaging platform so by this user can be able to understand and use wechaty without any hiccups.  The main thing is that all these things are done client side without any delay or slow and users can see the results immediately as soon as they run the code in the interactive tutorial page. There is no backend required for this approach and this interactive page just works perfectly fine like fluid and the user cannot notice any lag in the outputs or in the performance of the wechaty and web page.  All this is achieved through an JS emulation which works without any issues so by this wechaty and the interactive tutorial works flawlessly in the webpage like they run in real time. By using async functions, js workers and other frameworks an interactive experience is provided to the wechaty users.  The user have also options to change the code and run wechaty simultaneously User can edit the code and rerun the cell for a different output this will work exactly like how terminal works but it works directly from our website with a modern look and extremely improved UI of the page so by this user can understand in a efficient way and the wechaty will also run accordingly with the new updates as user gives so they can interact and see how it works.  All these beginner tutorials have the basic code to get started with wechaty as well as explanation which explains and makes users to understand the wechaty in an easy and interactive way. Note:- All the upcoming tutorials regarding overview, quick start, running locally, Money Bot, Assistant Bot, Coaxer Bot, using plugin, using redox and others will be made into an interactive way of learning tutorial in a step by step manner. These can be run directly in the website and users can edit the code and learn about the wechaty directly by doing it in our wechaty website. This approach that I have said above will help wechaty to run in the website itself. All these will be implemented as explained in the Quick Start Guide Section. I think this method will be more effective than a static website with a video tutorial because by this interactive learning tutorial users get the experience by doing it. Conclusion:  This project will help the beginner/new users of wechaty to learn about wechaty in a interactive way and helps for better understanding without any hassles This interactive tutorial will helps users to run code directly from the wechaty website without any additional requirements needed These tutorials will have a step by step instruction as well as good and clear explanation There will also be an UI to see the wechaty live in action and the user can test the wechaty directly from the browserAdditional Idea:  I am also interested in making this interactive beginner tutorial in different languages like chinese, english, Hindi, french etc.  This makes our users learn about the wechaty in their preferred language so that beginner users will be more comfortable when going through this tutorial.  Once I finish implementing this interactive tutorial then I will make a documentation for the code of this tutorial so that new developers can understand the code of this interactive tutorial and if they have any ideas to improve it they can improve it by going through the code documentation. Benefits to community:  This project benefits the wechaty and open source community by improving the tutorials for wechaty in a way that the new/beginner wechaty users can run example source code in the browser and learn how to use wechaty in an interactive way.  This interactive tutorial increases the pageviews and the duration of the tutorials will also be increased then the bounce rate of the tutorials will be decreased enormously.    The new tutorial will create a more personalized experience for the wechaty users      This new tutorial establishes an interaction between users and the content. This interaction allows wechaty users to have a more personalized experience beyond just a static tutorial   Not only does interactivity provide a better user experience, these interactions can also be measured. Using the data collected, we can see where/when/how users are clicking, and make adjustments to give them a more personalized experience. We can direct users to exactly what they are looking for and create more relevant tutorials for further visitors.     This tutorial increases user engagement. This website tutorial allows users to interact and automate each visitor's experience.  This website creates positive experience for our users   It increases conversions      This is done when we allow our visitors to do something and get a unique response back in regards to what was triggered.    This tutorial attracts more visitors and to be more engaged with the website. As they become more engaged, their trust and interest grows.     It invokes engagement and action. The thing that makes a website interactive is the ability for the user to actively engage with the content and various elements. This tutorial will break past one-way form of communication to start a two-way conversation with the user.  This tutorial can be extremely beneficial to both users and the wechaty community by providing individual and robust platforms for beginner tutorials. Deliverables: Project Timeline: Week 1 (May 18 - May 24):  Before the project timeline begins I will set up my development environment so that I will start the project as soon as possible this helps me to provide a professional tutorial In this will I will complete the work of making the overview interactive tutorial for the first section of wechaty which explains about the wechaty in general Create the log file for getting the user review in the webpage as mentioned in theimplementationWeek 2 (May 25 - May 31):  This week I will work on implementing the subsection of the overview which consist GIF and easy to understand way I have explained above like how wechaty will work and look like when implemented in a messaging platform.  I will finish implementing the JS emulator for our website which emulates the work of an bash/terminal How the emulator and this interactive website will look and how the users can edit the code live in the webpage and run wechaty in the browser itself all these is clearly explained above By this week our emulator will be ready so that we can implement this in our wechaty website to make real time interactive tutorials which users can understand easilyWeek 3 (June 1 - June 7):  Making step by step interactive tutorial for quick start guide Implementing the live code editor for this guide with code as well as explanation By this users can run the code from the wechaty website and understand itWeek 4 (June 8 - June 14):  In this week i will make this interactive tutorial for running locally This guide helps users to understand and get through the process of how to run the wechaty locally and users can find the code and run the code with the help of this tutorial directly from the website with output and good explanation if the user don't prefer to download in their local machineWeek 5 first month evaluation (June 15 - June 21):  I will submit all the code and documentation for evaluation that is finished in the previous weeks Then to make step by step tutorial for the money bot and how to use it with proper code and explanation with examples This allow users to run the example code and the code given in step by step tutorial for this botWeek 6 (June 22 - June 28):  Implement the UI for the bot to run directly in the browser once the user finishes the guide to code and understand this bot This allow users to see the bot in action from our website without any delay Start the work to make the interactive tutorial for the assistant botWeek 7 (June 29 - July 5):  Finishing the tutorial for assistant bot This allow users to run the bot directly from our website It have short code and proper explanation about what the code does and the users can run the code live and check the outputs or even they can built and change the bot as they wish from our website Implementation of UI for the bot to intact with the users so users can see how exactly the wechaty worksWeek 8 (July 6 - July 12):  Implementing the UI and the step by step interactive tutorial for coaxer bot This will also run directly on our website and users can learn about this bot by doing it Explanation of the code and making the code to run, able to edit and a proper explanation will be providedWeek 9 second month evaluation (July 13 - July 19):  This week I will submit the work that had been completed in the previous week I will interact with the respective mentors and work accordingly to produce a good and rich tutorial for wechaty users Start the interactive tutorial work for usage with dockerWeek 10 (July 20 - July 26):  Finishing the work of usage with docker tutorial Users can use this to learn and it gives step by step guide By this users will get hands on experience Starting the work for usage with heroku tutorialWeek 11 (July 27 - Aug 2):  Implementing the interactive tutorial and finishing up the work of heroku To start working for implementation on using plugin with wechaty To make this tutorial interactive by allowing users to make changes in the code and to run the code and understand by it Making detailed and good explanation on thisWeek 12 (Aug 3 - Aug 9):  Implementation of tutorial on using vorpal with wechaty Code samples and making it interactive so that the users can learn and understand by doing it rather than just by seeing A step by step explanation for the vorpal with wechatyWeek 13 third month evaluation (Aug 10 - Aug 16):  Making step by step guide with interactive tutorial on using redux with wechaty Doing some examples on wechaty so that user can feel free to explore this examples and they can run it live in our website and see the how it works in different use cases The third month evaluation will submitted on Aug 16 without fail by giving the previous week works and their outputsWeek 14 (Aug 17 - Aug 23):  Wechaty how to guide overview will be added in an interactive way so that users can have a better understanding of about wechaty Also to add use cases of wechaty in different areas with live code and examples to make and allow users to run and see the use cases of wechaty in live from the website Starting work for making interactive tutorial on installing wechatyWeek 15 (Aug 24 - Aug 30):  Doing/making the guides and step by step process for installing wechaty Implementation with code sample as well as explanation on how to install wechaty so the users can learn by doingWeek 16 (Aug 31 - Sep 6):  Starting work for creating a bot tutorial in an interactive way This tutorial will have sample code inorder to make users to understand how to make the bot Implementing the work to run the code from our web page without any delay Making explanation for the bot codes which makes users to understand quicklyWeek 17 (Sep 7 - Sep 13):  Making and implementing the interactive tutorial for listening events for wechaty and a detailed explanation with code examples and options to run will be provided to the user for better understanding Start working for dealing with messages tutorialWeek 18 fourth month evaluation (Sep 14 - Sep 20):  Submission of the work done in recent week with the code, tutorials and documentation Finishing the tutorial and implementation on dealing with messages Implementation on the interactive and user friendly tutorial on managing contacts, making rooms, managing friends, precessing files and writing tests all these tutorials will have a good and interactive explanation on making users to understand and use wechaty so easily directly from our websiteWeek 20 (Sep 21 - Sep 27):  Now all the intuitive tutorials/guides with code sample and explanation is finished, In this week i am going to implement the different language support for our interactive tutorials so that users across the world can understand in their native language and use it efficiently Documentation work will start for this interactive tutorial, code will be done in  . md  file so that in further if anyone want to improve this tutorials then they can go through this documentation and they can concentrate on improving the tutorialsWeek 21 (Sep 28 - Oct 4):  Documentation work will be finished and check for good quality I will use this week to go through all the code, tutorials, examples and explanation build from the starting till the end and if there is any issues they will be fixed The quality of the code, tutorials and documentation will be check continuously and improvedWeek 22 (Oct 5 - Oct 14):  I will ask for community suggestions and discuss with the mentors for any improvement and to improve the quality If there is any changes must be done according to user preferences that will be done accordingly Completing any remaining work and submission for final evaluationWeek 23 fifth and final evaluation (Oct 15 - Oct 22):  Submitting all the final works that is done from starting till now with good quality content and rich tutorialsI have already explained this interactive tutorial in the popsoal I submitted. The interactive tutorial will have a step-by-step code block (code editor which and run code and provide output in wechaty website) with step-by-step instructions/explanation for each code so that users can run the code and learn from it even users can change the code directly from the website then re-run it. Finally the users can run the actually wechaty bots in the website itself then the bot can respond and interact with the user this is done to show the users how the wechaty bot will work if it's deployed in any messaging platform from this users will get a idea how the bot is working and users will learn to use wechaty easily than ever!. This is done through JS emulation that is explained in detail in the project proposal without any back-end needed for this approach and everything is done in the front-end. Second approach: Since we have development server for wechaty community. By using this we can run all the code and this interactive tutorial can take advantage of this server. In this second approach the interactive tutorial will be done in the back-end and rendered in the front-end without any delay. The back-end scripts will be written in golang or rust so that it can be more fast to give users a real time experience. Final Conclusion: So let's discuss both of the approaches and select which approach is good for making this interactive tutorial. "
    }, {
    "id": 130,
    "url": "https://wechaty.js.org/2021/05/03/project-proposal-wechaty/",
    "title": "Abhishek Jaiswal :Project Proposal for GSoD'21",
    "body": "2021/05/03 - Introduction: Hello, ChatBot Developers! Myself Abhishek Jaiswal,CSE sophomore from IIIT Bhubaneswar,India and a MSFT student ambassador interested in improving the tutorials of Wechaty. My past Technical Writing Experience Technical Writer - AnalyticsVidya@medium &amp; Devtutorials@mediumTechnical Writer - HashnodeVideo Production Manager - Qualki Project Proposal: Abstract: A easy-to-learn tutorials are designed to assist end users to get familiar with the product or service. Good tutorials are very important because it provides an avenue for users to learn how to use a software, its features, tips, tricks. It also reduces support cost and is part of the corporate identity of the product: a good tutorials as well as user documentation is a sign of healthiness of the product, the developer team. Without good tutorials, a user may not know how to do the above things effectively and efficiently. Also User Documentations can play a pivotal role in ensuring a product’s success because great communication is and will always be at the heart of any business or product and a great documentation just takes that communication and puts it in a manageable framework that everyone can access for success. At the time of this writing, the Wechaty now has more than 9900 Stargazers over time and the having no downtime after 12th Nov,2020 for the API and FridayBot, this shows that a lot of people all over the world use the Wechaty and may want to read its tutorials for guidance on how to use the the chatbot maker. However, the Wechaty tutorial is currently outdated and incomplete and the Wehchaty community wants to use this project to improve its tutorials and user documentation to enable end users to have a seamless experience when using the Wechaty. Current State: Currently, the tutorials are available on its official website. It is obsolete, incomplete,hard to navigate or find information, does not cover code about some programming language of the chatbot maker and some posts and tutorials are written in Chineselanguage which causes a major setback for people who can’t read the Language. Why is your proposed user documentation an improvement over the current one?: The proposed user tutorials will be structured to improve and ensure efficiency,consistency, and peace of mind for any end user. It will contain written guides and its associated images, include instructions and explanations on how to use each feature of the Wechaty, up to date, allow the user to learn by doing, understandable and translatable in English languages as well all the blogs,posts,video subtitles aswell. Analysis: Huan and I had a conversation about the new changes that are to be made with the current tutorials and he shared two links that showed a project’s scope file written with Docusaurus documentation system v2 and a tutorials docs given on wechaty and said they expect to enhance the contents under the tutorial sub menu. The links he shared with me can be found here and here. I researched a lot about these tools to get a better understanding of how it works. Docusaurus documentation system v2 Docusaurus makes it easy to maintain Open Source documentation websites. Docusaurus currently provides support to help the website use translations, search, and versioning, along with some other special documentation markdown features. Some of its features are :  Powered by Markdown Built Using React Ready for Translations Document Versioning Document SearchIt makes design and documentation changes by using the included live server. Also, it publishes the site to GitHub pages or other static file hosts manually, using a script. Project Goals:  Allow the user to learn by doing Get the user started Make sure that the tutorial works all the time Ensure the user sees results immediately Make the tutorial repeatable Focus on concrete steps, not abstract concepts Provide the minimum necessary explanation Focus only on the steps the user needs to take Work with the contributor team to update the documentation on the Wechaty siteMy Previous Contribution:  https://github. com/wechaty/wechaty. js. org/pull/798 https://github. com/wechaty/wechaty. js. org/pull/789 https://github. com/wechaty/wechaty. js. org/pull/784 https://github. com/wechaty/wechaty. js. org/pull/782 https://github. com/wechaty/wechaty. js. org/pull/775 https://github. com/wechaty/wechaty. js. org/pull/761 https://github. com/wechaty/wechaty. js. org/pull/758Timeline: Doc development(Before 30 April)  Continue making contributions to the organisation.  Become more familiar with the current tutorials and make a blueprint of the changes to be done.  Learn new technologies and technical writing skills which will be helpful while implementing the project.  Learn more about the community and product.  Discussing the proposed documentation structure with the mentor and other members of the organisation.  Finalised the proposed feature and other modifications that need to be made with existing tutorials. Week 1 (1nd May - 8th May): This week I will focus on setting up the GitHub repository which I will use to push and pull all the changes I have made.  If a Github repository for the documentation has already been created by the Wechaty community before the beginning of the documentation period, I will fork the repository so that I can be making changes to my branch directly before creating a pull request to the main repository to be reviewed and merged by the mentor. If not, I will create a repository for the documentation on GitHub (of course after taking permission from the mentor).  Add a README file to GitHub to help future contributors understand how to contribute to Wechaty documentations and tutorials.  I will write documentation on two subheadings in the Getting Started section of the documentation.  Why Wechaty: A brief introduction and some little history of the Wechaty community and Chatbot Maker.  List of Examples: To excite people to use this chatbot maker.  Commit the newly made changes to my branch and create a pull request for review. Week 2(9th May - 15th May):  Help &amp; Contact :To mention all the necessary links and references with details.  Quick Start Setup : A quick easy to understand setup tutorial with necessary images and easy-to-understand words.  Installation : Straightforward installation with images for each step in installation. Week 3(16th May - 22nd May):  Showcase : To translate language as well as rearrange the topics in block form for better User Interface.  Hands-on tutorial’s Homepage :To translate page and retransform page for better experience. 4 Basic tutorials for beginners : To add a well explained introduction and some wechaty images to make interests for the users. Week 4(23rd May - 29th May):  Video Tutorial (Money Bot) : To translate the entire page and to add english subtitles to the video.  Create a bot : To reorganise the page, add items to left fields and conversion of codes to 5 different programming languages.  Listen to events : To reorganise the page, add items to left fields and conversion of codes to 5 different programming languages. Week 5(30th May - 5th June):  Video Tutorial (Assistant Bot) : To translate the entire page and to add english subtitles to the video.  Deal with message : To reorganise the page, add items to left fields and conversion of codes to 5 different programming languages.  Manage rooms : To reorganise the page, add items to left fields and conversion of codes to 5 different programming languages. Week 6(6th June - 12th June):  Video Tutorial (Coaxer Bot) : To translate the entire page and to add english subtitles to the video.  Make friends : To reorganise the page, add items to left fields and conversion of codes to 5 different programming languages.  Process files : To reorganise the page, add items to left fields and conversion of codes to 5 different programming languages. Week 7(13th June - 19th June):  Manage contacts : To reorganise the page, add items to left fields and conversion of codes to 5 different programming languages.  Write tests : To reorganise the page, add items to left fields and conversion of codes to 5 different programming languages.  Construct page for Heroku usage : To add content along with some visuals for better experience. Week 8(20th June - 26th June):  Construct page for Heroku usage : To add content along with some visuals for better experience.  Construct page for Heroku usage : To add content along with some visuals for better experience.  Reorganise Pugin with wechaty page : To reorganise all the content and add some photos for making it interesting. Week 9(27th June - 3rd July):  Reorganise Pugin with wechaty page : To reorganise all the content and add some photos for making it interesting.  Reorganise Pugin with wechaty page : To reorganise all the content and all photos for making it interesting. 5 Examples and cheatsheet : Add some new examples and make new cheatsheet for the project. Week 10(4th July - 10th July): Conversion of Blogs to english language with possible images as well :  How do I use Chatbot to reconstruct the sales system in Qiji Innovation Forum,@rickyyin Chatbot’s application in customized travel industry,@likai Microsoft Tech Summit-Quickly build a chatbot,@lijiaruiWeek 11(11th July - 17th July): Conversion of Blogs to english language with possible images as well :  Use wechaty to realize news and information broadcasting robot,@judaschrist Party entertainment robot,@osindex Wechaty-Let there be no difficult business online, @coderwhocodeAdditional Work Week 12(18th July - 24th July):  To reverify the reference doc,if we have any docs incomplete ,and translate it to english language as well ,and try to complete it within a week: API references Polyglot Puppet providers Puppet Services SpecificationsWeek 13(25th July - 31st July):  To go through Explanations docs ,and translate it to english language as well for easy understanding and well formatted documents.  Overview Conversational RPA Motivation Concepts Architecture Life Cycle Alternatives Glossary FAQ Troubleshooting Docusaurus6Week 14(1st August - 7th August):  This week I will put all my attention on proofreading the documentation for typos and errors.  Submit a project report and evaluation of my mentors Write and submit a report of my experience as a participant in Season of Docs. Personal Information:  Name: Abhishek Jaiswal Github: https://github. com/abhishek-iiit Blog: https://abhishek-iiit. hashnode. dev/ &amp; https://abhishek-iiit. medium. com/ Gitter handle: Abhishek Jaiswal Location: Uttar Pradesh, India Time Zone: (UTC + 05:30) India Typical working hours: 4PM - 10 PM (UTC + 05:30) India"
    }, {
    "id": 131,
    "url": "https://wechaty.js.org/2021/05/03/joseph-mawa-google-season-of-docs-project-technical-proposal/",
    "title": "Joseph Mawa: 2021 Google Season of Docs Technical Proposal",
    "body": "2021/05/03 - My name is Joseph Mawa. I am a technical writer and web developer. Below is my proposal for the project Create easy to learn tutorials for beginner users of Wechaty under Google Season of Docs 2021. Statement of interest:  Personal information Name: Mukosa Joseph Mawa Email: mjm. mawa@gmail. comProfessional information: Summary: I am a self-taught web developer and technical writer with a passion for open source software. I have published a number of beginner friendly technical articles on dev. to and freeCodeCamp. Before transitioning into tech, I was a high school teacher. One of my core responsibilities as a teacher was simplifying and sequencing text written in complex technical language for learners to easily understand. I have also been a frequent contributor to a couple of open source software. Notable ones are ocaml. org and disease. sh. Writing samples: Beginner friendly technical article written for freeCodeCamp:  Browser events explained in simple English How to add netlify form to a react app bootstrapped using create-react-appBeginner friendly tutorials published on dev. to:  What is useRef hook and how do you use it Usecontext hook and context API. What are they and when do you use them What is useEffect hook and how do you use it Interview type coding challenges in JavaScript What is useEffect hook and how do you use itOpen source contribution: I helped improve firefox profiler setup instructions Other useful linksResumeportfolio Project proposal: Project title: Create easy to learn tutorials for beginner users of Wechaty Project approach: This is a high level overview of how I intend to approach this project. This is an evolving plan which will likely change pending feedback from stakeholders. Seek to understand stakeholders: The first thing I will do is try to understand my audience. The tutorials are meant for absolute beginners who want to learn Wechaty but what else can we learn about them? If possible, I will seek answers to the following questions.  What is their technical background? What demographic groups do they belong to? What problem are they trying to solve with Wechaty? What is their motivation for using/learning Wechaty? Is it for profit? Are they hackers doing it for fun? Are they using Wechaty for building school projects? Are they researchers/ academics? Is it a mix of the above categories of people?It is important to learn as much as possible about your audience before writing tutorials so that it is tailored to their needs.  Learning takes place much faster when it is structured from known to unknown and reference is made to what the learner already knows to explain a concept. It also ensures cultural sensitivity when giving examples especially in a global audience. The more you know about your audience the more relevant your examples will be. Develop contentWork with the project volunteer to come up with the list of key things a total beginner who wants to learn Wechaty needs to know. Break those key learning areas into the smallest units possible. For example a learner might need to set up a development environment. Setting up a development environment is not the smallest unit possible. It can still be broken down. For example one might need a text editor, install software such as node or python, have access to certain platforms e. t. c. Sequence content: Sequence the learning areas which have been broken down in the previous step in chronological order. For example, the knowledge, skills and competences attained in step A might be prerequisite for step B, that of A and B might be needed for step C and so on. If that is the case, it would make a lot more sense to sequence from A, to B then to C. Therefore sequencing the units appropriately from simple to complex, from known to unknown will make the learning process enjoyable. Formulate instructional objectives: Turn those key learning areas into instructional objectives. The objective must be SMART. S - specificM - measurableA - attainableR - realisticT - within a time boundThe smallest units in the previous sections can be amalgamated where necessary so as to make practical sense. A typical example of an instructional objective is: At the end of this section a learner should be able to set up a development environment for Wechaty. The objective is specific, measurable, attainable, realistic and within a time bound i. e. from the start of the section till the end. Achieving the above objective should contribute in a certain way to the overall objective of learning Wechaty so that a combination of all the small learning objectives will translate into the overall objective. Map instructional objectives to learning activities: Identify practical, repeatable activities a learner can perform to achieve the stated objectives in the previous section. Let us say the main learning activity is building a chatbot using Wechaty. We would need to answer the following questions. What does building a chatbot using Wechaty entail?What steps should a learner follow when building a chatbot using Wechaty? This should be done while paying attention to the objectives in the previous section to make sure they are being achieved as the learner goes through these activities. The cardinal reason for going through the tutorials is to achieve the objectives in the previous section which will ultimately translate into the overall objective. Structure and write content: After outlining the activities in the previous section, we need to structure the content in a meaningful way. The proposed content structure and presentation is to split the tutorial into high level units/ sections. Each unit/section will have the following components. This is important because it ensures that anyone who has forgotten a specific concept can go to that specific section to remind themselves. Below are the proposed components of a unit. Each unit needs to have a link to the next and previous unit. Section headingThe section heading should be a high level summary of what the learner will be doing in a particular section. It should capture the objective you wish to achieve by making the learner go through the activity. ExplanationImmediately after the heading, there should be a brief explanation of what the learner will be doing in this particular section and why they are doing it. The focus should be on the learner. It is therefore important to use statements such as: In this section, you will declare a function which takes a string as argument and returns the number of characters in it. The focus here is on what the learner will do. PrerequisitesAfter an explanation of what the learner will do in this section as articulated in the preceding subsection, there should be an outline of what the learner should know or have, to be able to complete this section successfully. For example the knowledge acquired in the preceding sections might be necessary to be able to complete this section. A learner might also need to have access to certain platforms such as whatsapp or facebook. This is where the prerequisites have to be clearly outlined. Prerequisites could also be software or other tools necessary to complete the section. StepsThese are the actual steps a learner will have to go through. If it is a multi-step process, you can number them. For example step 1, step 2, step 3 and so on. There is no need to number if it is a single step process. Expected outputWhat should happen if a learner successfully followed the steps outlined in the above subsection. An example of expected output is: After successfully installing software X, you should see it listed in the package. json file. We can also provide hints on possible challenges the learner might encounter in this section and how they can be fixed. Fun QuizIf possible, simple optional quizzes should be included at the end of each section to test the knowledge gained. This can boost the morale of the learner and give feedback about the progress they are making. Additional resourcesThis is an optional section which points to additional resources a curious learner can explore to expand their knowledge about what has been covered in that particular section. It can link to Wechaty API if necessary. Things to pay attention to while writing the tutorial** Use simple English that a non native speaker can easily understand without having to look up meaning of words or phrases Avoid long sentences.  Minimize use of acronyms Avoid unnecessarily long paragraphs which might confuse learners Use formal language Be gender sensitive. Gender neutral language is better Pay attention to grammar and spelling Pay attention to technical accuracy Focus more on what the learner will doProposed timeline: Below is an estimate of the timeframe within which this project will be completed. It has been broken down into subtasks. It is worth pointing out that the processes below are not linear. They are iterative and cyclical. They can change as feedback is received from different stakeholders and incorporated in the project.       Month   Activities   Stakeholders         1   &lt;ul&gt; &lt;li&gt; Technical writer learns Wechaty &lt;/li&gt;&lt;li&gt; Engage stakeholders to understand the Wechaty community &lt;/li&gt;&lt;li&gt; Develop outline of tutorial content &lt;/li&gt;&lt;li&gt; Develop learning objectives &lt;/li&gt;&lt;li&gt; Formulate tutorial structure at a higher level &lt;/li&gt;&lt;li&gt; First tutorial draft &lt;/li&gt;&lt;li&gt; Release first draft and take feedback &lt;/li&gt;&lt;/ul&gt;   &lt;ul&gt; &lt;li&gt;Volunteer&lt;/li&gt;&lt;li&gt;Contributors&lt;/li&gt;&lt;li&gt;Users&lt;/li&gt; &lt;/ul&gt;       2   &lt;ul&gt; &lt;li&gt; Receive feedback from stakeholders about first draft &lt;/li&gt;&lt;li&gt; Incorporate feedback given for first draft &lt;/li&gt;&lt;li&gt; Release second draft &lt;/li&gt;&lt;li&gt; Incorporate feedback from stakeholders &lt;/li&gt;&lt;li&gt; Test the tutorial with volunteer beginners &lt;/li&gt;&lt;li&gt; Incorporate feedback from volunteers &lt;/li&gt;&lt;li&gt; Release final version of tutorials &lt;/li&gt;&lt;/ul&gt;   &lt;ul&gt; &lt;li&gt;Volunteer&lt;/li&gt;&lt;li&gt;Contributors&lt;/li&gt;&lt;li&gt;Users&lt;/li&gt; &lt;/ul&gt;       3   &lt;ul&gt; &lt;li&gt; Audit Wechaty website &lt;/li&gt;&lt;li&gt; Propose changes to the volunteer mentor &lt;/li&gt;&lt;li&gt; Make improvements to the Wechaty website &lt;/li&gt;&lt;li&gt; Get feedback &lt;/li&gt;&lt;li&gt; Incorporate feedback &lt;/li&gt;   &lt;ul&gt; &lt;li&gt;Volunteer&lt;/li&gt;&lt;li&gt;Contributors&lt;/li&gt;&lt;li&gt;Users&lt;/li&gt; &lt;/ul&gt;   Proposed budget: The proposed budget for the entire project is 5000USD(Negotiable). "
    }, {
    "id": 132,
    "url": "https://wechaty.js.org/2021/05/03/interactive-tutorials-for-newcomers/",
    "title": "Soumi Bardhan: Interactive tutorials for newcomers",
    "body": "2021/05/03 - GSoD 2021 Project Proposal: Project - Create easy to learn interactive tutorials for beginner users of Wechaty: I am Soumi Bardhan, a passionate python and deep learning dev. Google Season of Docs 2020 - Technical writer - Sympy:  Sympy is a lightweight independent computer algebra system. Added and updated documentation, added missing style sections like Parameters and improved organization.  My Season of Docs 2020 Report for the project Consistency Across docstrings : Sympy Documentation Analysed metrics on the google search console before, during and after. Updated the modules with the most number of users first, then moved on to the less used modules. Cppsecrets. com : Python Developer, technical writer:  Well written articles and tutorials on several python libraries.  Implementation of SQLAlchemy ORM for creating Flask Applications Functions of OS Module in python and implementations, tutorialsGeeks for Geeks, Technical Content Writer:  Written articles based on OpenCV library functions and data structures and algorithms.  Link to profileData driven investor : Technical Writer:  Articles and tutorials on deep learning.  Using several deep learning methods to create models.  Create frontend and backend applications to host the models on cloud.  Docker and AWSAnalytics Vidhya: Technical Writer:  Articles and tutorials on deep learning.  Using several deep learning methods on creating deep learning and ML models.  Create frontend and backend applications to host the models on cloud.  Using pycaret to create several regression models and tuning.  LSTMs for Stock PredictionThe Startup : Technical writer:  The Startup is the largest active medium publication. I write technical articles mostly in the NLP domain.  Natural Language Processing Deep Learning BERT(Bidirectional Encoder Representations from Transformers)Research Work:  My Research Work on Autism Spectrum Disorder Detection is also in progress. I am working at ITMR (Interactive Technologies &amp; Multimedia Research) Lab, IIIT Allahabad remotely to simulate the results of my research work that is almost completed. Links to some of my medium articles: Named Entity Recognition — Simple Transformers — Flask REST API Fixing Open Source Vulnerabilities in Azure Dev Ops- WhiteSource Bolt Dockerizing and Hosting your Flask Web App(Rest API) on AWS EC2 Weather Based Stock Prediction with Pycaret - Analytics Vidhya Tkinter Application to Switch Between Different Page Frames I believe creating a consistent documentation of code is very important for any open source project for its growth. Abstract: Current State of Wechaty Tutorials and previous work: Users come to Wechaty website and are seeking how to use Wechaty to build a chatbot application for solving their problems. Unfortunately, the learning curve is not friendly to Wechaty users, they struggle with setting up their development environment, can not get started with the simplest example source code, and find it hard to know what they can do with the Wechaty API. This problem leads Wechaty to lose lots of new users, increases the number of questions asked in the community, and lowers the user satisfaction. The current version of the Wechaty tutorial is not properly planned. The tutorials on the website have to be approved. Proposed Work: Tutorials need to be useful for the beginner, easy to follow, meaningful and extremely robust, and kept up-to-date. The Tutorial project will do the following :  Allow the user to learn by doing Get the user started Make sure that the tutorial works all the time Ensure the user sees results immediately Make the tutorial repeatable Focus on concrete steps, not abstract concepts Provide the minimum necessary explanation Focus only on the steps the user needs to take Work with the contributor team to update the documentation on the Wechaty site.  Make video tutorials available in English Each Module in the documentation needs image screenshots as well as gifs and video demonstrating the action. It’s also important that they get access to both the code, screenshots, outputs and videos directly from the same page.  To get beginners interested, it is important to define right in the beginning of tutorial what will be the end result. So that will be designed as well. Contributions:  795 : Added interactive code sandbox for contact bot 797 : Added subsections to Examples section and reorginzation 756 : Updates Google Cloud instructions and images for Getting Started Tutorial 749 : Enhance Getting started with Gitpod section of Getting Started Tutorials 774 : Update getting started with Redux 745 : Updates Usage with Heroku Page 776 : Added Case studies in EnglishProject Goals and Timeline:  Before May 1, continue making contributions to Wechaty.  Become more familiar with the user documentation and current version of Wechaty. Community bonding:  Set up a communication channel and time(due to timezone difference) Refine my goals and set expectations on both sides.  Discussing the order in which the tutorial pages will be updated.  Finalize the order of editing the tutorial sections. Documentation Period: Wechaty Website repository    As we already have a repository for the website, I will start with updating the existing pages first. I think it is important to add video walkthroughs and tutorials for beginners.     For this, I will be collaborating with existing contributors and taking their inputs and feedback on the tutorials I create.  Two important changes :    Define a specific structure for every tutorial page :      Aim   Prerequisites   Video Tutorial   Steps (with Screenshots)   Results   Try Out the Bot (interactive section)   Important links   References    Cutting down on text and adding video tutorials and gifs to engage beginners.  Add Interactive Sandboxes to all tutorials.  Adding simple English text for pages available only in Chinese.  Add a latest release section for blogs and information on the latest features. Week 1 : (1nd May - 8th May):  Update cheat sheet and upload video tutorial on use cases.  Cover common setbacks beginners face while contributing.  Video tutorial for a first-time github contributor, for both code and documentation. Week 2 : (9th May - 15th May):  Update docker. md and upload video tutorials.  Demo of usage of Ding Dong Bot and Basic functions. Week 3 : (16th May - 22nd May):  Video walkthrough of usage of advanced functions.  Overview. md will be made more attractive and friendly, to excite new users. Will add gifs to the webpage. Week 4 : (23rd May - 29th May):  Add Use cases of usage-with-heroku. md in details.  Record demo videos and gifs of Friday Bot. Create interactive sandbox. Week 5 : (30th May - 5th June):  Record demo videos and gifs of :     OSSBot   Mikt BO    Create interactive sandbox.  Organize and record videos and gifs for using-plugin-with-Wechaty. md. New users need to be able to see visuals. Week 6 : (6th June - 12th June):  Add separate pages for commonly used plugins with Wechaty.  Record videos for Running DingDong bot with GitPod with gifs. Week 7 : (13th June - 19th June):  Record videos for running Dingdong bot with Google Cloud along with gifs for blog posts, which can act as teasers and shared in open source communities. Week 8 : (20th June - 26th June):  Record video tutorial for getting started the hard way. Also, instead of mentioning the “hard way”, we can write “for experienced devs”. That is bound to make it sound easy. Also, adding a video tutorial will make it easy and resolve any issues they face along the way. Week 9 : (27th June - 3rd July):  Get started with Videos in simple easy to understand English about the Money Bot. (Here will need a bit of help with translation from already existing tutorials, although i will be creating completely fresh videos. ) Update the website as well to be multilingual(will add simple easy to read English)Week 10 : (4th July - 10th July):  Update the Assistant Bot webpage and create video tutorials.  Create interactive sandbox. Week 11 : (11th July - 17th July):  Update the Coaxer Bot webpage and create video tutorials. Week 12 : (18th July - 24th July):  Update the getting started - overview. md with gifs and visuals with what can be achieved with Wechaty.  Add videos for setting up a development environment for new Wechaty contributors for the Contributing section of the docs.  Add a video keynote from Wechaty creators in simple english talking about why Wechaty was developed and its history. Week 13 and 14:  Adding content to the testing page collaborating with the mentors.  Finalizing the work done and getting final reviews from the community. The modules mentioned here can be changed after further discussion with mentors and community. As suggested by mentors and community and by the search control stats, I will focus on updating those modules first which are more beginner friendly. The rest of the work will be decided based on the work done and search console results. Measuring my project’s success: Success shall be measured by the following metrics :  The tutorials page views increase by 50% The visit duration on tutorials increases by 50% (&gt;2 minutes) The bounce rate of tutorials decreases by 30% (&lt;50%)Why am I the right person for this project?: I believe myself to be the right person for this project because I have past experience in technical writing and I am well versed with git and github. I also find Wechaty very interesting. I have experience in writing tutorials as well as open source. I have worked as a technical writer with SymPy in GSoD 2020. I would love to improve Wechaty’s tutorials and documentation structure. I have set up the development environment for Wechaty [1] . I am very comfortable in making contributions. Stipend: Based on work division. If one technical writer is selected - $5000 If work is divided between two technical writers - $2500. In this case, I am open to collaborating with the other technical writer as well and working as a team. Personal Information: Soumi Bardhan  Github Linkedin Blog Location: Kolkata, West Bengal, India Time Zone: (UTC + 05:30) Typical working hours: 10AM - 7 PM (UTC + 05:30)References: 123 "
    }, {
    "id": 133,
    "url": "https://wechaty.js.org/2021/05/03/gsod-project-proposal-shwetal-wechaty/",
    "title": "Shwetal Soni: GSOD'21 project proposal for wechaty",
    "body": "2021/05/03 - GSOD21 Proposal for Wechaty: Introduction: Hello Fellow Developers! Myself Shwetal Soni. I’m CSE Sophomore from National Institue of Technology Hamirpur, Himachal Pradesh, India and a Frontend Web Developer and UI/UX Designer also. Currently I’m exploring blockchains. I’m interested in contributing to wechaty’s tutorial. Technical Writer: Shwetal Soni Contact Email: sonishwetal704@gmail. com Professional Information: Writing Samples:    Tutorial for writing Smart Contracts on Tezos     Getting over Imposter Syndrome  My Resume: shwetalsoni_resume My Portfolio: shwetalsoni. github. io Overview of my recent work: Recently I had written a beginner-friendly tutorial for writing smart contracts on SmartPy which takes the user from introducing to blockchain to finally deploying a smart contract. To make it easier to understand I have attached screenshots guiding them throughout the whole process ensuring they learn by doing. I got it reviewed by some people and they really found it useful and easy to follow. Project Title: Create easy to learn tutorials for beginner users of Wechaty Abstract: Tutorials are lessons that take the reader by the hand through a series of steps to complete running Wechaty code. They are what our project needs in order to show a beginner that they can achieve something with it. They are wholly learning-oriented, and specifically, they are oriented towards learning ‘how’ rather than learning ‘what’. Tutorials need to be useful for the beginner, easy to follow, meaningful, extremely robust, and kept up-to-date. The Tutorial project should:    Allow the user to learn by doing     Get the user started     Make sure that the tutorial works all the time     Ensure the user sees results immediately     Make the tutorial repeatable     Focus on concrete steps, not abstract concepts     Provide the minimum necessary explanation     Focus only on the steps the user needs to take     Work with the contributor team to update the documentation on the Wechaty site.  Current Situation: Users come to Wechaty website seeking how to use Wechaty to build a chatbot application for solving their problems. Unfortunately, the learning curve is not friendly to our users, they always struggle with setting up with their development environment, can not get started with the simplest example source code, and find it hard to know what they can do with our API. This problem leads to us losing lots of new users, an increased number of questions asked in the community, and lowered user satisfaction. Analysis: Being a new user to wechaty I encountered a lot of problems while running Ding Dong Bot. For deep analysis, I asked some of my friends to go through the documentation and try running the bot. Almost everyone faced a lot of issues while running the bot. This clearly depicts that the Tutorial is not properly structured. Following are the problems I have found out with the tutorials    Quick Start is a place where most of the beginners will head over to and should be mentioned at the top of tutorials unlike now it is inside a Getting Started dropdown.     Don’t mention something a learner doesn’t need to know in order to complete the tutorial. Inside Quick Start under the first heading In Next 10 min, I found out that the points written there about getting QR Code for wechaty and QR Code for WhatsApp are useless and even misleading. It messed me up when clicking on WeChat QR Code it didn’t open and later found out that it has nothing to do with the tutorial.     Tutorials overview didn’t have necessary info on what are the ways in which users can get started. In many good documentations, I have found out that they provide the main link on the overview page so that users can head over from there directly.     Tutorials should always be working but Usage with Heroku is not working.     Video Tutorials are like icing on the cake and should be provided in a language that is widely spoken other than Chinese. I even found a comment on youtube requesting for English video.     There is a link Getting started without leaving your browser after Let's run your first Ding Dong Bot given in the read more section by Huan Li. It is very well written and should be mentioned separately in the sidebar under the Gitpod option.     Currently Tutorials only teach the user to set up wechaty but a tutorial should also give the user an experience of working with the features of wechaty.  Based on the above analysis I propose the following structure: Getting Started with Wechaty |- Overview | -&gt; Beginner Level |   -&gt; Running on Gitpod |   -&gt; Running on Google Cloud Shell |   -&gt; Running Locally |   -&gt; Creating your first bot from scratch | -&gt; Intermediate and Advanced Level |   -&gt; Usage with Docker |   -&gt; Using with Heroku |   -&gt; Using Plugin with wechaty |   -&gt; Using Redux with wechaty |   -&gt; Using Vorpal with wechaty |- Quick Start | |- Running on Gitpod | |- Running on Google Cloud Shell | |- Running Locally |- Tutorial Series(Creating your first bot from scratch) | |- From Scratch | | |- Overview | | |- Installation | |- Tutorial | | |- Create a bot | | |- Dealing with messages | | |- Processing files | | |- Writing tests |- Video Tutorials | -&gt; Chinese Tutorials | -&gt; Other than Chinese Tutorials |- Advanced Topics | | |- Usage with Docker | | |- Using with Heroku | | |- Using Plugin with wechaty | | |- Using Redux with wechaty | | |- Using Vorpal with wechaty    The above structure is well organized from beginner to advanced level.   The overview section should give a complete overview of the topics. If a person is a beginner he can either simply run the app using any of the following options Running on Gitpod, Running on Google Cloud Shell, Running locally by clicking on the given links here.      Also the link for Tutorial Series (Creating your first bot from scratch) will also be given in case a user want to follow up with steps creating their own chatbot.    If a user has prior knowledge about wechaty, they can go to the advanced topics by clicking on the links given for respective topics Usage with Docker, Using with Heroku, etc.       Quick Start should be divided into sections. If a user wants to run the app using Gitpod, there should be a separate page for that. Similarly for the remaining two options also. This will enable proper step-wise step tutorial for every option unlike now Running with Gitpod and Running with Google Cloud Shell are both on the same page messing it up and leading to skipping of some important points.     Tutorial Series(Creating your first bot from scratch) is the most important part of this tutorial as this will allow the user to create their own chatbot from scratch and then playing around with the features provided by wechaty. It should be well equiped with code snippets with proper explanation and screenshots of how the result will look after running a given code/command. This will make sure that they learn by doing and will definitely gather interest of more users.     Video Tutorial plays a great role in providing a better understanding and should be available in the language which is widely spoken.   Advanced Topics At the end, if a user has gone through the easy concepts they can dive into intermediate and advanced concepts. Why is my proposed tutorial better?: QuickStart will get the user started. The Tutorial Series will allow the user to learn by doing. Users can see immediate results in the form of output screenshots attached with every step. The whole structure focuses only on the steps the user needs to take with the minimum necessary explanation. Why am I the right person for this project?: From last year I have building many personal projects and also writing Readme for that. Recently I learned to write Smart Contracts on Tezos blockchain and it had very few resources available to get the user started and hence I struggled a lot. This motivated me to write a medium article Tutorial for writing Smart Contracts on Tezos. So, I know what people expect from a tutorial. Hence, combining all my experience and analysis of this project I can assure a great tutorial. Proposed Timeline:  2 weeks -&gt; Information Gathering 3 weeks -&gt; Restructuring the tutorials. Organizing and presenting the content in a better way.  5 weeks -&gt; Creating a tutorial series.  2 weeks -&gt; Improvising and publication. Proposed Budget: Technical Writer Stipend -&gt; 5000 (Decided by the organization) "
    }, {
    "id": 134,
    "url": "https://wechaty.js.org/2021/05/03/gsod-2021-applicant-jaya2320/",
    "title": "Create easy to learn tutorials for beginner users of Wechaty",
    "body": "2021/05/03 - My name is Jaya Gupta, I am a 3rd year Informational Technology Student currently persuing my B. Tech from HMRITM, Delhi. I have learned various programming languages such as C , C, PYTHON, DJANGO, Machine Learning, Deep Learning. I have designed variety of projects using Web Development, Machine Learning, Deep Learning and Django. Also received position in hackathons and still working to achieve more. I am also very proficient in writing codes in Python and C language. I with my fellow team mates have designed a project named AAYE(Appointment At Your Ease) which aims to help patients have their daily routine check-ups with their doctors at home especially at the time of pandemic , so that we can break the traditional queue system. I have created a web application to detect skin cancer using art of technique called deep learning to help people and doctors to work on the next step immediately instead of wasting time on waiting for reports, it also includes an online forum so people can discuss and share their opinion, a mask detector using machine learning to help people know who is wearing mask or not especially in public places such as shops, malls etc. I really enjoy solving different questions from various competitive programming site in my free time. I believe, the developers and programmers of technology field are the inventors of 21st century. For me working in IT, particularly is a lot more than just punching numbers and code. It’s a highly creative endeavour, one that keeps a person on his toes and requires him to come up with solution to problems every single day. This single thought enthuses me to work in this field as it would bring best out of me, because it asks for so much. It could be any area in the technology, but the work will rarely, if ever, be boring. I, with my proper set of skills, in this technical field want to make things, no matter how trivial-easier, faster and better. This is my first time in GSOD, Iam not very proficient in technical writing, I am still learning. But I can vouch for the fact that I am a fast learner. I am always open to learn and unlearn at the same time. Honestly, joining this esteemed organization will help me learn a lot. I would love to seek the guidance of experienced and learned teams that are already onboard. Personal Infromation:  *Name:- Jaya GUPTA *Email:- jayagupta752@gmail. com Github LinkedinProject Proposal: *Open source organization:- Wechaty Project Title: Create easy to learn tutorials for beginner users of Wechaty. Problems in current Project: When new users come to Wechaty website in order to build a chatbot application for solving their problems, they found it difficult to use. Despite of video tutorials and current howto guide, the learning curve is not friendly to the users, they always struggle with setting up with their development environment, even find difficult to get started with the simplest example source code, and it become hard for them to use the API. What I found as a problem ?: According to my research the first most problem is that the video lecture is not understandable due to language barrier and the video is also not short and concise. Even the publication is also not easy to understand. The content is not in an actionable form which leads to developers struggling to set-up-environment or running the test code. My Approach To the Problem: Understanding the contributors: Before moving ahead how to solve the problem, I consider that knowing your contributors is very important. The first task is always to know :-What do they want ?Why do they want to ?When they want?then we should move ahead towards how to help them, it would give us clear understanding about the faults and how to fix them? Make video tutorials: According to my research, current video tutorials are not helpful. Areas to work on :- Video tutorial with a serial wise playlist. Each video should be less than 10 min at least. Short assignment at the end of each video to keep the audience engaged. After each video provides the solution of that assignment so that users can get their queries clear simultaneously. Managing video content: We need to structure the content in a meaningful way. The proposed content structure and presentation is to split the tutorial into high level units/ sections. Each unit/section will have the following components. Below are the proposed components of a unit. Each unit needs to have a link to the next and previous unit. Starting Section: This section should contain the brief summary about what we are going to learn in this video, or table of content so that the user can get the idea of what they will be learning. Main Section: This section will contain howto steps and all the content that was written in the starting section with brief explanation about the content and also a floating headline of the definition of words that might seem new to the user. Ending Section: This section provides the summary of the video and assignment ques related to that video to help the user understand the concept practically. Other resources: The solution of the previous assignment with short explanation. Link to wechat API so that user can directly go there and try it out Proposed Timeline: Before 30 April:  Contribute to the organization.  Understand and learn how to use Wechaty.  Make notes of the problem I face. Week - 1:  Re-document getting started page Communicate with volunteers to know about their suggestions. Week - 2:  Redocument help and contact page Redocument Installation Redocument Quick start setupWeek - 3:  Hands-on tutorial’s Homepage Basic tutorials for beginnersWeek - 4:  Create a bot : To reorganise the page, add items to left fields and conversion of codes to 5 different programming languages Make Video tutorial contentWeek - 5:  Deal with message : To reorganise the page, add items to left fields and conversion of codes to 5 different programming languages.  Manage rooms : To reorganise the page, add items to left fields and conversion of codes to 5 different programming languages. Week - 6:  Process files : To reorganise the page, add items to left fields and conversion of codes to 5 different programming languages. Week - 7:  Manage contacts : To reorganise the page, add items to left fields and conversion of codes to 5 different programming languages.  Construct page for Heroku usage : To add content along with some visuals for better experience. Week - 8:  Construct page for Heroku usage : To add content along with some visuals for better experience. Reorganise Pugin with wechaty page : To reorganise all the content and add some photos for making it interesting. Week - 9:  Reorganise Pugin with wechaty page : To reorganise all the content and add some photos for making it interesting. Reorganise Pugin with wechaty page : To reorganise all the content and all photos for making it interesting. Week - 10:  Conversion of Blogs to english language with possible images as well"
    }, {
    "id": 135,
    "url": "https://wechaty.js.org/2021/05/02/wechaty-bible-chatbot/",
    "title": "微信群机器人-读经助手",
    "body": "2021/05/02 - 笔者将从 开发意图、产品功能特性、技术方案、心得体会 等方面回顾总结 微信群机器人-读经助手 的产品开发历程，希望对其他开发者有所帮助。 二、开发意图: 笔者是一名基督徒微信群的成员，群里需要人工每天定时发送「文章」链接，并统计群成员「已读」人数。最早我们采取的方案是人工定时发送，群成员到 在线协同工具 如「石墨文档」手动填写「已读」。该方案虽然节省了统计人数的工作量，但依然有几个缺点：  群成员年龄分布广，包含 60、70岁成员，让他们跳转至第三方应用手动填写，操作成本高，导致打卡率低。 在群里直接文字打卡，可激励其他成员，而跳转至第三方应用打卡，就减弱了这个互动性。 每天人工定时发送，长期来看对发送人员是个不小的挑战。所以希望能够开发一个 微信机器人-读经助手 帮助实现如下功能：       定时在微信群中发送文章链接         基于群成员的聊天信息(已读、完成) 等，自动进行统计打卡   感谢 Wechaty ，基于 Wechaty SDK，笔者通过一个晚上，就实现了 读经助手 的上述核心诉求，从此解放双手。目前 读经助手 在投入到 6 个微信群中使用，最长服务时长达 2 个月，服务人数 200+。(不敢主动推广，原因后面会讲) 三、产品功能特性: 核心功能仅用了一个晚上就实现了，但笔者大概花了 一个月(代码量3000行左右 ts 代码) 的时间来丰富 读经助手 的周边功能。完整功能大致分为以下几类：       定时文章推送 (支持了多种基督教刊物)         群成员打卡 (基于群成员聊天，统计打卡人数、汇总生成 excel 表格)         获取文章链接 (获取多种基督教刊物的在线链接)         搜索文章内容 (搜索基督教刊物的内容)   功能简介:  更多功能: 更多功能长图 文章推送:  打卡统计:  搜文章内容: 四、技术实现: Wechaty: 目前来看，上手成本最低的应该是只用 puppet-services，我使用的 token 提供商是 Paimon, 注册手机号，即可获取 7 天 token。 部署方案: 一共经历了如下几个部署方案：       闲置电脑部署 wechaty 应用 + 数据库(AWS dynamodb 香港节点)，使用 dynamodb 是因为这是亚马逊云的免费数据库产品，想白嫖。         阿里云轻量应用服务器(1C 2G 40G-SSD 杭州节点) 部署 wechaty 应用 + 数据库(AWS dynamodb 香港节点)，阿里云服务器是98元每年(新用户活动价)，可连续买三年。但阿里云杭州节点 连 亚马逊香港节点，延迟有时候会有 几十秒。尝试过阿里云香港节点，数据库请求是快了，但发送给 puppet-services 的请求有时会有几秒的延迟。         阿里云部署 wechaty 应用 + 数据库换成服务器自带的 mongodb。 这样访问 puppet-services、数据库都非常快。 由于两种数据库都是文档型，迁移的成本还不算太高，大概花了一天时间做数据库迁移+适配层代码。   由于需要做内容搜索，所以也在阿里云服务器上部署了 ElasticSearch。阿里云 98 一年真香。 实现思路: 代码开源在该仓库，感兴趣的可以参考下，本节主要介绍下目录结构 ├── README. md├── deploy. sh 部署脚本├── dev. sh 开发环境脚本├── ecosystem. config. js pm2进程管理配置├── nodemon. json 本地开发配置├── package-lock. json├── package. json├── prod. sh 生产环境脚本├── server│   ├── index. ts wechaty 主入口│   └── src│     ├── actions actions 命令的实现│     │   ├── _7cthSchedule. ts│     │   ├── bibleSchedule. ts│     │   ├── commit. ts│     │   ├── index. ts│     │   ├── pushSchedule. ts│     │   ├── remind. ts│     │   ├── search. ts│     │   ├── smdjSchedule. ts│     │   └── static. ts│     ├── bible 圣经相关的资源│     │   ├── _7cth. ts│     │   ├── plan. ts│     │   ├── shareRes. ts│     │   └── smdj. ts│     ├── constants. ts │     ├── controller 放开 http 服务的控制器│     │   ├── index. ts│     │   ├── proxy. ts│     │   ├── search. ts│     │   ├── setting. ts│     │   └── utils. ts│     ├── ddb 数据库相关│     │   ├── commands│     │   ├── index. ts│     │   ├── mongoDb. ts│     │   ├── schema. ts│     │   ├── script│     │   └── syncModels. ts│     ├── handleMessage. ts 消息处理│     ├── http. ts http 服务器入口│     ├── interface│     │   └── index. ts│     ├── schedule. ts 定时任务入口│     ├── service http 服务对应的 service│     │   ├── esClient. ts│     │   ├── search. ts│     │   └── setting. ts│     └── util 工具函数库│       ├── bibleData. json│       ├── bibleUtils. ts│       ├── canvas. html│       ├── devUtils. ts│       ├── drawBible. html│       ├── drawUtils. ts│       ├── formatUtils. ts│       ├── index. ts│       ├── smdj-es-doc│       ├── smdjStats│       ├── smdjUtils. ts│       ├── songUtils. ts│       ├── timeUtils. ts│       └── wxUtils. ts五、心得体会: 第一次为自己写代码: 笔者之前大部分写的代码都是为了学习、工作(赚钱)。这次是 为了解放自己的双手、便利身边朋友 而写代码，心态从赚钱变成了奉献。发现自己又重新找回了，写程序的激情 和 热情，在开发读经机器人期间，有好几次通宵的经历，而且功能上线后，及时的反馈 和自我满足感是很让人愉悦的。 这也让我意识到，写代码不仅仅是一种工作，而确确实实是一项实用的生活技能、特长。 微信侧风险: 开发阶段，有次把机器人号，从测试群中主动踢出，发现 Provider Service 抛出了一个 Error，为了复现这个异常，我重复多次把这个号从测试群中踢出。然后过了一段时间，就收到了 微信风控通知，提示该号被 多人投诉、有骚扰用户的行为。 所以大家尽量不要将 机器人踢出群，最好采用主动退出的方式，以免被微信风控。 换了新的微信号后，大概服务了 2 个月不到，发现被微信主动踢下线了，再次登录提示使用了 微信外挂、非官方客户端或模拟器。不清楚是, provider service 的方案，被大批检测出，还是仅仅是 笔者的微信号，被投诉导致。。(/assets/2021/05-wechaty-bible-chatbot/04-01. webp) 笔者开发机器人的初衷是希望解放人力，其实越多的微信群使用(免费使用)，对我来说，开发机器人的价值越高。但由于存在微信封号风险，是目前笔者不敢主动推广，仅靠群成员的口口相传。 2 8 原则: 如上文提到的核心功能，笔者1个晚上就实现了，剩下的时间都在丰富七七八八的周边功能。但说实话，这些周边功能，都是我个人在使用，频率非常低，但却占据了我整体开发的 80% 以上时间。 交互友好性: 由于读经机器人有部分功能是需要输出长段的文字，考虑到阅读的友好性，防止老年机大段文字刷屏，读经机器人使用了 node-canvas 渲染引擎，并实现了简单的文字排版，将大段文字通过图片的方式发送给用户。 便利性与通用性: 为了使功能更加通用性，部分功能的开发，常常是站在程序员的视角出发，提供出多个参数化的配置，但这却加大了使用者的认知成本。比如 读经助手 提供了如下命令 @读经助手 创建读经计划 创世记1~玛拉基书4 90天 该命令中包含了如下几个参数「起始书卷、起始章节、结束书卷、结束章节、阅读天数」，更便利的做法是包装成如下指令 @读经助手 创建读经计划 旧约 90天 另外笔者还尝试过开发了一个 H5 页面，当群成员输入 @读经助手 群设置 返回该群设置的 H5 页面链接，这样通过 H5 页面的方式进行配置，虽然可以方便使用者。但同时也引入了安全性问题：任意一名群成员都能打开 H5 页面，他可以随意 删除、改变 群配置。如果要防止该问题，就需要额外开发 登录、鉴权。相比而言，使用群聊输入命令，是处于 全群监督下，不会有人进行乱操作。。所以虽然开发了 H5 设置页面，但没有对用户开发。  作者: kkdev163，软件开发工程师 "
    }, {
    "id": 136,
    "url": "https://wechaty.js.org/2021/05/01/landing-page-value-proposition/",
    "title": "Reconstruct Wechaty landing page with value propositions",
    "body": "2021/05/01 -  What is Value Proposition? A value proposition is a statement that answers the ‘why’ someone should do business with you.  It should convince a potential customer why your service or product will be of more value to them than similar offerings from your competition.  — How to Crack the Google Season of Docs, Edidiong Asikpo, 2020 The phrase(term) “value proposition” was first used in the paper A Business is a Value Delivery System, Michael Lanning and Edward Michaels, 1988 for the consulting firm McKinsey. Why Value Proposition is Important: The Value Proposition is a statement that answers the ‘why’ someone should do business with you. It should convince a potential customer why your service or product will be of more value to them than similar offerings from your competition. You know why your company is great, but do your potential customers know what sets your brand apart? it must tell your audience:  How your product or service solves/improves problems What benefits customers can expect Why customers should buy from you over your competitorsIt introduces you to prospective buyers and helps you make a strong first impression. That’s why it is so important to have a powerful one. Guidelines: Your value proposition needs to be specific, and address the problems that you can help your customers solve.  Identify all the benefits your product offers.  Describe what makes these benefits valuable.  Identify your customer’s main problem.  Connect this value to your buyer’s problem.  Differentiate yourself as the preferred provider of this value. It should be clear and concise. Anything too long will lose your readers. In a nutshell, a value proposition is a clear statement that offers three things:  Relevancy. Explain how your product solves customers’ problems or improves their situation.  Quantified value. Deliver specific benefits.  Differentiation. Tell the ideal customer why they should buy from you and not from the competition. Template: The value proposition is usually a block of text (a headline, sub-headline, and one paragraph of text) with a visual (photo, hero image, graphics). There is no one right way to go about it. We suggest you start with the following formula:  Headline. What is the end-benefit you’re offering in one short sentence? It can mention the product and/or customer. Make it an attention grabber.  Sub-headline or a 2–3 sentence paragraph. A specific explanation of what you do/offer, for whom, and why it’s useful.  3 bullet points. List the key benefits or features.  Visual. Images communicate much faster than words. Show the product image, the hero shot, or an image reinforcing your main message. Evaluate: Evaluate your current value proposition by checking whether it answers the questions below:  What product or service is your company selling? What is the end-benefit of using it? Who is your target customer for this product or service? What makes your offering unique and different?Use the headline/paragraph/bullets/visual formula to structure the answers. Examples: The 31 Best Value Proposition Examples You Wish You Had  Stripe MailChimp Lyft Dollar Shave Club Mizzen and Main Pagely Bitly Unbounce Apple MacBook Vimeo etc. About Wechaty Landing Page: The Wechaty landing page https://wechaty. js. org has been created with the default Docusaurus 2 template. It’s clean but has too few information about the value proposition, and we want to improve it. The plan is to add more information to our landing pages, so that it will can deliver the value propositions like the examples above. (Strip, MailChimp, Lyft, etc. ) The Reconstructing Plan: I have drafted a list of the value proposation in our Wechaty Meeting Notes and will continue improving it over there. Currently, I believe we have the following points can be showed on our landing page:  Voice from Developers Wechaty Puppet     Providers         WeChat     WeWork     Whatsapp     Lark     …          Services         WXWork     PadLocal     Paimon     Donut     …           Showcases     Friday BOT   OSS. Chat   …    Polyglot     TypeScript/JavaScript   gRPC   OpenAPI   Python   …    Ecosystem     Plugins   Vorpal   Redux    Commercial Companies     JuziBot https://www. juzi. bot   Chatopera https://www. chatopera. com    Community Cases     哄女朋友开心   Money BOT    Enterprise Cases     句子秒回 (Instance Reply) https://www. juzibot. com/    Contents     Talk: Wechaty 101: from v0. 0 to v0. 7, @huan, Jan 06, 2017 (slides)   Talk: Open-source Wechaty: 2016 to 2020, @huan, May 19, 2020 (slides)   Slides: Wechaty 2021, @huan, 2021    Contributors Sponsors     Google Season of Docs: GSoD 2021: USD 9,500 sponsored from Google!   开源软件供应链点亮计划         暑期 2020: RMB 108,000 sponsored from Huawei!     暑期 2021: RMB 75,000 sponsored from Huawei!          Juzi. BOT: USD 1,500 per month   Microsoft: USD 4,000 per year Azure Cloud Credit (via AI MVP Program)   Tencent: RMB 4,000 per year Tencent Cloud Credit (via Chatbot TVP Program)   Google: TensorFlow Research Cloud support (via ML GDE Program)   SujiTech: USD 100 per month    Honors &amp; Awards     Chatbot SDK Wechaty 获国内顶级开源组织颁发大奖，@中国开源云联盟，Dec 31, 2020   开源项目 Wechaty 作者李卓桓入选「中国开源先锋 33 人」, @思否，Dec 23, 2020    Code of Conduct https://wechaty. js. org/docs/community/code-of-conductBesides the above list, we still need our value proposition to be added. This is a Wechaty GSoD’21 project: That’s the reason why I want to add this docs page reconstructing project to our Wechaty GSoD’21. Please feel free to let me know what you think, and proposal for this project will be welcome! The project’s problem: Most of our new users come to Wechaty website by landing on our homepage at https://wechaty. js. org. Unfortunately, the landing page is too simple and leak of enough information for new users, especially no valua proposition. This problem leads to us losing lots of new users, or make new users take more time to understanding what Wechaty can do and why we are the best. We need to improve the homepage (landing page) on our website with value propositions. The project’s scope: Homepage (landing page) is the first look when a new user comes to our community. We need to make them to understanding what Wechaty can do and why we are the best. The landing page should:  It must tell your audience:     How your product or service solves/improves problems   What benefits customers can expect   Why customers should buy from you over your competitors    The value proposition needs to be specific, and address the problems that you can help your customers solve.      Identify all the benefits your product offers.    Describe what makes these benefits valuable.    Identify your customer’s main problem.    Connect this value to your buyer’s problem.    Differentiate yourself as the preferred provider of this value.     Value proposition should be clear and offers:     Relevancy. Explain how your product solves customers’ problems or improves their situation.    Quantified value. Deliver specific benefits.    Differentiation. Tell the ideal customer why they should buy from you and not from the competition.     The value proposition should bex a block of text (a headline, sub-headline, and one paragraph of text) with a visual (photo, hero image, graphics).      Headline. What is the end-benefit you’re offering in one short sentence? It can mention the product and/or customer. Make it an attention grabber.    Sub-headline or a 2–3 sentence paragraph. A specific explanation of what you do/offer, for whom, and why it’s useful.    3 bullet points. List the key benefits or features.    Visual. Images communicate much faster than words. Show the product image, the hero shot, or an image reinforcing your main message.     Has headline/paragraph/bullets/visual formula to structure answer following questions.      What product or service is your project providing?   What is the end-benefit of using it?   Who is your target user for this project?   What makes your offering unique and different?    Work with the contributor team to update the documentation on the Wechaty site. What is out-of-scope for this project:  This project is not for returns users: it’s for new users who have never used Wechaty before. We have committer candidates for mentoring our GSoD project,and we estimate that this work will take three months to complete. The creator of Wechaty @huan(who is the creator of Wechaty)have committed to supporting the project. Measuring your project’s success: As of today, homepage on our site receive 25% of the landing traffic,57% of landing traffic is new,Bounce-rate is 60%,Pages/Session is 2,Avg. Session Duration is 03:11. We will track the above metrics (bounce rate, pages per session, and avg session duration)monthly after the documentation is published. We would consider the project successful if, after publication of the new homepage:  The bounce rate of homepage decreased by 10% (&lt;50%) The pages per session increases by 50% (&gt;3) The avg session duration increased by 30% (&gt; 4:00)Project budget: USD 1,000. 00  Technical writer for reconstructing the Wechaty landing page Contact us: If you are a Technical Writerand you are interested to contribute in wechaty projectfor Google Season of Docs 2021,Please send your proposal(by following thetemplate of writing the statement of interestfrom Google)to our mail list at wechaty@googlegroups. com (web archive),and then introduce yourself after joining our Wechaty Gitter. im channel for connecting. "
    }, {
    "id": 137,
    "url": "https://wechaty.js.org/2021/04/30/google-season-of-docs/",
    "title": "Google Season of Docs ❤️ Wechaty",
    "body": "2021/04/30 -  What is Google Season of Docs?Season of Docs is an annual program organised by Google. Its goal is to bring technical writers and open source organisations together to foster collaboration and improvement of documentation in the Open Source space. — How to Crack the Google Season of Docs, Edidiong Asikpo, 2020 This year, Wechaty has been recongnized by Google and accepted by the Season of Docs (GSoD) program! We are very proud of participating in GSoD’21! As one of the 30 great open-source organizations, we want to improve our documentation, which definitely needs help from great Technical Writers! We has started to prepare the GSoD’21 at Feb, our proposal is to Create easy to learn tutorials for beginner users. Fortunately, we has been accepted by the Google Season of Docs program, and our budget request has been granted as $9,500!  Wechaty Organization has accepted by Google Season of Docs 2021. Wechaty GSoD’21 technical writers: After the Wechaty GSoD’21 has been announced by the Google officially on April 16, we have been contacted by 23 technical writers. It’s amazing that 15 of them have submitted the proposal and almost all proposals are in detail planing with great insights of how to improve the Wechaty docs. Thanks for the following technical writers from GSoD’21: your proposal are very valuable for the Wechaty community, and we hope we can implemented most of them in the following summer months!  All names have been linked to their great proposals:  Abhishek Jaiswal Ahmed Essam Anirudh TPVS Chris Estepa David Atanda Jaya Gupta Mukosa Joseph Mawa Rajiv Ranjan Singh Rohitesh Kumar Jain Rufai Mustapha Sajen Sarvajith k Shraddha Prasad Shwetal Soni Simin Liao (廖思閔) Soumi Bardhan Souvik BiswasBudget plan:  Wechaty Tutorials: $5k (split to 2 writers) Reconstruct Wechaty landing page (homepage) with value proposition: $1k Introduction: $1k References: $1k Volunteer stipends: $500 stipends for the writers has not been selected, but has submitted valid proposals or merged PRs: $1kTotal: $9,500 What’s the next steps: Today, we have send an announcement email to our Wechaty mailing list: Wechaty GSoD’21 Technical Writers Registration Form Opened We are going to organize a Zoom meeting for discussing how to collaborate together to make Wechaty docs better. Our goal is to make everyone enjoy the Wechaty GSoD’21 by sharing and learning from each other.  May 3: Send out the Google Form to technical writers May 5: Prepare Zoom Meeting: we will create agenda in meeting notes for all technical writers for adding agendas May 7: Online Zoom Meeting: the last discussion before the final selection. All technical writers will be invited to join, and everyone is welcome to join May 9: Announce the selection result of the technical writers for Wechaty GSoD’21Contact us: Talk to the community by joining our Gitter network if you aren’t already a member. "
    }, {
    "id": 138,
    "url": "https://wechaty.js.org/2021/04/24/ai-chatbot-paddlehub/",
    "title": "AI Poet Chatbot powered by Python Wechaty & PaddleHub",
    "body": "2021/04/24 - 小白也能超快上手的AI ChatBot教程，这次教大家一个用基于Python Wechaty和 PaddlePaddle 框架运行的，用AI续写情话的对话机器人。  合鸟 子 的B站link：手把手教你做个用AI续写情话的Wechaty聊天机器人 请你入坑酷酷的 Python-WechatyPython Wechaty如何使用PadLocal Puppet Service 想要了接更多关于 合鸟 子 👆视频中，AI续写情诗Paddlehub训练模型的，请看：飞桨开发者说：AI教你写情诗 "
    }, {
    "id": 139,
    "url": "https://wechaty.js.org/2021/04/22/wechaty-with-paddlepaddle/",
    "title": "AI ChatBot Creation Camp创意赛重磅来袭！",
    "body": "2021/04/22 - 人工智能时代的ChatBot需要具备哪些能力？它是智能小管家，帮你整理所有“码了就等于看了”的资料？它是斗图大师，分分钟帮你p好好友的鬼畜表情包？它是无情的夸人机器，每天都能自动生成新的彩虹屁？ ✨ 实用的、有趣的、鬼畜的… 不知大侠有何高见？快来组队实现吧！PaddlePaddle融合Wechaty能 spark 出怎样的inspiration？我们欢迎所有关于ChatBot的创意项目！只要你的项目够优秀，官方送你出道！  比赛报名入口：AI ChatBot 创意赛 比赛时间：2021/04/12 - 2021/05/31 1950年，艾伦·麦席森·图灵以一篇划时代的文章扣开了人工智能的大门。与此同时，机器能否让大批人类失误？怎样的智能才能匹配时代发展的脚步？未来的世界又该如何突破图灵测试的桎梏？接踵而至的问题让人们对AI充满了期待。 很快，在1966年诞生ELIZA就让图灵测试感受到AI的力量。这款由麻省理工学院开发的聊天机器人（ChatBot）获得了媲美心理医生的能力，其以大量的心理学语句为数据进行训练，在与病人沟通时，能够通过关键词逻辑选择将对话往更加聚焦的方向引导，进而挖掘对话人的真实需求和动机，而这些能力也让当时很多人误以为ELIZA就是真人。 “有多少智能，就有多少人工”。ELIZA的成功的背后是大量人力成本的注入，在前期训练成本增加的同时，其也更容易让被测试人相信自己所面对的就是一个有血有肉的“心理医生”。不过问题也一样存在，除了训练成本过高以外，1966年的NLP技术也太过稚嫩，ELIZA无法真正理解词汇，也无法进行自我学习和进化。 时光携技术一同推动了命运的转轮，AI发展至今也早不是昔日的吴下阿蒙。如今，ELIZA的后辈们活跃于各个领域，手机上的智能助手，电商用的智能客服，家庭生活的智能管家，交流用的表情包……ChatBot的训练语句在缩短，场景使用时间却延长了；ChatBot开发成本在减少，发挥空间却增加了；ChatBot的门槛在降低，人文温度却提升了。这一切的变化无不在告知这个时代：ChatBot的新时代到来了。 在这个时代里，ChatBot的竞争早已不再局限于技术，创意也显得尤为重要。因此，为了发掘更多优秀的ChatBot开发项目，培养更大优质人才，PaddleHub携手开源聊天机器人框架Wechaty带来了《AI ChatBot创意赛》。如果你在ChatBot开发方面有想法也有能力，那么欢迎报名参与本次大赛，为未来设计一款更加新颖、可靠、实用的ChatBot。而如果你的ChatBot创意项目足够优秀并进入了最终决赛，那么飞桨官方将会帮助你登上WAVE SUMMIT 2021峰会的舞台！ 赛题介绍: 本次大赛需要所有选手使用PaddleHub和Wechaty两个开源产品来打造属于自己的创意ai ChatBot，而大赛官方为选手们提供的不仅是一个全新的AI能力平台，也是一个能够与各路好手一较高下的舞台。那么这两大开源产品有哪些能力呢？ PaddleHub: PaddleHub是飞桨深度学习平台下的预训练模型应用管理工具。旨在为开发者提供丰富的、高质量的、直接可用的预训练模型。无需深度学习背景、无需数据与训练过程，可快速使用AI模型。预训练模型涵盖CV、NLP、Audio、Video主流四大品类，支持一键预测、一键服务化部署和快速迁移学习。全部模型均已开源并提供下载，可离线运行。 当然，PaddleHub不仅仅能够用于开发ChatBot，在之前的各类活动中，开发者朋友也利用这一平台开发出多个优质项目，比如传统艺术皮影戏的复现；也有人让AI大说土味情怀，一边尬一边撩；有人实现了一键替换天空，人人都能成为斯皮尔伯格；再或者利用AI帮助作画，轻松打破次元壁。而这些Demo均在GitHub开源可见。 查看精彩Demo请前往：github. com/PaddlePaddle/PaddleHub Wechaty: Wechaty 是一个开源聊天机器人框架SDK，具有多平台、多语言和多插件的特性，支持Python, Go, Java, Scala, . NET, PHP, Rust 等多语言版本，通过几行代码即可创建一个聊天机器人。经过5年多的发展，现在Wechaty开源社区已拥有数十位Committers，百余位Contributors，并被万名Github开发者Star。目前，Wechaty的开发者已遍布全球多个国家和地区，覆盖数万人，是国内最活跃的Conversational AI Chatbot 开发者社区。 Wechaty的优势在于对代码质量地管理，开发者可以使用了Github Actions地DevOps工具完成了CI/CD工作流，从自动化单元测试到自动打包集成测试，从自动发布NPM包到自动构建和发布对应版本地Docker Image，实现了全自动地社区代码发布，极大地提高了社区地协同效率。 目前，在Github上已有千余个开源项目基于Wechaty构建了聊天机器人。另外，Wechaty统一了即时通讯软件平台的对话接口，仅需要一套代码即可运行在多个平台之上，目前已成熟高效地推动了包括社群管理、数据运维、办公、资讯、广告、营销等多个领域不同实用场景的落地。比如OSS. Chat能够打通Github开发者社区，让开源社区获得即时动态；YanBot辅助管理相关的多个微信讨论群The R-fMRI Journal Club，并对用户对领域内文献的讨论和相关脑影像技术问题进行桥接；以及python-Wechaty斗图机器人能够与联系人趣聊斗图。 几行代码融合Wechaty和PaddleHub: 通过Wechaty的官方教程在本地搭建并运行Pyhton版本的Wechaty，使用Paddlehub预训练的文本生成模型与Wechaty的自动回复消息进行结合，实现了通过微信输入文字返回情话的功能。  Python 3. 8 / Pip 20. 1. 1 / PaddleHub 2. 0. 4 / PaddlePaddle 2. 0. 2 参赛支持: 在本次比赛中，Wechaty为参赛选手免费提供token。同时，百度大脑AI Studio还将为参赛选手免费发放100小时 GPU Tesla V100算力卡，选手报名即可在数据下载页获得申请地址。   不仅如此，4月14日 晚8：10， PaddleHub和Wechaty的工程师带来产品讲解及Demo演示，手把手带你使用这两款利器打造自己的AI Chatbot！  参赛奖品: 本次大赛的奖品依然分为两部分， 对于优秀参赛选手而言，飞桨将会为其提供官方渠道曝光和近距离接触专家的机会。  WAVE SUMMIT峰会官方出道位：优秀项目作者将有机会获得WAVE SUMMIT官方出道机会 投稿精选项目获得更多曝光: 比赛期间，选手可以在在AI Studio投稿，一旦通过精选项目评审，则可得到更多曝光机会。 Paddle/Wechaty工程师1对1项目指导：优秀项目作者将有机会接受百度资深工程师及Wechaty社区资深工程师的1对1技术指导。 PPDE/Wechaty Community Contributor绿色通道 ：优秀项目作者将获得飞桨PPDE技术专家及Wechaty Community Contributor申请绿色通道。当然，作为一场开发者大赛，丰厚的奖金和奖品也自然必不可少。百度飞桨针对参赛选手提供了以下奖励：       名称   数量   奖励         一等奖   1名   1万元人民币       二等奖   1名   Apple iPad Air 256G 1个（价值2598元）       三等奖   1名   Switch游戏机 1个（价值2200元）       早鸟奖   10名   Wechaty creators 李佳芮&amp;李卓桓《Chatbot从0到1》1本       提交奖   不限   比赛定制社区纪念品   需要注意的是，所有提交了参赛作品的选手均可获得由百度飞桨官方提供的独家纪念品一份！而本次活动的最终决赛将会成为百度年中开发者盛会WAVE SUMMIT上的一环，如果你的作品足够优秀并进入了决赛阶段，那么WAVE SUMMIT全场最靓的仔很可能就是你哦！ 赛程赛制:       时间   赛程         2021/4/12   正式启动注册报名       2021/4/14   线上比赛宣讲       2021/4/20   项目repo提交入口开启       2021/5/10   项目提交截止       2021/5月中下旬   最终决赛   参赛对象及要求    参赛对象：本次竞赛面向全社会开放，不限年龄、身份、国籍，相关领域的个人、高等院校、科研机构、企业单位、初创团队等均可报名参赛。  参赛要求：  本次比赛可以个人参加也可以团队参加，团队人数上线为5人。  参赛方式及规则 （1） 所有参赛选手都必须在百度大脑AI Studio平台注册报名； （2） 参赛者在规定时间内须基于飞桨深度学习平台进行项目制作，不得使用其他相关平台、框架及任何飞桨中未包含的学习方法参赛； （3） 参赛选手需确保注册时提交信息准确有效，所有的比赛资格及奖金支付均以提交信息为准，团队参赛的奖金和奖品将发送至团队队长，由团队内部自行决定奖金和奖品的分配； （4）选手名及队伍名的设定不得违反中国法律法规或社会公序良俗，且参赛队伍命名中不可出现“百度官方”，“飞桨官方”，“paddle官方”，“官方baseline”等字样。若命名违规的队伍在收到比赛主办方警告后仍未修改队伍名称，比赛主办方有权解散该队伍 ； （5） 赛事交流群：微信扫码添加飞桨小哥哥，回复“创意赛”即可入群。 参赛须知补充    公平竞技： 参赛者禁止在比赛中抄袭他人作品，经发现将取消比赛成绩并严肃处理；  组织声明： 组委会保留对比赛规则、赛事安排进行调整和修改的权利、比赛作弊行为的判定权利和处置权利、收回或拒绝授予影响组织及公平性的参赛团队奖项的权利；  作品产权： 参赛作品(包含但不限于算法、模型等)知识产权归参赛选手所有，组委会有权将参赛作品、作品相关、参赛团队信息用于宣传品、相关出版物、指定及授权媒体发布、官方网站浏览及下载、展览（含巡展）等活动项目，大赛组织单位享有优先合作权利。  反作弊说明（1） 参与者禁止注册多账户报名，经发现将取消成绩并严肃处理。（2） 参与者禁止在考核技术能力的范围外利用规则漏洞或技术漏洞等不良途径提高成绩排名，禁止上传其他项目链接进行积分。经发现将取消成绩并严肃处理。（3） 可以接触到赛题相关数据的人员，其提交作品将不计入排行榜及评奖。（4） AI Studio将收集选手信息以及代码、模型、系统报告用于成绩评定、比赛通知等相关比赛事项。 "
    }, {
    "id": 140,
    "url": "https://wechaty.js.org/2021/04/22/how-to-publish-blog-on-wechaty/",
    "title": "入门：小白如何在wechaty社区发布自己的第一篇博客（一）",
    "body": "2021/04/22 - 很高兴能执笔这篇博客，第一次使用github向wechaty社区提交博客时Q到了@huan（提交了十几次才最终通过），因此也被印象深刻了。今天和大家分享一下零基础或有那么一丢丢基础的小白如何从0到1的在wechaty发布博客（成为一个贡献者）。 作为系列博客的第一篇，今天首先和大家分享一下两个内容：    在wechaty发布博客的工作原理     来自官方的——How to post a blog   后续还有连载，请先读完这篇 在wechaty发布博客的工作原理: 之所以用”工作原理”来形容，是因为初学者在有了向wechaty发布博客的想法之后，很快会发现它在用一种「很技术的方式」而非传统的博客方式进行发布。技术到什么程度呢？你可能需要知道并了解以下几个工具：  markdown git github jekyll（这个可以暂时没有）说原理： 我们把整个wechaty的博客当成一本电子书，每个人都可以在这本书中书写自己的文章并发布。  先复制一本到自己的书架（fork it） 下载这本书到电脑上（git clone） 按规定的格式要求添加自己的文章，并上传到自己的书架（git commit并git push） 把书架上添加了自己内容的书发送给正本书的管理员审核（create pull requests） 系统自动校验文章格式是否符合要求以及签署一个贡献协议（auto check） 校验通过，等待管理员最终将内容更新到电子书的最新版本中继续，我们结合官方的指导文档说一下注意事项 来自官方的——How to post a blog: 来自官方的指导文档，对于有基础的同学直接移步参考原文https://github. com/wechaty/wechaty. js. org——无论如何即使是零基础也希望大家先去阅读一下原文 对于一个英语困难者，wechaty的文档无疑是一个灾难，so，让我们来百度翻译并注释一下： 总共13步，比大象装冰箱多了10步:    复刻（fork）wehaty代码   不知道什么是fork？总之很复杂，网上说的也不是很明白，简单点理解就是copy一份，到wechaty的github项目页面https://github. com/wechaty/wechaty. js. org，然后看图操作       同步你的分支   不知道如何同步？后边说     在本地（自己的电脑上）创建你的博客分支   使用git把github上的代码下载下来，看图操作复制地址，然后在你要存放文件的目录运行git clone https://github. com/wechaty/wechaty. js. org. git       使用markdown书写你的博客   不知道什么是markdown？后边说     添加你的博客文件到jekyll/_post文件夹   打开下载下来的代码，整个博客的书写仅需要在jekyll这个目录下操作，不要动也不要管其他目录，正文放在jekyll/_post`下，其他文件下边会说，一下以当前这篇博客为例讲解，个人认为学习此类知识最好的方式就是Copy and Modify（如同小学生写作为一样临摹，复制、粘贴、重命名、改内容，四部曲）。   例如本文正文,是在jekyll/_post目录下创建名为2021-04-22-how-to-publish-blog-on-wechaty. md的文件并在里边写正文内容。          正文内容书写规范：      添加博客头     所有的博客都必须有标题、作者、背景图片,写在正文打最开始:   --- title:  入门：小白如何在wechaty社区发布自己的第一篇博客  author: atorber categories: article tags:  - blog  - wechaty  - study  - introduction image: /assets/2021/04-how-to-publish-blog-on-wechaty/rare_book. webp --- &gt; 作者: [atorber](https://github. com/atorber/)，不务正业的产品经理       写作风格            所有的文件名和url地址使用小写字母, 并且使用- 连接，不允许中文字符。例如本文正文文件名：2021-04-22-how-to-publish-blog-on-wechaty. md           选择合适的图片可以使博客看起来更漂亮。例如本文背景图：            添加文档中的插图到 jekyll/assets 文件夹，在文件夹下当前年份下建立一个以”月份+博客文件名”为名称的文件夹来存放相关图片   在发布之前插入图片和视频，需要将所有图片、视频文件保存在博客专属的文件夹中，文件夹的位置和命名方式 /jekyll/assets/文章标标题/。例如本文图片存放文件夹：jekyll/assets/2021/04-how-to-publish-blog-on-wechaty，本文背景图的完整路径jekyll/assets/2021/04-how-to-publish-blog-on-wechaty/rare_book. webp     添加你的个人信息到jekyll/_contributors/your_github_id. md   新建一个文件your_github_id. md，把your_github_id换成你的github账号。例如本文个人信息文件jekyll/_contributors/atorber. md      个人信息内容     --- name: atorber site: &lt;https://github. com/atorber&gt; bio: 一个不误正业的产品经理 avatar: /assets/contributors/atorber/avatar. png email: tyutluyc@qq. com ---       个人头像     在jekyll/assets/contributors目录下新建一个your_github_id命名的文件夹，并把个人头像以avatar. png命名存放起来。 本文个人头像完整路径jekyll/assets/contributors/atorber/avatar. png     提交更改，使用博客标题作为备注信息   以文章标题为备注信息提交。本文示例提交命令   git commit -m  入门：小白如何在wechaty社区发布自己的第一篇博客      推送到分支   推送分支到自己的github   git push origin master     创建一个新的Pull请求   这一步在github界面操作（也可能可以直接推送到wechaty，超哥没有get到方法）       签署CLA   什么CLA？后边说，到自动检查的步骤会提示，首次签署时留意页面提示，超哥因为之前已经签署过了，暂时没办法操作截图，后边补上     等待传递GitHub操作CI，或者修复任何东西以确保CI变为绿色   Wait for pass the GitHub Action CI, or fix whatever to make sure CI turns green，百度直译，超哥也没搞太清楚，后边说     等待@wechaty的管理员审核  就这些!就这些？就这些… 贡献准则: 需要特别注意的几个点： 1. markdown格式规范化校验: 在文件命名正确、文件存放位置正确的情况下，大部分自动校验不通过的原因是正文markwown格式存在错误，原因是系统对格式进行了严格校验，尤其是对之前会使用markdown但对使用不规范的同学来说，需要认真学习一下了，可参考文档 https://github. com/DavidAnson/markdownlint/blob/main/doc/Rules. md 2. 只提交相关的文件: 请勿提交博客不相关的文件 3. 添加视频或pdf: 示例：  &lt;div style=   position: relative;  padding-bottom: 56. 25%;  padding-top:30px;  height:0;  overflow:hidden; &gt; &lt;iframe  src='https://www. youtube. com/embed/3eq8wJfCAWs'  allowfullscreen  webkitallowfullscreen  frameborder= 0   style=    position: absolute;   top:0;   left:0;   width:100%;   height:100%;    &gt;&lt;/iframe&gt;&lt;/div&gt;或者  &lt;div style=   position: relative;  padding-bottom: 56. 25%;  padding-top:30px;  height:0;  overflow:hidden; &gt; &lt;iframe  src='/assets/js/viewer-js/#/assets/2020/qijibot/final. pdf'  allowfullscreen  webkitallowfullscreen  frameborder= 0   style=    position: absolute;   top:0;   left:0;   width:100%;   height:100%;    &gt;&lt;/iframe&gt;&lt;/div&gt;更多： 将iframe添加到wechaty博客 测试（进阶内容，可以了解下，在本地npm完整的jekyll）: 为了确保一切（文件名、文件大小等）都正常，可以在“git push”之前运行以下命令检查它们。 npm installnpm run test预览: 在本地运行Jekyll来预览博客。 ——什么是Jekyll，自行百度 0. 依赖: 按照官方指示在本地安装jekyll jekyll quickstart 1. 手动安装Jekyll: 在本地运行Jekyll进行博客预览(对于熟悉Ruby语言的同学更容易一些。）  make install cd jekyll make serve2. 预览博客: 访问 http://127. 0. 0. 1:4000/blog/ 可以预览博客! 3. 总结: 安装Jekyll的过程有些小复杂了，略过吧 最后: 真正在写这篇博客时才发现，试图通过几篇博客教会0基础读者和0基础读者希望通过几篇博客成功发布自己的内容一样困难，无论如何，希望这些内容能给大家带来一些帮助。 TODO: 结合以上内容发布一个视频教程，或许是更好的选择，期待后续有时间或其他贡献者一起制作 常见问题:    macOS下报错jekyll/assets/. DS_Store does not match /\/[0-9\-a-z_]+\. /!？   mac下烦人的. DS_Store文件，运行sudo find / -name  . DS_Store  -depth -exec rm {} \;，然后，等几分钟和碰运气…  更多问题后续会根据反馈继续补充  历史文章  Wechaty+微信小程序实现群内活动报名"
    }, {
    "id": 141,
    "url": "https://wechaty.js.org/2021/04/17/python-wechaty-use-web/",
    "title": "教你用python-wecahty和web协议开发机器人",
    "body": "2021/04/17 - 写这篇文章的原因: go-wechaty作者dchaofei抢先写了web协议复活的博客，作为python-wechaty的作者我也需要给大家更加详细的介绍如何使用python-wechaty来登陆web版本的微信。 一、介绍: 微信版本的机器人种类很多，出现的协议也很多，比如Ipad、Mac以及Windows协议，而最早出现的其实是web版本的协议。在前几年由于腾讯的一些限制，将大部分用户的web登陆的权限给关掉了，导致很多web协议版本的微信机器人直接死掉了，比如著名的itchat。 可是自从统信和腾讯共同推出桌面版本的微信之后，web版本的机器人以某种方式复活了，而wechaty便是最早来解决这个事情的开源项目之一，接下来我将详细介绍如何使用python-wechaty基于web版本协议开发聊天机器人。 整体步骤分为两步：  使用Docker启动web协议服务 使用python-wechaty连接服务第一步将web版本的协议以gRPC服务的形式暴露出来，使用过程非常简单，只是需要注意几个配置项；第二步则是使用python-wechaty连接该服务，开发聊天机器人。 二、启动web协议服务: 启动web协议服务脚本如下所示： docker pull wechaty/wechaty:latestexport WECHATY_LOG= verbose export WECHATY_PUPPET= wechaty-puppet-wechat export WECHATY_PUPPET_SERVER_PORT= 8080 export WECHATY_TOKEN= python-wechaty-uos-token docker run -ti \--name wechaty_puppet_service_token_gateway \--rm \-e WECHATY_LOG \-e WECHATY_PUPPET \-e WECHATY_PUPPET_SERVER_PORT \-e WECHATY_TOKEN \-p  $WECHATY_PUPPET_SERVER_PORT:$WECHATY_PUPPET_SERVER_PORT  \wechaty/wechaty:latest如果是在本地测试时，WECHATY_PUPPET_SERVER_PORT和WECHATY_TOKEN相对比较随意，大家都可以随时设置，因为下一步中的连接可以设置本地连接。 如果是在服务端部署时，WECHATY_PUPPET_SERVER_PORT是需要保证所在服务器的该端口是保持开放的，以保证使用python-wechaty能够正常连接；此外WECHATY_TOKEN将用于在wechaty token中心注册启动的服务，以让python-wechaty能够找到该服务的地址，所以必须是修改成唯一标识符，推荐使用uuid来代替python-wechaty-uos-token。 三、使用python-wechaty连接服务: 使用python开发最简单的聊天机器人，代码如下所示： # bot. pyfrom wechaty import Wechatyimport osimport asyncioasync def main():  bot = Wechaty()  bot. on('scan', lambda status, qrcode, data: print('Scan QR Code to login: {}\nhttps://wechaty. js. org/qrcode/{}'. format(status, qrcode)))  bot. on('login', lambda user: print('User {} logged in'. format(user)))  bot. on('message', lambda message: print('Message: {}'. format(message)))  await bot. start()asyncio. run(main())当在本地测试时，可以通过设置WECHATY_PUPPET_SERVICE_ENDPOINT环境变量让python-wechaty直接与本地的web服务连接。例如：WECHATY_PUPPET_SERVICE_ENDPOINT=127. 0. 0. 1:8080，运行脚本如下所示： WECHATY_PUPPET_SERVICE_TOKEN=python-wechaty-uos-token WECHATY_PUPPET_SERVICE_ENDPOINT=127. 0. 0. 1:8080 python bot. py当在远端服务器部署时，只需要设置WECHATY_PUPPET_SERVICE_TOKEN即可连接启动的web服务，运行脚本如下所示： WECHATY_PUPPET_SERVICE_TOKEN=python-wechaty-uos-token python bot. py总结: python-wechaty是一个非常简单的聊天机器人框架，理论上能够对接任何IM平台，拥有原生与AI对接的能力，能够快速开发出功能强大的Chatbot，欢迎大家关注python-wechaty 相关链接:  python-wechty python-wechaty getting started web协议复活 Python Wechaty Getting Started puppet-providers 作者: wj-mcat 自然语言处理算法工程师，python-wechaty 作者 "
    }, {
    "id": 142,
    "url": "https://wechaty.js.org/2021/04/16/go-wechaty-use-web/",
    "title": "教你用go-wecahty和web协议开发机器人",
    "body": "2021/04/16 - 写这篇文章的原因: 最近发现 web 协议以某种方式又复活了，所以想让 go-wechaty 的小伙伴也能使用 web 协议。 前言: 大家都知道目前微信有 web、mac、pad、windows 等平台, 如果想实现一个微信自动化机器人就需要了解这些平台所使用的协议，而 web 平台我们可以看到 js 代码，相对来说是比较简单，其他平台就需要去 hook 或者反编译才能了解底层协议，正因为这些平台实现难度比较大所有没有开源的代码。 虽然难度比较大，但还是有人实现了这些协议，但是会以服务的方式提供出来，如果我们要想使用这些协议就必须找服务提供者商申请token 或者购买token。 go-wechaty 与 服务提供商的交互如下图  go-wecahty 首先会用之前我们购买或申请的 token 通过网关获取到服务提供商 token 所对应的服务器地址 然后用获取到的服务器地址与 puppet 服务进行直接连接可能购买或申请 token 会阻挡大多开发者开发微信机器人的想法，但是既然 web 协议可以用了，我们就可以自实现 puppet service了。 如何使用: 一、先用 @huan 提供的镜像启动一个 web 协议的 puppet-service export WECHATY_LOG= verbose export WECHATY_PUPPET= wechaty-puppet-wechat export WECHATY_PUPPET_SERVER_PORT= 30001 export WECHATY_TOKEN= 3d415ebb-7a6f-4cba-b602-1f4ae400f011 docker run -ti \--name wechaty_puppet_service_token_gateway \--rm \-e WECHATY_LOG \-e WECHATY_PUPPET \-e WECHATY_PUPPET_SERVER_PORT \-e WECHATY_TOKEN \-p  $WECHATY_PUPPET_SERVER_PORT:$WECHATY_PUPPET_SERVER_PORT  \wechaty/wechaty:latest当看到有输出 Online QR Code Image: https://wechaty. js. org/qrcode/xxxx 就说明启动成功了 WECHATY_PUPPET_SERVER_PORT 环境变量是我们启动 web 协议 puppet service 提供的端口 WECHATY_TOKEN 是我们随机生成的字符串，用于把当前puppet service 注册到 puppet 网关 二、启动 go-wecahty 写的一个简单的 ding-dong 机器人 git clone https://github. com/wechaty/go-wechaty-getting-started. gitWECHATY_PUPPET_SERVICE_ENDPOINT=127. 0. 0. 1:30001 make bot这个机器人只有一个功能，收到 ding 就会回复 dong 执行启动命令输出的结果，看到二维码链接我们就可以点击然后用微信扫码登录了 $ WECHATY_PUPPET_SERVICE_ENDPOINT=127. 0. 0. 1:30001 make bot// stdoutgo run examples/ding-dong-bot. go2021/04/16 19:44:18 PuppetService Start()2021/04/16 19:44:18 PuppetService onGrpcStreamEvent({type:EVENT_TYPE_SCAN payload:{ qrcode : https://login. weixin. qq. com/l/wZG2J5sZrw== , status :5}})Scan QR Code to login: ScanStatusTimeouthttps://wechaty. js. org/qrcode/https://login. weixin. qq. com/l/wZG2J5sZrw==2021/04/16 19:44:45 PuppetService ContactRawPayload(@d9b0073d47ec85dcfbe8b0427c3da085067103aa721478f77db1cad011267bc7)Scan QR Code to login: ScanStatusConfirmedhttps://wechaty. js. org/qrcode/https://login. weixin. qq. com/l/wZG2J5sZrw==2021/04/16 19:44:45 PuppetService onGrpcStreamEvent({type:EVENT_TYPE_LOGIN payload:{ contactId : @d9b0073d47ec85dcfbe8b0427c3da085067103aa721478f77db1cad011267bc7 }})2021/04/16 19:44:45 PuppetService ContactRawPayload(@d9b0073d47ec85dcfbe8b0427c3da085067103aa721478f77db1cad011267bc7)User 微信昵称 logined然后我们向机器人发送一个 ding, 机器人就会回复一个 dong 如果启动机器人不想依赖环境变量，也可以写在代码里 // Endpoint 和 Token 二选一var bot = wechaty. NewWechaty(wechaty. WithPuppetOption(wp. Option{    Endpoint:  127. 0. 0. 1:30001 ,    //Token:  3d415ebb-7a6f-4cba-b602-1f4ae400f011 ,    Timeout: time. Duration(2*time. Minute),}))🔗:  go wechty: https://github. com/wechaty/go-wechaty ding-dong bot: https://github. com/wechaty/go-wechaty-getting-started web协议复活: https://wechaty. js. org/2021/04/13/wechaty-uos-web/ Go Wechaty Getting Started: https://wechaty. js. org/docs/polyglot/go/ puppet-providers: https://wechaty. js. org/docs/puppet-providers/wechat 作者: dchaofei，go开发工程师，go-wechaty 作者 "
    }, {
    "id": 143,
    "url": "https://wechaty.js.org/2021/04/15/chatie-api-server-down/",
    "title": "Chatie API Service Incident Report",
    "body": "2021/04/15 - The Wechaty Puppet Serviceis running on top of the https://www. chatie. io service,which is open-sourced at here. It has been running for 5+ yearson a Heroku free Dynowith Cloudflare CDN,everything works like a charm. The Wechaty Puppet Service Server will register theirselvesto https://api. chatie. iowith their Wechaty Puppet Token,and the Wechaty Puppet Service Client will use this token for service discovery. For example, the following shows that Wechaty started with a token: export WECHATY_PUPPET_SERVICE_TOKEN=${TOKEN}make botIn the past 6 months,our online Hostiehas been increasing fast,first from 1,000, then 2,000,and now it’s 3,000+ concurrencywith a peek number around 3,500. On April 15, 2021,we have a terrible service incidentdue to the limitation update of the Heroku and Cloudflare free servcies:  Heroku limited our Dyno for no more than 1,000 concurrency WebSockets, which raised H11 - Backlog too deep errors.  Cloudflare false report DDoS attatck and block all our visitors when we have 3,000+ WebSocket connections trying to connect to us during the server is rebooting. Heroku Error: H11: By using heroku logs -t -a chatieio, we can see the follow H11 and H10 error messages: 2021-04-14T14:11:03. 885895+00:00 heroku[router]: at=error code=H11 desc= Backlog too deep  method=GET path= /v0/websocket  host=api. chatie. io request_id=59ec8c0c-aba6-4a7a-a7a1-c1d6ff798fc9 fwd= 52. 83. 49. 48,108. 162. 215. 120  dyno= connect= service= status=503 bytes= protocol=http at=error code=H11 desc=”Backlog too deep” 2021-04-14T14:12:01. 619098+00:00 heroku[router]: at=error code=H10 desc= App crashed  method=GET path= /v0/websocket  host=api. chatie. io request_id=d0fa3403-5d6f-4f42-a2f9-e81de0bfb6c3 fwd= 52. 82. 109. 225,108. 162. 215. 108  dyno= connect= service= status=503 bytes= protocol=http code=H10 desc=”App crashed” The Dyno status is totally a mess:  By reading the Does Heroku still limit Websocket connections?, @Owens, Feb 2019, we learned that the total WebSocket number of a single Dyno has some limitations:  Oct 2013: 6,000 Sep 2016: 1,500 Heroku Router docs: 50 (!?)Our concurrency has been over 3,000 for months: So I believe there must be a inforstructure updateto the Heroku system,which caused my free Dyno can not supportso may concurrency WebSocket connections any more. I have to switch to the paid plan and create more Professional Dynos to support 3K+ concurrency, and I found that there needs at least four Dynos to prevent the H11 error, which means each Dyno can only have no more than 1K concurrency WebSocket connections. Heroku Problem:  The Heroku Dyno fail with error H11 of a sudden.  In the past, we can connect 3000+ WebSocket connections with a free dyno.  From this week, it seems that we need 4 paid pro dynos to prevent the H11 error. Heroku Solution (Workaround): We use 4 dynos for our service for workaround. Workaround Issues: Because the service is not designed for the horizon scale, so the query will fail 3 times with 1-time success on average. 01:00:20 VERB Wechaty wechatifyUserModules(Puppet#0&lt;PuppetService&gt;(ding-dong-bot))01:00:20 VERB PuppetService start()01:00:20 VERB StateSwitch &lt;PuppetService&gt; on(pending) &lt;- (false)01:00:20 VERB PuppetService startGrpcClient()01:00:20 VERB PuppetService discoverServiceIp(puppet_donut_XXX)01:00:20 WARN No endpoint when starting grpc client, 10 retry left. Reconnecting in 10 seconds. . . 01:00:30 VERB PuppetService discoverServiceIp(puppet_donut_XXX)01:00:32 WARN No endpoint when starting grpc client, 9 retry left. Reconnecting in 10 seconds. . . 01:00:42 VERB PuppetService discoverServiceIp(puppet_donut_XXX)01:00:43 WARN No endpoint when starting grpc client, 8 retry left. Reconnecting in 10 seconds. . . 01:00:53 VERB PuppetService discoverServiceIp(puppet_donut_XXX)01:00:54 WARN No endpoint when starting grpc client, 7 retry left. Reconnecting in 10 seconds. . . 01:01:04 VERB PuppetService discoverServiceIp(puppet_donut_XXX)01:01:05 WARN No endpoint when starting grpc client, 6 retry left. Reconnecting in 10 seconds. . . 01:01:15 VERB PuppetService discoverServiceIp(puppet_donut_XXX)01:01:15 VERB PuppetService startGrpcStream()01:01:16 VERB PuppetService onGrpcStreamEvent({type:EVENT_TYPE_SCAN(22), payload: { qrcode : http://weixin. qq. com/x/AddMKwOGpxHRGRQNPWh5 , status :2} })Setup an Azure Server for Chatie API Service: It seems that the Heroku service can not meet the requirements of Chatie API service any more, so we have to create a VPS to host the Chatie API service by ourselves. It’s not hard for us to implemente this by the following steps:  Create a Azure server with Debian Linux Install Docker Prepare https://github. com/nginx-proxy/nginx-proxy container: we found the worker_connections in this container has been limited to 1024, so we need this PR#973.  Build docker image for chatie/server Start nginx-proxy with port 80 and 443 for the web service   Start chatie/service container with the following docker-compose. yml config:   version: '3. 8' services:  chatie-api:   image: chatie-api   container_name: chatie-api   network_mode: bridge   expose:    - 8788   environment:    - HTTPS_METHOD=noredirect    - VIRTUAL_HOST=api. chatie. io,www. chatie. io    - LETSENCRYPT_HOST=api. chatie. io,www. chatie. io    Change the DNS of api. chatie. io on Cloudflare from Heroku to our new Azure server. After the above steps, the service back to normal. The Cloudflare DNS TTL is 600 seconds by default,so the hostie concurrency increased to 3k+ after 10 minutes (600s). However, the system down again due to a Cloudflare HTTP DDoS protection, which has also never happened before. Cloudflare False Alarm: HTTP DDoS: What I did before trigger the DDoS protection is that I stop the Chatie API server and restart it again. This will cause all the client’s WebSocket connection to be closed, then every clients will start trying to reconnect immediatelly, which will cause 3K+ WebSocket new connection at the same time.  I try to add some Firewall Rules in the firewall settings to accept the traffic and bypass the HTTP DDoS protection, but have no luck to success. So finally I have to disable the Cloudflare proxy feature, to let the traffic do not touch Cloudflare CDN anymore. After all the traffic go to the Azure server directly, everything back to normal again. Conclusion: I do not like to setup server by myself. I want to use Heroku and Cloudflare to save my time. However, for now, our Chatie service have to run on my Azure box. I hope we can move this service back to cloud again, and soon. The service down affect about 12 hours:  Heroku workaround (service degrade) for about 8 hours Cloudflare false protection (service down) for about 4 hoursTo-do list:  Config to restart servers (Node &amp; Linux) when the services run into unknown stautus Config DevOps for CI/CDIssues:  Chatie. io server down Chatie/server#55"
    }, {
    "id": 144,
    "url": "https://wechaty.js.org/2021/04/13/wechaty-uos-web/",
    "title": "重磅：使用UOS微信桌面版协议登录，wechaty免费版web协议重放荣光",
    "body": "2021/04/13 - 很高兴能够写这篇文章通知大家Wechaty的web协议又能大放光彩了，如果之前你的微信提示不能登录web端，那么这个更新将会是你的福音。因为现在的wechaty-puppet-wechat已经支持使用UOS微信桌面版协议登录，赶快来尝试一下吧。 如何使用:  关键依赖：npm install wechaty-puppet-wechat –save 对现有代码无任何侵入性，只是更新一下依赖即可 一、首先安装最新的wechaty-puppet-wechat依赖和配置环境 npm install qrcode-terminal --savenpm install wechaty npm install wechaty-puppet-wechat --save // 这个依赖是关键export WECHATY_PUPPET=wechaty-puppet-wechat // 这里也是关键，需要配置你使用的puppet二、请保证你的puppet配置的是wechaty-puppet-wechat 如果你使用的是ipadlocal，又想体验一下web协议，那么也需要按照一下配置进行 案例： index. js import { Wechaty } from 'wechaty';const name = 'wechat-puppet-wechat';let bot = '';bot = new Wechaty({ name, // generate xxxx. memory-card. json and save login data for the next login});// 二维码生成function onScan(qrcode, status) { require('qrcode-terminal'). generate(qrcode); // 在console端显示二维码 const qrcodeImageUrl = [  'https://wechaty. js. org/qrcode/',  encodeURIComponent(qrcode), ]. join(''); console. log(qrcodeImageUrl);}// 登录async function onLogin(user) { console. log(`贴心小助理${user}登录了`); if (config. AUTOREPLY) {  console. log(`已开启机器人自动聊天模式`); } // 登陆后创建定时任务 await initDay();}//登出function onLogout(user) { console. log(`小助手${user} 已经登出`);}bot. on('scan', onScan);bot. on('login', onLogin);bot. on('logout', onLogout);bot . start() . then(() =&gt; console. log('开始登陆微信')) . catch((e) =&gt; console. error(e));按照以上配置，拿起你的手机扫码即可，你会发现以前不能登录的微信也可以登录了，惊喜不，意外不。 常见问题: 1、为什么我更新了最新依赖还是提示无法登录web端微信？ 请查看你项目的根目录，是否存在wechaty-puppet-wechat. memory-card. json这样的文件，如果有请把它删除后重新执行即可，这个存储的cookies有可能已经过期(最新版本已经修复此问题) 2、这个puppet可以保证一直能绕过web登录么？ 目前看来是可以绕过web端的限制，但是不保证以后会变化 3、绕过这个限制会被微信发现封禁么？ 目前采用的绕过方式其实是使用了UOS的桌面版微信请求头，所以如果你不做违反微信协议的事情，大概率是没问题的。如果你违反了微信规定，那就不知道了 更多问题后续会根据反馈继续补充 原理: 具体的实现原理可以参考这个issues ，代码修改参见 https://github. com/wechaty/wechaty-puppet-wechat/pull/129 大概的意思就是UOS下的微信只是网页版套了个electron，所以呢有大神就对比了一下请求头，发现了只要在请求的地址上首先加一个?target=t就是这样https://wx. qq. com/?target=t 然后在扫码登陆后拦截 https://wx. qq. com/cgi-bin/mmwebwx-bin/webwxnewloginpage 这个请求，并在请求头上添加两个固定的参数 extspam ='Gp8ICJkIEpkICggwMDAwMDAwMRAGGoAI1GiJSIpeO1RZTq9QBKsRbPJdi84ropi16EYI10WB6g74sGmRwSNXjPQnYUKYotKkvLGpshucCaeWZMOylnc6o2AgDX9grhQQx7fm2DJRTyuNhUlwmEoWhjoG3F0ySAWUsEbH3bJMsEBwoB//0qmFJob74ffdaslqL+IrSy7LJ76/G5TkvNC+J0VQkpH1u3iJJs0uUYyLDzdBIQ6Ogd8LDQ3VKnJLm4g/uDLe+G7zzzkOPzCjXL+70naaQ9medzqmh+/SmaQ6uFWLDQLcRln++wBwoEibNpG4uOJvqXy+ql50DjlNchSuqLmeadFoo9/mDT0q3G7o/80P15ostktjb7h9bfNc+nZVSnUEJXbCjTeqS5UYuxn+HTS5nZsPVxJA2O5GdKCYK4x8lTTKShRstqPfbQpplfllx2fwXcSljuYi3YipPyS3GCAqf5A7aYYwJ7AvGqUiR2SsVQ9Nbp8MGHET1GxhifC692APj6SJxZD3i1drSYZPMMsS9rKAJTGz2FEupohtpf2tgXm6c16nDk/cw+C7K7me5j5PLHv55DFCS84b06AytZPdkFZLj7FHOkcFGJXitHkX5cgww7vuf6F3p0yM/W73SoXTx6GX4G6Hg2rYx3O/9VU2Uq8lvURB4qIbD9XQpzmyiFMaytMnqxcZJcoXCtfkTJ6pI7a92JpRUvdSitg967VUDUAQnCXCM/m0snRkR9LtoXAO1FUGpwlp1EfIdCZFPKNnXMeqev0j9W9ZrkEs9ZWcUEexSj5z+dKYQBhIICviYUQHVqBTZSNy22PlUIeDeIs11j7q4t8rD8LPvzAKWVqXE+5lS1JPZkjg4y5hfX1Dod3t96clFfwsvDP6xBSe1NBcoKbkyGxYK0UvPGtKQEE0Se2zAymYDv41klYE9s+rxp8e94/H8XhrL9oGm8KWb2RmYnAE7ry9gd6e8ZuBRIsISlJAE/e8y8xFmP031S6Lnaet6YXPsFpuFsdQs535IjcFd75hh6DNMBYhSfjv456cvhsb99+fRw/KVZLC3yzNSCbLSyo9d9BI45Plma6V8akURQA/qsaAzU0VyTIqZJkPDTzhuCl92vD2AD/QOhx6iwRSVPAxcRFZcWjgc2wCKh+uCYkTVbNQpB9B90YlNmI3fWTuUOUjwOzQRxJZj11NsimjOJ50qQwTTFj6qQvQ1a/I+MkTx5UO+yNHl718JWcR3AXGmv/aa9rD1eNP8ioTGlOZwPgmr2sor2iBpKTOrB83QgZXP+xRYkb4zVC+LoAXEoIa1+zArywlgREer7DLePukkU6wHTkuSaF+ge5Of1bXuU4i938WJHj0t3D8uQxkJvoFi/EYN/7u2P1zGRLV4dHVUsZMGCCtnO6BBigFMAA='client-version' = '2. 0. 0', 这样就可以完美使用桌面版协议了，真的是非常感谢 @Luv Letter 的解释和 @artxia 的chrome插件代码让我有机会为wechaty-puppet-wechat添砖加瓦 快速体验: 如果想快速体验Wechaty的完整功能，以及可视化配置功能，可以关注我的 《微信每日说》 和 《智能微秘书》 项目，以上项目均已更新最新版web协议，全部支持web登录。  历史文章  wechaty-web-panel可视化插件 三步教你用Node做一个微信脱单神器，小白可上手 作者: Leo_chen，高级前端工程师，喜欢使用node做各种项目 "
    }, {
    "id": 145,
    "url": "https://wechaty.js.org/2021/04/12/wechat-group-chat-interactive-robot/",
    "title": "Go开发微信群聊互动机器人",
    "body": "2021/04/12 - 公司小程序的相关通知需要及时、定时推送到相关的群，由于微信web网页登录基本全部被封建，所有在查阅了大量微信机器人的资料后，选择了wechaty进行机器人开发，以此达到用户可以通过指令进行绑定微信群、查询活动、活动推送等功能，借此提高用户粘性，提高活动的达成率。 功能: 自动通过好友、自动同意入群、绑定/解绑微信群、#活动指令交互、消息池消息推送（同步/异步）、异常退出监测并重启 部署环境: Go 1. 14. 6 darwin/amd64、Mysql 5. 7、Redis 6. 0 购买Token: [chatTools平台]购买Token(175. 27. 139. 176/#/order) 下载代码: git clone https://github. com/blueseashore/wechaty-go. git &amp;&amp; cd wechaty-go配置环境变量: export WEROBOT_TOKEN = xxxexport REDIS_PORT = 6379export WEROBOT_LOGFILE = /tmp/robot. log编译可执行文件werobotctl和werobotd: go build -o . /bin/werobotctlcd roomgo build -o . . /bin/werobotdcd . . /bin. /werobotctl start运行效果: 其他Tips: 需要配置环境变量，需要替换指令功能的API地址 感谢: 感谢Wechaty团队提供微信机器人SDK，让开发者可以专注于业务代码。感谢句子互动提供的pad协议版token。  作者: blueseashoreCode: GithubEmail: 455019825@qq. com "
    }, {
    "id": 146,
    "url": "https://wechaty.js.org/2021/04/05/wechaty-contributor-meetup/",
    "title": "Wechaty Contributor Beijing Meetup 2020/04",
    "body": "2021/04/05 - Wechaty Contributor 北京聚餐 正值清明节，我们组织了一个小范围的 Wechaty Contributor 线下聚会。说起来有些唐突，因为事先并没有预约，由我临时起意问大家有没有空，毕竟 PadLocal 发布以来还没有和社区大佬们见过面。缘分就在于，也可能因为放假的缘故，刚好大家又能抽出时间，于是聚会才得以成行。 早上10点，一行人按照约定陆陆续续到达北京“青春的前小腿” CAFE。据高原讲，这里是 Huan 的根据地，和老板特别熟，有啥好喝的直接问他就可以。 落座一番寒暄，渐熟，开始了今天的议题：  我首先聊了一下 PadLocal 的缘起，我们也是因为自身业务需求才开始慢慢做的。越做越发现这里的技术特别有趣，同时也能够体会到微信团队的心思，夜深的时候常常有一种隔空对话的感觉，那简直是一种深入灵魂的交流。起初我们也犹豫要不要对外发布 PadLocal，发现 Wechaty 是一个特别有意义的社区。如果我们能够在 RPA 这件事件上对大家有所帮助，那也就值了，这也是我们团队的初心所在。 能和这么多 Wechaty 社区元老级的人物对话，当然不能放过这么绝佳的机会。聊了很多社区的历史，一些有意思的点滴，那些有趣的成员们。作为新人，对这个有爱的社区有了更加深入的认识。 大家还谈了很多微信生态的事情，特别是句子互动最近在做的企业微信。企业微信可能近几年最人激动人心的产品之一了，能够在这个平台深耕下去必定是一件意义非凡的事情，也祝福句子能够越做越好。 作为 Wechaty 创始人，Huan 最近在做很多关于社区建设的事情，比如怎么让 Wechaty 的文档更好。他推荐了The documentation system，分为“TUTORIALS”，“HOW TO”，“EXPLANATION”， “REFERENCE”。有了这个逻辑能够让文档编写更加顺畅，读者查阅起来也更加方便。当这篇博客上线的时候，大家可以去看一下 Wechaty 的官网，效果还是相当赞的。BTW，之前社区里有人抱怨，“这这这不好那那那不满意”（当然没有批评的意思）。但与其抱怨，不如也参与进来，只有这样我们才会让社区变得更好。何况大家现在能够使用到的 Wechaty：“The World’s Shortest ChatBot Code: 6 lines of JavaScript/Java/Pytho/Go…”，背后是多少像 Huan 这样的人辛苦付出才有的成果。这也次这次聚会，对我来讲最大的体会之一。聊了整整一个上午，相见恨晚相谈甚欢，这是一群有理想的人在做有理想的事情。若不是肚饿，都不知几时愿起身。 最后，Huan 问了我一个问题：“你怎么看 Wechaty 用英文作为社区的主要语言？”我相视一笑，用一口倍儿地道的老伦敦腔回答道：“We are totally fine with it”。 这里也预告一下，等我们忙完手头的一些事情，PadLocal 会组织一个 Workshop，聊一聊微信那点事。时间本来说 4 月底，目前看起来要鸽了，暂定 5 月吧。主题先买个关子不透露，对社区的成员来讲应该是相当有意思的，你可千万不能错过。 与会者介绍: @huan, Huan LI, Tencent TVP of Chatbot, &lt;zixia@zixia. net&gt; @lijiarui: Full stack developer, serial entrepreneur, Founder &amp; CEO of JuziBot @gaoyuan: Founder &amp; CTO of JuziBot @padlocal: Wechaty Padlocal puppet "
    }, {
    "id": 147,
    "url": "https://wechaty.js.org/2021/04/01/wechat-group-cryptocurrency-robot/",
    "title": "微信群中的加密货币报价机器人",
    "body": "2021/04/01 -  背景: 当今正时大牛市 (或者牛快结束了), 在很多时候并没有办法打开App软件看币价, 比如在上课的时候, 在上班摸鱼的时候, 在地铁上的时候, 所以在微信群中,查询自己所需要的币的价格是很有必要的. 部署环境: Node. js16+ (目前不要上15的车) TypeScript qrcode-terminalwechatywechaty-puppet-padlocal 在此项目中, 目前使用的是免费无限制的非小号API, 大致能用, 没上二线交易所以上的币一般没有. 本人运行环境 Debian 10. 实现: 刚开始使用尝试的是python实现,后来遇到了连接不上的问题(搭了gateway也连不上), 后面使用Typescript实现时再次遇到了连接不上的问题. 后面发现是服务器的问题, 建议用服务器: ping gateway. pad-local. com尝试能不能ping通. 在此项目中,大致框架借鉴的是 wechaty-puppet-padlocal-demo, 在此基础上进行修改,在部署时可以先按着Demo进行操作. Demo使用没问题时, 便可以进行二次修改. // coinBot. tsimport { PuppetPadlocal } from  wechaty-puppet-padlocal ;import { Contact, log, Message, ScanStatus, Wechaty } from  wechaty ;const puppet = new PuppetPadlocal({  token:  puppet_padlocal_yourTokenHere  // 输入你的token. }) const bot = new Wechaty({  name:  TestBot ,  puppet,})  . on( scan , (qrcode: string, status: ScanStatus) =&gt; {    if (status === ScanStatus. Waiting &amp;&amp; qrcode) {      const qrcodeImageUrl = [        'https://wechaty. js. org/qrcode/',        encodeURIComponent(qrcode),      ]. join('')      log. info( TestBot , `onScan: ${ScanStatus[status]}(${status}) - ${qrcodeImageUrl}`);      require('qrcode-terminal'). generate(qrcode, { small: true }) // show qrcode on console    } else {      log. info( TestBot , `onScan: ${ScanStatus[status]}(${status})`);    }  })  . on( login , (user: Contact) =&gt; {    log. info( TestBot , `${user} login`);  })  . on( logout , (user: Contact, reason: string) =&gt; {    log. info( TestBot , `${user} logout, reason: ${reason}`);  })  . on( message , async (message: Message) =&gt; {    if(message. text(). toString(). includes( . - )){ // 这里的反应前缀可以根据需求修改      log. info(message. text(). toString()); // 打印一下反应的Text.       const s1 = message. text(). toString(). split( - )[1];       let result = await coinBot(s1);      const member = message. talker();      if(result != null)      {        message. room(). say( \n  + result,member);      }      else{        log. info(message. toString());        message. room(). say( \n  +  没这币 ,member);      }      };  })  . on( error , (error) =&gt; {    log. error( TestBot , 'on error: ', error. stack);  })bot. start(). then(() =&gt; {  log. info( TestBot ,  started.  );});  async function coinBot(s1){  var result;  import rp from 'request-promise';  const requestOptions = {  method: 'GET',  uri: 'https://fxhapi. feixiaohao. com/public/v1/ticker', // 这里使用的非小号的API  qs: {  'start': '0',  'limit': '5000', //非小号最高数据5000  'convert': 'USD'  },  json: true,  gzip: true  };  let response = await rp(requestOptions);  for(var each in response)  {    if(response[each][ symbol ]. toLowerCase() == s1)    {      result =  [币种]:   + response[each][ symbol ] +`\n` +  [价格]:   +response[each][ price_usd ] + '\n' +  [24小时涨幅]:   + response[each][ percent_change_24h ] +  % ;      break;    }  }  return result;}运行效果: 致谢: 谢谢Wechaty团队‘好大’的指导.  作者: heygum "
    }, {
    "id": 148,
    "url": "https://wechaty.js.org/2021/03/31/wechaty-cryptocurrency-websocket/",
    "title": "使用wechaty提醒加密货币行情",
    "body": "2021/03/31 -  从2020年3月份以来，加密货币市场随着疫情导致的全球大放水而飞速扩张，BTC的价格从低点$3800涨到了最高$60000， 十几倍的涨幅吸引了全球越来越多的个人和机构投资者参与到这个市场。 这个7x24小时的市场瞬息万变，上下几个点甚至几十个点的波动常常在十几分钟甚至几分钟之内就能完成，这么大的波动在给投资者带来丰厚回报的同时也伴随着巨大的风险。作为一名个人投资者，非常希望能够及时得到虚拟货币价格的变动情况而进行交易。 因此, 我非常希望建立一个自动化机器人，在行情波动巨大的时候及时发出提醒。目前，市面上有各种各样的接口提供了消息推送，比如钉钉，spark， IFTTT， telegram等等. 但是，每个人手机里各种各样的消息推送常常让人应接不暇。而微信，作为最广泛使用的聊天工具，鲜有人错过阅读微信消息。 所以，我打算通过微信机器人来进行消息推送。通过搜索，了解到目前市场的消息机器人有itchat， wxpy，wechaty等等。可是随着腾讯施加压力，基于web微信的itchat和wxpy无法使用。而wechaty支持多种协议，比web协议更加安全，于是决定采用wechaty基于ipad协议 ( padLocal ) 来搭建机器人。 让我们进入正题！ 环境和依赖: pythonaiohttpasynciowechaty Wechaty Puppet Hostie部署：: 因为原生的wechaty是基于JavaScript和TypeScript写的，所以需要通过docker搭建Wechaty Puppet Hostie 服务作为中转， 从而可以通过python调用。  部署前置准备:一个满足以下三点要求的服务器：  Public IPPublic PortDocker  部署Wechaty Puppet Hostie具体代码如下（本人服务器为 Ununtu 18. 04） #! /usr/bin/bashexport WECHATY_LOG= verbose export WECHATY_PUPPET= wechaty-puppet-padlocal export WECHATY_PUPPET_PADLOCAL_TOKEN= puppet_padlocal${TOKEN} export WECHATY_PUPPET_SERVER_PORT= 9001 export WECHATY_TOKEN=$(curl -s https://www. uuidgenerator. net/api/version4) --name wechaty_puppet_service_token_gateway \ --rm \ -e WECHATY_LOG \ -e WECHATY_PUPPET \ -e WECHATY_PUPPET_PADLOCAL_TOKEN \ -e WECHATY_PUPPET_SERVER_PORT \ -e WECHATY_TOKEN \ -p  $WECHATY_PUPPET_SERVER_PORT:$WECHATY_PUPPET_SERVER_PORT  \ wechaty/wechaty代码中的WECHATY_PUPPET_PADLOCAL_TOKEN是需要向官方申请，可以得到的一个可以试用7天的token，后续通过社区的激励计划，还可以免费获得时效更长的token。详情参见这里。  验证Wechaty Puppet Hostie访问 https://api. chatie. io/v0/hosties/WECHATY_TOKEN ，其中WECHATY_TOKEN是指你刚刚自行设定的Token，当返回结果为服务器的Public IP时则说明部署成功，为0. 0. 0. 0时则说明部署失败~ 项目思路: 搭建完中转服务，现在我们需要集中注意力在需求和机器人的搭建上面。市场行情数据来源于国内三大交易所之一币安。为了获得更加及时的数据，我决定采用websocket来搭建我们的服务。关于机器人方面，我读了官方examples里面的代码发现机器人都是继承Wechaty基类来通过自定义回调函数来实现各种功能。利用事件驱动的回调函数这样是很被动的，而我想得到一个可直接调用的Wechaty对象，不通过start()函数进入事件循环监听, 而可以主动的发送信息。经过一天的阅读代码和自我摸索，终于实现了创建一个可以直接调用的机器人对象，稍后请参考详细代码，其中最重要的还是需要进入事件监听，然后在监听到成功登录的事件以后，中断监听，返回已经登录好的机器人对象， 从而实现直接调用。 首先我们建立Websocket基类, 并且建立HeartBeat类来定期执行某些任务，比如检查websocket连通性并断线重连等等。 #websocketAPI. pyimport loggingimport asyncioimport aiohttpclass Websocket:      websocket接口封装       def __init__(self, url, check_conn_interval=2, send_hb_interval=2):        初始化    @param url 建立websocket的地址    @param check_conn_interval 检查websocket连接时间间隔    @param send_hb_interval 发送心跳时间间隔，如果是0就不发送心跳消息           self. _url = url    self. _check_conn_interval = check_conn_interval    self. _send_hb_interval = send_hb_interval    self. ws = None # websocket连接对象  def initialize(self):        初始化           # 注册服务 检查连接是否正常    print( 注册服务 检查连接是否正常 )    heartbeat. register(self. _check_connection, self. _check_conn_interval)    # 注册服务 发送心跳    print( 注册服务 发送心跳 )    # 建立websocket连接    print( 建立websocket连接 )    asyncio. get_event_loop(). create_task(self. _connect())  async def _connect(self):    logger. info( url: , self. _url, caller=self)    # print( proxy: ,proxy)    session = aiohttp. ClientSession()    try:      self. ws = await session. ws_connect(self. _url, timeout=10, autoping=True)      # print(self. ws)    except Exception as e:      print( ERROR:{},{} . format(e. __class__, e))      self. ws = await session. ws_connect(self. _url, timeout=10, autoping=True)      print(self. ws)    except aiohttp. client_exceptions. ClientConnectorError:      logger. error( connect to server error! url: , self. _url, caller=self)      return    asyncio. get_event_loop(). create_task(self. connected_callback())    asyncio. get_event_loop(). create_task(self. receive())  async def _reconnect(self):        重新建立websocket连接           logger. warn( reconnecting websocket right now! , caller=self)    await self. _connect()  async def connected_callback(self):        连接建立成功的回调函数    * NOTE: 子类继承实现           pass  async def receive(self):        接收消息           async for msg in self. ws:      if msg. type == aiohttp. WSMsgType. TEXT:        try:          data = json. loads(msg. data)        except:          data = msg. data        await asyncio. get_event_loop(). create_task(self. process(data))      elif msg. type == aiohttp. WSMsgType. BINARY:        await asyncio. get_event_loop(). create_task(self. process_binary(msg. data))      elif msg. type == aiohttp. WSMsgType. CLOSED:        logger. warn( receive event CLOSED: , msg, caller=self)        await asyncio. get_event_loop(). create_task(self. _reconnect())        return      elif msg. type == aiohttp. WSMsgType. ERROR:        logger. error( receive event ERROR: , msg, caller=self)      else:        logger. warn( unhandled msg: , msg, caller=self)  async def process(self, msg):        处理websocket上接收到的消息 text 类型    * NOTE: 子类继承实现           raise NotImplementedError  async def process_binary(self, msg):        处理websocket上接收到的消息 binary类型    * NOTE: 子类继承实现           raise NotImplementedError  async def _check_connection(self, *args, **kwargs):        检查连接是否正常           # 检查websocket连接是否关闭，如果关闭，那么立即重连    # print(self. ws)    if not self. ws:      logger. warn( websocket connection not connected yet! , caller=self)      return    if self. ws. closed:      await asyncio. get_event_loop(). create_task(self. _reconnect())      return  async def _send_heartbeat_msg(self, *args, **kwargs):        发送心跳给服务器           if not self. ws:      logger. warn( websocket connection not connected yet! , caller=self)      return    if self. heartbeat_msg:      if isinstance(self. heartbeat_msg, dict):        await self. ws. send_json(self. heartbeat_msg)      elif isinstance(self. heartbeat_msg, str):        await self. ws. send_str(self. heartbeat_msg)      else:        logger. error( send heartbeat msg failed! heartbeat msg: , self. heartbeat_msg, caller=self)        return      logger. debug( send ping message: , self. heartbeat_msg, caller=self)class HeartBeat(object):      心跳       def __init__(self):    self. _count = 0 # 心跳次数    self. _interval = 1 # 服务心跳执行时间间隔(秒)    self. _print_interval = 0 # 心跳打印时间间隔(秒)，0为不打印    self. _tasks = {} # 跟随心跳执行的回调任务列表，由 self. register 注册 {task_id: {. . . }}  @property  def count(self):    return self. _count  def ticker(self):        启动心跳， 每秒执行一次           self. _count += 1    # 打印心跳次数    if self. _print_interval &gt; 0:      if self. _count % self. _print_interval == 0:        logger. info( do server heartbeat, count: , self. _count, caller=self)    # 设置下一次心跳回调    asyncio. get_event_loop(). call_later(self. _interval, self. ticker)    # 执行任务回调    for task_id, task in self. _tasks. items():      interval = task[ interval ]      if self. _count % interval != 0:        continue      func = task[ func ]      args = task[ args ]      kwargs = task[ kwargs ]      kwargs[ task_id ] = task_id      kwargs[ heart_beat_count ] = self. _count      asyncio. get_event_loop(). create_task(func(*args, **kwargs))  def register(self, func, interval=1, *args, **kwargs):        注册一个任务，在每次心跳的时候执行调用    @param func 心跳的时候执行的函数    @param interval 执行回调的时间间隔(秒)    @return task_id 任务id           t = {       func : func,       interval : interval,       args : args,       kwargs : kwargs    }    task_id =  websocket_task     self. _tasks[task_id] = t    return task_id  def unregister(self, task_id):        注销一个任务    @param task_id 任务id           if task_id in self. _tasks:      self. _tasks. pop(task_id)heartbeat = HeartBeat()接着通过币安提供的websocket API来拉取行情。 因此我们新建一个Binance的子类来继承Websocket类，并且在Binance中实现机器人。 import asyncioimport jsonfrom datetime import datetimeimport osimport tracebackimport aiohttpfrom wechaty import Wechaty, Message, WechatyPlugin, Room,WechatyOptionsfrom wechaty_puppet_service import puppetfrom wechaty_puppet import PuppetOptions, EventType, EventScanPayload, ScanStatus, EventLoginPayloadfrom wechaty_puppet. schemas. room import RoomQueryFilterfrom wechaty_puppet. schemas. contact import ContactQueryFilterfrom websocketAPI import heartbeat, Websocketimport loggerWECHATY_PUPPET_SERVICE_TOKEN = 'acfbbe16-5f80-4a61-a755-85c27c3f5511'WECHATY_PUPPET = 'wechaty-puppet-service'os. environ['WECHATY_PUPPET_SERVICE_TOKEN'] = WECHATY_PUPPET_SERVICE_TOKENos. environ['WECHATY_PUPPET'] = WECHATY_PUPPETclass Binance(Websocket):      Binance 行情       def __init__(self, to_wechat_id):    self. _platform =  BINANCE     self. _url =  wss://stream. binance. com:9443     self. _symbols = ['BTC/USDT'] #可以在这里添加关心的交易对    self. _channels = ['kline'] #行情数据，提供kline，trade和orderbook三种行情    self. _c_to_s = {} # { channel :  symbol }    self. to_wechat_id = to_wechat_id #被发送人的微信id，也可以是群id，不过需要更改 self. send_notification函数    self. bot: Wechaty = None    asyncio. get_event_loop(). run_until_complete(self. init_wechat_bot())    self. _make_url()    super(Binance, self). __init__(self. _url)    self. initialize()    self. volatility_threshold = 0. 0001 # 波动大于 0. 01%的时候发出提醒    self. kline_init = False    self. last_timestamp = None # 上一个event k线的timestamp    self. current_timestamp = None # 当前event k线的timestamp    self. has_sent_notification = {} # 判断当前k线是否已经发送了通知  async def init_wechat_bot(self): # 在这个函数里面，我们初始化了可以直接调用的机器人对象    puppet_options = PuppetOptions()    puppet_options. token = WECHATY_PUPPET_SERVICE_TOKEN    options = WechatyOptions()    options. puppet = WECHATY_PUPPET    options. puppet_options = puppet_options    self. bot = Wechaty(options)    await self. bot. init_puppet()    await self. bot. init_puppet_event_bridge(self. bot. puppet)    self. bot. puppet. _init_puppet()    async for response in self. bot. puppet. puppet_stub. event(): #初始化puppet以后，进入事件监听      if response is not None:        payload_data: dict = json. loads(response. payload)        if response. type == int(EventType. EVENT_TYPE_SCAN): # 返回二维码事件          logger. debug('receive scan info &lt;%s&gt;', payload_data)          # create qr_code          payload = EventScanPayload(            status=ScanStatus(payload_data['status']),            qrcode=payload_data. get('qrcode', None),            data=payload_data. get('data', None)          )          print('scan payload_data', payload_data)          self. bot. puppet. _event_stream. emit('scan', payload)        elif response. type == int(EventType. EVENT_TYPE_LOGIN): # 登录事件，在登录以后          logger. debug('receive login info &lt;%s&gt;', payload_data)          print('login payload_data', payload_data)          event_login_payload = EventLoginPayload(            contact_id=payload_data['contactId'])          self. bot. puppet. login_user_id = payload_data. get('contactId', None)          self. bot. puppet. _event_stream. emit('login', event_login_payload)          break  async def send_message(self, message):    contact = await self. bot. Contact. find(self. to_wechat_id) # 发送到联系人    if contact:      await contact. say(message)    # room = await self. bot. Room. find(self. to_wechat_id) # 发送到群    # if room:    #   await room. say(message)  def _make_url(self):        拼接请求url           cc = []    for ch in self. _channels:      if ch ==  kline : # 订阅K线 1分钟        for symbol in self. _symbols:          c = self. _symbol_to_channel(symbol,  kline_5m )          cc. append(c)      elif ch ==  orderbook : # 订阅订单薄 深度为5        for symbol in self. _symbols:          c = self. _symbol_to_channel(symbol,  depth20 )          cc. append(c)      elif ch ==  trade : # 订阅实时交易        for symbol in self. _symbols:          c = self. _symbol_to_channel(symbol,  trade )          cc. append(c)      else:        logger. error( channel error! channel: , ch, caller=self)    self. _url +=  /stream?streams=  +  / . join(cc)  async def process(self, msg):        处理websocket上接收到的消息           print(msg)    logger. debug( msg: , msg, caller=self)    if not isinstance(msg, dict):      return    channel = msg. get( stream )    if channel not in self. _c_to_s:      logger. warn( unkown channel, msg: , msg, caller=self)      return    symbol = self. _c_to_s[channel]    data = msg. get( data )    e = data. get( e ) # 事件名称    if e ==  kline : # K线      kline = {         platform : self. _platform,         symbol : symbol,         open : data. get( k ). get( o ), # 开盘价         high : data. get( k ). get( h ), # 最高价         low : data. get( k ). get( l ), # 最低价         close : data. get( k ). get( c ), # 收盘价         volume : data. get( k ). get( q ), # 交易量         timestamp : data. get( k ). get( t ), # 时间戳         kline_type : const. MARKET_TYPE_KLINE      }      # print( symbol: , symbol,  kline: , kline)      logger. info( symbol: , symbol,  kline: , kline, caller=self)    elif channel. endswith( depth20 ): # 订单薄      bids = []      asks = []      for bid in data. get( bids ):        bids. append(bid[:2])      for ask in data. get( asks ):        asks. append(ask[:2])      orderbook = {         platform : BINANCE,         symbol : symbol,         asks : asks,         bids : bids,         timestamp : tools. get_cur_timestamp_ms()      }      logger. info( symbol: , symbol,  orderbook: , orderbook, caller=self)      if not self. kline_init:        self. last_timestamp = data. get( k ). get( t )        self. current_timestamp = data. get( k ). get( t )        self. has_sent_notification = {str(self. current_timestamp): False}        self. kline_init = True      if self. current_timestamp != self. last_timestamp:        self. has_sent_notification = {str(self. current_timestamp): False}      logger. info( symbol: , symbol,  kline: , kline, caller=self)      high, low = float(data. get( k ). get( h )), float(data. get( k ). get( l ))      volatility = (high-low) / high      if volatility &gt; self. volatility_threshold and not self. has_sent_notification[str(self. current_timestamp)]:        await self. send_message( {} 5分钟内波幅达到{:. 4f}%! . format(symbol, volatility*100))        self. has_sent_notification[str(self. current_timestamp)] = True          elif e ==  trade : # 实时成交信息      trade = {         platform : self. _platform,         symbol : symbol,         action : ORDER_ACTION_SELL if data[ m ] else ORDER_ACTION_BUY,         price : data. get( p ),         quantity : data. get( q ),         timestamp : data. get( T )      }      logger. info( symbol: , symbol,  trade: , trade, caller=self)    else:      logger. error( event error! msg: , msg, caller=self)  def _symbol_to_channel(self, symbol, channel_type= ticker ):        symbol转换到channel    @param symbol symbol名字    @param channel_type 频道类型 kline K线 / ticker 行情           channel =  {x}@{y} . format(x=symbol. replace( / ,   ). lower(), y=channel_type)    self. _c_to_s[channel] = symbol    return channelif __name__ == '__main__':  binance_websocket = Binance(to_wechat_id='文件传输助手')  loop = asyncio. get_event_loop()  # loop. call_later(2, heartbeat. ticker)  loop. run_forever()至此我们的加密货币波动提醒机器人基本框架已经搭好，如果感兴趣的话，大家可以通过搭配k线事件，trade事件和orderbook事件形成新的信号提醒，也可以做各种量化交易提醒。 运行效果: 感谢: 在最后我们要感谢所有为我们提供工具和服务的团队和个人。特别感谢开源项目Wechaty团队和免费提供服务的padLocal团队。  作者: r-hou，学生，加密货币爱好者。 "
    }, {
    "id": 149,
    "url": "https://wechaty.js.org/2021/03/27/rcs-messaging-chatbot/",
    "title": "RCS Messaging Chatbot",
    "body": "2021/03/27 -  Rich Communication Services (RCS) is a communication protocol between mobile-telephone carriers and between phone and carrier, aiming at replacing SMS messages with a text-message system that is richer, provides phonebook polling (for service discovery), and can transmit in-call multimedia. It is part of the broader IP Multimedia Subsystem.  It is also marketed as Advanced Messaging, Chat, joyn, SMSoIP, Message+, and SMS+.  — Wikipedia In China, the telecom operators call the RCS a 5G Chatbot. (See: Chinese operators make major RCS commitment: Whitepaper, April 9, 2020)  Source: What is RCS Messaging? Rich Communication Services and Chatbots Internet Company:  Google Jibe - What’s possible with RCS? BotSociety - RCS Messaging designChina Unicom:  联通在线 - Chatbot 创新开发大赛来啦 中讯邮电设计院 - 硬核桃5G消息开发者社区     5G 消息开发者发布会中讯院总经理致辞   中讯院：介绍硬核桃社区   梦网：5G消息时代CSP转型之路    Source: 硬核桃社区发布会 Case Study:  RCS Messaging: Porsche Recruitment Chatbot from BOTfriends, GSMA Mobile World Congress 2019 (MWC19) in Barcelona, Oct 8, 2019     https://botfriends. de/en/    Cbot RCS Chatbot Improves User Experience of Banking Clients, GSMA Mobile World Congress 2019 (MWC19) in Barcelona, Jun 25, 2019     http://www. cbot. ai/   Conclusion: What I’m thinking about is, if we build a Wechaty Puppet RCS, then our chatbot will be able to run both on the WeChat and the RCS without modify any code! Here’s the Wechaty Puppet RCS Wishlist: Enable RCS Support for Wechaty wechaty/wishlist#53 Credit: Teaser image credit https://www. youtube. com/watch?v=xjQPH17AP6k "
    }, {
    "id": 150,
    "url": "https://wechaty.js.org/2021/03/25/google-season-of-docs-documentation-system/",
    "title": "Applying the documentation system to Wechaty docs",
    "body": "2021/03/25 - This year, Wechaty organization is applying the Google Season of Docs program because we want to improve our documentation for the community. When I’m reading Google Season of Docs - Project Ideas, I found this great talk: What nobody tells you about documentation, Daniele Procida, 2017, PyCon AU, which techs me The Grand Unified Theory of Documentation:  There is a secret that needs to be understood in order to write good software documentation: there isn’t one thing called documentation, there are four.  They are: tutorials, how-to guides, technical references, and explanations.  They represent four different purposes or functions and require four different approaches to their creation.  Understanding the implications of this will help improve most documentation - often immensely. What nobody tells you about documentation: In the Daniele’s 30 minutes talk video, I decided to follow his principle to refactor our Wechaty Documentation website.   What nobody tells you about documentation, Daniele Procida, 2017, PyCon AU In the above video, Daniele “using real-life examples I’ll draw out the key functions of documentation, and how they map onto different ways of writing it. Putting this into practice is simple when armed with some basic guidelines. The benefits are huge, and available with a minimum of effort. ” (link) The most important concept is the following diagram:  Credit: Documentation System By following the above concepts, I re-structured our docs site by a better understanding of what Wechaty documentation should be like, and also great help me to write a better GSoD proposal for submitting to Google. The Good Docs Project: The Good Docs Project is also a great project with huge helps. The goal of the Good Docs Project is to improve open source software documentation by providing high quality templates and writing instructions to the open source community and beyond. The following diagram illustrated the lifecycle of the documentation:  Each document type serves a different purpose and has differing requirements — The Good Docs Project Updated docs site: Please read our branding new docs site at http://wechaty. js. org/docs/ which following the concepts of documentation system! Related Issues:  Follow the Documentation System from Daniele Procida #704 Google Season of Docs Application #72"
    }, {
    "id": 151,
    "url": "https://wechaty.js.org/2021/03/17/tag-based-bot-detect-vip-customer/",
    "title": "基于标签的多功能服务系统&检测你身边的VIP用户",
    "body": "2021/03/17 - 随着时间的推移，我们在不断的认识新的朋友，不断加新的好友， 在我们的微信里， 好友列表会有很多，甚至上千人，有的时候我们自己也理不清哪些好友是我们的客户，哪些好友是我们的朋友同学，哪些好友是我们在某次活动相识，甚至哪些好友只是萍水相逢但是实际上却极有可能是我们很好的潜在客户或者未来的合作伙伴，而因为平时的忽视可能就这样错过。 所以首先给我们的微信好友进行标签化的科学分类是很有必要的，有了标签，更重要的是如何进一步对这些标签化的好友进行管理和经营，本系统即目标于解决此问题。 本系统实现了以下两个基本功能：  1. 我们在后台可以有多种类型以及门类的的service， 但是每种service的受众其实是不同的，取决于我们的微信好友们的不同兴趣指标，即好友属于哪种受众群体。如果我们把好友按照不同的兴趣指标进行分类，那么我们可以把对应的service精准投放/对接给不同的受众群体(对应标签的用户群) 。即满足了客户的需求，又避免打扰不需要的客户，提高了服务的效率。2. 每一个标签的群体里对我们的service/bot 的兴趣值是不同的，如何找到标签中对我们最感兴趣的用户呢？这也就是寻找VIP客户的过程。我们需要列出每一个好友的属性，包括我们自定义的一些属性存于database中，在交流的过程中我们可以不断更新每个好友的各个属性，对每个属性都赋予权重，最后通过排序算出加权总和最高的用户，即我们的VIP用户。（此处可以进一步延伸并扩展，如果找到我们未来最合拍的商业合作或者创业伙伴？/最有价值的客户？/ 对你最感兴趣的高富帅/白富美？:-O） 系统整体架构简化图 相关服务和框架:  TypeormMySQLwechatYBTC ServiceUnicorn Service 功能简介：挑选了我的两个受众群体， 其中一个群体是喜欢投资比特币，那么他们比较想要快速了解到最近的整合比特币最新资讯，这里简单的实现了一个获取比特币资讯的service。第二个群体喜欢关注最新的行业资讯，想了解最新的独角兽公司的资讯，也实现了一个抓取整合独角兽公司的service。这两个service都利用wechaty的API实现的bot去对接客户，这样客户可以自动通过type不同的选项获取资讯。而service获取的资讯会实时的更新数据到MySQL数据库(typescript与DB交互还是有些坑，搞了一阵)，这样基于WechatY的bot 可以通过share的db信息将最新资讯返回给customers. 这里我们的两个标签分别取名为btc和company.  对于不同tag的user, 我们回复不同的autoReploy Message import {Entity, Column, PrimaryGeneratedColumn} from  typeorm ;@Entity()export class TagCatalog {  @PrimaryGeneratedColumn() id: number; @Column() tag: string;  @Column( text ) autoReplyMsg: string;   @Column( text ) scheduleMsg: string;} 可以看到标签为btc的用户发来一条信息，首先通过wechatY的bot 发送自动回复消息告知我们的service.   当用户选择1时，我们返回最新的当日BTC价格以及实时价格。这里后台的BTC service 会实时的更新MySQL 数据库，我们通过wechatY的bot 读取MySQL来返回最新的BTC价格 async function sayCurrentPrice(fromPersion: Contact){ createMySQLConnection(). then(async connection =&gt; {   let btcMessageRepository = connection. getRepository(BtcPriceMessage);  let btcCurrentPrice = await btcMessageRepository. findOne({id: 1});  console. log( the current price meesage:  , btcCurrentPrice);  if(btcCurrentPrice){   fromPersion. say(btcCurrentPrice. message);  }else{   fromPersion. say( Sorry, did not find the current btc price in our system );  }  // close the connection.   connection. close(); })} 标签为company的用户发来信息，我们告知其service.   用户选择1,返回实时市值最高的5个独角兽公司。这里后台的UniCorn service 会实时的更新MySQL 数据库，我们通过wechatY的bot 读取MySQL来返回当前市值最高的5个独角兽公司。 至此，基于标签的多功能服务系统的雏形完成了。那么如何获得标签为company的用户粘性值最高的人呢，即对我们最感兴趣的VIP客户呢？ 这需要再数据库中存储用户的各个属性， 这里仅为方便展示，我们只选取最简单的属性，用和bot的聊天次数属性作为唯一的权重计算。 通过一段时间与不同用户的的交流, 通过数据库的查询我们发现了我们的VIP客户，即db中talkTimes最高的用户。 @Entity()export class ContactAndInterest {  @PrimaryGeneratedColumn() id: number; @Column() tag: string;  @Column( int ) talktimes: number;  @Column() wxid : string; @Column() alias : string;// @Column({ type:  varchar , charset:  utf8 , collation:  utf8_general_ci })@Column({ type:  varchar , charset:  utf8 , collation:  utf8_bin }) name : string;}async function updateDbForInterest(fromPerson: Contact, tagName: string){ createMySQLConnection(). then(async connection =&gt; {   let personRepository = connection. getRepository(ContactAndInterest);  let personIntrestToUpdate = await personRepository. findOne({wxid: fromPerson. id});  console. log( the person to update from the db:  , personIntrestToUpdate);  if(personIntrestToUpdate){   personIntrestToUpdate. wxid = fromPerson. id;   // if before is true then assign, else use empty   personIntrestToUpdate. alias = await fromPerson. alias() || '';   personIntrestToUpdate. name = await fromPerson. name() || '';   personIntrestToUpdate. tag = tagName;   personIntrestToUpdate. talktimes = personIntrestToUpdate. talktimes + 1;  }else{   personIntrestToUpdate = new ContactAndInterest();   personIntrestToUpdate. wxid = fromPerson. id;   personIntrestToUpdate. alias = await fromPerson. alias() || '';   personIntrestToUpdate. name = await fromPerson. name() || '';   personIntrestToUpdate. tag = tagName;   personIntrestToUpdate. talktimes = 1;  }  await personRepository. save(personIntrestToUpdate);  log. info( updated the personInterest object of %s , personIntrestToUpdate);  // close the connection.   connection. close(); }). catch(error =&gt; {  console. log(error); });}感谢感谢WechatY提供的如此强大的微信API, 记得当时找开源的API找了很久，虽然也有其他的API, 不过有些API接口太少。最后发现了WechatY后感觉不错，希望wechaty不断完善，能够不断壮大，越来越好的发展下去。 回顾与展望由于之前基本没写过typescript, 所以这里也是现学现卖，很多语法写法并不是太考究还请海涵。 这里只是一个雏形的实现， 后面我觉得可以更深的去挖掘我们的微信好友， 比如将不同标签的好友的各种信息通过可视化的方式展现在前端，让人一目了然。 增加更多的属性去分析不同的用户，通过高级的算法去更好的分析用户，计算出VIP用户群体。开发更多的services去对接相应的用户转化为更高的价值。希望可以完成一个功能更加强大的服务。 "
    }, {
    "id": 152,
    "url": "https://wechaty.js.org/2021/03/17/node-wechaty-and-wechaty-puppet-padlocal/",
    "title": "Wechaty+微信小程序实现群内活动报名",
    "body": "2021/03/17 - 超哥之前开发了一个叫做「群组大师」的小程序，听名字就知道，是用来管理群组的，管理群组的什么呢？ 最初的想法是管理群组活动，超哥是羽毛球爱好者，经常出入京城各个羽毛球约球群，群内人肉接龙报名的传统让人抓狂，所以开发了一个小程序来发布活动和报名。 然鹅，现实是残酷的，培养球友的习惯并不容易，so，小程序基本没人使用…  峰回路转突然就在最近，超哥又混进一个羽毛球群，竟然在使用微信机器人进行报名，并且用起来确实比小程序要爽，于是乎萌生了「机器人+小程序」的想法 思路和实现: 流程:  基于Wechaty制作微信机器人，获取群内实时消息 将消息转发给「群组大师」后台服务接口 后台服务根据消息是否命中关键字，返回活动和报名信息 机器人程序将返回的信息发送到群指令设置: 帮助——获取指令列表活动——查询活动详情报名——报名活动取消——取消活动报名 实现:  基于Puppet Service: PadLocal实现，详细介绍参见 https://wechaty. js. org/docs/puppet-services/padlocal 参考PadLocal官方demo示例 https://github. com/padlocal/wechaty-puppet-padlocal-demo 修改demo中的main. ts文件，编写自己的业务逻辑效果图:  打开「群组大师」，找到群列表  进入群主页  发布活动  提交并发布  发布成功进入活动详情  在对应微信群内使用指令进行活动报名，首次使用可发送 帮助 获取全部指令列表  发送 活动 查看群内活动详情，发送 报名 即可立即报名活动  发送 取消，取消活动报名  在「群组大师」小程序中可查看活动报名详情 demo源码：: 特别说明：  替换代码中的Token为自己的，「群组大师」提供的http://test-958d13-1251176925. ap-shanghai. service. tcloudbase. com/test/groupmaster接口是本人使用小程序云开发开放供小伙伴们测试体验使用的接口，请务必不要滥用。 下载https://github. com/padlocal/wechaty-puppet-padlocal-demo中示例，将main. ts中代码替换为如下，运行并登陆微信 将机器人微信加入到群组 联系超哥（微信ledongmao）帮你在后台绑定为你群组的管理员，即可发布和管理活动（自主认领微信群的功能还在开发中，目前人肉设置群管理员）import { PuppetPadlocal } from  wechaty-puppet-padlocal ;import { Contact, log, Message, ScanStatus, Wechaty } from  wechaty ;import { FileBox } from 'file-box'import {  UrlLink,  MiniProgram,} from 'wechaty'import request from 'request';const puppet = new PuppetPadlocal({  token:  ---------- })function print(msg: string, res?: any): void {  console. debug(msg + '------------------------------------')  console. debug(res)  console. debug('\n')}const bot = new Wechaty({  name:  TestBot ,  puppet,})  . on( scan , (qrcode: string, status: ScanStatus) =&gt; {    if (status === ScanStatus. Waiting &amp;&amp; qrcode) {      const qrcodeImageUrl = [        'https://wechaty. js. org/qrcode/',        encodeURIComponent(qrcode),      ]. join('')      log. info( TestBot , `onScan: ${ScanStatus[status]}(${status}) - ${qrcodeImageUrl}`);      require('qrcode-terminal'). generate(qrcode, { small: true }) // show qrcode on console    } else {      log. info( TestBot , `onScan: ${ScanStatus[status]}(${status})`);    }  })  . on( login , (user: Contact) =&gt; {    log. info( TestBot , `${user} login`);  })  . on( logout , (user: Contact, reason: string) =&gt; {    log. info( TestBot , `${user} logout, reason: ${reason}`);  })  . on( message , async (message: Message) =&gt; {    const contact = message. talker()    const text = message. text()    const room = message. room()    // print('@me', await message. mentionSelf())    // print('message. text()', message. text())    // print('talker', contact)    // print('wxid', contact. id)    // print('gender', contact. gender())    // print('type', contact. type())    // print('name', contact. name())    // print('avatar', await contact. avatar())    // print('alias', await contact. alias())    // print('city', contact. city())    // print('friend', contact. friend())    // print('province', contact. province())    // print('roomid', room. id)    // print('room. topic()', await room. topic())    let datas = {      // 'me': await message. mentionSelf(),      'message_text': 'X' + message. text(),      // 'talker': contact,      'wxid': contact. id,      'gender': contact. gender(),      'type': contact. type(),      'name': contact. name(),      'avatar': await contact. avatar(),      'alias': await contact. alias() || '',      'city': contact. city(),      'friend': contact. friend(),      'province': contact. province(),      'roomid': room. id,      'room_topic': await room. topic(),    }    print('datas', datas)    let datas_jsonstr = JSON. stringify(datas)    // 群组大师小程序提供的活动查询和报名接口    let url = 'http://test-958d13-1251176925. ap-shanghai. service. tcloudbase. com/test/groupmaster?action=wechaty' + '&amp;data=' + datas_jsonstr    request(encodeURI(url), function (error, response, body) {      console. error('error:', error); // Print the error if one occurred      console. log('statusCode:', response &amp;&amp; response. statusCode); // Print the response status code if a response was received      console. log('body:', JSON. parse(body)); // Print the HTML for the Google homepage.       if (JSON. parse(body). data &amp;&amp; JSON. parse(body). data. content) {        // 小程序返回的活动报名信息发送到群        message. say(JSON. parse(body). data. content)      }    });    // const toContact = message. to()    // if (toContact) {    //   const name = toContact. name()    //   print(`toContact: ${name} Contact: ${contact. name()} Text: ${text}`)    // } else {    //   print(`Contact: ${contact. name()} Text: ${text}`)    // }    // 1. send Image    if (/^ding$/i. test(message. text())) {      const fileBox = FileBox. fromUrl('https://wechaty. github. io/wechaty/images/bot-qr-code. png')      await message. say(fileBox)    }    // 2. send Text    if (/^dong$/i. test(message. text())) {      await message. say('dingdingding')    }    // 3. send Contact    if (/^luyuchao$/i. test(message. text())) {      const contactCard = await bot. Contact. find({ name: 'luyuchao' })      if (!contactCard) {        console. log('not found')        return      }      await message. say(contactCard)    }    // 4. send UrlLink    if (/^link$/i. test(message. text())) {      const urlLink = new UrlLink({        description: '点击链接关注超哥的个人微信公众号——彪悍的超哥',        thumbnailUrl: 'https://camo. githubusercontent. com/f310a2097d4aa79d6db2962fa42bb3bb2f6d43df/68747470733a2f2f6368617469652e696f2f776563686174792f696d616765732f776563686174792d6c6f676f2d656e2e706e67',        title: '关注超哥',        url: 'https://mp. weixin. qq. com/s/sC76qzmzV61IV-I6RMOj2w',      });      await message. say(urlLink);    }    // 5. send MiniProgram (only supported by `wechaty-puppet-macpro`)    // if (/^mini-program$/i. test(message. text())) {    //   const miniProgram = new MiniProgram({    //     appid: 'gh_0aa444a25adc',    //     title: '我正在使用Authing认证身份，你也来试试吧',    //     pagePath: 'routes/explore. html',    //     description: '身份管家',    //     thumbUrl: '30590201000452305002010002041092541302033d0af802040b30feb602045df0c2c5042b777875706c6f61645f31373533353339353230344063686174726f6f6d3131355f313537363035393538390204010400030201000400',    //     thumbKey: '42f8609e62817ae45cf7d8fefb532e83',    //   });    //   await message. say(miniProgram);    // }  })  . on( error , (error) =&gt; {    log. error( TestBot , 'on error: ', error. stack);  })bot. start(). then(() =&gt; {  log. info( TestBot ,  started.  );});"
    }, {
    "id": 153,
    "url": "https://wechaty.js.org/2021/03/14/summer-2021-kick-off-meeting/",
    "title": "Summer of Wechaty, 我们来啦",
    "body": "2021/03/14 - 去年夏天，Wechaty 社区参与了“开源软件供应链点亮计划-暑期2020”（以下简称暑期2020）活动，在为期三个月的开发结束后，多位同学顺利完成开发，为 Wechaty 社区实现多平台、多语言、多功能贡献了智慧和力量。点此了解更多。 今年，我们计划继续参与暑期2021系列活动 ，吸引更多的新鲜血液加入 Wechaty 社区，共同推动 Wechaty 成为易用度最高、可迁移性最强的聊天机器人框架。 值得注意的是，今年的暑期2021将由暑期2020中的部分优秀导师和学生牵头组织，一方面，这代表在暑期2020中，我们成功吸纳了新的活跃贡献者加入社区，是对社区在暑期2020活动中表现的肯定；另一方面，我们相信这些曾经的参与者，会从他们的角度提出新的思路和想法，让暑期2021活动更加高效、更加人性化。 开源软件供应链点亮计划: Institute of Software Chinese Academy of Sciences (ISCAS) Open Source Promotion Plan (OSPP) encourages everyone to pay close attention to open source software and open source community, aiming to cultivate and explore more outstanding developers. ‘Summer 2021’ will be held in this summer. We will collaborate closely with the open source community to provide one-to-one mentor guidance and invite some specialists to conduct free online lectures. In order to promote the development of open source software and facilitate the construction of excellent open source software community, we encourage researchers, open source enthusiasts, professors as well as students to participate in the development and maintenance of open source software. Furthermore, ‘Summer 2021’ is supposed to increase the activity of open source projects, and promote the development of open source ecology. 开源软件供应链点亮计划鼓励大家关注开源软件和开源社区，致力于培养和发掘更多优秀的开发者。活动将在暑期进行，我们将与开源社区紧密合作，提供一对一的导师指导，邀请技术大牛开展线上免费讲座。我们鼓励研究人员、开源爱好者、在校师生参与开源软件的开发与维护，促进开源软件的发展和优秀开源软件社区建设，增加开源项目的活跃度，推进开源生态的发展。  官网：https://summer. iscas. ac. cn/ 详细介绍：https://summer. iscas. ac. cn/help/ GitHub: https://github. com/summer-ospp暑期2021社区组织者:  Yuan, CTO of Juzi. BOT, Creator of Wechaty Puppet Service WXWork Jing, Author of Python Wechaty Zilin, Undergraduate of Sichuan University, Author of Wechaty-Meme-Bot Fairy, Author of Lark Puppet Jihuayu, Game DeveloperKick off meeting: 为了更好地筹备暑期2021，我们组织了一场启动会议，视频回顾：  Mentor Wanted: 我们期待更多有经验的开发者加入暑期2021的导师团队，帮助来自全国各地的高校学生了解开源社区、提高综合能力。如果你有能力、时间和精力，欢迎加入我们的导师团队，和我们一起度过一个难忘的夏天！ 报名方式：请发送邮件和个人介绍至froxanne1024@gmail. com "
    }, {
    "id": 154,
    "url": "https://wechaty.js.org/2021/03/08/python-wechaty-and-wechaty-puppet-padlocal/",
    "title": "Python-wechaty & wechaty-puppet-padlocal的初探",
    "body": "2021/03/08 - 本文为本地运行python-wechaty + 云上虚拟机运行wechaty-puppet-padlocal的简易教学 注意事项:  wechaty-puppet-padlocal目前只能用国内公网IP Fixed at 2021-03-16 新注册的wechat小号会无法登入 Fixed at 2021-03-10 Update cmd in step1 docker runTest Date:  March 01, 2021 March 16, 2021环境:  本地的手机(iPad or 手机都可以) PC(本文用Mac) 阿里云上的虚拟机 for puppet架构:  在虚拟机上运行wechaty-puppet 验证API有无注册成功 运行本地python-wechaty-getting-started 扫码登入Step 1 wechaty-puppet-padlocal: 你会需要一个国内的公网IP+Token(请向管理员注册)来让wechaty-puppet生效虚拟机部分,试用or免费方案你可以选用阿里云or华为云的orGCP很可惜google没有在国内的IP，不然你还可以顺便玩一下gcp的k8s建议你还是使用国内资源 注册个ubuntu20. 04即可,注意安全组要放行port 8788在ubuntu cmdline里运行以下指令 apt updateapt install docker. iodocker pull wechaty/wechatyexport WECHATY_PUPPET_PADLOCAL_TOKEN=puppet_padlocal_xxxxxxxxxxxxxxxxxxexport WECHATY_PUPPET_SERVER_PORT=8788export WECHATY_PUPPET=wechaty-puppet-padlocalexport WECHATY_LOG=verbosedocker run \ --rm \ -ti \ -e WECHATY_LOG \ -e WECHATY_PUPPET \ -e WECHATY_PUPPET_PADLOCAL_TOKEN \ -e WECHATY_PUPPET_SERVER_PORT \ -e WECHATY_TOKEN= $WECHATY_PUPPET_PADLOCAL_TOKEN  \ -p  $WECHATY_PUPPET_SERVER_PORT:$WECHATY_PUPPET_SERVER_PORT  \ wechaty/wechaty可以下指令检查一下是否正常运行，如图 netstat -ntlpdocker container ls 你可以telnet 虚拟机IP:8788 简易debug一下通不通(Optional)你可以運行將docker run改為docker-compose，虛擬機當機後可以自動長起來 Step 2 验证hostie token: 访问https://api. chatie. io/v0/hosties/puppet_padlocal_xxxxxxxx去检验你的token是否成功注册,如果不行请回到step1去检查。Good:{ host : 47. 119. 129. 29 , port :8788} No Good:{ host : 0. 0. 0. 0 , port :0} Step 3 本地运行python: python-wechaty-getting-started你需要Python3. 7+运行以下cmd git clone https://github. com/wechaty/python-wechaty-getting-startedcd python-wechaty-getting-startedpip3 install -r requirements. txtexport WECHATY_PUPPET=wechaty-puppet-serviceexport WECHATY_PUPPET_SERVICE_TOKEN=your_token_at_herepython3 examples/ding-dong-bot. py坐等QR code出现扫码就好 Step 4 微信扫码: 目前用新注册帐号会失败 Fixed扫完后就登入了 最后再请朋友或是发给自己ding(不要有空格跟全小写)就会自动回dong啦！后续有非常多资源跟应用在官网上，大家有空就翻翻看。Happy hacking! "
    }, {
    "id": 155,
    "url": "https://wechaty.js.org/2021/03/04/wechaty-puppet-providers-trends/",
    "title": "Wechaty Puppet Providers Trends",
    "body": "2021/03/04 - Do you want know which Wechaty Puppet Provider is most used by our Wechaty developers? Wechaty Puppet Provider (WPP): Different IM systems need different Wechaty Puppets, and they have different names, and all implementing the Wechaty Puppet API; we call them the Wechaty Puppet Provider. For example, the WPP who is supporting WeChat is named wechaty-puppet-wechat, supporting Whatsapp is named wechaty-puppet-whatsapp, and supporting Lark is named wechaty-puppet-lark. And our community are also building the Wechaty Puppet Service (Providers) for any RPA protocol. The Trends: We are very interested in how many users choose which WPP. Luckily, an open-source project named NPM Trends is an NPM package comparison app hosted at npmtrends. com written by John Potter. So we can get to know how many users are using which WPP in the past: The Trends in March 2021:  wechaty-puppet-wechat(renamed from wechaty-puppet-puppeteer) is the top 1 used WPP, which has around 300 downloads per day.  wechaty-puppet-service follows as second, which is our official Wechaty Puppet Service Provider, with around 200 downloads per day.  wechaty-puppet-padlocal is a new star from our community, which is the third most used WPP now. It provides the pad protocol to the community. Thank you very much @padlocal, for creating this WPP &amp; WPS! It is around 180 downloads per day. Conclusion: If you are interested in the adaption of WPPs, you can visit the NPM Trends service to learn the Wechaty Puppet Providers Trends. Related Links:  Puppet Specification A Check-list for Creating New Puppets for Wechaty #1167 Wechaty Puppet API Docs Wechaty Puppet Compatibility Wechaty Puppet Development Wechaty Puppet Directory Wechaty Puppet Links"
    }, {
    "id": 156,
    "url": "https://wechaty.js.org/2021/02/28/wechat-chatroom-assistant/",
    "title": "微信群消息助手（wechat chatroom assistant）",
    "body": "2021/02/28 -  背景: 个人的微信里加了很多微信群，在这些微信群里经常会有一些重要的通知，或者一些我关心的文件等等，但是因为群里人多，所以也会有很多无关的消息。不想错过这些重要的通知，但是又不可能又精力自己一个个群去爬楼，非常浪费时间。所以就有了这么一个群消息助手机器人的需求，能够自动帮我按照定义的规则过滤消息，把我感兴趣的消息发到我个人的微信上。 功能: 根据定义的规则自动识别我关心的消息，并发送到我的个人微信上。初步的实现很简单，所有的规则，包括forward的对象都是hardcode在代码里的。之后可以将这些修改配可配置的方式，使得机器人更通用。 还有一些其他的想法，比如提供一些命令，能够“教”机器人干些什么事情，动态的执行某些代码。 实现逻辑: 逻辑非常简单；利用wechaty接收用户消息，对消息类型进行判断，并采取相应的行动（forward，或者say），并给出一些上下文消息（比如是从那个群来的，谁发的，等等） 依赖:  python-wechaty：wechaty python核心库 wechaty-puppet-padlocal：wechaty的ipad协议实现实现过程: async def on_message(msg: Message):       Message Handler for the Bot       global counter  counter += 1  log. error('received %s messages' % counter)  me = bot. Contact. load('paulhybryant0104')  text = msg. text()  mention_self = await msg. mention_self()  mention_text = await msg. mention_text()  if msg. room():    topic = await msg. room(). topic()    log. error('room: %s, topic %s' % (msg. room(). room_id, topic))    # @me    if mention_self:      log. error('mentioned me')      await me. say('来自群: %s' % topic)      await msg. forward(me)    # @all    elif '@所有人' in mention_text or '@All' in mention_text:      log. error('mentioned all')      await me. say('来自群: %s' % topic)      await msg. forward(me)    # For testing    elif topic == 'MyAssistant':      log. error(msg)      if msg. type() == MessageType. MESSAGE_TYPE_ATTACHMENT:        filebox = await msg. to_file_box()        await me. say(filebox)    # 低风险投资3群    elif msg. room(). room_id == '4932234304@chatroom':      if msg. type() == MessageType. MESSAGE_TYPE_ATTACHMENT:        filebox = await msg. to_file_box()        await me. say(filebox)    # TODO: Automatically cache chatroom ids, given topic (room name)    elif topic == '投资学习8群':      log. error(msg. room(). room_id)      if msg. type() == MessageType. MESSAGE_TYPE_ATTACHMENT:        filebox = await msg. to_file_box()        await me. say(filebox)    else:      for keyword in KEYWORDS:        if keyword in text:          log. error('contains keyword: %s' % keyword)          await me. say('来自群: %s' % topic)          await msg. forward(me)  else:    log. error(msg)    if text == '#weather':      await msg. say('TODO: report today\'s weather')本地运行:  克隆项目git clone g https://github. com/paulhybryant/wechat-bot. gitcd wechat-bot 安装依赖pip install -r requirements. txt 启动项目参考这篇文章来配置wechaty-puppet-service环境 export WECHATY_PUPPET_SERVICE_TOKEN=&lt;your token&gt;export WECHATY_PUPPET= wechaty-puppet-service python3 chatroom_assistant. py效果图: 致谢: 感谢Wechaty团队提供微信机器人SDK，让开发者可以专注于业务代码。感谢句子互动提供的pad协议版token。  作者: paulhybryantCode: Github "
    }, {
    "id": 157,
    "url": "https://wechaty.js.org/2021/02/20/google-cloud-shell-tutorials/",
    "title": "Google Cloud Shell Tutorials for Wechaty",
    "body": "2021/02/20 - Today, We have created a Google Cloud Shell Tutorial for easy getting started with Wechaty! The above button will take you to the Google Cloud Shell, open our tutorial in the right panel. Please follow it to enjoy playing with our Wechaty ding-dong BOT! What is Google Cloud Shell?:  Google cloud shell, is an online bash shell based on debian. The free tier, includes 1. 7 Gigabytes of Random-access memory, and a persistent 5 gigabyte home directory. Aside from the home, and root directories, cloud shell environment is volatile. The editor in Google Cloud Shell is based on Eclipse Theia. — Wikipedia What is Google Cloud Shell Tutorial?:  Cloud Shell supports building and launching tutorials to help users familiarize themselves with your project quickly and effectively.  A tutorial is a set of instructions written in Markdown. Cloud Shell creates in-context tutorials from these Markdown files by parsing the text into steps and substeps that are then displayed in a panel in Google Cloud Console.  — Writing tutorials in Cloud Shell  Button generated via open-in-cloud-shell"
    }, {
    "id": 158,
    "url": "https://wechaty.js.org/2021/02/17/summer-wechaty-nanjing-summit-journey/",
    "title": "一次愉快的南京开源峰会之旅",
    "body": "2021/02/17 -  写在前面：本来此篇博文应该在去年完成，由于其它事情耽搁一直拖延到现在。 我是暑期2020活动wechaty社区的学生开发者之一江姗姗，很荣幸被选为此次活动的优秀学生之一，和wechaty社区其他成员一起参加位于南京的“共献·开源“开源软件供应链2020峰会，此次峰会由中国科学院软件研究所和openEuler社区共同主办，于2020年11月14号到15号在南京开幕，同时全程在线直播。 这次会议是我第一次参与的开源会议，认识了很多来自全国各地的开源爱好者们，和社区的其他成员一起向大家介绍并展示wechaty社区的开源项目，可谓是收获满满。 会议前的准备: 在会议前，参会的社区成员们(@univerone, @wj-Mcat, @rickyyin98, @huan)于PNP cafe聚在了一起共同讨论需要准备的事项，制订了OKR (Objective and Key Results),具体可见A OKR Review for the Summer 2020 Summit，我在会议前具体负责的是参与flyer的设计，在会议期间和@wj-Mcat以及@rickyyin98一起在展台区域向大家介绍wehcaty。 会议中:  Talk: 在会议期间，我作为优秀学生代表和大家分享了参加暑期2020活动的经验和体会。给对wechaty社区项目感兴趣的同学有两点建议：一是如果时间充足的话，尽量多与社区导师沟通，不断完善项目计划的细节，这样后续执行的过程也比较方便。还有就是除了自己擅长的项目之外，也可以大胆尝试自己感兴趣但是没有接触过的新项目。 video:  slides:  致谢: 最后，感谢中国科学院软件研究所和openEuler社区给予的参会机会，感谢超级耐心和负责的中国科学院软件研究所的夏艺菲老师。 "
    }, {
    "id": 159,
    "url": "https://wechaty.js.org/2021/02/15/publishment-of-wechaty-whatsapp-puppet/",
    "title": "Wechaty-Puppet-Whatsapp Has been Published",
    "body": "2021/02/15 - With the introduction of wechaty puppet and the growth of the wechaty ecosystem and community, we’re happy to introduce wechaty-puppet-whatsapp which connects Wechaty API, the conversational RPA SDK for chatbot makers, and WhatsApp, a free, multi-platform messaging app. As a developer, you can use wechaty-puppet-whatsapp to build your own WhatsApp chatbot with a few lines of code, which can send and receive WhatsApp messages with wechaty API.  GitHub repo: https://github. com/wechaty/wechaty-puppet-whatsapp npm package: https://npmjs. com/package/wechaty-puppet-whatsappGetting started: First, you should install the package. npm i wechaty-puppet-whatsappnpm i wechatyTo enable the display of QR code in the terminal, qrcode-terminal should also be installed. npm i qrcode-terminalThen, you can implement your bot in a few lines of code, here is an basic demo: import { Wechaty, log} from 'wechaty';import qrterminal from 'qrcode-terminal';import { PuppetWhatsapp} from 'wechaty-puppet-whatsapp';const puppet = new PuppetWhatsapp()const bot = new Wechaty({ puppet })bot . on('scan', qrcode =&gt; qrterminal. generate(qrcode, { small: true })) . on('login', user =&gt; log. info(`User ${user} logged in`)) . on('message', message =&gt; log. info(`Message: ${message}`))bot. start() . then(() =&gt; log. info('StarterBot', 'Starter Bot Started. ')) . catch(e =&gt; log. error('StarterBot', e))After scanning a WhatsApp QR code and logging in, you can view the received messages in the terminal, feel free to implement your own function over the messages based on your need.  Next Steps: As always, feel free to file an issue on the github repo for any feedback. wechaty-puppet-whatsapp is an open-source project. If you’re interested in contributing to this project, check out the contribution guidelines to learn more, and welcome to join the Wechaty Developers’ Home or our Gitter network https://gitter. im/wechaty/wechaty to join our community. Here are some features to be implemented:       Feature   Status         Send and Receive text messages   ✅       Send media (images/audio/documents)   ❌       Send video   ❌       Receive Video   ❌       Receive media (images/audio/video/documents)   ❌       Send contact cards   ❌       Get invite for group   ❌       Modify group subject   ❌       Add group participants   ❌       Kick group participants   ❌       Mention users   ❌       Get contact info   ❌       Get profile pictures   ❌       Set user status message   ❌   Thanks: Wechaty Puppet Whatsapp is built on top of whatsapp-web. js, which is A WhatsApp client library for NodeJS that connects through the WhatsApp Web browser app, created by Pedro S. Lopez, @pedroslopez. Learn more: Other than WhatsApp, wechaty ecosystem also supports different instant messaging (IM) systems(such as TikTok, Dingding), you can refer to the following links for more details:  Wechat Offical Account TikTok Lark Kuaishou Gitter WxWork"
    }, {
    "id": 160,
    "url": "https://wechaty.js.org/2021/02/14/ziki-wechaty-helper/",
    "title": "基于wechaty的个人知识库机器人",
    "body": "2021/02/14 - 搭建个人知识库可以帮助将繁多和碎片化的知识进行分类收集，形成有条理的结构化知识体系，同时提供知识点的快速检索。 我的个人知识库（Ziki）某一页面 我的知识库文章大部分来源于订阅的rss文章，经阅读后会收藏部分文章，再由后台将这些文章同步到知识库，并执行与知识树的匹配。但移动端其他app例如知乎、虎扑等的帖子，却还无法自动入库，还依赖去知识库页面内手动输入url的方式添加，操作路径太长。考虑到大多app都有一键分享到微信的功能，搭建一个微信机器人来解决最适合不过了。 核心功能:  将感兴趣的文章分享给微信机器人，机器人接收后传给知识库接口处理，接口会将该文章入库和挂载到相关的知识点 发送关键字给微信机器人，机器人接收后查询知识库接口，返回与该关键字有关的文章列表分享知乎文章给机器人，实现文章的自动入库 向机器人查询知识点文章列表 代码: 仓库地址: ziki-wechaty-helper 配置: wechaty 配置: config/wechaty. js module. exports = { // puppet provider puppet:  wechaty-puppet-padlocal , // token for puppet service token:  puppet_padlocal_xxxxxx , // bot name name:  Ziki Helper , limitedUsers: [ wxid_xxxxx ],}知识库接口配置: config/ziki. js module. exports = { favorApi:  http://xxxxxx , // favor api queryApi:  http://xxxxxx , // query api username:  xx , password:  xx }运行: npm run start 作者:日拱一卒，持续学习，搭建知识体系，工作快乐，生活美好。 "
    }, {
    "id": 161,
    "url": "https://wechaty.js.org/2021/02/14/gource-visualizing-wechaty-history/",
    "title": "Gource Visualization for Wechaty",
    "body": "2021/02/14 -  Gource is an amazing and flexible tool that can be used to display activity from your repositories using a video visualization that people love. — How to use Gource to visualize your code repos Wechaty was built from scratch by Huan in May 2016. Let’s see what’s the first 30 days for the Wechaty Git Repo looks like! The Visualization for Wechaty Website Contributors (2016 - 2022):  The visualization is amazing, we can see the file tree growth by every git commit/push from Wechaty Contributors with a clear timeline! Wechaty Milestones: Wechaty was great improved in the past 5 years, we’d like to thank all our contributors because it definitely is a community effort! I’d like to list the milestones that Wechaty archived from each year below for summary. 2016:  NPM Published the very first version: 0. 0. 1 Commits 1,000+ Line of Code 10,000+ GitHub Stars 330+2017:  First Pull Request &amp; Meetup Testing CI/CD DevOps Dockerization Document JSDoc GitHub Stars 2,000+2018:  Refactoring Modularized SLOC 27,630 to 7,817 Ecosystem Wechaty Puppet New Puppet PadChat New Puppet PadPro Git Commits 4,000+ Contributors 40+ Blog Posts 70+ GitHub Stars 4,000+2019:  NPM Downloads 700K+ Docker Pulls 30K+ Contributors 60+ GitHub Stars 6,000+2020:  Git Commits 6,000+ Polyglot 6+ Languages GitHub Stars 9,000+2021 (Till Feberary):  Puppet Services 4+ Puppet Providers 10+ Contributors 160+ Blog Posts 254+ NPM Downloads 1 Million Used by 700+ Issue/PRs 2,100+ GitHub Stars 10,000+The first 30 days of Wechaty:  The above visualization is to show what I did in the first 30 days (May, 2016) when I built Wechaty from scratch! How to Generate Gource Video: Want to make your Git repo a video like mine? Go ahead to install &amp; visualize it! Install: At first, you need to download gource source code from https://gource. io/. I use the following commands successfully installed Gource in my Linux Ubuntu 20. 04 desktop: # Install development dependencies$ sudo apt install \  libglew-dev \  libsdl2-dev  libsdl2-image-dev \  libboost-all-dev \  libglm-dev# Download, configure, and make install$ tar zxvf . . /gource-0. 51. tar. gz$ cd gource-0. 51/$ . /configure$ make$ sudo make install# Gsource will be install in /usr/local/bin$ gsourceVisualize: I use the following script to generate the gource visualization video: $ git clone git@github. com:wechaty/wechaty. js. org. git$ cd wechaty. js. org$ gource \  -1920x1080 \  --camera-mode overview \  --highlight-all-users \  --file-idle-time 0 \  -auto-skip-seconds 0. 001 \  --seconds-per-day 0. 5 \  --hide progress,mouse \  --stop-at-end \  --max-files 99999999999 \  --max-file-lag 0. 00001 \  --output-ppm-stream - \  | \  ffmpeg \    -f image2pipe \    -vcodec ppm \    -i \    - \    -y \    -vcodec libx264 \    -threads 8 \    -b 3000k \    -maxrate 8000k \    -bufsize 10000k \    video. mp4 Script credit: Matthias Krüger, https://bugs. archlinux. org/task/26905 Useful Argument Examples:  --start-date 2016-05-01 --stop-date 2016-06-01Links:  Gource Event Sourcing made Simple What they don’t tell you about event sourcing"
    }, {
    "id": 162,
    "url": "https://wechaty.js.org/2021/02/09/how-to-use-wechaty-to-ask-for-payment-before-user-joining-the-group/",
    "title": "使用小微商户 + Wechaty构建一个可付费的私域流量运营助手",
    "body": "2021/02/09 - 一直以来在私域流量运营领域都有这样一个需求：自动通过好友，并在新好友支付一定的费用之后，依据新好友所发送的关键字，将其拉到对应的微信群。关键字与微信群对应，并且微信群满员以后可以自动扩建。 有人想过这样的解决方法，先让潜在用户添加人工客服微信，转帐或扫码支付，人工验证之后，再拉他/她入群。但是这个方法人工成本高，人工成本高，就意味着会拉高入群票价。 还有一个变通的方法，采用微商城，让用户在商城内自助完成支付，然后通过钩子设置发给用户一个四位数字的验证码，就是虚拟发货。完成这一步后，再引导用户拿着验证码添加机器人助手微信，机器人助手收到验证码以后，先到数据库里验证订单真伪，核实后再拉人入群。 这个方案看起来相当美好了，但是仍然有很大问题。一句话概括，就是太复杂。需要数据库，需要微商城等，部署成本高了自然也会推高入群票价。有人可能还会想到，可以使用知识星球或类似产品，这个产品确实很棒，但有时候我们就只想在微信中聚集私域流量，怎么办呢？ 能否有这样一个简单的方案：机器人助手自动通过好友后，依据新好友发送的关键字，自主判断是否需要付费，如果需要，发给新好友一个支付二维码，待新好友完成扫码支付后，自动将TA拉入微信群。整个过程没有第三方跳转，完全在微信窗口内完成。还有，整个方案不涉及Web服务、数据库服务等，只需要部署一个微信机器人就可以了。 答案是可以的，于是作者写了这个开源项目。我给它取名为：一个使用小微商户+微信聊天机器人构建的可付费私域运营助手。 这是一个实验性的小项目，还不完善，但可行性是具备的，完全可运行，收到的款项也会自动转到个人微信卡。希望这个项目能给你启发，但不提供任何技术保证和使用许诺。 该项目基于微信小微商户+Wechaty实现，并借鉴于Wechaty的示例代码。 接下来介绍一下它需要准备什么，如何使用，未尾有作者录制的视频，方便你快速查看项目的交互效果。 主要功能: 主要支持的功能交互指令：  申请加入xx群，可以加入群，将xx换成具体的关键字，例如书法 #查询2021xxx，用于查询旧订单，如果支付了可以补拉进群 指定的管理员，可以使用@xxx 勿发这样的群消息指令，让机器人踢出某人使用准备: 在使用之前需要Wechaty的token和小微商户的MCHID和SECRET。前者可在这里购买，是月租付费形式。后者在这里申请，它是一次性付费的，面向个人开放。 拿到启动材料后，需要在本地bash中配置一下系统变量： export WEPAY_MCHID=xxxexport WEPAY_SECRET=xxxexport WECHATY_PUPPET_HOSTIE_TOKEN=xxx这是Linux/Mac下的配置，在Windows下需要自行修改一下配置方法。 如何启动: 启动： git clone https://github. com/rixingyike/wechat-operation-assistant. git --depth=1cd wechat-operation-assistantnpm inpm run serve投石问路版本: 版本：v1. 0 当然了这个版本还存在一些问题，例如机器人助手依据昵称管理员权限，这存在漏洞。Wechaty中Contact对象有一个alias方法，可以设置/获取联系人备注，可以使用这个方法代替name检验管理员权限。 后续作者可能对这个项目进行不断完善，如果你有什么建议，欢迎提出来，也欢迎提交PR。 使用视频:  2021年02月09日  作者: 程序员LIYI，首发于公众号: 一个小小智能机器人：帮我们自动拉人，自动核实付费，自动将收款转到个人银行卡。以下内容重发时有修改。 "
    }, {
    "id": 163,
    "url": "https://wechaty.js.org/2021/02/06/wechaty-getting-started-without-leave-your-browser/",
    "title": "Getting Started Without Leave Your Browser: Wechaty ❤️ Gitpod",
    "body": "2021/02/06 -  Gitpod is an online IDE which can be launched from any GitHub page. Simply prefix any GitHub-URL with “https://gitpod. io#” or use our browser extension that adds a button to GitHub pages.  Within seconds, Gitpod provides you with a fully working development environment, including a VS Code-powered IDE and a cloud-based Linux container configured specifically for the project at hand.  — Gitpod — Online IDE For GitHub Wechaty Getting Started: We have created a template GitHub repo https://github. com/wechaty/wechaty-getting-started for new developers. This repository should work out-of-the-box, and is the best start point for Wechaty beginners.  GitHub: https://github. com/wechaty/wechaty-getting-started ding-dong-bot. ts: https://github. com/wechaty/wechaty-getting-started/blob/master/examples/ding-dong-bot. tsFeatures:  Works out-of-the-box under Linux/Mac/Windows.  Supports all puppets like Web, Pad, Windows, and Mac.  Reply a dong message when it received a ding. The Problem: Setting developing environment is hard. Lots of developers are struggle with:  fail to install Node. js fail install NPM dependencies successful (some related to GFW, some related to local build tools settings) can not read the QR Code on terminal (always related to local font settings) etc. The Solution: Getting Started with GitPod. io: Gitpod is an online IDE which can be launched from any GitHub page. Within seconds, Gitpod provides you with a fully working development environment, including a VS Code-powered IDE and a cloud-based Linux container configured specifically for the project at hand. So we’d like to suggest that the new developers should play with wechaty-getting-start repo with Gitpod. io service because it-just-works. 👇 Click me: Click the ☝️ above [Gitpod | Ready-to-Code] button to launch Gitpod with Wechaty Getting Started ding-dong BOT instantly inside your favorite browser. The button will take you to this link: https://gitpod. io/#https://github. com/wechaty/wechaty-getting-started Screenshot:  Wechaty ❤️ Gitpod "
    }, {
    "id": 164,
    "url": "https://wechaty.js.org/2021/02/04/matrix-with-wechaty/",
    "title": "用Matrix和wechaty来聊微信",
    "body": "2021/02/04 - Matrix chat是一个很不错的聊天软件，它支持了多种聊天协议和聊天机器人。并且支持通过matrix-appservice-wechaty来支持微信聊天。现在我来梳理一下matrix-appservice-wechaty的部署方法。 需要准备的东西:  域名（假设你的域名是example. com） 服务器，最好国内的配置流程: 配置域名解析:       Type   Host   Priority   Weight   Port   Target         A   matrix   -   -   -   matrix-server-IP       CNAME   element   -   -   -   matrix.        CNAME   dimension (*)   -   -   -   matrix.        CNAME   jitsi (*)   -   -   -   matrix.        SRV   _matrix-identity. _tcp   10   0   443   matrix.    配置matrix chat: git clone https://github. com/spantaleev/matrix-docker-ansible-deploy. gitmkdir inventory/host_vars/example. com/export MATRIX_REGISTRATION_ADMIN_SECRET=$(pwgen -s 64 1)echo 'matrix_domain: example. commatrix_ssl_lets_encrypt_support_email: ${email}matrix_synapse_enable_registration: truematrix_registration_admin_secret:  ${MATRIX_REGISTRATION_ADMIN_SECRET} matrix_postgres_connection_password: 'synapse-password'matrix_synapse_federation_enabled: truematrix_ma1sd_enabled: true' &gt; inventory/host_vars/example. com/vars. ymlecho 'example. com ansible_host=example. com ansible_ssh_user=root' &gt;&gt; inventory/hostsansible-playbook -i inventory/hosts setup. yml --tags=setup-all,start等一切部署完之后可以检测一下有没有问题 ansible-playbook -i inventory/hosts setup. yml --tags=self-check配置matrix-appservice-wechaty: 连接远程服务器 新建docker-compose. yml并填入如下内容 version: '2'services: wechaty-gateway:   image: wechaty/wechaty:next   volumes:    - /matrix/synapse/config:/data   networks:    - default   environment:    - WECHATY_PUPPET_SERVER_PORT=7777    - WECHATY_TOKEN=    - WECHATY_PUPPET=wechaty-puppet-padlocal    - WECHATY_PUPPET_PADLOCAL_TOKEN=   ports:    - 7777:7777 matrix-appservice-wechaty:   container_name: matrix-appservice-wechaty   image: wechaty/matrix-appservice   volumes:    - /matrix/synapse/config:/data   networks:    - default   environment:    - WECHATY_PUPPET_SERVICE_TOKEN=puppet_    - WECHATY_PUPPET_SERVICE_ENDPOINT=example. com:7777    - WECHATY_PUPPET=wechaty-puppet-service#    - WECHATY_PUPPET=wechaty-puppet-puppeteer    - WECHATY_LOG=silly   command: [ --config ,  /data/wechaty-config. yaml ,  --file ,  /data/wechaty-registration. yaml ]   ports:    - 8788:8788padlocal_token需要申请random_token是随机字符串，可以用uuid如果没有padlocal_token可以使用wechaty-puppet-puppeteer，把内容改为 version: '2'services: matrix-appservice-wechaty:   container_name: matrix-appservice-wechaty   image: wechaty/matrix-appservice   volumes:    - /matrix/synapse/config:/data   networks:    - default   environment:    - WECHATY_PUPPET=wechaty-puppet-puppeteer    - WECHATY_LOG=silly   command: [ --config ,  /data/wechaty-config. yaml ,  --file ,  /data/wechaty-registration. yaml ]   ports:    - 8788:8788然后新增文件/matrix/synapse/config/wechaty-config. yaml，并填入如下内容 domain: example. comhomeserverUrl: https://matrix. example. comregistration: /data/wechaty-registration. yaml运行docker-compose run --rm matrix-appservice-wechaty --config /data/wechaty-config. yaml --url  http://example:8788  --generate-registration生成配置文件 然后编辑/matrix/synapse/config/homeserver. yaml修改app_service_config_files那一行为app_service_config_files: [ /data/wechaty-registration. yaml ] 运行systemctl restart matrix-*重启matrix服务 注册并登录:  打开https://example. com，然后注册账号 点击People右边的➕，然后输入@wechaty:example. com点击Go 在打开的聊天窗口，等出现This room has been registered as your bridge management/status room.  然后发送!login，如果提示 You are not enable matrix-appservice-wechaty yet. Please talk to the wechaty bot to check you in. I had enabled it for you ;-) 就再发送一遍 扫描二维码登录参考资料:     作者: Roy。首发于博客: 用Matrix和wechaty来聊微信 "
    }, {
    "id": 165,
    "url": "https://wechaty.js.org/2021/02/03/python-wechaty-for-padlocal-puppet-service/",
    "title": "Python Wechaty如何使用PadLocal Puppet Service",
    "body": "2021/02/03 - 本文描述Python语言下如何使用iPad协议的PadLocal Token。其他Wechaty多语言开发也能做参考。  wechaty-puppet-padlocal TOKEN 申请方法搭建PadLocal Token Gateway: # 设置环境变量export WECHATY_LOG= verbose export WECHATY_PUPPET= wechaty-puppet-padlocal export WECHATY_PUPPET_PADLOCAL_TOKEN= puppet_padlocal_XXXXXX export WECHATY_PUPPET_SERVER_PORT= 9001 export WECHATY_TOKEN= 1fe5f846-3cfb-401d-b20c-XXXXX docker run -ti \ --name wechaty_puppet_service_token_gateway \ --rm \ -e WECHATY_LOG \ -e WECHATY_PUPPET \ -e WECHATY_PUPPET_PADLOCAL_TOKEN \ -e WECHATY_PUPPET_SERVER_PORT \ -e WECHATY_TOKEN \ -p  $WECHATY_PUPPET_SERVER_PORT:$WECHATY_PUPPET_SERVER_PORT  \ wechaty/wechaty:0. 56 WECHATY_PUPPET_PADLOCAL_TOKEN 申请得到的token代码 WECHATY_PUPPET_SERVER_PORT 设置对外访问端口，需要保证端口没被占用，没被防火墙匹配 WECHATY_TOKEN 生成个人随机TOKEN。WECHATY_TOKEN：个人理解为和远程wechaty服务器做通讯用，通过这个唯一token可以返回当前主机访问地址和端口。所以需要避免和别人重复。可以通过下面代码，确定是否成功。 curl https://api. chatie. io/v0/hosties/$WECHATY_TOKEN (个人随机token){ host : 36. 7. XXX. XXX , port :9001}python-Wechaty对接GateWay: 在对接Gateway的时候，这里需要注意下，如果GateWay是部署在公网可以访问的服务器上，按照默认配置就可访问；如果是部署在自己内网服务器上，就会报Your service token has no available endpoint, is your token correct?，这个时候需要设置WECHATY_PUPPET_SERVICE_ENDPOINT。 #1 默认配置export WECHATY_PUPPET= wechaty-puppet-service export WECHATY_PUPPET_SERVICE_TOKEN= puppet_padlocal_XXXXXX #2 主机是部署在内网服务器上export WECHATY_PUPPET= wechaty-puppet-service export WECHATY_PUPPET_SERVICE_TOKEN= puppet_padlocal_XXXXXX export WECHATY_PUPPET_SERVICE_ENDPOINT= 192. 168. 1. 56:9001 WECHATY_PUPPET_SERVICE_ENDPOINT：内网IP地址:端口号 python-wechaty-getting-started: git clone https://github. com/wj-Mcat/python-wechaty-getting-startedcd python-wechaty-getting-startedexport WECHATY_PUPPET= wechaty-puppet-service export WECHATY_PUPPET_SERVICE_TOKEN= puppet_padlocal_XXXXXX python examples/ding-dong-bot. py到此，恭喜你入坑。具体的使用可以查看python-wechaty-getting-started 参考:  如何成为 Wechaty Contributor 可以通过该链接查看 https://wechaty. js. org/docs/contributor-program/ . NET Wechaty 如何使用 PadLocal Puppet Service 特别感谢 @huan 的帮助。"
    }, {
    "id": 166,
    "url": "https://wechaty.js.org/2021/01/28/csharp-wechaty-for-padlocal-puppet-service/",
    "title": ".NET Wechaty如何使用PadLocal Puppet Service",
    "body": "2021/01/28 - . NET Wechaty 如何使用 PadLocal Puppet Service: PadLocal 介绍: 至于什么是PadLocal的详细介绍我这里就不累述了，把相关的文档贴在这里，大家可以去仔细的查看  New Wechaty Puppet Service: PadLocal wechaty-puppet-padlocal wechaty-puppet-padlocal-demo TOKEN 申请方法 或者在 Wechaty Contributors 群 @好大部署Wechaty Gateway:  WECHATY_PUPPET_PADLOCAL_TOKEN  是你的PadLocal token，前缀 puppet_padlocal_ 请勿去掉 WECHATY_TOKEN 可以随机生成一个GUID作为你GateWay的token，可以访问改地址随机生成：https://www. uuidgenerator. net/version4 WECHATY_PUPPET_SERVER_PORT 在设置端口前，请保证该端口没有被占用，如果是Linux系统，则可以通过 netstat  -anp  |grep 端口 命令检查该端口是否被占用# 设置环境变量export WECHATY_LOG= verbose export WECHATY_PUPPET= wechaty-puppet-padlocal export WECHATY_PUPPET_PADLOCAL_TOKEN= puppet_padlocal_XXX export WECHATY_PUPPET_SERVER_PORT= 9001 export WECHATY_TOKEN= 0c7b8f97-f3cc-40a5-a537-d492fd689801 # 运行dockerdocker run -ti \ --name wechaty_puppet_service_token_gateway \ --rm \ -e WECHATY_LOG \ -e WECHATY_PUPPET \ -e WECHATY_PUPPET_PADLOCAL_TOKEN \ -e WECHATY_PUPPET_SERVER_PORT \ -e WECHATY_TOKEN \ -p  $WECHATY_PUPPET_SERVER_PORT:$WECHATY_PUPPET_SERVER_PORT  \ wechaty/wechaty:0. 56 多语言Wechaty对接GateWay: 在对接Gateway的时候，这里需要注意下，如果GateWay的是部署在公网可以访问的服务器上，则我们可以直接设置 WECHATY_TOKEN 即可连接，如果是部署在自己内网服务器上，这里则需要指定自己服务器的 IP  和 Port ，其他的多语言版本也是类似，其他的地方就没有什么变动的。我这里以 . NET Wechaty 为例做个说明： // GateWay 部署在 dev. chatie. iovar PuppetOptions = new Module. Puppet. Schemas. PuppetOptions(){  Token =  0c7b8f97-f3cc-40a5-a537-d492fd689801 ,};// GateWay部署在自己的服务器上var PuppetOptions = new Module. Puppet. Schemas. PuppetOptions(){  Token =  0c7b8f97-f3cc-40a5-a537-d492fd689801 ,  Endpoint =  192. 168. 1. 100:9004 };info: Wechaty. Wechaty[0]   init puppet event bridgeinfo: Microsoft. Hosting. Lifetime[0]   Application started. Press Ctrl+C to shut down. info: Microsoft. Hosting. Lifetime[0]   Hosting environment: Productioninfo: Microsoft. Hosting. Lifetime[0]   Content root path: D:\coding\github\wechaty\dotnet\dotnet-wechaty\src\Wechaty. Getting. Start\bin\Debug\netcoreapp3. 1info: Wechaty. Module. Puppet. WechatyPuppet[0]   dateTime:2021-01-28 17:53:00 Login,PayLoad:{ contactId : xiaoxianxian } onGrpcStreamEvent(Login) info: Wechaty. Module. Puppet. WechatyPuppet[0]   dateTime:2021-01-28 17:53:04 Message,PayLoad:{ messageId : 379439903307716939 } onGrpcStreamEvent(Message) info: Wechaty. Module. Puppet. WechatyPuppet[0]   dateTime:2021-01-28 17:53:06 Message,PayLoad:{ messageId : 1921871762129872913 } onGrpcStreamEvent(Message) &lt;msg&gt;&lt;op id='11'&gt;&lt;name&gt;HandOffMaster&lt;/name&gt;&lt;arg&gt;&lt;handofflist opcode= 4  seq= 1528  deviceid= A1ce85b51b227c93  networkstatus= wifi &gt;    &lt;/handofflist&gt;&lt;/arg&gt;&lt;/op&gt;&lt;/msg&gt;. NET Wechaty Getting Start: 6行命令启动一个 . NET Wechaty 服务 var PuppetOptions = new PuppetOptions(){  Token =  0c7b8f97-f3cc-40a5-a537-d492fd689801 ,}; bot = new Wechaty. Wechaty(PuppetOptions); await bot. OnScan(WechatyScanEventListener)   . OnLogin(WechatyLoginEventListener)   . OnMessage(WechatyMessageEventListenerAsync)   . OnHeartbeat(WechatyHeartbeatEventListener)   . Start();具体的使用可以查看 dotnet-wechaty-getting-started  . NET Wechaty dotnet-wechaty-getting-started 之前我写过一篇博客介绍如何使用. NET Wechaty，大家可以通过这里了解如何使用dev. chatie. io 服务器申请:  Wechaty Contributor Server Host 是由微软 MVP Sponsorship 赞助的，只针对 Wechaty Contributor Program 的 Contributor 使用，具体的申请方式请查看 PMC-issue-13。 如何成为 Wechaty Contributor 可以通过该链接查看 https://wechaty. js. org/docs/contributor-program/Blogs:  Introducing Wechaty Puppet Service (Providers), @huan, Jan 14, 2021"
    }, {
    "id": 167,
    "url": "https://wechaty.js.org/2021/01/26/wechaty-charbot-lite/",
    "title": "基于Wechaty实现运维自动化交互及微信消息通知",
    "body": "2021/01/26 - 如今运维人员都在强调自动化，降低运维成本。尽管现在搭建一套运维自动化体系架构并不难，然后有些工作还是必须需要运维手动工作，比如上线动作（上线的过程自动化，但是操作点由谁来操作，比如jenkins上谁去点击构建），或者开发找dba执行sql等日常操作，这些暂时都必须人为手动操作。次数多了，难免会想这些怎么去实现自动化，无需人为干预！针对这些运维痛点，目前已实现qq机器人实现上述自动化操作。其背后的逻辑是，当@机器人后，机器人自动往运维平台接口post数据，在运维平台接口里解析指令并处理相关逻辑，最终返回给用户。 为了实现在微信上实现同等功能，便开始在github上寻找微信机器人，直到看到Wechaty解决方案，它是适用于微信个人及企业微信的BotSDK，提供微信机器人完美解决方案。 Wechaty: Wechaty 是适用于微信个人帐户的Bot SDK，可以帮助您创建6行JavaScript的机器人，并具有包括Linux，Windows，Darwin（OSX / Mac）和Docker在内的跨平台支持。  Powered by Wechaty Wechaty开源激励计划全球最短的ChatBot代码：6行JavaScript: import { Wechaty } from 'wechaty'Wechaty. instance() . on('scan', (qrcode, status) =&gt; console. log(`Scan QR Code to login: ${status}\nhttps://api. qrserver. com/v1/create-qr-code/?data=${encodeURIComponent(qrcode )}`)) . on('login',      user =&gt; console. log(`User ${user} logined`)) . on('message',    message =&gt; console. log(`Message: ${message}`)) . start()使用Wechaty实现:  接收微信好友及微信群信息，并post给运维接口对指令集做逻辑处理     提供外部访问Wechaty接口，方便外面调用，如外部通过http请求给微信群或个人发信息         发送文本： curl http://xxx:3000/send_group_msg?type=text&amp;group_name=test&amp;message=test     发送图片： curl http://xxx:3000/send_group_msg?type=media&amp;group_name=test&amp;message=test&amp;url=www. xxx. com/xx. png          运行起来:    安装Node. js:   node官网：https://nodejs. org/zh-cn/Wechaty 要求Node. js版本10或以上，本环境使用的版本是nodev16. 20. 0 npm6. 14. 8。     运行Wechaty:   先来安装一下 cd wechaty-charbot &amp;&amp; npm install   没有问题就可以运行Wechaty了   在config/index. js下修改官方提供的token  执行 node index. js 当您看到输出 在Wechaty服务上监听 3000 端口. . . 就是成功运行了～ 您需要知道的事情: 请勿使用此项目做违反微信团队相关规定或违法事情。尽量使用延时函数，防止被检测出类似机器人行为操作导致被微信团队禁止登录Web版本风险，因此您需要承担使用不当导致被禁止登录的风险，均与作者无关。 最后: 此项目开源仅供技术产品交流。对于开发者来说Wechaty是个很棒的产品，感谢Wechaty作者提供该解决方案。  Author: @zhoujian1028Code: @zhoujian1028/wechaty-charbot "
    }, {
    "id": 168,
    "url": "https://wechaty.js.org/2021/01/25/wechaty-0.56-released/",
    "title": "Wechaty 0.56 Released!",
    "body": "2021/01/25 - V0. 56 is the latest stable version of Wechaty, it is recommended to be upgraded for all developers. npm install wechaty@0. 56v0. 56 (2021-01-25): Full Changelog Highlights for v0. 56: 1. New Wechaty Puppet Services:  Published Wechaty Puppet Service Published Wechaty Puppet Service: PadLocal Published Wechaty Puppet Service: WxWork Published Wechaty Puppet Service: Paimon Published Wechaty Puppet Service: Donut2. New Wechaty Puppets:  Published Puppet: Official-Account Published Puppet: Gitter. im Published Puppet: Lark Published Puppet: Whatsapp3. New Wechaty Languages:  Published Python Wechaty Published Go Wechaty Published Java Wechaty Published . NET Wechaty Published PHP Wechaty Published Scala WechatyImplemented enhancements:  Switch from wechaty-puppet-hostie to wechaty-puppet-service #2122 Add wechaty-puppet-padlocal to our puppet config #2102 Use message. talker\(\) to replace message. from\(\) #2094 Create a looseInstanceOfClass to check FileBox and Puppet instances #2090 Issue with batch operation on room loading process #2068 Support more properties on contact #2036 Refactoring Multi-instance Wechaty Design: Try to remove the Accessory class and related codes #2027 Use Typed-Emitter in Wechaty #2014 Support WECHATY_HOSTIE_PORT environment variable #1984 Wechaty v0. 23 PadPro Testing, an enhanced pad puppet implementation! #1668 Using wechaty to start a wechatOA account #1016Fixed bugs:  FileBox instance type checking problem #2035 Wechaty. off() not work: can not remove listeners. #2019 friendship. contact() will load Contact only, contact. ready() is wanted. #1954Closed issues:  不能登录，也没显示二维码就直接退出 #2099 Can’t login after scan the qrcode #2092 网络不好程序自动重启后推送异常 #2088 Message. forward() does not support returning a message #2073 bot. Friendship. add() 总是报错 #2060 在使用FileBox 发送视频时候出现问题 #2059 The AWS Access Key Id you provided does not exist in our records. #2058 When setting up hostie token gateway, Account was locked after 5 getContactInfo call within a second. #2040 Support phone related operations #2037 BREAKING CHANGES: remove hotImport support from wechaty #1997 ERR GRPC_GATEWAY GRPC SERVER ERROR #1996 微信安装 #1990 Cannot read property ‘QQ’ of undefined #1982 Need upgrade wechaty-puppet@0. 25. 7 version for wechaty #1980 The qrcode all the time timeout #1977 Upgrade wechaty-puppet-hostie@0. 7. 10 for fix the bug of friendship. accpet() #1966 23:42:53 SILL GrpcGateway callback type:【invalid-token】 #1959 准备支持企业微信群吗 #1958 node-pre-gyp WARN #1953 How to filter official account numbers #1951 Update wechaty-puppet-hostie version for wechaty #1948 Is that you? #1942 ipad WeChat login will automatically log out, The returned QR code is invalid, you cannot log in again, you must restart #1940 New version release notes for wechaty 0. 38 #1937 Can the receive the recall “ room-leave”. #1745 Refactor message. ts file to fit the requirement in CodeClimate #1663 Want to get information about sent-out message #1501Merged pull requests:  rename wechaty-puppet-hostie -&gt; wechaty-puppet-service #2124 (huan) Update README. md #2118 (lijiarui) Update room-invitation. ts #2104 (profthecopyright) Update contact. ts #2095 (su-chang) create looseInstanceOfClass (#2090) #2091 (huan) Update Dockerfile #2079 (yesxin) Bump minor 49 #2078 (windmemory) fix #2073 #2074 (windmemory) Split to trunks when making requests of room. findAll() and room. ready() #2067 (windmemory) bump hostie version to be the stable one #2051 (windmemory) 0. 48. 0 #2050 (windmemory) feat: add more methods into contact class #2048 (windmemory) feat: add scoped wxwork puppet into puppet config #2043 (windmemory) add phone method in contact class #2039 (windmemory) remove Accessories by wechatify user classes #2028 (huan)Join us:  Join our community discussion on Gitter: https://gitter. im/wechaty/wechaty Read our blog posts: https://wechaty. js. org/blog Getting started with Wechaty now: https://github. com/wechaty/wechaty-getting-started Interested in working with us? Join our team!"
    }, {
    "id": 169,
    "url": "https://wechaty.js.org/2021/01/20/chatbot-conversational-user-interface/",
    "title": "Huan: 介绍对话机器人（Chatbot）与对话式用户交互界面（CUI）",
    "body": "2021/01/20 - Wechaty 是一个为对话式用户交互界面提供接口服务的 SDK，通过 RPA 技术，为 Chatbot 开发者提供便利的即时通讯平台接入服务，打造更加优秀的 Conversational AI 对话机器人。 为什么我们要做 Chatbot ，我们经常提起的 Chatbot 等名词究竟是什么，它们有哪些优势？本文希望可以简明扼要的介绍清楚：  什么是对话机器人（Chatbot） 什么是对话式用户交互界面（Conversational User Interface, CUI） Chatbot 能做什么 什么是 Conversational AI (CAI) CUI 与即时通讯平台（Instant Messaging, IM）什么是对话机器人（Chatbot）: Chatbot 是一个有能力与用户通过自然语言进行交谈的软件。 一般 Chatbot 都会运行在现有的即时消息软件平台上，比如 Slack、微信、钉钉。它也可以直接嵌入在独立网站或者移动手机 APP 中。 什么是对话式用户交互界面（Conversational User Interface, CUI）: 对话式用户交互界面（Conversational User Interface, CUI）与以前使用按钮、输入框和滚动条的图形界面（Graphical User Interface, GUI）类似，但是 CUI 是通过模拟人类说话来与用户进行交互。 比如，网站是图形界面，也就是说主要的用户界面是按钮，图片，滚动条等。与之对比，Chatbot 是一个对话界面，它的主要用户界面是用户和软件之间的对话。 现在 CUI 非常常见，你很可能已经使用过CUI了。比如如果你用 iPhone，那么应该接触过 Siri；如果你经常在线购物，那么你应该在淘宝上被小二机器人服务过。 所有的这些服务都是基于对话为中心进行设计的。设计对话的目标是让人与计算机之间的协作变得简单。区别于使用传统的计算机语言，对话机器人能够让用户通过与计算机进行像与其他人一样的“交谈”来完成任务。 Chatbot 能做什么: Chatbot 能够应用在很多日常任务中。比如查天气，完成在线的订单；可以推广和销售产品、提升用户活跃度；也可以帮助你为客户提供实时的问题回答，提升用户体验等。 对话机器人可以降低人员成本，提升客户服务质量。和人工坐席相比，它最大的优势是可以永远实时回复，并且可以同时回复很多人。 开发者可以 Chatbot 开发公司现有员工岗位的能力。想象一下 Chatbot 作为团队一员，能够每天24小时，每周7天不间断的工作，还不用领工资；它还可以被打造成为一个全面手，同时作为销售员、市场专员、客户服务坐席，一人独挡一面，为客户提供一站式全方位的支持。 什么是 Conversational AI (CAI): 对话式交互是计算机从文本命令到图形界面之后，随着人工智能能力的不断增强，计算机软件系统下一代的人机交互界面。为对话式用户交互界面提供的 AI 能力，就是 Conversational AI (CAI)。 人工智能的发展是近些年来对话机器人能够越来越强大的基础原动力。近些年的世界变化表明，这些智能技术它们所不断学习和进步的速度，远远超越了我们人类。 CUI 与即时通讯平台（Instant Messaging, IM）: 对话式用户交互界面(CUI)也需要适配各种平台，就像现有的响应式网页设计（Responsive Web Design）界面需要适配不同的屏幕分辨率和兼容电脑鼠标和手机触屏一样。 CUI 基于不同的平台，你的 Chatbot 需要适应不同平台之间的不同特点。换言之，你需要确保你的用户在不同的设备和平台上访问你的对话机器人时，能够得到一致的体验。目前，最流行的对话平台包括：微信、Whatsapp、Slack、钉钉、飞书等。 写在最后: Chatbot 是一个蕴含着巨大机会的新领域。今天的 Chatbot，就好像是 1996 年的网页。 Google，Microsoft，Facebook，Amazon，和 Apple 这些大公司已经发现了 CUI 可以作为未来拓展用户的重要途径。这种基于自然语言的 Chatbot 可能很快替代大量的 APPs ，使用户可以直接通过语言来和他们喜欢的数字服务进行交互。理解对话式用户交互界面（CUI）是理解未来科技发展的重要一步。 Chatbot 现在不断在迭代升级，对各种商业场景的未来都会产生巨大影响。你绝不应该错过这个绝佳的机会，今天就尽快建立一个属于你自己的 Chatbot 并通过它实现与你的客户的自然语言沟通，提升用户体验把！  Teaser image credit: What Is a Chatbot? The Full Guide to Chatbots in 2020 "
    }, {
    "id": 170,
    "url": "https://wechaty.js.org/2021/01/19/wechaty-api-restful/",
    "title": "Wechaty restful api",
    "body": "2021/01/19 - This article will explain why I started to use wechaty, made the restful api wrapping the bot and what I would do as the next step. 1. Why I started to use wechaty: wechat individual bot has been decommissioned since 2019. The wechat web reject the login using QRCode. To continue to use the bot, I tried a lot of ways and finally find the alternative — wechaty(The solution wechat enterprise provided )https://wechaty. js. org/docs/api/message 2. How to use wechaty for bot: There are only three steps to make one simplest bot. 2. 1 Install enterprise wechat in the smart phone: 2. 2 Apply one 15-days trial token from wechaty: Please refer to this page to get the token https://github. com/wechaty/wechaty 2. 3 Write the test code as below: Now you can send first message through bot to one account or group. Please refer to the repository https://github. com/luyomo/wechaty-api 3. Prepare restful api for wechaty robot: Because I am not so familiar with the nodejs and want to use other languages to implement all kinds of services, I decided to make one API service to wrap the robot. I chose the Koa2 as the api module to publish bot and implemented the below APIs. 3. 1 Publish mode: 3. 1. 1 send chat to human: curl -X POST -H ‘Content-Type: application/json’ [Context: “http://127. 0. 0. 1:3000/contact/contactName”] — data ‘{“data”:”Hello world. I am bot”}’ 3. 1. 2 send chat to room: curl -X POST -H ‘Content-Type: application/json’ [Context: “http://127. 0. 0. 1:3000/room/roomName”] — data ‘{“data”:”Hello world. I am bot”}’ 3. 1. 3 send chat to group(map the chinese to english group name): curl -X POST -H ‘Content-Type: application/json’ [Context: “http://127. 0. 0. 1:3000/group/groupName”] — data ‘{“data”:”Hello world. I am bot”}’ The reason I added this group because the curl does not support the Chinese language. So use the maps to resolve it. 3. 2 interactive mode: Last is to make bot to reply: Now only prepare the ping to show whether the bot service is active or not. 4 First service — Temperature forecast: Extract the temperature info from api. openweathermap. org and send to my wechat regularly. This only saved my time to browse the web every morning. 5. Next to do: 5. 1 Redirect the line message to wechat: This is my wife’s request. She always missed important messages from line since she use wechat mostly. She wants the bot to help her. 5. 2 Use gmail api to send message if the email meets some conditions. (From or Subject): "
    }, {
    "id": 171,
    "url": "https://wechaty.js.org/2021/01/15/carpool-bot-with-wechaty-1/",
    "title": "基于wechaty的拼车小程序（1）",
    "body": "2021/01/15 - 产品构想: 我的初步想法是：  微信小程序为前端，用户可以在小程序上浏览其他用户发布的拼车信息（出发地、到达地、时间等等） 在用户通过小程序发起「加入拼车」的请求后，我们需要做的事情概括起来就是：将「发起者」与「参与者」联系到一起 实现「发起者」与「参与者」联系到一起有许多方式：     将发起拼车的用户的WechatId发送给新用户   将两个用户拉到一个群聊里   做一个留言系统或者IM系统让两个用户进行对话    综合考虑来看，将多个用户拉到一个群聊里将是最简洁的方案     群聊即用即删，用户可以随时退出群聊，避免骚扰。    而微信小程序因为微信本身的政策原因，是不允许「发布二维码」、「拉入群聊」等操作的，因此需要WechatBot来助一臂之力。     PS：目前市面现有的拼车小程序基于公众号来实现，需要用户关注指定公众号并发送暗号获得入群链接，同时他们以此盈利。   如何使用wechaty来构造bot:    对需求进行拆解，初步阶段的需求大概如下：      当「发起人」发起一个拼车时，Bot能与「发起人」创建一个群聊，并将「拼车信息」与「群聊ID」进行持久化存储。   当「参与人」参与拼车时，Bot能将「参与人」根据「群聊ID」拉入同一个群聊。      大致使用到的wechaty API如下：      contact. find通过wechatId查找用户   room. create创建群聊   room. invite拉人进群      Bot部分代码如下：    public async CreateRoomById(id: string, topic: string): Promise&lt;Room&gt; {  const contact = await this. bot. Contact. find({ id: id });  if (contact == null) {   throw new Error(`cant find user by id, id=${id}`);  }  id = helper_id;  const helper = await this. bot. Contact. find({ id: id });  if (helper == null) {   throw new Error(`cant find user by id, id=${id}`);  }  const contactList = [contact, helper];  const room = await this. bot. Room. create(contactList, topic);  console. log( createDingRoom() new ding room created:  , room);  return room; } public async InviteToRoom(userId: string, roomId: string) {  const contact = await this. bot. Contact. find({ id: userId });  if (contact == null) {   throw new Error(`cant find user by id, id=${userId}`);  }  const room = await this. bot. Room. find({ id: roomId });  if (room == null) {   throw new Error(`cant find room by id, id=${roomId}`);  }  try {   await room. add(contact);  } catch (e) {   console. error(e);  } }      使用express框架来搭建简易web服务器，对外提供借口   const app: express. Application = express();// create room by userIdapp. post( /room/create , async (req, res) =&gt; { let id: string = req. query. id as string; let topic: string = req. query. topic as string; let resp: any = {}; try {  const room = await bot. CreateRoomById(id, topic);  resp. id = room. id; } catch (e) {  console. log( Error , e); } res. send(new Resp(ERROR_CODE. Success, ERROR_MSG. Success, resp));});// invite someone to a roomapp. post( /room/invite , async (req, res) =&gt; { let userId: string = req. query. userId as string; let roomId: string = req. query. roomId as string; try {  const room = await bot. InviteToRoom(userId, roomId); } catch (e) {  console. log( Error , e); } res. send(new Resp(ERROR_CODE. Success, ERROR_MSG. Success, null));});   后端服务: 另外需要一个后端服务，主要支持以下功能：  接受前端（小程序端）发送的用户请求。 将Bot处理好的「拼车信息」、「群聊ID」绑定在一起，存储到数据库里。 向前端（小程序端）返回全部的拼车信息，供用户选择。 将用户填写的wechatId与小程序的openId进行绑定，存储到数据库，使用户不必每次都填写。开发截图:    小程序前端开发尚未完成，比较粗糙。     用户填写WechatId的界面。（因小程序不提供用户wechatId，需要用户手动填写）       用户发布拼车与加入拼车的界面：       用户进行「加入群聊」后，Bot将用户拉入群聊（bot视角）：    项目相关:    项目代码文件放在：github     后续的TODO：          完善小程序前端。          支持进度条显示「当前时间」距离「结束拼车时间」的长短              拼车信息支持显示「人数」与「总人数」           添加Bot在群内可供用户进行交互的操作          /close 结束拼车     /update 刷新群聊人数     ……etc              支持当用户发起「加入」时却未添加Bot未好友时，Bot能主动发起「好友请求」        作者: JellyCode: Github "
    }, {
    "id": 172,
    "url": "https://wechaty.js.org/2021/01/14/wechaty-puppet-service/",
    "title": "Introducing Wechaty Puppet Service (Providers)",
    "body": "2021/01/14 - Wechaty is an SDK for chatbot makers. It uses Robotic Progress Automation (RPA) technology to help developers to be more productive for building Conversational User Interface (CUI), which we call it a Chatbot. Wechaty Puppet: For different instant messaging (IM) systems (such as WeChat, Whatsapp, and TikTok), the Wechaty community builds separate RPA modules for each, and we call those modules Wechaty Puppet. Wechaty Puppet is the core concept in the Wechaty ecosystem, which is in charge of connecting the Wechaty API to the underlying IM Platform bot account. Wechaty Puppet Abstract: Wechaty Puppet is a standard for maintaining compatibility between IM systems. Wechaty Puppet defines the universal IM interface for compatibility with Wechaty API to variants of IM systems. Wechaty Puppet Provider: Different IM systems need different Wechaty Puppets, and they have different names and all implementing the Wechaty Puppet API, we call them the Wechaty Puppet Provider. For example, the Wechaty Puppet Provider who is supporting WeChat is named wechaty-puppet-wechat, supporting Whatsapp is named wechaty-puppet-whatsapp, and supporting Lark is named wechaty-puppet-lark. When we published Wechaty in May 2016, we were using WebDriver/Puppeteer(wechaty-puppet-wechat) and wechaty-puppet-wechat4u to hook to the Web WeChat code. Still, later the Web Protocol has been deprecated, and we have to find other ways to get the job done. Beyonds the Web Protocol, the community have tried many technologies in the past years, such as:  Windows Hook     WxWork   Donut    Pad Protocol     PadLocal   PadChat (deprecated)   PadPro (deprecated)   PadPlus (deprecated)    Mac Hook     macOS (under construction)   MacPro (deprecated)    App Hook: IosBird (deprecated)To learn about all Wechaty Puppet Providers, you can go to our Wechaty Puppet Directory Using Wechaty Puppet Providers: Let’s see a code example (in TypeScript) of how to change Wechaty Puppet Providers. We have the following six lines code, which is the world’s shortest chatbot: // bot. tsimport { Wechaty } from 'wechaty'Wechaty. instance() // Global Instance. on('scan', (qrcode, status) =&gt; console. log(`Scan QR Code to login: ${status}\nhttps://wechaty. js. org/qrcode/${encodeURIComponent(qrcode)}`)). on('login',      user =&gt; console. log(`User ${user} logged in`)). on('message',    message =&gt; console. log(`Message: ${message}`)). start()The above code will use the default Wechaty Puppet Provider (which is wechaty-puppet-wechat) because we have not specified manually. If we want this bot to serve on Whatsapp, we need to specify a Wechaty Puppet Provider for Whatsapp. We have two methods to specify Wechaty Puppet Providers for our program:  Using the WECHATY_PUPPET environment variable Import the Wechaty Puppet manually in code1. Using the WECHATY_PUPPET environment variable: The WECHATY_PUPPET environment will be used as the Wechaty Puppet Provider NPM name, and then you are all set. export WECHATY_PUPPET=wechaty-puppet-whatsappts-node bot. tsThe above shell commands set the wechaty-puppet-whatsapp to the environment variable WECHATY_PUPPET and our Wechaty system will use it. 2. Import the Wechaty Puppet manually in code: On the other hand, you can import the Wechaty Puppet Provider NPM module directly in your code and then add an option when instantiating the Wechaty with the object name puppet: // bot. tsimport { Wechaty } from 'wechaty'+ import { PuppetWhatsapp } from 'wechaty-puppet-whatsapp'- Wechaty. instance() // Global Instance+ Wechaty. instance({ puppet: new PuppetWhatsapp() }). on('scan', (qrcode, status) =&gt; console. log(`Scan QR Code to login: ${status}\nhttps://wechaty. js. org/qrcode/${encodeURIComponent(qrcode)}`)). on('login',      user =&gt; console. log(`User ${user} logged in`)). on('message',    message =&gt; console. log(`Message: ${message}`)). start()The above code can be self-explained: the Wechaty will use PuppetWhatsapp from the wechaty-puppet-whatsapp module. Build Polyglot(Multi-language) Wechaty with the TypeScript Ecosystem: Wechaty, Wechaty Puppet, and Wechaty Puppet Providers are all written in TypeScript (before 2020). We are pleased with TypeScript because it’s robust, scalable, and portable. In 2020, we started to build Wechaty in many other languages, like Python, Go, Java, PHP, . NET, Scala, etc. Wechaty community started to translate Wechaty from TypeScript to those languages (Issue #1927), and the plan was going very smoothly. Polyglot Wechaty has been published, and almost all developers from all programming languages are happy with Wechaty by developing using their favorite language now. However, as we mentioned, all the Wechaty ecosystems are build on top of TypeScript, especially all the Wechaty Puppets. How can we reuse them in Polyglot Wechaty? Our goal is to reuse all the TypeScript ecosystems with the Polyglot Wechaty. But how? RPC for Rescue: The key to using the TypeScript ecosystem in other languages is to cloudify the Wechaty Puppet API. As we mentioned before:  Wechaty Puppet is a standard for maintaining compatibility between IM systems. Wechaty Puppet defines the universal IM interface for compatibility with Wechaty API to variants of IM systems. Wechaty is built on top of the Wechaty Puppet API. If we can use the Wechaty Puppet Providers remotely via network, then Polyglot Wechaty will be able to use the Wechaty Puppet API from the TypeScript ecosystem. How can we use a Wechaty Puppet Provider remotely via network? The answer is that we can convert it to Remote Procedure Call (RPC). The goal of Wechaty RPC is to cloudify our Wechaty Puppet Providers. A Wechaty Puppet Provider, like PadLocal, is written in TypeScript and can only be used in TypeScript program locally. With RPC, we can design our Wechaty Ecosystem Architecture as the following diagram:  +-------------------------------------------------------+ |            Wechaty            | |                            | |         TypeScript/JavaScript         | |     Python, Go, Java, . NET, PHP, Scala      | +-------------------------------------------------------+ +-------------------------------------------------------+ |        Wechaty Puppet Abstract        | |                            | |        (wechaty-puppet-service)        | +-------------------------------------------------------+  +--------------------+ gRPC +---------------------++-----------------------------------------------------------+|         Wechaty Puppet Service          ||            (Provider)             ||    &lt;https://wechaty. js. org/docs/puppet-services&gt;    |+-----------------------------------------------------------+ +-------------------------------------------------------+ |         Wechaty Puppet Abstract        | +-------------------------------------------------------+ +--------------------------+ +--------------------------+ |    Pad Protocol:   | |    Web Protocol:   | | wechaty-puppet-padlocal | | wechaty-puppet-wechat | +--------------------------+ +--------------------------+ +--------------------------+ +--------------------------+ |   Windows Protocol:  | |    Mac Protocol:   | | wechaty-puppet-wxwork  | | wechaty-puppet-macpro  | +--------------------------+ +--------------------------+Google Remote Procedure Call (gRPC): Google Remote Procedure Call (gRPC) is a modern open source high performance RPC framework that can run in any environment. Currently, gRPC provides support for many languages like Node. js, Python, Golang, . NET, C++, Java, etc. It is very easy to generate the gRPC client and server interfaces from . proto service definition by using protocol buffer compiler protoc with a special gRPC polyglot plugin to generate gRPC services in all supported languages. In Feb 2020, we finished the Wechaty gRPC service abstracting module with the wechaty-puppet-service implementation. Wechaty gRPC is always auto-generating gRPC client from our wechaty. proto service defination, and publish them as multi-language modules. Learn more about how it works of our DevOps pipeline by reading our GitHub Action Workflows. Wechaty Puppet Service: Wechaty Puppet Service is gRPC for Wechaty Puppet Provider. For example, we can cloudify the Wechaty Puppet Provider wechaty-puppet-padlocal to a Wechaty Puppet Service by running our Wechaty Puppet Service Token Gateway. Using Wechaty Puppet Service Token Gateway to Setup Wechaty Puppet Service: Wechaty Puppet Service Token Gateway is a gateway for converting the Wechaty Puppet Provider to a Wechaty Puppet Service. Here’s an example for setup a Wechaty Puppet Service for the PadLocal Puppet Provider. 1. WECHATY_PUPPET: Define the underlying Wechaty Puppet Provider and its parameters: export WECHATY_PUPPET='wechaty-puppet-padlocal'export WECHATY_PUPPET_PADLOCAL_TOKEN='puppet_padlocal_xxx' Note: you can using any Wechaty Puppet at here, like wechaty-puppet-wechat, wechaty-puppet-whatsapp, and any others we mentioned earlier. 2. WECHATY_TOKEN: Generate a new UUIDv4 as your Wechaty Puppet Service Token. Your new token MUST different to any existing tokens in our system. (or they will conflict) export WECHATY_TOKEN='2fdb00a5-5c31-4018-84ac-c64e5f995057'3. WECHATY_PUPPET_SERVER_PORT: Specify a free port for the Wechaty Puppet Service (it will also be used for the docker port mapping) export WECHATY_PUPPET_SERVER_PORT=8788 // any available port can be visited from internet4. WECHATY_LOG: Set log to verbose to get more debug log messages. export WECHATY_LOG= verbose 5. Start Wechaty Puppet Servcie Token Gateway: At last, everything we need has been packaged to the docker image wechaty/wechaty. All you need is to use a docker command to start your Wechaty Puppet Service Token Gateway with the above configuration: docker run -ti --rm \ \ -e WECHATY_PUPPET \ -e WECHATY_PUPPET_PADLOCAL_TOKEN \ \ -e WECHATY_TOKEN \ -e WECHATY_PUPPET_SERVER_PORT \ \ -e WECHATY_LOG \ \ -p  $WECHATY_PUPPET_SERVER_PORT:$WECHATY_PUPPET_SERVER_PORT” \ wechaty/wechaty:0. 56You can see lots of the output log messages in your terminal with the above command. Then you can confirm your Wechaty Puppet Service is online by visiting: curl https://api. chatie. io/v0/hosties/${WECHATY_TOKEN} Replace ${WECHATY_TOKEN} to your real token in the above configuration ✅ If you get an HTTP/200 response with a JSON object body that includes your ip and port, then you are all set. ❌ If you get an HTTP/404 response, your Puppet Service Gateway has some issues and needs to be troubleshooting. Using Wechaty Puppet Service with Wechaty: Using Wechaty Puppet Service is very easy. Just set the WECHATY_PUPPET to wechaty-puppet-service and WECHATY_PUPPET_SERVICE_TOKEN to your Wechaty Puppet Service Token. export WECHATY_PUPPET=wechaty-puppet-serviceexport WECHATY_PUPPET_SERVICE_TOKEN=${WECHATY_PUPPET_SERVICE_TOKEN}ts-node bot. tsYou may have a question of what is the value of WECHATY_PUPPET_SERVICE_TOKEN? The answer is that the value should be the WECHATY_TOKEN when you set up your Wechaty Puppet Service Gateway in the previous step. Ready-to-use Wechaty Puppet Services: With the power of Wechaty Puppet Service Token Gateway, we can convert any Wechaty Puppet Provider to Wechaty Puppet Service by yourself. However, it would be lots of reasons that you need a ready-to-use Wechaty Puppet Service:  You are a Polyglot Wechaty developer, but you do not want to run another docker container in your system.  You are a TpyeScript Wechaty developer, but the Wechaty Puppet Provider needs a complicated system setup, like an X11 System, Wine, or Android Emulator.  etc. And there has another scenario for the Wechaty Puppet Provider is closed source, which means you will not be able to install it, but only can use it as a Wechaty Puppet Service. Introducing Wechaty Puppet Service Provider: Our Wechaty Community now has serval Wechaty Puppet Services which works out-of-the-box. All you need is to get a Wechaty Puppet Service Token, then use wechaty-puppet-service with that token. For now, the Wechaty community has four official Wechaty Puppet Services:  WXWork: WeCom Windows Protocol PadLocal: WeChat Pad Protocol Paimon: WeChat Pad Protocol Donut: WeChat Windows ProtocolMore Puppet Service Providers are welcomed, please learn more from https://github. com/wechaty/puppet-services and feel free to contact us by joining our Gitter network if you aren’t already a member. Learn more about all the Wechaty Puppet Services at our official website: https://wechaty. js. org/docs/puppet-services/ Summary: In this post, we clarified the following core concepts of Wechaty:  Wechaty Puppet Wechaty Puppet Abstract Wechaty Puppet Provider Wechaty gRPC Wechaty Puppet Service Wechaty Puppet Service Token Wechaty Puppet Service ProviderI hope it can help our developer to understand Wechaty ecosystem better. The Wechaty Puppet Core repo is here and gRPC repo is there. Interested in RPA, building chatbots &amp; providing service for developers? Join the Wechaty community on Gitter! And, We are hiring! Appendix: The following topics on GitHub was created when we were building the Wechaty Puppet Service ecosystem. Please feel free to read them and join the discussion by commenting those issues/discussions.  Deprecated Announcement: Padplus service will end on Dec 1st, 2020 #11 go-wechaty implementation wechaty-puppet-service discussion. #22 How to create your own Wechaty Servie Token with the Web Protocol #1986 MemoryCard support: required for stateless puppet service #16 Puppet Service Specifications #54 Support rock puppet service provider. #98 the relationship between hostie, grpc, and puppet. #1947 Using your Puppet PadPlus token with Python, Java, and Go Wechaty #1985 Wechaty is All You Need: Python, Go, and Java Translation Project #1927 Wechaty Puppet Service Provider FAQ #1 Wechaty Puppet Service Registration &amp; Discovery (w. r. t. token) #39 Wechaty Workshop for Puppet Makers: How to Make a Puppet for Wechaty Support GRPC in Go #50"
    }, {
    "id": 173,
    "url": "https://wechaty.js.org/2021/01/04/summer-2020-summit-okr/",
    "title": "A OKR Review for the Summer 2020 Summit",
    "body": "2021/01/04 - In Nov 14, 2020, The Open Source Promotion Plan - Summer 2020 Summit was held in Nanjing (thanks ISCAS &amp; openEuler Community for the organizing!). As an open-source organization we enjoyed this program and we have four people: @univerone, @wj-Mcat, @rickyyin98, and @huan attended the Summit. Before the travel to Nanjing, in order to make the goal clear, we have a meeting about how to improve the efforts we can influence in this summit, which leads us to consider to use the OKR (Objective and Key Results) to make everyone understand what we should deliver at the summit. What is OKR:  Objectives and key results (OKR) is a goal-setting framework for defining and tracking objectives and their outcomes.  — Wikipedia  An OKR consists of an Objective, which tells you where to go, and several Key Results, which are the results you need to achieve to get to your Objective. Initiatives are all the projects and tasks that will help you achieve your Key Results.  — The ultimate OKR guide The following points about the Key Result are copy/pasted from our previous discussion from our AI-ML. Club: BUPT/magic-mirror - OKR管理项目的方式探讨 #17 What is Key Result: The Key Result needs to be an outcome(what we get) instead of output(what we do). At the same time, we have to make sure KRs are value-based, measurable with metrics, and most importantly, should be short.  Measurable: Key results are measurable and should be easy to grade with a number (Google uses a scale of 0 – 1. 0) Short: as short as possible Value-basedFor an Objective update example, in 1958 NASA had 8 goals including examples like:  “The establishment of long-range studies of the potential benefits to be gained from, the opportunities for, and the problems involved in the utilization of aeronautical and space activities for peaceful and scientific purposes. ” By 1961, thanks to Kennedy, NASA had one Ultimate goal:  “Before the decade is out, land a man on the moon and return him safely to earth”. A short goal will make it easy to be understood, so we should always prevent long descriptions. Measurable: Almost anything can be measured. If you’re struggling to find Key Results for an Objective, ask yourself “How will I know when my Objective has been achieved?”. Make sure to choose Key Results that are outcome based, look for metrics you don’t directly own or control, but that you can influence. What is Initiative (To-do list): When we are planning to do something, we are very likely to define a list of todos, because we can control it very easily, like  I will write 3 blogs this week. However, the above description will miss the direction of why we need to do that, and what we want to get an outcome of that action. So we need to move into the high level of a todo description, defines what we want to get as a result of our actions:  I will get my new blogs read by 1,000 chatbot developers. The above result will not be able to be controlled by ourselves, but we can only influence it, which means we have to write a better blog so that the readers will share it, and we have to think about how to spread the blog article to cover the target users (chatbot developers in this case). So, I believe the reason the Padoo introduce the initiative concept to OKRs is that everyone wants to have a TODO list for their OKRs, which could make them more comfortable. And they always want to put a TODO list as the Key Results, which is not right and needs to be clarified. Key Result v. s. Initiative: The most important when we are using OKRs is that we have to make sure that we are listing the real Key Results instead of Initiatives as our Key Results. According to What is an OKR?: 1. Key Result:  “How do I know if I’m getting there?” A Key Result shows you how you’re progressing towards your Objective. Think of it as a signpost with a distance marker.  A Key Result is a metric with a starting value and a target value that measures progress towards an Objective. 2. Initiative:  “What will I do to get there?” An Initiative describes what you’ll do to influence your Key Results. Think of it as the description of what you’ll do to get to your destination.  An Initiative is a description of the work you’ll do to influence a Key Result. In short, a Key Result is “What you can get(outcome)”, and the Initiative is “What you can do(output)”.       Difference   Outcome V. S. Output   Influence V. S. Control   Value V. S. Activity         Key Result   What you can GET (outcome)   You cannot control it, you can only INFLUENCE it   Value-based       Initiative   What you can DO (output)   You can CONTROL it directly   Activity-based   At last, Key Results must be measurable. Wechaty OKRs: The following OKR discussion is copy/pasted from wechaty/summer-of-code - Wechaty Open Source Software Supply Chain 2020 Najing Summit OKR Review #26 In this open-source summit, we have the following Ultimate Objectives and Key Results: Ultimate Objectives:  Make Wechaty to be known as one of the best open-source projects in China Make more people get to know what problem that Wechaty can solve.      Wechaty is a RPA SDK for Chatbot Makers that supports connecting to WeChat, DingTalk, Lark, WhatsApp, Teams, and Gitter and it can build a chatbot in 6 lines of code in almost any language.    Ultimate Key Results:  100+ influences on-site 500+ new developers join our community:     Wechaty Developers’ Home WeChat room, Gitter, Stars on GitHub     6 blog posts with video embedded form the event with 3,000+ influences A Standard of Process (SOP) for promoting Wechaty in events in the future     Check-list, Resources, Scripts    Team OKR: 1. OKR: @wj-Mcat: Objectives:  Tell a story that how do I start python-wechaty open-source project and make it attractive Give a live-coding process that can invite developers into Wechat Group and play with one/two games. Key Results:  Make a presentation that influence 30+ developers on-site Write a blog post for the representation that gets 100+ reads from chatbot developers.  Build a Wechat Group at the beginning of the presentation to include 30+ audiences in the rooms. 2. OKR: @univerone: Objectives:  Make Wechaty draw the most attention among all the projects. Key Results:  Collect videos(Captured by Dji and Talk videos), Collect relevant pictures, make a vlog video(with help from Bohao), publish it on YouTube, has 100 views.  Write a blog and have 100 views.  Introduce Wechaty to more than 20 people. 3. OKR: @rickyyin98: Objectives:  Make Wechaty all design to be known as one of the most attractive open-source design in this event Set up a SOP and make it can cover all similar activitiesKey Results:  Present our projects via live code game &amp; flyer, influence 200+ developers convert 20+ developers to Wechaty Developer. 4. OKR: @huan: Objectives:  Tell a story form the Wechaty open source community and make it attractive Play a ding/dong game with audiences in the room to demo what Wechaty can do and make it funKey Results:  Make a presentation that influences 50+ developers on site Write a blog post for the presentation that get 100+ reads from chatbot developers Build a WeChat group at the beginning of the presentation to includes 50+ audiences in the roomRelated Links:  The Ultimate Guide to OKR Guide: Set goals with OKRs Teaser image credit: What Are OKRs? How to Use OKRs for Planning (and Achieving) Your Goals "
    }, {
    "id": 174,
    "url": "https://wechaty.js.org/2020/12/31/summer-2020-student-developers/",
    "title": "今年夏天，Wechaty 社区与 9 位开源后浪的故事",
    "body": "2020/12/31 - 今夏， Wechaty 社区诞生了 9 位后浪贡献者：毕凯乔、王俊伟、谢昱清、范蕊、江姗姗、林昊翰、唐光彬、肖梓霖与孔祥哲。他们都还是正在就读本科与研究所的学生。 9 位后浪贡献者与 Wechaty 的故事要从今年中科院软件所和华为 openEuler 项目共同举办的“开源软件供应链点亮计划——暑期 2020” 说起。 故事的开始: 在这 9 位学生成为贡献者的过程中，我们不能不提到那些作为学生指路明灯的社区导师们。 在参与活动前，Wechaty 社区负责辅导学生的导师们正聚在一起讨论任务的设计。由于 Wechaty 项目相当年轻，这也是许多导师第一次参加类似的活动，大家难免感到些许的忐忑。 很幸运的是，最终我们还是吸引了一群优秀的学生参加到我们的项目中，并在 7 月 - 9 月的这 3 个月的时间中，Wechaty 社区诞生了 9 位开源新星。大部分的学生都是第一次参加到大型的生产项目中，在这个过程中发现自己的不足，也提升了工程实践上的能力，提高了读代码和分析代码的能力。其中也有同学在与社区互动的同时了解了开源社区互助的精神，并祈愿自己能在未来也继续发挥这种精神来帮助更多的人。 这 9 位同学们开发的项目中有些功能已经发布上线，为众多的社区用户所用；其他则会在未来的版本中陆续与大家见面。在文章后面我们将详细介绍这 9 个项目的具体细节和学生/导师们对本次开源活动的一些体会： 项目 1 - 基于python-wechaty的群聊助手机器人（CHAssisT）:  暑期2020的优秀学生最具潜力奖！  学生：孔祥哲，清华大学（大二） 导师：吴京京 Issue: https://github. com/wechaty/summer-of-code/issues/6 Git: https://github. com/kxz18/python-wechaty-groupchat-bot Blog: https://wechaty. js. org/2020/08/14/chassist-bot-final/项目描述: 在实际工作和学习过程中，微信作为主要的沟通渠道工具，承载着主要的事件发布任务。可是由于群聊信息是依时间线展开，一旦信息数量过大，将导致历史消息难以寻找。故此时需要一款群聊助手机器人，能够根据引用消息的回复，提取出其中的历史消息，并将其打上对应的标签同时保存到服务器本地。消息是保存在群聊助手机器人内部中，群内人员只需要艾特助手机器人即可查询历史消息，同时会定时清除和展示一定时间段内的历史打标消息，同时还支持手动清除和展示历史打标消息。 本项目基于python-wechaty实现了一个群聊助手机器人。该机器人主要由四个插件组成。第一个插件是群聊消息打标插件，通过群成员引用重要消息回复机器人的方式记录重要信息，以便之后以问答的方式进行查找。第二个插件是定时消息插件，用于定时消息的发放。第三个插件是群成员的管理插件，当有新人进群时进行欢迎，当一定人数群成员对某位群成员言行表示不适时自动从群聊中删除该位群成员。第四个插件用于提升交互，为帮助系统插件，提供自定义的功能文档，辅助前三个插件工作。四个插件也可单独使用。 心得体会: 本次SoC活动让我接触了开源社区，并进行了一次软件工程的简单实践。从刚开始的需求确认、项目技术确认，到每周的迭代更新、单元测试，到最后的项目文档书写、CI配置，整个过程和基本的软件工程是一致的。 在项目前期，最重要的是确定好项目的需求，并根据现有需求和以后可能增加的需求进行项目的架构。这步虽然不涉及实质性代码书写，但对之后的整个开发过程都有非常大的指导意义。需求是否明确，架构是否合适，会决定开发过程的难度和代码量，因此一定要认真对待。就我自己而言，我花费了近两周的时间进行需求确认和项目架构。确认需求时可以用用户故事的形式，容易发现需求文档中的细节问题，项目架构可以用UML图、泳道图等。项目架构多采取OOP的思想，保证有较好的扩展性。在架构完成之后，可以根据不同模块的难度和依赖关系进行开发排期。有了详细的计划，之后才能更注重于开发本身，从而提升效率。 项目真正进入开发之后，可能会时不时遇到问题，大多数问题都能用搜索引擎解决，百度搜不到的可以用google，如果是具体的第三方库的问题，则通常可以通过查阅文档和github的issue解决。如果实在无法解决，也可以在例会中向导师寻求帮助。在代码书写的过程中，最好能提前配置好社区的代码风格检查，如果社区没有配置这类检查的惯例，也最好能先多学习社区的代码，保证开发过程中代码的规范性和可读性。同时，对于大型项目而言，由于整体统调debug的难度较大，因此单元测试是非常必要的，在一个模块完成之后，一定要配置相应的单元测试，保证该模块实现没有问题，这样最后把所有模块组合起来之后出bug的概率就很小了。 开发完成后，还需要进行文档的书写和CI的配置。这两项内容其实社区一般都会有范例提供，文档保证和社区风格相近或一致即可。写文档的时候还是要先从使用者的角度考虑，再给出开发者需要的说明文档。因为多数人选择项目时肯定会先看项目的使用方法和功能说明，当真正选中项目进行后续开发时，才会去参考开发者所需的接口和项目架构。 导师寄语: 孔祥哲同学根据原定项目需求，迅速完成大部分功能，切代码质量非常好。期间与我保持着密切的联系，主动咨询问题，解决项目中的各种难题。孔祥哲同学自项目开始之期就开始高效率的开发，每天都有足够的代码提交量，积极完成项目功能，且能够精准的剖析出项目中存在的各种问题，承担着该项目的主要工作，包括需求深度分析，模块开发和扩展模块的讨论。 该同学的编程能力，对业务的分析能力都非常好，期间能够快速精准的发现主要问题，加快项目的开发速度，是一个十分优秀的实践者。该学生在过程中表现出高效率，希望该同学能够继续按照自己的兴趣，继续学习，期待你以后的高光时刻。 项目 2 - 基于开放 API 封装 Wechaty 接口下的飞书聊天机器人:  学生：范蕊，南开大学（大四） 导师：高原，李佳芮 Issue: https://github. com/wechaty/summer-of-code/issues/12 Git: https://github. com/Roxanne718/wechaty-puppet-lark Blog: https://wechaty. js. org/2020/09/30/wechaty-puppet-lark-final-blog/项目描述: 本项目主要实现飞书版本的puppet，帮助开发者快速将 Wechaty 微信机器人移植到飞书上。实现的主要思路是根据飞书开放平台提供的API实现puppet内的功能函数。 心得体会: 这是我第一次在开源社区贡献代码，感谢活动主办方和Wechaty社区的帮助和支持。虽然只有短短三个月的时间，但我在这个项目中收获了很多。在与导师的交流中学习到了很多优秀的开发思路和习惯，也认识到了很多优秀的同伴。目前这个项目还没有达到我预期的水准，后续我还会继续跟进、完善，希望能完成一套完整的飞书机器人框架。 这是我第一次严格意义上自己独立开发，在开发过程中遇到不少问题，如前后接口不一致、项目后期修改了前期的逻辑等等。在为新的bug焦头烂额的过程中我越来越理解到了工程化的重要性，希望自己能汲取教训，在今后的开发中做得更好。 最后，希望“开源软件供应链点亮计划”系列活动越办越好，相信未来的开发者们也能从中获得成长。 项目 3 - 基于Python-wechaty建立一个斗图机器人:  学生：肖子霖，四川大学（大三） 导师：黄纯洪 Issue: https://github. com/wechaty/summer-of-code/issues/7 Git: https://github. com/MrZilinXiao/python-wechaty-meme-bot/ Blog: https://wechaty. js. org/2020/09/27/python-wechaty-meme-bot-final/项目描述: 斗图功能是目前很多年轻人，甚至很多00后非常喜欢玩的，很受20岁左右的人的喜爱。目前市面上有很多斗图的软件，自动生成斗图的软件，还有很多自制的表情包也拿出来斗图，其下载量也还是不错的。所以说，在此背景下，开发出一款基于Python-wechaty的斗图机器人也是不错的。 本项目基于OCR与自然语言生成技术，实现了一个能基于使用者发送的图片表情内容进行即时交互的斗图机器人，项目主要使用了GPT2作为语言生成模型，chineseocr_lite作为OCR模块，同时支持多轮对话与对话回复的互相关损失计算，此外还提供了RESTFul API接口，可以为Wechaty多语言计划、甚至是其他的chatbot提供斗图服务。 心得体会: 与很多参与活动的同学一样，我也是第一次参与到开源社区的工作中来，在此之前我的Github可以说只算得上是个人的项目仓库；在为期三个月的开发过程中，我学习了许多与开源社区、Wechaty生态相关的内容，同时也了解到了CI/CD流程、代码风格等很难在本科课本中找到的内容；尽管作为本科生，我并未接触过太多开源社区，但在与社区核心成员、同样参加暑期2020活动的同学沟通的过程中，我逐渐发现Wechaty社区成员间相互交流的氛围深深吸引了我。尽管暑期2020活动已落下帷幕，但我们所有参与活动同学的开源之旅却才刚刚开始，我希望我个人在今后不断的磨练中能提高开发水平，能继续为包括Wechaty社区在内的开源社区做出力所能及的贡献！ 最后，再次感谢中科院软研所与OpenEuler社区主办的暑期2020活动，感谢Wechaty社区全体成员、特别是社区导师黄老师的悉心指导，感谢其余参与活动小伙伴的踊跃分享与积极交流！ 导师寄语: 项目的初衷是做一个“能”斗图以及“会”斗图的机器人，肖子霖在项目中期完成了“能”斗图的机器人，在项目的后期，“能”斗图的机器人也是完成了升华，成为“会”斗图的机器人。从最终结果来看，肖子霖同学的完成情况还是比较好的。 在项目后期的实施过程中，肖子霖同学克服各种困难，在自己不熟悉的领域，比如自然语言处理，也是取得了一定的成绩，这一点是可以肯定的。在项目过程中，肖子霖积极参与项目的开发，在未知的领域中进行探索，努力寻找解决问题的方案与办法，最终完成一个”会”斗图的机器人。 本项目在后期的话，由于机器学习的特殊性质，可能代码量并不是特别多，工作量上面主要突出在不断修改模型以及调参，最终一个“会”斗图的机器人才能得以完成。 总体上来说，本次项目肖子霖同学完成得不错。从一开始的表情包的识别，包括文字识别和情感识别，到后来的“能”斗图的机器人，再到最后的“会”斗图的机器人，肖子霖同学都用实际行动完成了项目。 最后一个建议：从目前呈现的效果来看，“怼”的效果可能还欠缺一点火候，希望后期可以“怼”得更好。 项目 4 - 编写一个“每日一句”插件:  暑期2020的优秀学生突出贡献奖！  学生：江姗姗，北京大学 导师：Gcaufy Issue: https://github. com/wechaty/summer-of-code/issues/10 Git: https://github. com/univerone/WordsPerDay Blog: https://wechaty. js. org/2020/09/26/wechaty-words-per-day-plugin-final/项目描述: 利用插件为机器人赋能。在很多交流群中会有需求说每天的某个时间机器人在群里发送一句话，或者一篇文章咨讯。 比如英文学习群可能需要每天一句英文知识点，炒股群可能需要每天一则财经资讯，工作群每天一心灵鸡汤，等等。 本项目主要开发了一个可以被 wechaty 调用的插件，能够根据用户自定义的规则进行文字信息的提取，能够定时在指定的群里发送信息， 另外本插件还支持生成每日变化的打卡图片。 心得体会: 很开心在这个暑假认识了wechaty社区，在之前虽然有接触过简单的github使用，但是从来没有接触过像wechaty一样大型并且活跃的开源社区，大家都是来自五湖四海，因为对于开源的热情和爱好而聚集到了一起，真的是很神奇的过程，也没有push和强制性的要求，氛围比较轻松愉快，大家都是出于兴趣来写代码，添加新的功能，开发新的东西最大的原因可能是觉得有意思或者好玩。 以前都是自己闭门写代码，写出来的东西很不规范，别人也看不懂，认识了wechaty社区之后，也开始学着看别人的优秀代码，在写代码的过程中注意规范，引入github action等自动化部署工具，对于我个人来说我觉得自己收获了很多，也很喜欢wechaty社区这种包容开放的开发风格。在项目结束之后，有幸和wechaty社区一起参加了南京的开源峰会，也是超级愉快和很多收获之旅。 项目开发过程中也存在一些遗憾，自己还是太过于内向，对技术水平不太自信，不太敢和和社区导师以及其他开发者讨论技术问题，错过了很多交流机会，这是我在以后需要注意的地方，还有就是时间管理问题，开源社区的项目都是大家在业余时间内完成的，自己总是在项目开发的过程中总是赶ddl，要向其他开发者们学习合理规划和分配时间。 总体来说，我自己最大的体会是要积极主动地接触新的事物和挑战，也感谢wechaty社区和中科院软件所给了我这次机会。 项目 5 - 基于 RPA 封装 Wechaty 接口下的快手聊天机器人:  学生：毕凯乔，长春工业大学（大四） 导师：王凯峰，尹伯昊 Issue: https://github. com/wechaty/summer-of-code/issues/14 Git: https://github. com/bikaiqiao/kuaishouPuppet. git Blog: https://wechaty. js. org/2020/08/20/wechaty-puppet-kuaishou-mid-term/项目描述: 快手内部有强大的IM系统，大量用户已经习惯直接在快手内与内容创作者和粉丝群进行聊天沟通。 但是目前没有成熟的快手聊天机器人框架，对于繁琐的自动回复、群管理等运营场景，尚未出现完整成熟的解决方案。 心得体会:  Source: 恭喜我院2017级毕凯乔、王俊伟同学…成功参与了开源软件供应链点亮计划——暑期2020并顺利结项 作为一名大四大学生，即将毕业工作，深感自身专业技能的不足。在CSDN中看到了“开源软件供应链点亮计划——暑期2020”的活动，这项活动为鼓励大学生能更多的参与维护开源社区的工作，给出了丰厚的奖金和礼品。而我更需要在这项活动中提升自己的专业技能，为将来的工作铺垫道路。 我们的参与的社区是Wechaty社区，最开始主要开发wechat的聊天机器人，而在这次活动中，该社区希望能够把自己的聊天机器人桥接到更多的平台，我们分别选择了“_基于__RPA_封装_Wechaty_接口下的快手聊天机器人”和“_基于__RPA_封装_Wechaty_接口下的抖音聊天机器人”。社区使用的语言是typescript，比我们平时使用的javascript的语法要略难一些。同时这也是我们第一次接触这么大规模的项目源码，项目的解决方案又并没有太多的开源先例，也较难搜寻。我们先后尝试了三种思路，最后才在社区导师的帮助下，完成了demo版本。 通过参加这次活动，我都深刻的认识到了自己技术水平的不足，在面对大型项目的时候并不能迅速的找到最佳解决方案。我们虽然通过了活动的最终审核，但是在内卷愈发严重的今天，我们可能会为曾经年少轻狂的无知付出惨痛的代价。现在距离大学毕业仅仅剩下半年左右的时间，亡羊补牢，为时不晚。我将会在接下来的生活中，更加努力的学习专业知识，提升技术水平，以让自己在未来能获得更高的竞争力。 希望大家都能够在筚路蓝缕中砥砺前行。 项目 6 - 基于RPA封装的Wechaty接口下的抖音聊天机器人:  学生：王俊伟，长春工业大学（大四） 导师：王凯峰，尹伯昊 Issue: https://github. com/wechaty/summer-of-code/issues/13 Git: https://github. com/gavinwang23/wechaty-puppet-douyin Blog: https://wechaty. js. org/2020/10/13/wechaty-puppet-douyin-final-term/项目描述: 抖音内部有强大的IM系统，大量用户已经习惯直接在抖音内与内容创作者和粉丝群进行聊天沟通。但是目前没有成熟的抖音聊天机器人框架，对于繁琐的自动回复、群管理等运营场景，尚未出现完整成熟的解决方案。 Wechaty是全球最大的开源聊天机器人框架，希望实现基于同一套应用层代码实现不同软件的聊天机器人 项目 7 - 基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人:  学生：谢昱清 导师：高原，李佳芮 Issue: https://github. com/wechaty/summer-of-code/issues/2 Git: https://github. com/Sapio-S/wechaty-puppet-official/ Blog: https://wechaty. js. org/2020/09/27/puppet-work-final/项目描述: 企业需要将聊天记录储存并进行分析，但接口过于复杂，需要基于现有开放接口进行二次封装企业微信作为微信的企业版，提供多种API来满足企业的不同需求。而企业微信提供的会话存档功能能满足企业消息做留存、进而通过分析大量的消息数据优化工作流程、追责和质检这一需求。 但是，企业微信的会话存档接口因为安全要求很高，所以有很多的加密，解析等工作，虽然一方面保证了安全性，但是却大大增加了开发的难度。 Wechaty是全球最大的开源聊天机器人框架，希望实现基于同一套应用层代码实现不同软件的聊天机器人 Wechaty 作为全球最大的聊天机器人开发者社区之一，提供了非常简单的接口实现，让开发者能够用6行代码就实现自己的一个聊天机器人，如果能把企业微信的会话存档接口封装到 Wechaty 里来，则可以大大简化企业内开发者的开发流程。 因为 Wechaty 是建立在 puppet 系统之上的，puppet 是 Wechaty 依赖的一层抽象层，它定义了底层各个 IM 接入方案需要实现的接口，也正是因为 puppet 抽象层的存在，让很多 Wechaty 开发者可以仅仅通过一个变量，就能够随意切换不同的底层 IM 接入。 心得体会: 在项目期间，我感觉自己对于代码的理解能力在不断提高，回首一看，原先不懂的现在都明白个大概了，收获真的很大。在写这个报告的时候其实才算是对整个wechaty的架构有了一个比较清晰的认识，从7月初的完全不懂到八月的逐渐入门再到现在的恍然大悟（或许也没有真正领悟），很有成就感。 当然遗憾和不足也同样很多。主要的问题还是在于自身，对语言的不熟悉、时间上的冲突，导致目前的结果并不十分令人满意，遗留下了不少的坑待填。对于我而言这也是一个很重要的教训，未来做项目也要规划好时间，及早了解需要的技术栈，这样才能更好地完成任务。 另：其实本来觉得自己的代码虽然肯定不能直接发布使用，也勉强算是马马虎虎完成了主要的功能。但是一看别人的blog，我陷入了深深的尴尬，其实可以完成度更高、做得更好的。希望这学期学校开设的软件工程等等课程可以让我更深入地理解并熟悉完整开发流程吧！ 项目 8 - 为 go-wechaty 设计实现插件体系:  学生：林昊翰，西安电子科技大学（大三） 导师：丁小雨 Issue: https://github. com/wechaty/summer-of-code/issues/9 Git: https://github. com/wechaty/go-wechaty/pull/67 Blog: https://wechaty. js. org/2020/09/27/go-wechaty-plugin/项目描述: wechaty 是一款支持多协议的微信接入方案，随着社区多语言生态的建立，吸引了更多的开发者和爱好者的加入；同时需求的推动和技术的发展，插件系统逐渐完善，但是在多语言系统中 Plugin 体系尚未完成，我们希望通过这个任务，能够让更多的人加入 go-wechaty 的建设。 目前 go-wechaty examples/ding-dong-bot. go 有一个 ding-dong bot, 但是我们希望这个 ding-dong 是通用的，如果我们的 Plugin 体系能编写出来，也许实现 ding-dong 就只需要一行代码。例如：go bot. Use(DingDong{}) go-wechaty 是 Go 语言实现 wechaty 的项目，同样支持多协议接入；同时借助 gorountine 和 channel 的语言特性，实现了更加合理的封装和设计。 心得体会: 我在大学的前两年时间里并没有参与过大项目的开发，更别提要求较高的开源项目。开源项目的远程协作开发对我来说有极大吸引力，但我一直没有一个合适的机会参与其中（水平不足、不知道如何参与等情况让我屡次放弃跨出第一步）。 本届开源软件供应链点亮计划正好提供了这次机会，让我参与到 Wechaty 社区中进行项目开发。Wechaty 社区是一个包容度很高的社区，社区内的导师们对学生提出的问题都会耐心解答。 这次活动的经历增加了我参与开源软件开发的经验，同时争强了我的沟通交流能力。在以后的开发历程中，我会为继续为开源社区贡献代码。 在本项目的开发过程中，我遇到的主要问题来自对 Go 程序开发的不熟悉，在许多细节上会产生疑惑。实际测试程序时，也有一些小问题需要解决，比如 Docker 的使用、排错。我的解决方案主要是自己学习、查阅资料。这次项目开发的经历大大提升了我的编程能力，以及一些计算机相关知识。 对于部分无法自己解决的问题，社区里的导师们给了我很大帮助，导师们在阅读我的代码后给出了许多具有针对性的建议，这对我完成项目的开发是十分必要的，感谢导师们的付出。 导师点评: 昊翰同学的学习能力，和能动性特别强，能够很快的上手新的知识和方法；从最初的对开源项目的无从下手，到熟悉常规的共享代码的方式，以及对 Go 的掌握，都能感受到进步和收获；相信这么一次短暂的活动经历，能在你今后的工作和生活中成为谈资。 相信大部分从学校过渡到工作中，都会对长周期的项目产生动摇，其实你只需要按照原计划去完成既定工作就好，大项目拆解成小项目是计划和执行中很重要的部分；报告中提到了周计划，很欣慰你看到了这点带给你的价值，他使你没有偏离原有计划的方向，也希望你今后的工作中能从此有所收获。 项目 9 - Go-wechaty Github Action optimization:  学生：唐光彬，华南农业大学（大二） 导师：丁小雨 Issue: https://github. com/wechaty/summer-of-code/issues/8 Git: https://github. com/wechaty/go-wechaty Blog: https://wechaty. js. org/2020/09/27/go-wechaty-gh-actions-optimization-final-poc/项目描述: Github Action 已经发布有段时间了，在 go-wechaty 的 单元测试，代码检测和代码评级均有已有所落地。 Go-wechaty Github Action optimization 主要通过使用 Github Actions 的特性实现跨仓库的 CI 优化，旨在为开发者减轻负担。 心得体会: 作为一个对项目开发来说都没多少经验的小白，第一次为开源项目出一份微薄的力。在这三个月里，陆陆续续学习了 Github Actions 和 Docker 有关的知识。特别感谢导师丁小雨的付出，在他的指导下我也感受到开源社区的温暖和力量。 尽管这次开发的代码量比较少，我从中收获的是开源项目协作的流程以及开源社区的互助共享精神，收获颇丰。这一次规范又专业的多人协作，让我体验了一把充满效率的开发之旅。这次活动也让我了解到许多优秀的开发者，让我愈发决心磨练自己的开发技术。 最后，再一次感谢开源软件供应链点亮计划系列活动、Wechaty社区给我这次机会，也十分感谢丁小雨老师和其他老师、同伴给我带来的指导和帮助。 导师点评: 光彬同学能够很好的主动扩充自己尚未掌握的知识领域，甚至于在一定方向上能够主动的去探索新的技术方案，这一点在工作中是很重要的技能，希望你能够不段的扩充自己的知识领域，能够解决更多未知的问题。 技术方面相信你有足够的积极性去解决，就像你在总结中提到的你会意识到自己技术上的提升空间，但是另一方面希望你能够在开源方面有更多的收获，它可以使你在今后的工作中能够推动更多项目协同上的改进。 To Be Continued: 这次的活动对同学和对导师来说都是意义非凡的，不管同学们未来是否继续为 Wechaty 社区贡献，希望这次的活动能为他们成为职业程序员铺路与点亮他们对开源的热情。 星星之火，可以燎原。夏天或许过去了，但你与 Wechaty 社区的故事仍未完待续， 欢迎每个希望为 Wechaty 项目贡献的伙伴们加入我们，与我们谱写更多的故事！ 你可以从这里开始：https://github. com/wechaty/wechaty/issues 欢迎加入 Wechaty 社区:       地址   入口         https://github. com/wechaty/wechaty   源码       https://wechaty. js. org   官网       https://gitter. im/wechaty/wechaty   Gitter 聊天室       https://wechaty. js. org/blog   博客       https://www. youtube. com/playlist…   YouTube       https://photos. google. com/…   Album       https://docs. google. com/document/…   Meeting Notes    Special thanks to Milvus community for the template "
    }, {
    "id": 175,
    "url": "https://wechaty.js.org/2020/12/31/osschat-a-bridge-to-the-apache-way-in-china/",
    "title": "Osschat a bridge to the apache way in China",
    "body": "2020/12/31 - OSSChat 是一个机器人工具，用于桥接 IM 应用（如微信）与 Apache 社区工具（如邮件列表、Jira），OSS. Chat项目的任务是将微信和其他社交平台（未来）以及GitHub出现的问题和邮件列表之间的三方沟通和翻译障碍发送给开源开发社区，使ASF的文化、技术和协作流程能够更高效、更容易被接受。 我们于2020年12月13日，收到此评估申请。我们作为Apache Local Community北京成员，很高兴为中国本土开源项目进行Apache孵化器适配度评估。 有了Chatbot，开发人员可以更轻松地共享和交流关于开源项目开发的信息。特别是，归档和向社区提供公开信息是我们认为非常有意义的事情之一。通过OSS. Chat项目，我们希望进一步促进、传播甚至优化Apache项目社区的文化、技术和协作。 OSSChat会议:  这里是OSSChat会议记录 怎样使用OSS. Chat: 详情可以阅读How to useGithub Repo：https://github. com/kaiyuanshe/OSSChat下面是李卓桓对OSS Bot的介绍以及如何将GitHub问题与任何开源项目的微信室同步：Introducing OSS Bot: Sync GitHub Issues with WeChat Groups for Open-source Projects   0:00:13 概述Github Repo 0:02:29 怎样在自己的issue里面配置ossbot 0:02:29 第一步 装GitHub APP 0:03:03 第二步 将GitHub项目和微信群的配置送到代码里面 0:06:01 第三步 将机器人送到微信群中 0:07:03 问答与指导Apache提案: Incubator OSSChat ProposalWeekly Meeting Notes 导师: Craig L. Russell，Apache软件基金会主席Junping Du，腾讯开源联盟主席Ted Liu，主席，开元社 贡献者: Zhuang Biaowei(庄表伟)，华为技术有限公司产品经理Huan(李卓桓)Tencent TVP of Chatbothuan@kaiyuanshe. orgRui(李佳芮)Wechaty合著者，JuziBot的创始人 OSS. Chat - 通往 Apache Way 的一道虹桥:    OSS. Chat 项目的使命是为开源项目开发社群搭建一道打通 WeChat 及其它社交平台 (未来) 和 GitHub Issues 与邮件列表的三向沟通和翻译壁垒的桥梁，让 ASF 的文化、技术和协作流程能尽快地容易地被接受，而不是一开始就磕磕绊绊。通过 Chatbot 这种自动化流程机制，让开发者能够更加便捷的分享和沟通开源项目的开发信息。尤其是对社区开放资料的存档和二次归纳处理，是我们认为很有意义的一件事情。透过 OSS. Chat 项目，我们希望能进一步推广、传播乃至于优化 Apache 项目社区的文化、技术、与协作。     李卓桓，Tencent TVP of Chatbot。清华大学本科，中欧国际工商学院EMBA。现任PreAngel合伙人，Plug and Play Venture Partner，关注钟子期AI创业项目。zixia BBS、叽歪网创始人，曾任优酷网首席科学家、水木清华BBS站长，ChinaRen系统工程师。拥有丰富的互联网创业投资和编程经验，著有《Linux网络编程》《反垃圾邮件完全手册》《智能对话与深度学习》《Chatbot从0到1》《简明的 TensorFlow 2》等技术图书。2016 年在 GitHub 发布基于 Apache-2. 0 许可证的 Conversational SDK Wechaty 开源项目，现有数十位 Committers，百余位 Contributors ，并被近万名 GitHub 开发者 Star   幻灯片ApacheCon 2020 链接: Dashboard：https://oss. chatGitHub:https://github. com/kaiyuanshe/osschat开源社, 由 CSDN、GitCafe、GNOME. Asia、微软开放技术公司、优麒麟社区联合创始，由国内外支持开源的企业、社区及个人，依“贡献、共识、共治”原则，所组织的开源联盟，旨在共创健康可持续发展的开源生态体系，并推动中国开源社区成为全球开源软件的积极参与及贡献者。  作者: juzibot "
    }, {
    "id": 176,
    "url": "https://wechaty.js.org/2020/12/31/open-source-award-wechaty/",
    "title": "Chatbot SDK Wechaty 获国内顶级开源组织颁发大奖",
    "body": "2020/12/31 - ​​12月30日，Wechaty开源社区再度拿下重要荣誉，由中国开源云联盟举办的《第十届中国云计算标准和应用大会》上，Wechaty与阿里、小米、华为等巨头并列，入选中国优秀开源项目。 中国开源云联盟（COSCL）成立于2012年8月，是我国最顶级开源组织之一，现有我国180余家开源生态圈产、学、研、用成员单位，致力于联合国内开源产业界相关方，在中国共同推动开源生态系统搭建、技术社区建设、开源项目培育、开源团体标准研制、开源技术推广应用等工作。 参选项目方案要具备很强的技术专业特点以及深入的行业贡献，同时，还要考察技术未来发展前景等多个维度，考评制度非常严格，此次，拿下优秀开源项目荣誉，证明了Wechaty得到了行业的高度认可。 Wechaty是2016年基于Apache-2. 0许可证发布的开源对话式交互人机界面SDK，具备极简开发、多语言、丰富组件等关键能力，并支持微信、Whatsapp、Gitter、飞书、快手等各大即时通讯工具对话平台，已经广泛应用在教育、零售、社区管理等领域。 Wechaty 联合作者李佳芮表示，Wechaty在行业中已成为了创新者，Wechaty除了具备聊天对话机器人的基础功能之外，还内置了丰富的插件模块，并且拥有灵活扩展支持通用IM平台的Puppet插件，最终实现跨即时通讯工具对话平台的交互统一化，为客户在对话式交互人机界面应用场景上快速开发的同时降低管理成本；并且，Wechaty运营中聚合了Wechaty开源社区的大量开发者开源项目，电商、教育、社区等，通过Wechaty降低开发门槛，可以达到传统应用系统快速对话式交互化，为开发者带来极大的便利性。 未来，Wechaty将继续保持开源开放，与更多的人工智能、对话人机界面上下游生态伙伴合作共赢。​​​​ "
    }, {
    "id": 177,
    "url": "https://wechaty.js.org/2020/12/31/dotnet-wechaty-getting-start/",
    "title": ".NET Wechaty Getting Start",
    "body": "2020/12/31 - . NET Wechaty 是使用. Net Core对TS版本Wechaty的翻译。 . Net Core 支持跨平台，因此. NET Wechaty同样也支持跨平台,目前在Windows,Centos,Ubuntu 下已测试通过，Mac未测试，如果有Mac系统的欢迎测试，ARM架构的目前只测试Raspberry，但是GRPC连接有问题，问题待排查。 . NET Wechaty dotnet-wechaty-getting-started . NET Wechaty Geetting Start: 新建一个控制台程序: 新建一个. Net Core 3. 1 控制台程序 添加Nuget包: 只需要引用Wechaty一个Nuget包即可，其他相关包会自动引入 6行代码运行一个Bot: // 初始化一个botvar bot = new Wechaty. Wechaty(new PuppetOptions(){  // 如何申请token，请看：https://github. com/juzibot/Welcome/wiki/Everything-about-Wechaty  Token =  your token ,  PuppetService =  wechaty-puppet-service }); // 监听bot事件 await bot . OnScan((string qrcode, ScanStatus status, string? data) =&gt; { }) . OnLogin((ContactSelf user) =&gt; { }) . OnMessage((Message message) =&gt; { }) . OnHeartbeat((object data) =&gt; { }) . Start();实现ding dong 最简单的功能: await bot . OnScan((string qrcode, ScanStatus status, string? data) =&gt; { }) . OnLogin((ContactSelf user) =&gt; { }) . OnMessage((Message message) =&gt; {     // 如果接收到的文本消息为 ding    if (message. Text ==  ding )    {      // 则发送一个文本: dong      message. Say( dong );    }  }) . OnHeartbeat((object data) =&gt; { }) . Start();完整代码: using System;using System. Threading. Tasks;using Wechaty. Module. Puppet. Schemas;using Wechaty. User;namespace dotnet_wechaty_getting_start{  class Program  {    static async Task Main(string[] args)    {      // 初始化一个bot      var bot = new Wechaty. Wechaty(new PuppetOptions()      {        Token =  puppet_rock_4448d7e832fd436c9f2a1d33eea8e865 ,        PuppetService =  wechaty-puppet-service       });      // 监听bot事件      await bot        . OnScan((string qrcode, ScanStatus status, string? data) =&gt;        {          const string QrcodeServerUrl =  https://wechaty. js. org/qrcode/ ;          if (status == ScanStatus. Waiting || status == ScanStatus. Timeout)          {            var qrcodeImageUrl = QrcodeServerUrl + qrcode;            Console. WriteLine(qrcodeImageUrl);          }          else if (status == ScanStatus. Scanned)          {            Console. WriteLine(data);          }        })        . OnLogin((ContactSelf user) =&gt; { })        . OnMessage((Message message) =&gt;        {          if (message. Text ==  ding )          {            message. Say( dong );          }        })        . OnHeartbeat((object data) =&gt; { })        . Start();      Console. ReadLine();    }  }}Wechaty 社区: 社区信息: :octocat: https://github. com/Wechaty/wechaty:beetle: https://github. com/Wechaty/wechaty/issues:book: https://github. com/Wechaty/wechaty/wiki:whale: https://hub. docker. com/r/wechaty/wechaty 多语言Wechaty:  Wechaty - Conversatioanl SDK for Chatot Makers (TypeScript) Python Wechaty - RPA SDK for Chatbot Makers written in Python Go Wechaty - RPA SDK for Chatbot Makers written in Go Java Wechaty - RPA SDK for Chatbot Makers written in Java(Kotlin) Scala Wechaty - RPA SDK for Chatbot Makers written in Scala PHP Wechaty - RPA SDK for Chatbot Makers written in PHP . Net(C#) Wechaty - RPA SDK for Chatbot Makers written in . NET(C#)Join Wechaty: 口令：wechaty . NET Wechaty Contributors 招募: 如果您对. NET 感兴趣，对Wechaty感兴趣欢迎加入. NET Wechaty Tearm#pr-24有任何关于. NET Wechaty的开发问题，可以在该issue下提问 "
    }, {
    "id": 178,
    "url": "https://wechaty.js.org/2020/12/30/wechaty-2020-dinner-666/",
    "title": "2020 Wechaty 666: 6 lines of code, 6 platforms, and 6 languages",
    "body": "2020/12/30 - Time past fast, the year 2020 has gone. When we look back to the past 12 months, we are very happy to see that the Wechaty community growth HUGE, thanks for all our great developers from the community, especially those who have submited Issues and Pull Requests! Meetup Video: Dec 30, 2020, we have a Wechaty developers meetup dinner at Wudaokou. we have reviewed the 2020 and outlook the 2021 for our great Wechaty open-source project and the community!   YouTube: https://youtu. be/a9i5YoKiRYY The following friends attended our dinner:  Huan, Creator of Wechaty, Chatbot TVP of Tencent, PreAngel Partner 李佳芮, Co-creator of Wechaty, Microsoft AI MVP, Founder &amp; CEO of Juzi. BOT 吴京京, Creator of Python Wechaty, NLP ML Postgraduate student of BUPT 丁小雨, Creator of Go Wechaty, Engineer 借来的天堂, Python Wechaty Contributor 谢扬, Wechaty Contributor, Founder &amp; CEO of Authing. cn 尹伯昊, Wechaty Contributor, CMO of Juzi. BOT 王海良, Wechaty Contributor, Founder &amp; CEO of Chatopera. com theif, MIT Ph. D, Machine Learning Researcher, Entrepreneur 孙翰南, Wechaty Developer, Founder &amp; CEO of Fami A Xiao, Wechaty Developer (online)  Thanks @windmemory supporting for the final cutting pro software, and here’s a good 20 mins tutorial for getting started with it: LEARN FINAL CUT PRO X IN 20 MINUTES // TUTORIAL FOR BEGINNERS 2020 Review: We have summurized what we did those fantastic improvements in 2020 into one number: 666! Why 666? It’s because we have got three sixes! 6 Lines of Code: Firstly, as we all know, Wechaty can build a chatbot with only 6 lines of JavaScript/TypeScript code! And after 2020, we can not only write Wechaty chatbots in JavaScript/TypeScript, but also write them in almost any languages that you are using, for example, Python! bot = Wechaty()bot. on('scan', lambda status, qrcode, data: print('Scan QR Code to login: {}\nhttps://wechaty. js. org/qrcode/{}'. format(status, qrcode)))bot. on('login', lambda user: print('User {} logged in'. format(user)))bot. on('message', lambda message: print('Message: {}'. format(message)))await bot. start() The World’s Shortest ChatBot Code: 6 lines of JavaScript 6 Programming Languages: Secondly, Wechaty can be used in 6 programming languages other than JavaScript/TypeScript, they are:  Python Wechaty Go Wechaty Java Wechaty Scala Wechaty PHP Wechaty! . NET WechatyWe drafted the Multi-language Wechaty Issue #1927 in March 2020, and our Wechaty community members are so great that we finished translate Wechaty from TypeScript to Python, Go, and Java in 2 months, and then we got another three (Scala, PHP, . NET) done in the next 3 months, it’s so unbelievable! And after 2020, we can not only connect Wechaty to WeChat, but also connect our chatbot to more IM platforms! 6 IM Platforms: Thirdly, Wechaty can connecting to 6 IM platforms other than WeChat, they are:  Whatsapp TikTok Lark Kuaishou Gitter WxWorkMost of those support (Whatsapp, TikTok, Lark, Kuaishou) are built by community developers who comes from the Open Source Promotion Plan - Summer 2020. Summer 2020 is a Google Summer of Code like program co-organized by ISCAS &amp; openEuler Community. Wechaty was recognized by the organizer as a valuable open-source project, we published a dozen oss tasks to student develoeprs who want to practice with the oss, and they are so great that everyone did a great job with us! And after 2020, we can not only use Wechaty Puppet locally, but also we can cloudify the Wechaty Pupppet as a Service (TBW)! So, 2020 Wechaty 666! 2021 Outlook: For the coming 2021, we have a great conversation with all the friends at our dinner. There will be more and more opptunities for Wechaty in 2021, we have picked four out of them which we believe they are the most important ones.  Globalization: Google Summer of Code Book: Chatbot 1 to 2 More Puppet Service Providers Five Years Celebration1. Globalization:  Google Summer of Code 2021 will start soon, Wechaty should apply to join as a open-source organization, then connect to the global student developers through the GSoC in 2021. (We should also join Summer 2021 in China as well) The Open Source Fundation is a great place to hold our Wechaty oss project. We should keep eyes on the top tier fundations and learn how to play with them. E. g. , it would be very helpful for us if we can join Apache or Linux fundation. 2. Book &amp; Documentation:  The Wechaty Docs Website is not clear for our developers, especially a developers never know Wechaty before. We should fill the contents in our docs in 2021.  We have a plan to write a book (code name Chatbot 1 to 2) online, the target audience is a programmer who want to build a chatbot to solve their conversational user interface problem but has never heard about Wechaty,to getting started with Wechaty and write good chatbot code. 3. More Puppet Service Providers: Currently we have only four Wechaty Puppet Service Providers, and we should find more developers who is willing and able to build and provide the Wechaty Puppet Service. (at least increase another four providers) 4. Five Years Celebration: We have already 150 contributors with Wechaty open-source project! However, most of us are never meet in person before, so let’s meet in 2021! Our plan is to host a 5 Years Celebration in March 2021, please let us know what you think by discussing at https://github. com/wechaty/wechaty/discussions/categories/5-years-celebration! Gifts: All the friends got beautiful Wechaty stickers! If you like them, please stay tuned and we will send out a form to fill your address and then we will send stickers to you! "
    }, {
    "id": 179,
    "url": "https://wechaty.js.org/2020/12/28/automatic-rebate-robot/",
    "title": "用wechaty制作返利机器人",
    "body": "2020/12/28 - 实现的功能：: 1，通过发送淘口令会自动识别淘口令并返回一个返利链接2，通过返利链接支付完商品，该用户会收到预计返利金额3，订单交易完成，增加该用户的账户的金额，同时会收到增加的金额和余额提醒。上级代理，上上级代理也会有相应的提成 实现方式：: 前台使用ts版本的wechaty与用户进行交互。后台使用java版本大淘客sdk，数据库使用mysql。前台通过在ts导入jar包调用后台接口。 缺陷：: 1，无法识别好友推荐人，所以收到好友申请时需要手动往数据库添加代理信息2，无法识别交易订单有哪个用户发起，所以需要给每个用户添加一个pid 好友模块：: 同意好友请求后设置该好友备注为wxid，方便后期查找 消息模块：: 对收到的文本信息进行解析返回对应的信息，如果调用api无法识别商品id则不返回返利链接;如果识别到商品id，但没有优惠信息返回无优惠;如果有优惠信息返回返利链接； 订单查询模块：: 登录后触发10s定时器，每隔10s查询这段时间的订单交易信息，解析出支付成功订单的优惠信息以及pid，根据pid查询对应的wxid，对该wxid用户发送预计佣金信息。对支付成功订单给该用户发送佣金信息，并按照比例，同时对上级，上上级发送返利信息。 "
    }, {
    "id": 180,
    "url": "https://wechaty.js.org/2020/12/28/auto-push-news/",
    "title": "java-wechaty auto get news",
    "body": "2020/12/28 - In daily life, most people always want to know latest news. This tutorial will record how to automatically get the current latest news. Project structure: Technology selection: kotlin + java-wechaty + Spring bootIDE: IntelliJ IDEA Core Modules:  Wechaty(WeChat push) Timing task Information acquisitionStart: Init project: Visit Spring initializr and generate: Download &amp; unzip, open with IDEA: Add dependency(newest version) and update: &lt;dependency&gt;  &lt;groupId&gt;io. github. wechaty&lt;/groupId&gt;  &lt;artifactId&gt;wechaty&lt;/artifactId&gt;  &lt;version&gt;0. 1. 5-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; Add wechaty scan plugin: Create WechatyPlugins. kt file in com. example. demo: package com. bugcatt. wxbot. wechaty. pluginsimport io. github. wechaty. MessageListenerimport io. github. wechaty. ScanListenerimport io. github. wechaty. Wechatyimport io. github. wechaty. WechatyPluginimport io. github. wechaty. schemas. MessageTypeimport io. github. wechaty. schemas. ScanStatusimport io. github. wechaty. user. Messageimport io. github. wechaty. utils. QrcodeUtilstypealias DingDongOptions = DingDongOptionsObjectclass DingDongOptionsObject {  var at = true  var dm = true  var room = true}fun isMatchOptions(options: DingDongOptionsObject? = null, message: Message): Boolean {  val localOptions: DingDongOptionsObject = options ?: DingDongOptionsObject()  if (localOptions. room &amp;&amp; message. room() != null) {    return true  }  if (localOptions. at &amp;&amp; message. room() != null &amp;&amp; message. mentionSelf()) {    return true  }  if (localOptions. dm &amp;&amp; message. room() == null) {    return true  }  return false}class WechatyPlugins {  companion object {    @JvmStatic    fun DingDongPlugin(options: DingDongOptions?): WechatyPlugin {      return fun(wechaty: Wechaty) {        wechaty. onMessage(object : MessageListener {          override fun handler(message: Message) {            if (message. type() != MessageType. Text) {              return            }            val room = message. room()            val text = if (room == null) {              message. mentionText()            } else {              message. text()            }            if (!isMatchOptions(options, message)) {              return            }            if (! #ding . equals(text)) {              return            }            if (room == null) {              message. say( dong , message. from()!!)            } else {              room. say( dong )            }            return          }        })      }    }    @JvmStatic    fun ScanPlugin(): WechatyPlugin {      return fun(wechaty) {        wechaty. onScan(object : ScanListener {          override fun handler(qrcode: String?, statusScanStatus: ScanStatus, data: String?) {            println(QrcodeUtils. getQr(qrcode!!))          }        })      }    }  }}Screenshot: Autowire wechaty: Change DemoApplication. kt to: package com. example. demoimport io. github. wechaty. Wechatyimport org. springframework. boot. autoconfigure. SpringBootApplicationimport org. springframework. boot. runApplicationimport org. springframework. context. annotation. Bean@SpringBootApplicationclass DemoApplication{  @Bean  fun wechaty():Wechaty{    val wechatyToken =  your wechaty token     val bot = Wechaty. instance(wechatyToken)    bot. use(WechatyPlugins. ScanPlugin())    bot. start(false)    return bot  }}fun main(args: Array&lt;String&gt;) {  runApplication&lt;DemoApplication&gt;(*args)} Then run the application, you’ll see log of wechaty. Create schedule: Enable scheduling: First we need enable schedule:Add a @EnableScheduling to application: We need schedule of spring boot, so we create MySchedule. kt: Inject wechaty: We wanna use functions of wechaty. Because the injection has been completed above, we only need to directly introduce here: Create a schedule task: Let’s create a schedule for test. Print time every 5 second. Replace your MySchedule. kt: package com. example. demoimport io. github. wechaty. Wechatyimport org. springframework. scheduling. annotation. Scheduledimport org. springframework. stereotype. Componentimport java. time. LocalDateTime@Componentclass MySchedule(private val wechaty: Wechaty) {  @Scheduled(fixedDelay = 5000)  fun autoSuggest() {    println( time: ${LocalDateTime. now()} )  }}Run application, you can see time print on your console: Next, we only need to focus on how to push and content. Free news api: RestTemplate: Because we need RestTemplate to send http request, so we add a dependency into pom. xml: &lt;dependency&gt;  &lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; Don’t forget to reimport. News Api: There’s a free news Api. Let’s use it. First, we create a data class to receive json data. Create ToutiaoResponse. kt: package com. example. demoimport com. fasterxml. jackson. annotation. JsonPropertydata class ToutiaoResponse(    @JsonProperty( reason )    val reason: String? = null,    @JsonProperty( result )    val result: Result? = null) {  data class Result(      @JsonProperty( data )      val `data`: List&lt;Data&gt;? = null,      @JsonProperty( stat )      val stat: String? = null  )  data class Data(      @JsonProperty( author_name )      val authorName: String? = null,      @JsonProperty( category )      val category: String? = null,      @JsonProperty( date )      val date: String? = null,      @JsonProperty( thumbnail_pic_s )      val thumbnailPicS: String? = null,      @JsonProperty( thumbnail_pic_s02 )      val thumbnailPicS02: String? = null,      @JsonProperty( thumbnail_pic_s03 )      val thumbnailPicS03: String? = null,      @JsonProperty( title )      val title: String? = null,      @JsonProperty( uniquekey )      val uniquekey: String? = null,      @JsonProperty( url )      val url: String? = null  )}Then create NewsUtil. kt: package com. example. demoimport org. springframework. web. client. RestTemplateimport org. springframework. web. client. getForObjectclass NewsUtil {  fun getNews(): ToutiaoResponse {    val type =  top     val appKey =       val url =  http://v. juhe. cn/toutiao/index?type=$type&amp;key=$appKey     val restTemplate = RestTemplate()    return restTemplate. getForObject(url, ToutiaoResponse::javaClass)  }}Finally, we just use this function in our schedule: package com. example. demoimport io. github. wechaty. Wechatyimport org. springframework. scheduling. annotation. Scheduledimport org. springframework. stereotype. Component@Componentclass MySchedule(private val wechaty: Wechaty) {  @Scheduled(fixedDelay = 600000)  fun autoSuggest() {    val newsResponse = NewsUtil(). getNews()    val newsList = newsResponse. result?. data?:return    for (i in 0. . 2) {      wechaty. say( Latest news: ${newsList[i]. title}  +           \n${newsList[i]. url} )    }  }}Ok, here’s the very simple news auto push plugin. You can use your imagination to create more useful plugins! You can find code here "
    }, {
    "id": 181,
    "url": "https://wechaty.js.org/2020/12/25/python-wechaty-room-inviter-plugin/",
    "title": "Python-Wechaty之自动回复&关键字入群插件",
    "body": "2020/12/25 - 经不可靠统计，大部分聊天机器人的初学者都是以：自动回复和关键字入群这两个基础功能上手，然后才会逐步开发更多更复杂的功能，在此我将介绍如何使用python-wechaty快速实现这两个功能。  python-wechaty：一个面向所有IM平台的聊天机器人框架。 一、背景介绍: 1. 1 自动回复: 有接触到微信公众号的同学都知道，它有一个自动回复的功能：你给它发送一个关键字，它就给你回复指定的内容，可以是纯文字，图片，视频等。  微信公众号的自动回复数量只有200个，虽然能够满足大部分的需求，可是如果扩充的话，便可以选择自定义开发。 而在微信中回复的内容又可以是什么呢？可以是：纯文字、带艾特消息@的文字、图片、动图（表情包）、视频，语音、视频、小程序以及好友名片等，这些消息内容在python-wechaty都能够使用简单的配置即可完成此功能。 1. 2 关键字入群: 目前有很多社区运营者都会面临着一些问题：  群人数一多，就只能够一个一个拉人入群。 有好几个用户/开发者群，某些群人数满了，无法动态拉到其他群。 一个人管理的活动太多，每次都需要根据用户的意图将其拉到指定的群，大大增加运营同学的工作量。 每天就光拉人入群就花了半天的时间，还有半天是在偷着休息，因为太累了。 ……以上问题都是我根据身边部分同学和朋友的吐槽中总结而来，为了帮助他们快速完成KPI，提升业绩，我做了以下AutoReplyPlugin和RoomInviterPlugin两个插件。 接下来我将介绍如何上手这两个插件，快速解决你们身边的一些问题。 二、安装 &amp; 配置: 编程环境要求python3. 7+版本，以及一个token两个依赖包。 1. 1 配置Token: 什么是Token？为什么要配置Token？如何获取Token？ 这么粗暴的灵魂三问在我们官网上早已有相关的文档，也欢迎各位去挖掘我们潜在的文档链接，说不定你就能找到属于你的One Piece，所以在此章节我就只介绍如何在python-wechaty中配置Token。 Token的配置可以有多种方式：    方法一：通过环境变量来配置    export WECHATY_PUPPET_SERVICE_TOKEN='your-token'      方法二：通过python代码来配置    import os os. environ['WECHATY_PUPPET_SERVICE_TOKEN'] = 'your-token'   那如何获取长期Token呢？详细请看：Everything-about-Wechaty 1. 2 安装依赖包: 整个依赖包分为两个：wechaty以及wechaty-plugin-contrib，安装脚本如下所示： # 安装python-wechaty包pip install wechaty# 安装插件库pip install wechaty-plugin-contrib前者为使用python-wechaty开发聊天机器人的基础依赖包，里面包含开发过程中的对象，甚至是自定义插件；后者为官方维护的插件库，在里面有很多常见的基础插件，让你快速解决日常学习工作中的自动化问题。同时也欢迎各位来提交PR，贡献属于自己的插件。 Wechaty社区欢迎各位优秀开发者共建Chatbot领域基础设施 三、关键字入群: 关键字入群是很多社区运营同学的日常工作，也是最消耗体力的活儿，并没有很很复杂的脑力活儿。现在都0202年了，居然有同学还没有使用到自动化工具来提升工作效率，更有趣的事儿，他们大部分都有一个程序猿同事/同学/老公/老婆。为了让他们更好的帮助自己身边的人解决问题，关键字入群这个插件你们必须得安利一波儿～ 3. 1 功能介绍: 当用户私聊你，发送一个关键字，然后聊天机器人会根据关键字寻找到对应的群，比如你给Wechaty官方机器人发送一个“wechaty”的关键字，它会将你拉到Wechaty的开发者群内，并发送欢迎语。 功能实际上很简单，如果从零开发的话，会让你无从下说。可是如果你使用python-wechaty的话，只需要几行简单的配置代码即可开发此功能。 RoomInviterPlugin Is All You Need. 3. 2 示例代码: 最好的代码永远是最简单的代码 以下代码接近于人类语言，即使是新手，相信看完也知道如何开发专属聊天机器人： import asynciofrom typing import Dictfrom wechaty import Wechatyfrom wechaty_plugin_contrib. contrib import (  RoomInviterOptions,  RoomInviterPlugin)from wechaty_plugin_contrib. matchers import (  MessageMatcher,  RoomMatcher)async def run():     async run method     rules: Dict[MessageMatcher, RoomMatcher] = {    MessageMatcher('wechaty'): RoomMatcher('Wechaty开发者群（1）'),    MessageMatcher('python-wechaty'): RoomMatcher('Python-Wechaty开发者群（2）'),  }  plugin = RoomInviterPlugin(options=RoomInviterOptions(    name='python-wechaty关键字入群插件',    rules=rules,    welcome='欢迎入群 ～'  ))  bot = Wechaty(). use(plugin)  await bot. start()asyncio. run(run())在以上代码中，主要是分为三步：导入对象，注入规则，启动机器人。    导入对象   在wechaty-plugin-contrib的插件库中，所有的插件都会存在于wechaty_plugin_contrib. contrib下。大家一方面可以从源代码中查看的到最新的插件列表，也可以从README中查看到对应的插件列表。      相信大家能够在这里找到灵感来源，或者一怒之下提交自己的定制插件。       注入规则   在上述代码中，rules是一个规则字典，表示匹配到指定消息后就将消息发送者邀请到指定的群内；plugin就是封装核心逻辑组件，处理所有的自动化操作逻辑，开发者不需要关心这部分。     启动机器人   启动机器人只需要调用一下start这个函数。  三、自动回复: 自动回复也是我们日常生活工作中的一些高频使用场景，而回复内容不仅限于文字，还可以是图片，文件，链接以及小程序等等。比如你给机器人发“网易”，它会给你发送一个网易云音乐的小程序；你给它发一个”身份证“，它会给你发送身份证的正反面照片；…… 等等。 以上应用场景很常见，而且还有更多的实际应用案例可根据自己的需求来调整。 示例代码如下所示： import asynciofrom wechaty import Wechaty, MiniProgram # type: ignorefrom wechaty_puppet import (  # type: ignore  FileBox)from wechaty_plugin_contrib import (  AutoReplyRule,  AutoReplyPlugin,  AutoReplyOptions,)from wechaty_plugin_contrib. matchers import ContactMatcherasync def run():     async run method     img_url = 'https://ss0. bdstatic. com/70cFuHSh_Q1YnxGkpoWK1HF6hhy' \       '/it/u=1257042014,3164688936&amp;fm=26&amp;gp=0. jpg'  plugin = AutoReplyPlugin(options=AutoReplyOptions(    rules=[      AutoReplyRule(keyword='ding', reply_content='dong'),      AutoReplyRule(keyword='七龙珠', reply_content='七龙珠'),      AutoReplyRule(        keyword='七龙珠',        reply_content=FileBox. from_url(img_url, name='python. png')      ),      AutoReplyRule(        keyword='网易-李白',        reply_content=MiniProgram. create_from_json({. . . })      )    ],    matchers=[      ContactMatcher('秋客'),    ]  ))  bot = Wechaty(). use(plugin)  await bot. start()asyncio. run(run())代码非常简单（API设计的很人性化），相信大家一眼就能够看懂，在此我就不做过多解释。 四、总结: python-wechaty有非常人性化的API，同时内置了很多高频功能插件库，提供给开发者能够快速上手开发出自己的小应用。 整个wechaty的目标是面向所有IM平台，打造一款通用聊天机器人框架，也欢迎各位关注并使用python-wechaty框架。 "
    }, {
    "id": 182,
    "url": "https://wechaty.js.org/2020/12/23/wxwork-and-donut/",
    "title": "基于Wechaty开发的企业级机器人助手",
    "body": "2020/12/23 - GitHub 上搜了一圈，看到了挺多微信 bot 的方案，后面决定使用 wechaty，因为感觉设计得很优雅，6 行代码就可以轻松构建一个 wxbot。  官方文档文档近期正在频繁更新中 为什么需要该功能: 作为一名前端开发工程师，平时也喜欢写技术博客和交朋友，为此我也创建了微信技术交流群和微信公众号，一般我都会在文章下面贴出公众号和我的个人二维码，给有兴趣的小伙伴们添加微信然后我再拉他们进群这些，但是不停的同意微信好友验证，再发送群邀请真的是太痛苦了，相信很多做公众号的小伙伴都和我一样，作为一名开发，这种重复劳动是绝对不能忍受的基于这种情况和公司业务情况，调研发现了并了解到了wechaty，发现其提供的功能能够覆盖到企业和个人微信，并且能够自己定制化开发符合自己需求的功能。 Wechaty 是什么: 微信个人号功能非常强大和灵活，是一个非常适合用来做 ChatBot 的载体。它可以灵活不受限制的发送语音短信、视频、图片和文字，支持多人群聊。但是使用微信个人微信号作为 ChatBot，需要通过非官方的第三方库接入微信。因为截至 2018 年底，微信尚无任何官方的 ChatBot API 发布。 Wechaty 是一个开源的的对话机器人 SDK，支持 个人号 微信。它是一个使用 Typescript 构建的 Node. js 应用。支持多种微信接入方案，包括网页，ipad，ios，windows， android 等。同时支持 Linux, Windows, Darwin(OSX/Mac) 和 Docker 多个平台。 在 GitHub 上可以找到很多支持微信个人号接入的第三方类库，其中大多都是基于 Web Wechat 的 API 来实现的，如基于 Python 的 WeixinBot，基于 Node. js 的 Wechaty 等。少数支持非 Web 协议的库，大多是商业私有闭源的，Wechaty 是少有的开源项目支持非 Web 协议的类库。 只需要 6 行代码，你就可以 通过个人号 搭建一个 微信机器人功能 ，用来自动管理微信消息。 更多功能包括:  消息处理：关键词回复 群管理：自动入群，拉人，踢人 自动处理好友请求 智能对话：通过简单配置，即可加入智能对话系统，完成指定任务 … 请自行开脑洞所有你能想到的交互模式。在微信上都有实现的可能。每日定时拉取天气预报。 每天给你心爱的人发送早安和晚安信息。 什么成语接龙啦。快问快答等等功能 当然 wechaty 的功能服务并不是免费的: 200/月的费用，如果你是个人开发可能会斟酌一二。但是你可以通过社区申请一个长达 15 天的免费 token 来尝试使用和开发一个小型机器人，从而决定你是否需要购买使用。关于申请的地址我放在了这里Wechaty Token 申请及使用文档和常见问题 基于 wechaty-puppet-service 开发企业级微信机器人: 目录结构: ├── config│  └── index. js // 配置文件├── package. json├── service│  ├── bot-service│  │  ├── error-service. js│  │  ├── friendship-service. js│  │  ├── heartbeat-service. js│  │  ├── login-service│  │  │  ├── function-service. js│  │  │  └── index. js│  │  ├── logout-service. js│  │  ├── message-service│  │  │  ├── function-service. js│  │  │  └── index. js│  │  ├── ready-service│  │  │  ├── function-service. js│  │  │  └── index. js│  │  ├── room-invite-service. js│  │  ├── room-join-service. js│  │  ├── room-leave-service. js│  │  ├── room-topic-service. js│  │  └── scan-service│  │    └── index. js│  ├── common-service│  │  ├── chatbot-service. js│  │  ├── ding-service. js│  │  └── oss-service. js│  └── redis-service│    └── index. js├── src│  └── main. js // 入口├── store│  └── index. js // 全局存储对象├── utils│  ├── oss. js // 阿里云oss认证│  └── redis. js // redis认证登录└── yarn. locksrc/main. js import { Wechaty } from 'wechaty'; // 机器人木偶import { onScan } from '. . /service/bot-service/scan-service'; // 当机器人需要扫码登陆的时候会触发这个事件。import { onLogin } from '. . /service/bot-service/login-service'; // 当机器人成功登陆后，会触发事件，并会在事件中传递当前登陆机器人的信息import { onLogout } from '. . /service/bot-service/logout-service'; // 当机器人检测到登出的时候，会触发事件，并会在事件中传递机器人的信息。import { onReady } from '. . /service/bot-service/ready-service'; // 当所有数据加载完成后，会触发这个事件。在wechaty-puppet-padchat 中，它意味着已经加载完成Contact 和Room 的信息。import { onMessage } from '. . /service/bot-service/message-service'; // 当机器人收到消息的时候会触发这个事件。import { onRoomInvite } from '. . /service/bot-service/room-invite-service'; // 当收到群邀请的时候，会触发这个事件。import { onRoomTopic } from '. . /service/bot-service/room-topic-service'; // 当有人修改群名称的时候会触发这个事件。import { onRoomJoin } from '. . /service/bot-service/room-join-service'; // 当有人进入微信群的时候会触发这个事件。机器人主动进入某个微信群，那个样会触发这个事件。import { onRoomleave } from '. . /service/bot-service/room-leave-service'; // 当机器人把群里某个用户移出群聊的时候会触发这个时间。用户主动退群是无法检测到的。import { onFriendship } from '. . /service/bot-service/friendship-service'; // 当有人给机器人发好友请求的时候会触发这个事件。import { onHeartbeat } from '. . /service/bot-service/heartbeat-service'; // 获取机器人的心跳。import { onError } from '. . /service/bot-service/error-service'; // 当机器人内部出错的时候会触发error 事件。import { wechatyToken } from '. . /config/index'; // 机器人tokenimport { globalData } from '. . /store/index'; // 全局对象globalData. bot = new Wechaty({ puppet:  wechaty-puppet-service , puppetOptions: {  token: wechatyToken, },});globalData. bot . on( scan , onScan) . on( login , onLogin) . on( logout , onLogout) . on( ready , onReady) . on( message , onMessage) . on( room-invite , onRoomInvite) . on( room-topic , onRoomTopic) . on( room-join , onRoomJoin) . on( room-leave , onRoomleave) . on( friendship , onFriendship) . on( heartbeat , onHeartbeat) . on( error , onError) . start();具体功能实现及代码:  扫码登录通过 node 启动后，触发 onScan 事件，将登录二维码打印在控制台，扫码登录import QrcodeTerminal from 'qrcode-terminal';import { ScanStatus } from 'wechaty-puppet';/** * @method onScan 当机器人需要扫码登陆的时候会触发这个事件。 建议你安装 qrcode-terminal(运行 npm install qrcode-terminal) 这个包，这样你可以在命令行中直接看到二维码。 * @param {*} qrcode * @param {*} status */const onScan = async (qrcode, status) =&gt; { try {  if (status === ScanStatus. Waiting) {   console. log(    `========================👉二维码状态：${status}👈========================\n\n`   );   QrcodeTerminal. generate(qrcode, {    small: true,   });  } } catch (error) {  console. log( onScan , error); }};module. exports = { onScan }; 登录成功扫码登录成功后会触发 onLogin 事件，通过事件接收到登录信息和机器人信息，通过钉钉接口将登录通知发送至钉钉群内const { notificationLoginInformation,} = require( . . /. . /common-service/ding-service );import { updateBotInfo } from '. /function-service';import { globalData } from '. . /. . /. . /store/index';/** * @method onLogin 当机器人成功登陆后，会触发事件，并会在事件中传递当前登陆机器人的信息 * @param {*} botInfo */const onLogin = async (botInfo) =&gt; { try {  console. log(    ========================👉 onLogin 👈========================\n\n   );  console. log(`机器人信息：${JSON. stringify(botInfo)}\n\n`);  // 全局存储机器人信息  globalData. botPayload = botInfo. payload;  // 更新机器人列表  updateBotInfo();  // 机器人登录登出提醒/通知钉钉接口  notificationLoginInformation(true); } catch (error) {  console. log(`onLogin: ${error}`); }};module. exports = { onLogin };— 机器人异常退出当 node 服务异常终端，或者手机上退出机器人登录后会触发 onLogout 事件，同样钉钉群内通知信息，并且销毁程序中运行的一些定时器等 const { notificationLoginInformation,} = require( . . /common-service//ding-service );import { globalData } from '. . /. . /store/index';/** * @method onLogout 当机器人检测到登出的时候，会触发事件，并会在事件中传递机器人的信息。 * @param {*} botInfo */const onLogout = async (botInfo) =&gt; { try {  console. log(    ========================👉 onLogout 👈========================   );  console. log(`当bot检测到注销时，将与当前登录用户的联系人发出注销。`);  // 全局存储机器人信息  globalData. botPayload = botInfo. payload;  const { updateRoomInfoTimer, chatbotSayQueueTimer } = globalData;  // 机器人退出清空定时器  if (updateRoomInfoTimer) {   clearTimeout(updateRoomInfoTimer);  }  if (chatbotSayQueueTimer) {   clearInterval(chatbotSayQueueTimer);  }  // 机器人登录登出提醒/通知钉钉接口  notificationLoginInformation(false); } catch (error) {  console. log(`error in onLogout：${error}`); }};module. exports = { onLogout }; 消息接收处理当微信接收到新的消息时候会触发 onMessage 事件，通过事件内对消息的判断，群内消息还是私聊消息等做出不同的逻辑处理。从而实现业务需求。部分代码如下import dayjs from 'dayjs';import { say } from '. . /. . /common-service/chatbot-service';const { isCanSay, roomIdentifyVin, rooImageIdentifyVin, contactIdentifyVin, contactImageIdentifyVin, messageProcessing, storageRoomMessage, storageContactMessage,} = require( . /function-service );const { roomMessageFeedback, contactMessageFeedback,} = require( . . /. . /common-service/ding-service );import { globalData } from '. . /. . /. . /store/index';import { Message } from 'wechaty';/** * @method onMessage 当机器人收到消息的时候会触发这个事件。 * @param {*} message */const onMessage = async (message) =&gt; { try {  console. log(    ========================👉 onMessage 👈========================\n\n   );  // 机器人信息  const { botPayload } = globalData;  // 获取发送消息的联系人  const contact = message. from();  // 获取消息所在的微信群，如果这条消息不在微信群中，会返回null  const room = message. room();  // 查看这条消息是否为机器人发送的  const isSelf = message. self();  // 处理消息内容  const text = await messageProcessing(message);  // console. log(`========================👉 处理消息后内容为：${text} 👈========================\n\n`)  // 消息为空不处理  if (!text) return;  // 消息详情  const messagePayload = message. payload;  // console. log(`========================👉 消息详情：${JSON. stringify(messagePayload)} 👈========================\n\n`)  // 消息联系人详情  const contactPayload = contact. payload;  // console. log(`========================👉 消息联系人详情：${JSON. stringify(contactPayload)} 👈========================\n\n`)  // 群消息  if (room) {   console. log(    `========================👉 群聊消息 👈========================\n\n`   );   // 做相应的逻辑处理   // 私聊消息  } else {   console. log(    `========================👉 私聊消息 👈========================\n\n`   );   console. log(    `消息时间：${dayjs(messagePayload. timestamp). format(      YYYY-MM-DD HH:mm:ss     )}\n\n微信名称：${contactPayload. name}\n\n微信类型：${     contactPayload. type    }\n\n备注昵称：${     contactPayload. alias    }\n\n消息内容：${text}\n\n消息类型：${messagePayload. type}\n\n`   );  } } catch (error) {  console. log(`onMessage：${error}`); }};module. exports = { onMessage };至于其他的一些生命周期以及钩子函数。大家可以参考文档做出属于自己的应用机器人 封装 say 方法: 因为 say()方法会在多处调用，并且要根据不同的消息类型发送的内容做出不同的数据处理。大家以后也会遇到，因此这里将我封装的一个 say 方法展示给大家用于参考 import { MiniProgram, UrlLink, FileBox } from 'wechaty';import dayjs from 'dayjs';import { DelayQueueExector } from 'rx-queue';const { redisHexists, redisHset, redisHget, redisSet, redisLpush,} = require( . . /redis-service/index );import { globalData } from '. . /. . /store/index';const delay = new DelayQueueExector(10000);/** * @method say 机器人发送消息 * @param {*} messageType  消息类型  7文本，1文件，6图片，3个人名片，14卡片链接 9小程序 * @param {*} sender    来源  房间 || 个人 实例对象 * @param {*} messageInfo 内容 *//** * messageInfo 数据结构 *   tetx: string    文本消息必传 *   fileUrl: string   文件消息必传 *   imageUr: string   图片消息必传 *   cardId: string   个人名片消息必传 *   linkInfo: object  卡片消息必传 *     description: string   描述 *     thumbnailUrl: string  缩略图地址 *     title: string      标题 *     url: string       跳转地址 */async function say({ messageType, sender, messageInfo }) { // console. log(messageType); // console. log(sender); // console. log(messageInfo); try {  return new Promise(async (resolve, reject) =&gt; {   // 机器人信息   const { bot } = globalData;   // 枚举消息类型   const MessageType = {    text: 7, // 文本    fromFile: 1, // 文件    fromUrl: 6, // 图片    contactCard: 3, // 个人名片    urlLink: 14, // 卡片链接    miniProgram: 9, // 小程序   };   // 内容不存在   if (!messageInfo) {    return;   }   // 要发送的消息内容   let content;   switch (messageType) {    // 文本 7    case MessageType. text:     content = messageInfo. text;     break;    // 文件 1    case MessageType. fromFile:     content = FileBox. fromFile(messageInfo. fromFile);     break;    // 图片 6    case MessageType. fromUrl:     content = FileBox. fromUrl(messageInfo. fromUrl);     break;    // 个人名片 3    case MessageType. contactCard:     content = await bot. Contact. load( 1688853777824721 );     break;    // 链接 14    case MessageType. urlLink:     content = new UrlLink({      description:        WeChat Bot SDK for Individual Account, Powered by TypeScript, Docker, and Love ,      thumbnailUrl:        https://avatars0. githubusercontent. com/u/25162437?s=200&amp;v=4 ,      title:  Welcome to Wechaty ,      url:  https://github. com/wechaty/wechaty ,     });     break;    // 小程序 9    case MessageType. miniProgram:     content = new MiniProgram({      appid:  wx60090841b63b6250 ,      title:  我正在使用Authing认证身份，你也来试试吧 ,      pagePath:  pages/home/home. html ,      description:  身份管家 ,      thumbUrl:        30590201000452305002010002041092541302033d0af802040b30feb602045df0c2c5042b777875706c6f61645f31373533353339353230344063686174726f6f6d3131355f313537363035393538390204010400030201000400 ,      thumbKey:  42f8609e62817ae45cf7d8fefb532e83 ,     });     break;    default:     break;   }   delay. execute(async () =&gt; {    sender     . say(content)     . then((value) =&gt; {      console. log(       `========================👉 机器人回复 👈========================\n\n`      );      resolve();     })     . catch((reason) =&gt; {      console. log(       `========================😢 机器人发送消息失败 😢========================\n\n`,       reason      );     });   });  }); } catch (error) {  console. log( error in say , error); }}module. exports = { say,};对了，对于 onMessage 事件中消息格式的判断我也做了一层封装，这里给大家提供参考。 /** * @method messageProcessing 处理消息内容 * @param {*} message */async function messageProcessing(message) { try {  return new Promise(async (resolve, reject) =&gt; {   console. log(    `========================👉 messageProcessing 👈========================\n\n`   );   // 消息详情   const messagePayload = message. payload;   // 获取消息的文本内容。   let text = message. text();   /** Unknown: 0,     Attachment: 1,     Audio: 2,     Contact: 3,     ChatHistory: 4,     Emoticon: 5,     Image: 6,     Text: 7,     Location: 8,     MiniProgram: 9,     GroupNote: 10,     Transfer: 11,     RedEnvelope: 12,     Recalled: 13,     Url: 14,     Video: 15   */   // 消息类型   switch (messagePayload. type) {    // 附件 0    case Message. Type. Unknown:     console. log(      `========================👉 消息类型为未知消息：${messagePayload. type} 👈========================\n\n`     );     text =  [你收到一个未知消息，请在手机上查看] ;     break;    // 附件 1    case Message. Type. Attachment:     console. log(      `========================👉 消息类型为附件：${messagePayload. type} 👈========================\n\n`     );     // 暂时不知道怎么处理     text =  [你收到一个附件，请在手机上查看] ;     break;    // 音频 2    case Message. Type. Audio:     console. log(      `========================👉 消息类型为音频：${messagePayload. type} 👈========================\n\n`     );     text =  [你收到一条语音消息，请在手机上查看] ;     break;    // 个人名片 3    case Message. Type. Contact:     console. log(      `========================👉 消息类型为个人名片：${messagePayload. type} 👈========================\n\n`     );     text =  [你收到一张个人名片，请在手机上查看] ;     break;    // 聊天记录 4    case Message. Type. ChatHistory:     console. log(      `========================👉 消息类型为聊天记录：${messagePayload. type} 👈========================\n\n`     );     text =  [你收到聊天记录，请在手机上查看] ;     break;    // 表情符号 5    case Message. Type. Emoticon:     console. log(      `========================👉 消息类型为表情符号：${messagePayload. type} 👈========================\n\n`     );     text =  [你收到表情符号，请在手机上查看] ;     // 暂时不知道怎么处理     break;    // 图片 6    case Message. Type. Image:     console. log(      `========================👉 消息类型为图片：${messagePayload. type} 👈========================\n\n`     );     // 上传图片至阿里云获取图片地址     text = await addImageOss(message);     break;    // 文本 7    case Message. Type. Text:     console. log(      `========================👉 消息类型为文本：${messagePayload. type} 👈========================\n\n`     );     // 去空格换行     text = text. replace(/\s+/g,   );     break;    // 位置 8    case Message. Type. Location:     console. log(      `========================👉 消息类型为位置：${messagePayload. type} 👈========================\n\n`     );     text =  [你收到一条图片消息，请在手机上查看] ;     break;    // 小程序 9    case Message. Type. MiniProgram:     console. log(      `========================👉 消息类型为小程序：${messagePayload. type} 👈========================\n\n`     );     text =  [你收到一个小程序消息，请在手机上查看] ;     break;    // GroupNote 10    case Message. Type. GroupNote:     console. log(      `========================👉 消息类型为GroupNote：${messagePayload. type} 👈========================\n\n`     );     text =  [你收到一个GroupNote，请在手机上查看] ;     break;    // Transfer 11    case Message. Type. Transfer:     console. log(      `========================👉 消息类型为Transfer：${messagePayload. type} 👈========================\n\n`     );     text =  [你收到一个Transfer，请在手机上查看] ;     break;    // 红包 12    case Message. Type. RedEnvelope:     console. log(      `========================👉 消息类型为红包：${messagePayload. type} 👈========================\n\n`     );     text =  [你收到一个红包，请在手机上查看] ;     break;    // Recalled 13    case Message. Type. Recalled:     console. log(      `========================👉 消息类型为Recalled：${messagePayload. type} 👈========================\n\n`     );     text =  [你收到一个Recalled，请在手机上查看] ;     break;    // 链接地址 14    case Message. Type. Url:     console. log(      `========================👉 消息类型为链接地址：${messagePayload. type} 👈========================\n\n`     );     // 暂时不知道怎么处理     text =  [你收到一条链接消息，请在手机上查看] ;     break;    // 视频 15    case Message. Type. Video:     console. log(      `========================👉 消息类型为视频：${messagePayload. type} 👈========================\n\n`     );     text =  [你收到一个视频消息，请在手机上查看] ;     break;    default:     text =   ;     break;   }   resolve(text);  }); } catch (error) {  console. log( error in messageProcessing , error); }}为什么这样做一层封装处理，是因为我们的业务需求要将聊天内容进行 redis 和 mysql 数据存储。方便以后数据订正和查询使用。 实现的功能: 基于 wechaty 我们实现的功能有那些呢？ — 根据关键词反馈消息  识别图片 关键词指令绑定群信息。根据不同指令进行群配置。 redis 存储机器人信息。将群信息存储并同步在 redis 和 mysql 中。后台配置对应群是否开启某些功能等等。 定时发送消息 群邀请自动通过，入群以后做出相应数据存储逻辑判断功能设置等 好友申请自动通过，关键字申请自动邀请入不同的群，功能覆盖等等 等等功能。最后: 你如果想用我这些东西，拉下代码 config. js 里换下 token 和一些配置信息就可以，当然我在不停更新，功能会越来越多，所以仓库中代码和文中会有些不一样，使用时简单看下代码，都写了详细注释，也很简单，但是因为代码中很多地方涉及到来企业敏感信息。我只好重新写来一份最小可执行的demo，大家仅供参考。 ❤️ 看完帮个忙: 如果你觉得这篇内容对你挺有启发，我想邀请你帮我个小忙： 点赞，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-） 关注公众号「番茄学前端」，我会定时更新和发布前端相关信息和项目案例经验供你参考。 这里提供给大家一个最小demo: 项目地址 感谢:  作者: zhihuifanqiechaodan 前端开发工程师 "
    }, {
    "id": 183,
    "url": "https://wechaty.js.org/2020/12/23/open-source-pioneer-huan/",
    "title": "开源项目 Wechaty 作者李卓桓入选「中国开源先锋 33 人」",
    "body": "2020/12/23 -  2020 年 12 月 23 日，由 SegmentFault 思否发起的第二届“中国技术先锋”年度评选结果揭晓，Wechaty 作者，BOT5 Club Chair，腾讯 Chatbot TVP，PreAngel Partner 李卓桓入选 2020 “中国开源先锋33人”年度榜单。 12 月 23 日，「SegmentFault 思否」联合「开源社」重磅推出《2020 中国开源先锋 33 人》榜单。Wechaty 作者李卓桓入选“心”尖上的开源人物。 近年来，开源一直是技术圈非常火热的话题。SegmentFault 思否基于对开源领域的重点观察与实践，联合长期耕耘与推广开源文化的开源社展开了第二届“中国技术先锋”年度评选。本次评选历时 1 个月，共收到近百份自主申报表，结合部分评委提名人选，依托各科技企业和个人在国内技术领域的行为、影响力指标，最终评选产生这份《2020 中国开源先锋 33 人》榜单。本次与李卓桓同登榜单的还有开放原子开源基金会 TOC 主席堵俊平、PingCAP 联合创始人兼 CTO 黄东旭、VS Code 中文社区创始人韩骏等。 本次开源先锋的评选不仅限于开发者，同时包含贡献代码的开发者、开源项目发起人、开源布道师、开源治理专家与推动者、关注开源的投资人、开源社区运营者等等，都是开源生态发展道路上不可或缺的角色。Wechaty 作者李卓桓，曾创立 zixia bbs，出任水木清华 BBS 站长，就职 ChinaRen；在优酷担任首席科学家，领导研发工作；后创立国内微博客网站叽歪网，在中欧国际工商学院攻读EMBA之后投身早期天使孵化 PreAngel ，帮助早期技术背景创业者起步。2016 年，基于自身对人工智能和对话人机交互领域的热爱，发布 Wechaty RPA SDK，致力于帮助开发者提供一站式对话交互人机界面的服务开发和多场景解决方案。 此外，作为国内开发者社区领军人物，李卓桓还是腾讯聊天机器人方向最具价值专家（Chatbot TVP），引领 BOT5 Club 成功举办 40 场，吸引了诸多人工智能算法专家、Chatbot行业公司创始人、巨头公司对话应用产品经理、技术极客等，被誉为五道口最聚人气的 Chatbot 沙龙。除了聊天机器人方向，李卓桓还是 Google 机器学习开发者专家（ML GDE）和 Microsoft 人工智能最具价值专家（AI MVP）；编撰《Chatbot 从0到1》、《简明的 TensorFlow 2》，帮助开发者实现对话式人机交互界面启蒙，和入门人工智能算法构建、训练和应用； "
    }, {
    "id": 184,
    "url": "https://wechaty.js.org/2020/12/10/wechaty-robot-lite/",
    "title": "wechaty-robot-lite 微信小助手",
    "body": "2020/12/10 - 最近在dy上看到有相关wx机器人（SCRM）在进行相关推广，而之前学习的时候，用基于python开发的itchat玩过一段时间，后来，某一天突然发现微信登不上了，官方的微信网页版也不能登陆了（至于是啥原因，咱也不知道，也不敢去研究）。 最近又在捣鼓捣鼓这个小助手，遂捡起了之前看过的wechaty。对！！！就是他！！！他来了~~ 老规矩，先撩姐（????） 简介：:  官方（git） 语言：node(TypeScript )，python，java（项目多是支持node，一些是开源了python和java；看issues说是node项目支持的更完美~~咱也没细究） 协议：iPad、Mac、WinPc、Web等等（支持的协议挺多的，当然，web协议的README里会声明，登录不了web版微信的号不能正常使用） 使用：这里有个东东要提前声明下：token，wechaty的服务都依赖于token，有个合法的token才能正常使用wechaty的服务；后面会细说 免费：参与开源激励计划→传送门(点它) 收费：官方发布是200￥/号/月，具体→传送门(点它) 说明：官方声明，一个token原则上只能同时在线一个微信号，这里的意思就有意味了。这个token不会绑定你的微信号，但是呢，只能同时在线一个微信，你要是想做n个微信的私域，那就需要n个token学习：:  我这里的项目是基于wechaty-puppet-service 官方API文档（很重要！！！一定要先看文档再下手，如果要基于这个开发，一定要把它当作手册） 官方参考示例（至于我为什么基于这个示例，因为官方给的我15天免费token是donut版，基于windows协议） 语言：主要是nodejs，基于express框架→传送门（点它） 技术栈：express框架（前端ejs），socket io 名词解释     token：官方解释           Our Mission: Make it easy to build a WeChat Chatbot for developers.       We provide a free access using iPad protocol for the developers who have a strong will and ability to build a valuable chatbot for users.    Any developers can add JuziBOT Inc’s staff ( Wechat number : juzibot) as a Wechat friend. You will receive a review form after adding. If you pass the review and willing to write a blog in Wechaty , you can use our iPad protocol for free！    我们的使命：轻松为开发人员构建微信聊天机器人    我们为有强烈意愿和能力为用户构建有价值的聊天机器人的开发人员提供了使用iPad协议的免费访问权限    任何开发人员都可以将JuziBOT Inc的工作人员（微信编号：juzibot）添加为微信好友。添加后，您将收到一份审查表。如果您通过审查并愿意在Wechaty中写博客，则可以免费使用我们的iPad协议！        意思是我们提交审查表后，会获得为期15天的免费Token；想要获取长期有效的免费token，那就参加所谓的开源激励计划，就是在15天后，需要提交一个MVP(最小可行化产品)的Github仓库，Wechaty会将其fork到社区中的同时，会提供一个长期免费Token   wechaty-puppet-padplus：基于ipad协议的微信机器人   wechaty-puppet-service：基于windows协议的机器人   初步需求：:  关键字自动通过好友验证     当有人添加机器人时，判断验证消息关键字后通过或直接通过   通过验证后自动回复并介绍机器人功能    私聊关键字回复     例如回复 加群 推送群聊邀请   例如回复 作者微信 推送作者微信名片   例如回复 白名单群名 邀请入群    自动聊天     对接AI机器人，这里科普推荐免费机器人api和免费天气查询api，回复 芜湖天气   群聊中通过 @[机器人]xxx 可以和机器人聊天   私聊发送消息即可聊天   向机器人询问天气    加入群聊自动欢迎     当新的小伙伴加入群聊后自动 @[新的小伙伴] 发一个文字欢迎    web聊天     前台获取好友列表   通过socket实时向前台推送还有消息   实现前台向好友发送消息   项目结构：: |--bin/|----www # 项目启动文件|--publick/ #静态资源木狼|----image/|----javascripts/|----stylesheets/|------style. css|--routes/ # 路由|----index. js|----users. js|--views/ # 模板|----error. ejs|----index. ejs|--wechaty/|----onFriendShip. js # 好友添加监听回调|----onMessage. js  # 消息监听回调|----onRoomJoin. js  # 进入群聊监听回调|----onRoomLeave. js # 退出群聊监听回调|--app. js  # 核心|--common. js # 公共方法|--config. js # 配置文件|--donut. js # wechaty核心|--package. js|--package-lock. js|--socketio. js # socket核心代码开干: 项目初始化 新建文件夹wechaty-lite，进入目录执行cnpm init -y  (大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。) cnpm init -y安装核心包 // Wechaty核心包cnpm install --save wechaty// wechaty-puppet协议包cnpm install --save wechaty-puppet//开发过程中，还需要用到qrcode-terminal这个包，作用就是将二维码输出在终端来供我们扫码登录cnpm install --save qrcode-terminal//node5以后可以不用使用--save核心代码: 配置文件config. js module. exports = {  // puppet_donu Token  token:  PUT_YOUR_TOKEN_HERE ,  // 机器人名字  name:  Oreo ,  // 房间/群聊  room: {    // 管理群组列表    roomList: {      // 群名(用于展示，建议用群名) : 群id(先运行程序，获取群id（roomId）)      大家有钱花:  xxxx1@chatroom ,      wechaty开发组:  xxxx2@chatroom     },    // 加入房间回复    roomJoinReply: `\n 您好，进群请先看群公告！自觉遵守群规则，文明交流！最后，请用简短的话向大家介绍你自己！?? \n\n Hello, please read the group announcement first! Consciously abide by the group rules, civilized communication! Finally, please introduce yourself in short words! ??`,    autoReturnRoomList: ['大家有钱花', 'wechaty开发组']  },  // 私人  personal: {    // 好友验证自动通过关键字    addFriendKeywords: [ 12345 ,  一二三四五 ,  上山打老虎 ],    // 是否开启加群    addRoom: true,    //阻断不使用机器人回复的好友列表（wxid）    robotBlockList: ['tengxun', 'tengxun1'],    //阻断不使用机器人群回复的好友列表（wxid）    robotQunBlockList: ['tengxun', 'tengxun2']  },  //三方api信息  thirdApi: {    // http://www. itpk. cn/  ai机器人    itpk: {      apiKey:  xxx ,      apiSecret:  xxx     },    // http://www. tianqiapi. com/  天气预报    tianqiapi: {      appId:  zzz ,      appSecret:  zzz     }  }};启动文件www 在Create HTTP server. 后引入socketio和wechaty，进行启动  引入socketio，调用封装的getSocketio()进行初始化启动； 引入donut，调用封装的run()进行初始化启动；/** * Create socket. io server. */var io = require('. . /socketio');io. getSocketio(server);/** * Create puppet_donut server. */var puppet_donut = require('. . /donut');puppet_donut. run();socket服务socketio. js文件 该示例主要介绍了socket发送机制，如发送给自己，发送给初自己外的其他用户（广播），推送给所有人；（还可以推送给某一个socket连接用户，通过id，这里不介绍了）  监听客户端的消息； 监听客户端的微信消息并发送给相关好友； 封装接口sendWechatLoginMsg、sendWechatMsg给wechaty调用；var socketio = {};import common from '. /common';// 获取iovar io = null;//微信登录消息推送至客户端socketio. sendWechatLoginMsg = function(msg){  io. emit('getWechatLoginMsg', + msg);//触发所有用户};//回调消息推送至客户端socketio. sendWechatMsg = function(msg){  io. emit('getWechatMsg', '【' + common. currentDateTime() + '】' + msg);//触发所有用户};//初始化socketiosocketio. getSocketio = function(server){ // http(s) server  io = require( socket. io )(server);  //监听连接成功  io. sockets. on('connection', function (socket) {    console. log('连接成功');    //监听事件event01    socket. on('event01',function(){ // 处理来自客户端的’event01’事件      console. log('监听点击事件');      var datas = [1,2,3,4,5];      socket. emit('event02', {datas: datas}); // 给该客户端发送event02事件      socket. broadcast. emit('event02', {datas: datas}); // 发送给其它客户端    });    //监听事件send    socket. on( send , data =&gt; { // 监听的频道必须和客户端监听的频道相同，等待消息      // io. emit( 监听频道 ,  发送的信息 ); // 向所有客户端发送信息      console. log('客户端发送的内容：', data);      io. emit('getMsg', '我是返回的消息. . . . . . ' + common. currentDateTime());//触发所有用户      // socket. emit('getMsg', '我是返回的消息. . . . . . ' + new Date(). getTime());//触发当前用户      // socket. broadcast. emit('getMsg', '我是返回的消息. . . . . . ' + new Date(). getTime());//触发除去该用户以外的用户      // io. to(socketedId). emit('getMsg', '我是返回的消息. . . . . . ' + new Date(). getTime());//触发指定用户    });    //监听前台发送微信文本消息，并进行消息发送    socket. on( sendWechatText , data =&gt; {      console. log('客户端发送的内容：', data);      var puppet_donut = require('. /donut');      puppet_donut. sendTextMsgToContact(data. friendNick, data. wechatContent);      io. emit('sendWechatTextCallback', '微信消息发送成功. . . . . . ' + common. currentDateTime());//触发所有用户    });    // 更多事件，就更多处理函数    // . . . . . .     socket. on( disconnect , data =&gt; { // 客户端断开链接      console. log('断开连接：', data);    });    socket. on('error', function (err) {  //发生错误时触发      console. log(err);    });    setTimeout( () =&gt; {      socket. emit('getMsg', '我是初始化3s后的返回消息. . . . . . ');    }, 3000)  })};module. exports = socketio;donut服务donut. js文件 该示例主要介绍了引用wechaty包，实现wechaty初始化、加入群聊、退出群聊、消息等监听和多种发送消息函数封装  bot初始化； 实现bot监听（OnMessage、OnRoomJoin…）； 消息发送（文本、媒体、链接等消息）；import { FileBox } from 'wechaty';var puppet_donut = {};//获取bot（机器人）var bot = null;//发送文本消息给联系人puppet_donut. sendTextMsgToContact = async function(friendName, text){  const contact = await bot. Contact. find({name: friendName}); //根据昵称搜索好友 change 'lijiarui' to any of your contact name in wechat  if(!contact) return; //好友不存在直接返回  await contact. say(text); //调用contact对象的say方法发送消息，contact对象很多方法，参考官方文档};//发送媒体消息给联系人puppet_donut. sendMediaMsgToContact = async function(friendName, fileUrl, filePath){  const contact = await bot. Contact. find({name: friendName}); // change 'lijiarui' to any of your contact name in wechat  if(!contact) return;  if(fileUrl){    const fileBox1 = FileBox. fromUrl(fileUrl);    await contact. say(fileBox1)  }  if(filePath){    const fileBox2 = FileBox. fromFile(filePath);    await contact. say(fileBox2)  }};//发送名片消息给联系人puppet_donut. sendContactCardMsgToContact = async function(friendName, contactId){  const contact = await bot. Contact. find({name: friendName}); // change 'lijiarui' to any of your contact name in wechat  if(!contact) return;  const contactCard = bot. Contact. load(contactId);  await contact. say(contactCard);};//发送链接消息给联系人puppet_donut. sendUrlLinkMsgToContact = async function(friendName, description, thumbnailUrl, title, url){  const contact = await bot. Contact. find({name: friendName}); // change 'lijiarui' to any of your contact name in wechat  if(!contact) return;  const urlLink = new UrlLink ({    description : description,    thumbnailUrl: thumbnailUrl,    title    : title,    url     : url,  });  await contact. say(urlLink);};//发送小程序消息给联系人puppet_donut. sendMiniProgramMsgToContact = async function(friendName, username, appid, title, pagepath, description, thumbnailurl){  const contact = await bot. Contact. find({name: friendName}); // change 'lijiarui' to any of your contact name in wechat  if(!contact) return;  const miniProgram = new MiniProgram ({    username      : username,   //get from mp. weixin. qq. com    appid       : appid,    //optional, get from mp. weixin. qq. com    title       : title,    //optional    pagepath      : pagepath,   //optional    description    : description, //optional    thumbnailurl    : thumbnailurl, //optional  });  await contact. say(miniProgram)};//初始化调用puppet_donut. run = function(){  import { Wechaty } from 'wechaty';  import { ScanStatus } from 'wechaty-puppet';  import QrcodeTerminal from 'qrcode-terminal';  import io from '. /socketio';  import config from '. /config';  import onRoomJoin from '. /wechaty/onRoomJoin';   // 加入房间监听回调  import onRoomLeave from '. /wechaty/onRoomLeave';  // 退出房间监听回调  import onMessage from '. /wechaty/onMessage';    // 消息监听回调  import onFriendShip from '. /wechaty/onFriendShip'; // 好友添加监听回调  const token = config. token;  bot = new Wechaty({    puppet: 'wechaty-puppet-service',    puppetOptions: {      token,    },    name: config. name  });  bot    . on('scan', (qrcode, status) =&gt; {      if (status === ScanStatus. Waiting) {        QrcodeTerminal. generate(qrcode, {          small: true        });        io. sendWechatMsg( 请扫描二维码进行登录&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; );      }    })    . on('login', async user =&gt; {      console. log(`user: ${JSON. stringify(user)}`);      io. sendWechatMsg( 登录成功&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; );      var loginInfo = {        nick: config. name,        avatar: user. payload. avatar      };      io. sendWechatLoginMsg(loginInfo);    })    . on( room-join , onRoomJoin)  // 加入群聊监听    . on( room-leave , onRoomLeave) // 退出群聊房间监听    . on( message , onMessage(bot)) // 消息监听    . on( friendship , onFriendShip) // 好友添加监听    . start();};module. exports = puppet_donut;Wechaty监听: 这边重点描述下wechaty的监听示例，这也是为什么单独把几个监听业务给抽出来到wechaty目录下的原因之一。  scan        //扫码登录监听 login        //登录成功监听 room-join    //加入群聊监听 room-leave   //退出群聊监听 message    //消息通知监听 friendship    //好友添加监听初始化:   bot = new Wechaty({    puppet: 'wechaty-puppet-service',    puppetOptions: {      token,    },    name: config. name  });发送文本消息给好友: //发送文本消息给联系人puppet_donut. sendTextMsgToContact = async function(friendName, text){  const contact = await bot. Contact. find({name: friendName}); //根据昵称搜索好友 change 'lijiarui' to any of your contact name in wechat  if(!contact) return; //好友不存在直接返回  await contact. say(text); //调用contact对象的say方法发送消息，contact对象很多方法，参考官方文档};这里传入两个参数  friendName //好友昵称，这里可以调用对象Contact的find({name: friendName})函数进行好友查询 text        //发送的文本内容其他的发送方式在代码里，这里直接看代码，不一一解释（代码详细注释，建议参考官方文档） 监听配置启动:   bot    . on('scan', (qrcode, status) =&gt; {      if (status === ScanStatus. Waiting) {        QrcodeTerminal. generate(qrcode, {          small: true        });        io. sendWechatMsg( 请扫描二维码进行登录&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; );      }    })    . on('login', async user =&gt; {      console. log(`user: ${JSON. stringify(user)}`);      io. sendWechatMsg( 登录成功&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; );      var loginInfo = {        nick: config. name,        avatar: user. payload. avatar      };      io. sendWechatLoginMsg(loginInfo);    })    . on( room-join , onRoomJoin)  // 加入群聊监听    . on( room-leave , onRoomLeave) // 退出群聊房间监听    . on( message , onMessage(bot)) // 消息监听    . on( friendship , onFriendShip) // 好友添加监听    . start();scan（顾名思义，是用于扫码登录的一个监听）:         QrcodeTerminal. generate(qrcode, {          small: true        });这里代码较简单，意思是前面通过 import QrcodeTerminal from 'qrcode-terminal';引用qrcode-terminal模块，用于在终端进行二维码输出，方便我们测试扫码； 我们借助Qrterminal. generate这个API将 qr 码输出到终端而已，后面那个small参数是因为qrcode-terminal 这个包默认输出的二维码很大，给它变小一些； 这边有一个坑，在webstorm上打码的时候，在终端输出的二维码是这样的， 这时候我们需要把这些字符串复制到码农神器notepad++里，如下图 然后进行扫码登录； 这个问题我在centos下测试是没有这个问题，生产上大家不用担心。 onFriendShip: 用于好友监听的监听，这块逻辑比较简单（参看别人代码，直接撸过来的，哈哈哈，在此感谢这位朋友）； 监听好友添加的请求通知，如果打招呼信息hello()内容符合关键词列表，则进行允予通过accept(); 这里我看了官方文档，可实现的业务很多，大家可参考官方api进行更多业务拓展！！！ import { Friendship } from 'wechaty';// 配置文件import config from '. . /config';import io from '. . /socketio';// 好友添加验证消息自动同意关键字数组const addFriendKeywords = config. personal. addFriendKeywords;// 好友添加监听回调module. exports = async function onFriendShip(friendship) {  let logMsg;  try {    logMsg =  添加好友  + friendship. contact(). name();    console. log(logMsg);    switch (friendship. type()) {      /**       * 1. 新的好友请求       * 设置请求后，我们可以从request. hello中获得验证消息,       * 并通过`request. accept（）`接受此请求       */      case Friendship. Type. Receive:        // 判断配置信息中是否存在该验证消息        if (addFriendKeywords. some(v =&gt; v == friendship. hello())) {          logMsg = `自动通过验证，因为验证消息是 ${friendship. hello()} `;          // 通过验证          await friendship. accept()        } else {          logMsg =  不自动通过，因为验证消息是:   + friendship. hello();        }        break;      /**       * 2. 友谊确认       */      case Friendship. Type. Confirm:        logMsg =  friend ship confirmed with   + friendship. contact(). name();        break    }    console. log(logMsg)    io. sendWechatMsg(logMsg);  } catch (e) {    logMsg = e. message  }};onRoomJoin: 这里主要监听用户加入房间的回调 // 配置文件import config from '. . /config';import io from '. . /socketio';// 加入房间回复const roomJoinReply = config. room. roomJoinReply;// 管理群组列表const roomList = config. room. roomList;// 进入房间监听回调 room-群聊 inviteeList-受邀者名单 inviter-邀请者module. exports = async function onRoomJoin(room, inviteeList, inviter) {  // 判断配置项群组id数组中是否存在该群聊id  if (Object. values(roomList). some(v =&gt; v == room. id)) {    // let roomTopic = await room. topic()    inviteeList. map(c =&gt; {      // 发送消息并@      console. log( 【邀请者】：  + inviter +   邀请   + c +   入群 );      io. sendWechatMsg( 【邀请者】：  + inviter +   邀请   + c +   入群 );      room. say(roomJoinReply, c)    })  }};这里我们说明下，如果是在配置白名单roomJoinReply里的群，只要有新人加入，我们就发一个欢迎词并@他下 这些内容我们现在放在config中，实际业务肯定是放在db中，业务启动去获取或实时监听； 此回调接收三个参数  room 群聊实例 inviteeList 受邀者名单 inviter 邀请者有了房间，受邀者，邀请者，这里可实现的业务就多了~~此处啪啦啪啦省略800字… 做一下判断就可以了，这里的room. id就是我们配置的管理群组列表对象roomJoinReply的value值 为什么要有管理群组列表对象呢？因为我们在登录了一个微信号时，群组进入监听是针对微信号中所有群组的 我的需求是要管理我的群组，所以事先跑了下程序，输出了room，然后群里发个消息，就拿到了我想管理的群组所有信息，id自然也在里面，然后写到了配置里，这里输出一个room的聊天信息示例，这里面的roomId就是房号 { _events :{}, _eventsCount :0, id : 2098964982947510281 , payload :{ filename :  , fromId : 发送者微信号 , id : 209896498xxxxx消息唯一id , mentionIdList :[ wxid_diuxkznxxxx群里好友wxid列表 ], roomId : xxxx@chatroom , text : @Oreo 北京天气 , timestamp :1607568215000, toId :  , type :7}}接下来就是，监听到新加入，把受邀者列表遍历一下，使用room. say方法发送群消息即可，受邀者列表里存的就是加入的微信号实例，say 方法第一个参数就是要发送的消息，第二个参数就是为了@此人一下。。。其他业务开发请参考官方文档（再来一个传送门） onRoomLeave: 监听用户退出群聊 import io from '. . /socketio';// 进入房间监听回调 room-群聊 leaver-退群者module. exports = async function onRoomLeave(room, leaver) {  console. log( 群-【  + room. name +  】：  + leaver +   退群 );  io. sendWechatMsg( 群-【  + room. name +  】：  + leaver +   退群 );};这里的业务更简单了，主要是监听用户推出群聊 此回调接收三个参数  room 群聊实例 leaver 退出群聊者onMessage: 主要监听消息的接收     // 判断此消息类型是否为文本    if (msg. type() == Message. Type. Text) {      // 判断消息类型来自群聊      if (msg. room()) {        // 获取群聊        const room = await msg. room();        io. sendWechatMsg('【' + room. payload. topic + '】@' + msg. from(). name() + '：' + msg. text());        if(config. room. autoReturnRoomList. length &gt; 0 &amp;&amp; !config. room. autoReturnRoomList. includes(room. payload. topic)) return;//判断该群是否在阻断名单,如果是空数组，则不阻断        // 收到消息，提到自己        if (await msg. mentionSelf()) {          // 获取提到自己的名字          // let self = await msg. to();//该函数返回null          // self =  @  + self. name();          let self =  @  + config. name;          // 获取消息内容，拿到整个消息文本，去掉 @+名字          let sendText = msg. text(). replace(self,   );          // 请求机器人接口回复          let res = await requestRobot(sendText);          // 返回消息，并@来自人          room. say(res, msg. from());          return;        }        // 收到消息，没有提到自己 忽略      } else {        // 回复信息是关键字 “加群”        io. sendWechatMsg('@' + msg. from(). name() + '：' + msg. text());        if(config. personal. robotBlockList. includes(msg. from(). id)) return;//判断该好友是否在阻断名单        if(!config. personal. robotQunBlockList. includes(msg. from(). id)){//判断该好友是否在群阻断名单          if (await isAddRoom(msg)) return;          // 回复信息是所管理的群聊名          if (await isRoomName(bot, msg)) return;        }        // 请求机器人聊天接口        let res = await requestRobot(msg. text());        // 返回聊天接口内容        await msg. say(res)      }    } else {      console. log( 消息不是文本！ );      io. sendWechatMsg('收到非文本消息');    }这里有个代码块 let self = await msg. to();参考别人的代码，这个协议版本这里获取出来的的是null，所以直接改成替换成自己的name（config中配置），可能是协议或版本不一样，api做了调整；这里我没细查官方api，欢迎补充。 加入群聊监听 这里有个业务点简单描述下，根据用户私聊的的内容，判断是否触发关键词，如果触发直接发送可加的群信息； /** * @description 回复信息是关键字 “加群” 处理函数 * @param {Object} msg 消息对象 * @return {Promise} true-是 false-不是 */async function isAddRoom(msg) {  // 关键字 加群 处理  if (msg. text() ==  wo要加群123 ) {    let roomListName = Object. keys(roomList);    let info = `${name}当前管理群聊有${roomListName. length}个，回复群聊名即可加入哦\n\n`;    roomListName. map(v =&gt; {      info +=  【  + v +  】  +  \n     });    msg. say(info);    return true  }  return false}回复群名进行群邀请 /** * @description 回复信息是所管理的群聊名 处理函数 * @param {Object} bot 实例对象 * @param {Object} msg 消息对象 * @return {Promise} true-是群聊 false-不是群聊 */async function isRoomName(bot, msg) {  // 回复信息为管理的群聊名  if (Object. keys(roomList). some(v =&gt; v == msg. text())) {    // 通过群聊id获取到该群聊实例    const room = await bot. Room. find({ id: roomList[msg. text()] });    // 判断是否在房间中 在-提示并结束    if (await room. has(msg. from())) {      await msg. say( 您已经在房间中了 );      return true    }    // 发送群邀请    await room. add(msg. from())    await msg. say( 已发送群邀请 );    return true  }  return false}AI机器人: 说到微信机器人，肯定不能脱离AI只能回复；这里的业务用到了自动陪聊和天气查询的功能，分别用到了如下api，相关参数配置在config文件，大家自行申请api 参数进行修改  免费机器人     接口文档：http://www. itpk. cn/   这里自行注册，还可以配置自定义回复，无答案回复，自行训练等等    免费天气     接口文档：http://www. tianqiapi. com/   这里官方文档竟然给了个公开能用的appid和appsecret…额。。。大家自行参考文档   这里没什么可细说，主要是调用第三方封装的api，进行一些关键词的自动答复； 涉及到api的http请求，所以需要引入如下两个模块 cnpm install --save requestcnpm install --save urlencode这里小小吐槽下图灵，n年体验过图灵，这回本来想申请图灵的api测试，结果关注官方公众号等渠道体验。。。好吧，竟然没有机器人只能答复，遂找了家免费的AI机器人，希望大家别吐槽不智能~~~哈哈，毕竟itpk也需要慢慢进步嘛 /** * @description 机器人请求接口 处理函数 * @param {String} info 发送文字 * @return {Promise} 相应内容 */function requestRobot(info) {  info = info. trim();  return new Promise((resolve, reject) =&gt; {    let url = `http://i. itpk. cn/api. php?type=json&amp;question=${urlencode(info)}&amp;api_key=${itpkApiKey}&amp;api_secret=${itpkApiSecret}`;    if (info. endsWith( 天气 )) {      info = info. replace( 天气 ,   );      url = `https://tianqiapi. com/api?version=v6&amp;city=${urlencode(info)}&amp;appid=${tianqiAppId}&amp;appsecret=${tianqiAppSecret}`; //https://tianqiapi. com/api?version=v6&amp;appid=94481879&amp;appsecret=kYt0kSZ8  官网demo竟然给了个能用的appid和appsecret      request(url, (error, response, body) =&gt; {        if (!error &amp;&amp; response. statusCode == 200) {          if (body) {            if (!common. isJSON(body)) {              resolve('今天的天气. . . 555');            } else {              let res = JSON. parse(body);              if(res. errcode){                resolve('今天的天气. . . 555. . . 555');              }else {                let send =  【日期】：  + res. date +  （  + res. week +  ）\n  +                   【最近更新时间】：  + res. update_time +  \n  +                   【国家】：  + res. country +  （  + res. countryEn +  ）\n  +                   【城市】：  + res. city +  （  + res. cityEn +  ）\n  +                   【天气】：  + res. wea +  \n  +                   【体感温度】：  + res. tem +  ℃\n  +                   【温度范围】：  + res. tem2 +  ℃~  + res. tem1 +  ℃\n  +                   【风向】：  + res. win +  \n  +                   【风力】：  + res. win_speed +  \n  +                   【湿度】：  + res. humidity +  \n  +                   【能见度】：  + res. visibility +  \n  +                   【气压】：  + res. pressure +  hPa\n  +                   【空气质量】：  + res. air +  \n  +                   【pm2. 5】：  + res. air_pm25 +  \n  +                   【温馨提示】：  + res. air_tips +  \n ;                resolve(send);              }            }          }else {            resolve('再等等吧，今天的天气预报好像. . . 还在路上呢');          }        }else {          resolve('今天的天气预报好像. . . 还在路上呢');        }      });    } else{      request(url, (error, response, body) =&gt; {        if (!error &amp;&amp; response. statusCode == 200) {          if (body) {            if (body. startsWith('?')) {//此处返回的json数据有些问题，额外处理              body = body. replace('?', '')            }            if (!common. isJSON(body)) {              resolve(body);            } else {              let res = JSON. parse(body);              let send;              if (res. type) {                send = '【' + res. type + '】\n \n签号：' + res. number1 + '\n \n';                switch (res. type) {                  case '观音灵签':                    send = send + '好坏：' + res. haohua                      + '\n\n' + '签语：' + res. qianyu + '\n'                      + '\n' + '诗意：' + res. shiyi + '\n'                      + '\n' + '白话：' + res. jieqian + '\n';                    break;                  case '月老灵签':                    send = send + '好坏：' + res. haohua                      + '\n\n' + '诗意：' + res. shiyi + '\n'                      + '\n' + '解签：' + res. jieqian + '\n'                      + '\n' + '注释：' + res. zhushi + '\n'                      + '\n' + '白话：' + res. baihua + '\n';                    break;                  case '财神爷灵签':                    send = send + '签语：' + res. qianyu                      + '\n\n' + '注释：' + res. zhushi + '\n'                      + '\n' + '解签：' + res. jieqian + '\n'                      + '\n' + '解说：' + res. jieshuo + '\n'                      + '\n' + '结果：' + res. jieguo + '\n'                      + '\n' + '婚姻：' + res. hunyin + '\n'                      + '\n' + '事业：' + res. shiye + '\n'                      + '\n' + '功名：' + res. gongming + '\n'                      + '\n' + '失物：' + res. shiwu + '\n'                      + '\n' + '出外移居：' + res. cwyj + '\n'                      + '\n' + '六甲：' + res. liujia + '\n'                      + '\n' + '求财：' + res. qiucai + '\n'                      + '\n' + '交易：' + res. jiaoyi + '\n'                      + '\n' + '疾病：' + res. jibin + '\n'                      + '\n' + '诉讼：' + res. susong + '\n'                      + '\n' + '运途：' + res. yuntu + '\n'                      + '\n' + '某事：' + res. moushi + '\n'                      + '\n' + '合伙做生意：' + res. hhzsy + '\n';                    break;                  default:                }              } else if (res. title) {                send = '【' + res. title + '】\n \n \n' + res. content;              } else {                send =  天呐~~我竟然. . .  ;              }              resolve(send);            }          } else {            resolve( 我. . 我. . 我甚至不知道你在说什么. . .  )          }        } else {          resolve( 你在说什么，我脑子有点短路诶！ )        }      })    }  })}这里有个槽点，调用机器人api，设置返回的数据是json，但是返回的body字符串里开通竟然多个个’-‘，完了还只能在编译器的控制台能看到，放到浏览器和别的编译器显示不出来，只能进行简单替换处理             if (body. startsWith('?')) {//此处返回的json数据有些问题，额外处理              body = body. replace('?', '')            }回归SocketIo 前端操作: 这里为了体验下机器人的代入感，做了个前端demo（很简陋，这里别吐槽。。。就是为了和socket结合一起实时看效果；忽略右上角的红x…调试时中断服务的原因…） 这里简介下nodejs express socketio的一些使用 前端引用socket. io. js，为了方式前后端socket版本不一致带来的问题，强烈建议如下引用方式 &lt;script src= /socket. io/socket. io. js &gt;&lt;/script&gt;会直接调用接口/socket. io目录下的js文件，实际调用到modules目录下的文件 前端建立socket连接 var socket = io(url);建立连接后，监听名为getMsg的事件     socket. on('getMsg', data =&gt; {      console. log('服务端消息：', data);      msg. innerHTML = `${data} &lt;br/&gt;`;    })建立连接，想服务端推送数据（socket. emit()），可以是String，可以是json对象     function sendWxmsg(){      var friendNick = document. querySelector('#friendNick'). value;      var wechatContent = document. querySelector('#wechatContent'). value;      if(!friendNick || !wechatContent){        alert( 请输入信息 );        return;      }      var wechatSend = {        friendNick: friendNick,        wechatContent: wechatContent      };      socket. emit('sendWechatText', wechatSend);    }回归SocketIo 后端操作: 初始化socketio io = require( socket. io )(server);监听客户端的连接，这里socketio知识点很多，比如多客户端连接。通过id和session区分等，建议搭建参考官方文档，官方对socketio支持很赞，java，python，nodejs等等 io. sockets. on('connection', function (socket) {});事件监听，这里举例’send‘事件监听，具体触发如下  调用初始化的io进行emit()或send()，可向所有用户推送该消息（适用场景向所有客户端推送紧急通知） 调用该监听通道，向当前用户回复消息socket. emit() 调用当前监听通道，向出自己外的其他用户进行广播推送socket. broadcast. emit() 调用初始化的io向某个客户端进行单独的消息推送io. to(socketedId). emit()    //监听事件send    socket. on( send , data =&gt; { // 监听的频道必须和客户端监听的频道相同，等待消息      // io. emit( 监听频道 ,  发送的信息 ); // 向所有客户端发送信息      console. log('客户端发送的内容：', data);      io. emit('getMsg', '我是返回的消息. . . . . . ' + common. currentDateTime());//触发所有用户      // socket. emit('getMsg', '我是返回的消息. . . . . . ' + new Date(). getTime());//触发当前用户      // socket. broadcast. emit('getMsg', '我是返回的消息. . . . . . ' + new Date(). getTime());//触发除去该用户以外的用户      // io. to(socketedId). emit('getMsg', '我是返回的消息. . . . . . ' + new Date(). getTime());//触发指定用户    });此demo的核心代码基本就介绍这么多了… 总结: 写在最后:  config的很多配置在实际业务中应业务化处理，比如db化接受实时操作； 关于wechaty，根据个人的体验，除了没有朋友圈，视频号相关的内容操作，其他的基本满足机器人、私域相关的操作，支持多语言，提供Java，Go，Python，Javascript，C#等主流语言的兼容支持，根据官方api，业务可扩展性极强； 关于nodejs，由于作者之前并没有nodejs实战开发经验，也是基于这个demo看了nodejs相关文档，学习express框架初学，提供不了太多解读。不过nodejs基于脚本语言，学习起来还是很快； 关于socketio，和nodejs结合在一起，体验nodejs的异步非阻塞，简直要起了飞； 环境     系统：win7、centos7. 6成功运行   nodejs版本：windows下调试：v16. 16. 2；centos：v10. 16. 0；（wechaty对node版本有要求，不同协议版本最低要求不一致，大家自行参考开源说明和官方文档）    代码     主要是抽空码出来的，没有太多时间优化   有一些业务代码写好了，但是并没有接入使用，欢迎大家补充                         刚开始查找微信助手相关功能时在CSDN看到这篇文章[《Wechaty       不使用微信的web协议的机器人》](https://blog. csdn. net/lx91216/article/details/106257248)，勾起了我对wechaty的回忆和探索，因此这篇文档很多内容上也是参考了它（时间关系甚至直接搬运，希望原文作者原谅哈…）                     源码直通车→点我《wechaty-robot-lite》   后面有空，会持续迭代功能，后续需求扩展  推送     例如每日早8点，拉取头条热门文章发送至群聊   可设置定时任务，定时给自己/群聊发送消息   好友可定制天气预报定时推送功能    消息监听发送     同步展示推送媒体消息等   支持发送动图，表情包等信息   开启斗图模式    群聊功能消息管理     监听群聊中消息，有不正当言论时或不文明用语对其警告   涉zheng，涉huang等言论清除出群    群聊游戏 后台管理系统(可视化配置及群聊数据统计)     丰富聊天功能，提供媒体消息发送，资源库内容发送   统计群聊活跃度，关键词通知统计功能   PS：: 这篇文档说的最多的应该是”官方文档“四个字了吧，这里再点一下，认真看文档！！！ 参考文档:  Wechaty官方API Wechaty官方文档 Wechaty官方示例 socketio nodejs express框架效果截图:  待完结 "
    }, {
    "id": 185,
    "url": "https://wechaty.js.org/2020/12/10/bridge-between-backend-and-wechat/",
    "title": "沟通后端系统和微信消息的桥梁",
    "body": "2020/12/10 - 困惑于各类后端系统与同事、客户和其他相关方的沟通：一方面是后端系统纷繁复杂，开发语言众多；另一方面是不同人群对邮件、短信等各自的喜好程度不同，相对而言，微信是商务人群中使用量较大的，虽然微信提供了公众号等方式集成，但恰恰是大多数微信使用者只会在非常必须才会去用的服务方式。 之前基于微信网页版的插件较多，也尝试过集成，不幸的是微信收掉了绝大多数微信用户的网页版登录权限。最近一个偶然机会接触到wechaty，阅读了先前贡献者们的经验分享，立即有了参与的冲动，按机器人指导完成了注册获取token，开始了体验开发之旅。 超小的微信网关: 本来最熟悉Java，但wechaty是js的，正好也用nodejs在做其他工作，就从它开始吧。考虑到需要与其他系统集成，将wechaty封装成微信通讯网关，设计使用restful的双向调用，解耦网关和后端系统。虽然最近特别事杂，紧赶慢赶也终于在15天token有效期完成了最小化产品的提交，可以满足包括好友、微信群操作和文字类消息互动的全部商务需求，仅仅100行代码出头。运行也很简单，参考README即可： 感谢wechaty提供了很好的思路，感谢wechaty-puppet提供了良好的设计，让我能够站在巨人肩膀之上快速完成工作，感谢所有帮助过和感兴趣的小伙伴！ 经过一段时间测试，基本没发现掉线，服务也正常。如果喜欢，请了解体验审阅 https://github. com/johnwang71/wechaty-integration 这段短小的代码，更欢迎提出好的建议和问题！ "
    }, {
    "id": 186,
    "url": "https://wechaty.js.org/2020/12/08/wechaty-bot-hostie/",
    "title": "基于Wechaty开发的群聊小助手",
    "body": "2020/12/08 - GitHub上搜了一圈，看到了挺多微信bot的方案，后面决定使用wechaty，因为感觉设计得很优雅，6行代码就可以轻松构建一个wxbot。  官方文档文档近期正在频繁更新中 目前的需求很简单，在猫群里置放一个可以唠嗑可以玩游戏的机器人 实现了几个功能  成语接龙 看图猜成语 接入了图灵机器人未实现  根据前一天聊天内容生成词云 猫粮查询 猫疾病的查询目前图灵机器人聊天使用了第三方的接口，需要注册天行api方可使用，token需填入. env文件中 核心代码 const bot = new Wechaty({ puppet: 'wechaty-puppet-service', puppetOptions: {  token, }});bot . on('scan', (qrcode, status) =&gt; {  if (status === ScanStatus. Waiting) {   QrcodeTerminal. generate(qrcode, {    small: true   })  } }) . on('login', async user =&gt; {  console. log(`user: ${JSON. stringify(user)}`) }) . on('error', (error) =&gt; {  console. error(error) })async function main() { await bot. start() // 储存一波数据 let store: any = [] _config. activeRoomIds. forEach(async item =&gt; {  const room = await bot. Room. find({topic: item})  if (room) {   store. push({    id: room. id,    active: ''   })    // 群信息   room. on('message', async (message) =&gt; {    roomMessageHandler(message, room, store)   })   room. on('join', (inviteeList, inviter) =&gt; {    roomJoinHandler(room, inviteeList, inviter)   })  } })}main()由于padplus马上要废弃，所以使用的是puppet-service，具体api可以查看官网文档，目前有少许功能并未实现，比较遗憾，等后续功能更加完善，准备用vue3+express做一个后台的管理系统，方便管理机器人。 安装: npm install运行: npm run main 作者: Penley 前端开发工程师Code: Github 微信机器人，群聊小助手 "
    }, {
    "id": 187,
    "url": "https://wechaty.js.org/2020/12/08/python-wechaty-open-source-journey/",
    "title": "Python-Wechaty 南京开源峰会之旅",
    "body": "2020/12/08 - 开源应该是每一个优秀程序员的必经之路 python-wechaty之开源软件2020峰会: 非常有幸能够参加此次是开源软件供应链2020峰会，本次峰会由中国科学院软件研究所、openEuler社区主办，中科院软件研究所南京软件技术研究院承办，峰会主题为“共献·开源”，包括1个主论坛、7个分论坛以及1场学生专题报告，而我代表wechaty社区导师之一参加此“开源&amp;教育”分论坛的分享活动，会上有来自全国各地的开源软件从业者、企业技术专家、高校及科研机构代表、开源社区代表、学生等300余人现场参会、2. 3万余人同步线上参会。 我是如何开始python-wechaty开源项目的: 其实一切都要从一场活动开始…  各位同学以及已经工作了的同事，都可以尝试着参加一些开放性的沙龙和技术峰会，在会上你能够和其他人交流想法，探讨问题，结识志同道合的人，收获你意想不到的体验。 在分享会上我了解到wechaty项目，特别是被佳芮的live coding环节吸引到了，通过简单的几行代码就可以开发一个非常好玩的聊天机器人，接下来通过一段时间的学习和探索掌握了wechaty的基本使用。 然而，最初的wechaty版本只有TypeScript版本，并没有目前的多语言版本，而我自己又是一个python的忠实粉丝，觉得这么好用的一个开源框架怎么可能没有一个python开发版本呢？这个疑问一直围绕在我的心头。 终于，在今年二月份疫情期间，大家都被困在家里，预期说被困，不如说是解放。因为我们拥有大把的时间坐在房间，和网友讨论各种问题，而wechaty社区尤为活跃，当是我已能够帮助大家解决一部分问题。 突然，其中就有人开始问我心目中的那个问题了：为什么wechaty没有一个python版本的开发框架呢？作者（李卓桓）便开始鼓励我们上手开发，而我当时第一个报名（也不知道当时有什么勇气，现在看来非常感谢当初的那份无畏勇气），经过了两个月的折腾之后，便有了python-wechaty的第一个ding-dong版本。 开源项目并没有你想的那么难: 其实在这两个月期间我过的还是挺痛苦的，因为作者（李卓桓）给python-wechaty制定的代码质量要求还挺高的（高是一个相对性词），需要经过各种代码审查才能够通过，而这些代码审查的工具我是从来都没有用过，在实际开发的过程中遇到了各种坑儿。让我印象最深刻的就是需要解决python中最经典的问题：包的循环引用的问题。虽然解决方案有很多，可是需要寻找一种能够通过严格代码审查的解决方案对应当时我的而言还是非常有难度。 在开发的过程中，每个函数的命名，注释以及代码风格当时都做了很多的讨论，让我印象最深刻的就是关于数组类型的命名的讨论：比如好友ID列表变量命名，有room_ids 和 room_id_list 两种风格的讨论。通过这些非常细致的技术讨论，让我对编程有了一个全新的认识：写代码并不只是完成了一个功能就行了，而是需要在阅读性，代码风格，代码鲁棒性等各个层面作出权衡。 虽然以上都是一些小细节的问题，可是正是细节处才能够体现出能力，而只需要付出足够的时间，就能够被解决，你就能够拥有这些能力。 所以开源项目并没有你想象的那么难，只需要你付出足够的努力就可以获得对应的硬实力。 开源项目并没有你想的那么简单: 自从开源项目逐步稳定，参与的人也越来越多，于是你作为项目的主要推动人，需要组织和管理项目的issue和pull request，需要协调参与项目的每个人，而大家都是来自于开源社区，处于一个松散合作，并非使用强制性约束来做项目，所以此时的项目管理就变得非常难以推动。 于是我请教了wechaty开源社区多个不同的作者，他们不吝赐教，给予我非常多有价值的建议以及未来的一些规划的看法，于是我开始进行一些调整，和团队的人积极沟通每一个细节问题，并能够顺利的基于github中的issue和pr来管理所有的事情。 开源项目其实是一种以开源的思想来和世界上任何一个人合作开发，并没有一种强制性的约束，更多的是开放性思维来协作，这些东西都是需要深度学习的， 所以开源项目并没有你想象的那么简单，只需要你付出足够的坚持就可以获得对应的软实力 一定要积极参加开源项目: 其实很多开源项目都非常欢迎新鲜的血液，也愿意去指导那些愿意学习的同学，所以如果你有一颗想要开源的心，就勇敢的尝试参与开源项目把，在里面你将收获非常多的提升和帮助，也会帮你认识很多优秀的人。 Talk: Multi-Wechaty SDK for Chatbot:   YouTube: https://youtu. be/ncSWIRtHyAo Vlog： Wechaty社区南京开源峰会之旅:   YouTube: https://youtu. be/0ARx1cCf5p0 "
    }, {
    "id": 188,
    "url": "https://wechaty.js.org/2020/12/07/puppet-wxwork-beta-release/",
    "title": "Wechaty Puppet Service WxWork Beta 版发布公告",
    "body": "2020/12/07 - 恭喜 WxWork 作为 Wechaty 社区新的 Puppet Service 正式进入 Beta 版！经过历时一个月的测试，WxWork 现在已经通过社区验证，可以正式售卖给社区的小伙伴了！ 想要使用的，请点击wxwork 购买链接 购买吧！ 关于 Wechaty Puppet Service WxWork: WxWork 是 juzibot 基于 wechaty-puppet-service 做的新 puppet service，句子互动围绕微信生态为客户提供智能营销和销售服务，帮助企业引流并实现转化，客户覆盖教育、保险、大健康等多个领域。曾入选百度AI加速器 和 Facebook 大陆首期加速器，获得PreAngel、Plug and Play，Y Combination, TSVC和阿尔法公社多家中美机构投资。 而在今年，句子互动更加聚焦在企业微信，通过为客户提供 SCRM 系统帮助客户实现引流和转化，因此今年发布了 企业微信 的 puppet。 关于 Wechaty Puppet WxWork Beta 版的发布历程如下： WxWork 的 Alpha Release:  写一个 getting started 告诉开发者如何将这个 puppet 跑起来: https://github. com/juzibot/wxwork-tester puppet service provider 的 token 要通过 api. chatie. io 发布，以最大化提升开发者社区体验。 token 设置规范为：puppet_wxwork_XXX为了能让开发者更好的了解如何运行 WxWork, 在这里给出大家运行的最小化代码： import { Wechaty } from 'wechaty'import { ScanStatus } from 'wechaty-puppet'import QrcodeTerminal from 'qrcode-terminal';const token = 'get a wxwork token from: https://github. com/wechaty/puppet-services#buy-token'const bot = new Wechaty({ puppet: 'wechaty-puppet-service', // 注意这里是 wechaty-puppet-service 而不是 wechaty-puppet-wxwork puppetOptions: {  token, }});bot . on('scan', (qrcode, status) =&gt; {  if (status === ScanStatus. Waiting) {   QrcodeTerminal. generate(qrcode, {    small: true   })  } }) . on('login', async user =&gt; {  console. log(`user: ${JSON. stringify(user)}`) }) . on('message', async message =&gt; {  console. log(`message: ${JSON. stringify(message)}`) }) . start()介绍 wechaty-puppet-service:  This part is written by Huan 在 Wechaty 的发展过程中，我们曾经发布过很多 Wechaty Puppet ，比如 Web 协议的 wechaty-puppet-puppeteer， Pad 协议的 wechaty-puppet-padplus ，Mac 协议的 wechaty-puppet-macpro，iOS 协议的 wechaty-puppet-iosbird ，等等。 所以，如果你是一个随着 Wechaty 发展一路走来的开发者，那么你会记得，过去每一个不同的协议，我们都需要在运行 Wechaty 的本地环境中，安装上述的 NPM 包，来启用对应的协议。 然而，Wechaty 社区在发展过程中，我们发现其实针对不同的协议，其核心的区别在于 Wechaty Puppet Abstract Class 这个抽象层之下的逻辑实现，而 Wechaty Puppet API 是完全一致的。所以，我们如果能够把 Wechaty Puppet API 及其之上层的代码重用，而将其之下层面的代码进行 gRPC 化封装，这样我们就能够通过一个 Wechaty Puppet 的实现，最终得以支持不同的底层协议。这就是 wechaty-puppet-service 的由来。 简而言之，Wechaty Puppet Service 是一个可以兼容任意 Wechaty Puppet 协议的模块，Wechaty 只需要安装 wechaty-puppet-service ，然后通过设置 WECHATY_PUPPET_SERVICE_TOKEN，即可通过 gRPC 协议，与 token 所对应的 gRPC 服务器进行通讯，实现 Wechaty Puppet Service 化，而提供 Wechaty Puppet Service 的第三方，既是我们称之为 Wechaty Puppet Service Provider 的角色。 在未来，Wechaty 社区计划大部分的 Puppet Service 都将基于 wechaty-puppet-service 进行发布和使用。同时针对某些特定的 Puppet Service ，比如 wechaty-puppet-padlocal (PadLocal可以使用本地服务器 IP 与 Server 进行连接），也可以通过本地运行一个 Puppet Service Token Gateway 进行转换。（详见 Issue #1986) 目前，在社区最佳实践中，使用 wechaty-puppet-service 的方法如下： export WECHATY_PUPPET=wechaty-puppet-serviceexport WECHATY_PUPPET_SERVICE_TOKEN=__YOUR_TOKEN__// Start your bot with the above two variablests-node bot. ts在上面的 __YOUR_TOKEN__ 可以是任何的 Wechaty Puppet Service Token。了解如何获取 Wechaty Puppet Service Token 可以官网介绍： https://wechaty. js. org/docs/puppet-services/ WxWork 的 Alpha Test: WxWork 通过了 Alpha test 的内容，以下是 Rock 支持的功能清单，并和已有的Puppet进行对比。 Puppet Comparison:       Puppet   wxwork   rock   donut   padplus         支持账号   企业微信   个人微信   个人微信   个人微信                              收发文本   ✅   ✅   ✅   ✅       收发个人名片   ✅   ✅   ✅   ✅       收发图文链接   ✅   ✅   ✅   ✅       发送图片、文件   ✅   ✅（较慢）   ✅   ✅（对内容有大小限制，20M以下）       接收图片、文件   ✅   ✅   ✅   ✅（对内容有大小限制，25M以下）       发送视频   ✅   ✅（较慢）   ✅   ✅       接收视频   ✅   ✅   ✅   ✅       发送小程序   ✅   ✅   ✅   ✅       接收动图   ✅   ❌   ❌   ✅       发送动图   ✅   ✅（以文件形式发送）   ✅   ✅       接收语音消息   ✅   ❌   ✅   ✅       发送语音消息   ❌   ❌   ❌   ❌       转发文本   ✅   ✅   ✅   ✅       转发图片   ✅   ✅   ✅   ✅       转发图文链接   ✅   ❌   ✅   ✅       转发音频   ✅   ❌   ✅   ❌       转发视频   ✅   ✅   ✅   ✅       转发文件   ✅   ✅   ✅   ✅       转发动图   ✅   ❌   ❌   ❌       转发小程序   ✅   ✅   ✅   ✅                              创建群聊   ✅   ✅   ✅   ✅       设置群公告   ✅   ✅   ✅   ✅       获取群公告   ❌   ✅   ❌   ✅       群二维码   ❌   ❌   ❌   ✅       拉人进群   ✅   ✅   ✅   ✅       踢人出群   ✅   ✅   ✅   ✅       退出群聊   ❌   ✅   ✅   ✅       改群名称   ✅   ❌   ✅   ✅       入群事件   ✅   ✅   ✅   ✅       离群事件   ✅   ✅   ✅   ✅       群名称变更事件   ✅   ❌   ✅   ✅       @群成员   ✅   ✅   ✅   ✅       群列表   ✅   ✅   ✅   ✅       群成员列表   ✅   ✅   ✅   ✅       群详情   ✅   ✅   ✅   ✅                              修改备注   ✅   ❌   ✅   ✅       添加好友   ✅   ❌   ✅   ✅       自动通过好友   ✅   ✅   ✅   ✅       好友列表   ✅   ✅   ✅   ✅       好友详情   ✅   ✅   ✅   ✅                              登录事件   ✅   ✅   ✅   ✅       扫码状态   ❌   ❌   ❌   ✅       登出事件   ✅   ❌   ✅   ✅       主动退出登录   ❌   ✅   ✅   ✅       依赖协议   Windows   iPad   Windows   iPad   WxWork 的 Beta Test:  压力测试：      项目名   详情   状态         crash   崩溃，测扫码登录ready事件顺序是否正常   通过       flood-message   群发消息，测大批量发消息是否都有回调   通过       group-chat   群聊功能，测群加载人数，建群离群操作是否正常   通过       loading   加载，测加载时长，联系人和群的数量是否匹配   通过       loading-lost-tag   测启动奔溃导致的标签备注丢失问题   通过       receive-and-send-message   测收发不同类型的消息都正常   通过       receive-small-image   测试是否有收不到小图片的情况   测试是否有收不到小图片的情况    产品测试：     通过句子秒回的在线测试，详见Product Test   WxWork 的产品测试，已完成 100%，同时，句子互动 提供基于企业微信的 SCRM 系统，并基于 WxWork 提供了可视化的工具，有兴趣的小伙伴也可以来 句客宝 通过企业微信扫码登陆后体验。 最后，要在此感谢 puppet provider 为社区持续做出如下贡献：:  为每个 wechaty contributor 提供2个免费token 未申请开源激励计划的开发者，提供15天的免费测试token"
    }, {
    "id": 189,
    "url": "https://wechaty.js.org/2020/11/14/summer-2020-wechaty/",
    "title": "开源软件供应链点亮计划暑期 2020 公布结果：基于 Wechaty 开发的项目斩获突出贡献奖和最具潜力两大奖项！",
    "body": "2020/11/14 - “暑期2020”是由中科院软件所与 openEuler 社区共同举办、中科院软件研究所南京软件技术研究院承办的一项面向高校学生的暑期活动，旨在鼓励高校在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。 该活动从 5 月份开始，参与活动的学生可自主选择感兴趣的项目，与社区导师沟通实现方案并撰写项目计划书。被选中的学生在社区导师指导下，按计划完成开发工作，并将成果贡献给社区。经过为期 3 个月的开发，活动正式落下帷幕。 此次活动共吸引42家社区、34所高校、388个项目加入，这其中不仅有Linux、Apache、CNCF 等国际顶级开源基金会支持的开源项目，也有Wechaty等国内顶级开源项目。 在本次活动中，Wechaty社区基于Puppet、Plugin等不同方向，为暑期2020定制了开发任务，并安排资深导师与申请者沟通方案，指导学生按计划完成开发。 Wechaty是2016年基于Apache-2. 0许可证发布的开源对话式交互人机界面SDK，具备极简开发、多语言、丰富组件等关键能力，并支持微信、Whatsapp、Gitter、飞书、快手等各大即时通讯工具对话平台，已经广泛应用在教育、零售、社区管理等领域，开发者来自腾讯、百度、阿里、Google、微软等多家公司，在 GitHub 上被近万名开发者收藏（star）。 经过3个月的努力，最终151位同学通过了结项审核，同学们的结项报告及日常研发工作得到了社区及组委会的一致认可。从项目角度（项目完成质量、代码的可读性、文档的完整度使得项目具有可延续性）、社区角度（学生对社区的贡献度、完成项目对社区的重要性等）、学生角度（学生参与活动的进步程度和快速学习能力）、开源角度（学生展现出未来持续贡献开源的潜力和意愿）等多方面综合评审后，得出了暑期2020的最终奖项！  Wechaty 社区的 @univerone (江姗姗) 同学荣获暑期2020的优秀学生突出贡献奖！ Wechaty 社区的 @kxz18 (孔详哲) 同学荣获暑期2020的优秀学生最具潜力奖！“暑期2020”为高校学生提供了绝佳的、友好开放的交流平台。使学生可以真正投身于开源软件的开发维护，得到资深开源软件开发者指导的机会，促进开源软件在国内的发展和优秀开源软件社区建设，增加开源项目在国内的活跃度，在开源领域与世界接轨。 附：Wechaty 开源软件供应链点亮计划暑期 2020 招募书:  "
    }, {
    "id": 190,
    "url": "https://wechaty.js.org/2020/11/14/summer-2020-summit-talks/",
    "title": "开源专题论坛：Wechaty 的开源之路",
    "body": "2020/11/14 - 11 月 14 日 - 11 月 15 日由中国科学软件研究所与 Open Euler 社区共同主办的开源软件供应链 2020 峰会在南京玄武苏宁诺富特酒店盛大举行，Wechaty 社区作为“开源软件供应链点亮计划-暑期 2020”的参与社区也受邀出席了峰会，并由李卓桓在开源文化会场分享了 Wechaty 的开源之路，吴京京在开源教育会场分享了 Multi-Wechaty SDK for Chatbot。 峰会现场众多开源负责人、社区代表、各大高校及研究机构的老师、行业领军企业的技术专家等，共同就各自领域的开源经验及开源软件供应链展开深入探讨交流。 Wechaty 是 2016 年基于 Apache-2. 0 许可证发布的开源对话式交互人机界面 SDK，具备极简开发、多语言、丰富组件等关键能力，并支持微信、Whatsapp、Gitter、飞书、快手等各大即时通讯工具对话平台，已经广泛应用在教育、零售、社区管理等领域，开发者来自腾讯、百度、阿里、Google、微软等多家公司，在 GitHub 上被近万名开发者收藏（star）。 Wechaty 开源之路: Wechaty 作者 Huan 在开源文化分会场做报告：Wechaty 开源之路   YouTube: https://youtu. be/DMMGB-32LFM 现场花絮：Wechaty 社区的好朋友们:  "
    }, {
    "id": 191,
    "url": "https://wechaty.js.org/2020/11/10/six-lines-code-two-ai-mvps-one-chatbot/",
    "title": "Microsoft MVP Blog: Six Lines Of Code. Two MVPs. One Chatbot.",
    "body": "2020/11/10 - Six lines of code. Two MVPs. One chatbot. This is the proposition behind Wechaty, a RPA SDK which enables for bot development with just six lines of JavaScript, Python, Go, and Java, and cross-platform support including Linux, Windows, MacOS, and Docker. Created by AI MVPs Jiarui Li and Huan Li, the open-source repository on GitHub has enabled more than 10,000 developers from countries around the world to make AI chatbots and connect to each other. “We found that although the chatbot has become one of the hot spots of the internet and something which has been integrating and affecting everyone’s lives, for most developers it remained really difficult to build a chatbot,” the Chinese duo says. “Now, thanks to Microsoft AI techniques like BotFramework and Cognitive Service, developers can build a chatbot quickly without any mathematical and algorithmic skills. With Wechaty, developers can use basic software and engineering skills to build an intelligent chatbot at a very low cost. ” For developers, Wechaty helps raise working efficiency and save time in three ways. First, developers save the time of creating a basic framework, which usually takes three to six months. Second, the open-source ecosystem enables developers to leverage the work of others in their solutions. Third, Wechaty supports dozens of instant messaging platforms, so one chatbot can be migrated seamlessly between WeChat, WeChat Work, Gitter, WhatsApp, DingDing, Telegram, and others. Launching in 2016, the duo has since built Microsoft AI plugins for Wechaty and given several tech talks at Microsoft Summit. Moreover, the duo has published a book, titled “Chatbot Zero to One: Practice Guide to Conversational Interaction Design,” in order to share their experience of building a chatbot using Microsoft technology. During its history, Wechaty has been updated 24 times, attracted about 10,000 developers, and received more than 100 contributors. “We built Wechaty to provide the community with a good communication platform,” the duo says. “They are passionate to test, find problems, and submit the quantity of pull requests to help Wechaty repair and grow in return. Certainly, we could say that without these fantastic contributors and community, we could not have today’s high-quality Wechaty!” Wechaty actively supports this community with hundreds of technical blogs and videos, docs, and case studies available on the official website. Further, the team organizes Bot Friday, a weekly club for chatbot builders and chatbot entrepreneurs which discusses and explores technical problems. “As Microsoft MVPs, we are always excited to hear “Thank you for sharing. Your project helps us to understand how AI-related projects can make a positive difference in the world’,” the duo says. “In the future, we have a great vision to upgrade Wechaty from a Conversational SDK to SaaS, which will offer a more convenient and efficient service to everyone. ” For more on Wechaty, check out their Github.  Source: Microsoft MVP Award Program Blog "
    }, {
    "id": 192,
    "url": "https://wechaty.js.org/2020/11/10/product-spider-for-sharing/",
    "title": "基于Wechaty打造实时爬取产品信息并分享给用户群",
    "body": "2020/11/10 - 基于Wechaty打造实时爬取产品信息并分享给用户群 1. 主要功能: 公司想实现通过爬取walmart的降价信息或者是新入库的产品来提供给客户，方便客户及时地获得这些信息，用来抢购。  通过walmart提供的api，用python多线程异步地爬取产品，从而得到降价信息 python把读取到的产品写入一个具有‘read false’标志位的txt文件中 wechaty通过设置定时任务读取这个txt文件，并将标志位置为‘read True’ wechaty处理爬取到的字符串，并将处理后的产品图像，产品信息实时的发送到群聊中2. Wechaty框架介绍: Weachaty 是一个开源的的对话机器人 SDK，支持个人微信号。它是一个使用Typescript 构建的Node. js 应用。支持多种微信接入方案，包括网页，ipad，ios，windows， android 等。同时支持Linux, Windows, Darwin(OSX/Mac) 和 Docker 多个平台。在GitHub上可以找到很多支持微信个人号接入的第三方类库，其中大多都是基于Web Wechat的API来实现的，如基于Python的WeixinBot，基于Node. js的Wechaty等。少数支持非Web协议的库，大多是商业私有闭源的，Wechaty是少有的开源项目支持非Web协议的类库。且目前来讲，Wechaty已经开始陆续支持多种编程语言了（Go、Python、Java等等）。官方说只需要6行代码，就可以做到自动管理微信消息了。 import { Wechaty } from 'wechaty'Wechaty. instance(). on('scan',     qrcode   =&gt; console. log('扫码登录')). on('login',    user    =&gt; console. log('登录成功：' + user)). on('message',   message   =&gt; console. log('收到消息：' + message)). on('friendship',  friendship =&gt; console. log('收到好友请求：' + friendship)). on('room-invite', invitation =&gt; console. log('收到入群邀请：' + invitation)). start()可以看到，Wechaty能做到的事情很多，可以收消息、发消息、好友管理、群管理，更多功能可以参考官方文档中文版、英文版英文版的文档更新更全更新。 3. 安装Wechaty: 原本一开始我是想着用Python版本的 Wechaty 的，因为爬虫写的也用的是python，这样就可以直接把机器人和爬虫更好的整合，但是python版本的机器人运行时会出现报错，所以就选择了社区更为完善的ts版本。对于typescript语言来说是javascript的一个超集，对于使用过React框架开发的人员来说还是比较友好的。 使用wechaty: 我使用的系统是windows10，第一步首先是在github处克隆源码 git clone https://github. com/wechaty/wechaty-getting-started. git安装完毕进入文件夹目录下，下载相关的依赖 npm installnpm start如何使用Wechaty: 本来想图个方便使用网页版微信来实现这些功能，但是由于微信官方的原因，我的账号的网页版功能已经不能使用，所以就只好使用padplus的令牌来实现微信机器人的功能，首先要初始化wechaty类 const bot = new Wechaty({ name: 'ding-dong-bot', /**  * Specify a `puppet` for a specific protocol (Web/Pad/Mac/Windows, etc).  *  * You can use the following providers:  * - wechaty-puppet-service  * - wechaty-puppet-puppeteer  * - padplus - project  * - etc.  *  * Learn more about Wechaty Puppet Providers at:  * https://github. com/wechaty/wechaty-puppet/wiki/Directory  */ puppet: puppet,})const token = 'your token'const puppet = new PuppetPadplus({ token,})为了实现业务逻辑，那么必须要调整onlogin()函数的功能，在里面加入main()函数，当然main是一个定时器函数，设定间隔读取爬虫和机器人的接口文件，如果读取到了，就接下来找到群来发送读取到的信息。 function onLogin (user: Contact) { log. info('StarterBot', '%s login', user) main()}async function main () { let imagehref0 = '' let jslistofpd0 = '' let flagOfSay = 0 // let imagehref1 = '' let jslistofpd1 = '' // let imagehref2 = '' // let jslistofpd2 = '' // todo 改变文件路径位置，与沃尔玛的文件位置同源 setInterval( function () {  fs. readFile(   'D:\\scriptworm\\walmart-data-local\\productPriceDropAndRestock0. txt',   (err:any,data:any) =&gt;  {   if (err) {       console. error(err)       return      }   console. log('[datatostring]', data. toString())   // imagehref0 = jslistofpd0. substring(jslistofpd0. search(/imagehref/) + 10, jslistofpd0. search(/FFFFFF/) + 6)   // jslistofpd0 = jslistofpd0. substring(jslistofpd0. search(/name/), jslistofpd0. search(/onlyapi/) + 7)   let str1 = data. toString()   let a1 = str1. search(/_read_False_/)   console. log(a1)   let a2 = str1. search(/_read_True_/)   console. log(a2)   if (a1 == 0) {    // todo: contact. say(something)    console. log(str1)    jslistofpd0 = data. toString()    console. log(jslistofpd0)    imagehref0 = jslistofpd0. substring(jslistofpd0. search(/imagehref/) + 10, jslistofpd0. search(/FFFFFF/) + 6)    jslistofpd1 = jslistofpd0. substring(jslistofpd0. search(/购物链接/) + 5, jslistofpd0. search(/%3Faffp1%3D/))    jslistofpd0 = jslistofpd0. substring(jslistofpd0. search(/商品名称/) + 5, jslistofpd0. search(/购物链接/))    fs. writeFile('D:\\scriptworm\\walmart-data-local\\productPriceDropAndRestock0. txt', '_read_True_', () =&gt; {flagOfSay = 1})          }  } ) }, 1000* 10) setInterval(async function () {   if(imagehref0 != '') {    let fileBox0 = FileBox. fromUrl(imagehref0)    //const contac = await bot. Contact. find({name: 'xxx'})     const contac = await bot. Room. find({ topic: 'your wanted room' })    // await new Promise(() =&gt;    if (contac &amp;&amp; flagOfSay == 1) {     await contac. say(jslistofpd0)      . then(() =&gt; setTimeout(function () { contac. say(jslistofpd1)}, 1000))      . then(() =&gt; setTimeout(function () { contac. say(fileBox0)}, 2000))     flagOfSay = 0    }   }  }, 1000 * 10)}这里不少的功能都可以在wechaty的官方文档有所解释，比如filebox(用于发送图片等复杂信息)，还有诸如contact. say()，room. say(). 对于typescript语言的异步功能可以参阅JavaScript的官方文档，大同小异，可以直接在ts文件里面写js的代码，只需要指定一些变量的属性。下面是完整的代码(出于隐私问题，令牌以及群名已被替换掉) /** * Wechaty - WeChat Bot SDK for Personal Account, Powered by TypeScript, Docker, and 💖 * - https://github. com/wechaty/wechaty */import { FileBox } from 'file-box'import { Contact, Message, ScanStatus, Wechaty, log,}        from 'wechaty'import { generate } from 'qrcode-terminal'import { PuppetPadplus } from 'wechaty-puppet-padplus'// You can safely ignore the next line because it is using for CodeSandboxrequire('. /. code-sandbox. js')import fs from 'fs'const token = 'puppet_padplus_xxxxxx'const puppet = new PuppetPadplus({ token,})function onScan (qrcode: string, status: ScanStatus) { if (status === ScanStatus. Waiting || status === ScanStatus. Timeout) {  generate(qrcode, { small: true }) // show qrcode on console  const qrcodeImageUrl = [   'https://wechaty. js. org/qrcode/',   encodeURIComponent(qrcode),  ]. join('')  log. info('StarterBot', 'onScan: %s(%s) - %s', ScanStatus[status], status, qrcodeImageUrl) } else {  log. info('StarterBot', 'onScan: %s(%s)', ScanStatus[status], status) }}function onLogin (user: Contact) { log. info('StarterBot', '%s login', user) main()}function onLogout (user: Contact) { log. info('StarterBot', '%s logout', user)}async function onMessage (msg: Message) { log. info('StarterBot', msg. toString()) const contact = msg. from() log. info('name', contact?. name()) // if (contact) { await contact. say('[自动回复]主人暂时不在，稍后看到再回复') } if (msg. text() === 'ding') {  await msg. say('dong') }}// const WECHATY_PUPPET_PADPLUS_TOKEN = 'puppet_padplus_285b71c97d022f21'const bot = new Wechaty({ name: 'ding-dong-bot', /**  * Specify a `puppet` for a specific protocol (Web/Pad/Mac/Windows, etc).  *  * You can use the following providers:  * - wechaty-puppet-service  * - wechaty-puppet-puppeteer  * - padplus - project  * - etc.  *  * Learn more about Wechaty Puppet Providers at:  * https://github. com/wechaty/wechaty-puppet/wiki/Directory  */ puppet: puppet,})bot. on('scan',  onScan)bot. on('login',  onLogin)bot. on('logout', onLogout)bot. on('message', onMessage)bot. start() . then(() =&gt; log. info('StarterBot', 'Starter Bot Started. ')) . catch(e =&gt; log. error('StarterBot', e))async function main () { let imagehref0 = '' let jslistofpd0 = '' let flagOfSay = 0 // let imagehref1 = '' let jslistofpd1 = '' // let imagehref2 = '' // let jslistofpd2 = '' // todo 改变文件路径位置，与沃尔玛的文件位置同源 setInterval( function () {  fs. readFile(   'D:\\scriptworm\\walmart-data-local\\productPriceDropAndRestock0. txt',   (err:any,data:any) =&gt;  {   if (err) {       console. error(err)       return      }   console. log('[datatostring]', data. toString())   // imagehref0 = jslistofpd0. substring(jslistofpd0. search(/imagehref/) + 10, jslistofpd0. search(/FFFFFF/) + 6)   // jslistofpd0 = jslistofpd0. substring(jslistofpd0. search(/name/), jslistofpd0. search(/onlyapi/) + 7)   let str1 = data. toString()   let a1 = str1. search(/_read_False_/)   console. log(a1)   let a2 = str1. search(/_read_True_/)   console. log(a2)   if (a1 == 0) {    // todo: contact. say(something)    console. log(str1)    jslistofpd0 = data. toString()    console. log(jslistofpd0)    imagehref0 = jslistofpd0. substring(jslistofpd0. search(/imagehref/) + 10, jslistofpd0. search(/FFFFFF/) + 6)    jslistofpd1 = jslistofpd0. substring(jslistofpd0. search(/购物链接/) + 5, jslistofpd0. search(/%3Faffp1%3D/))    jslistofpd0 = jslistofpd0. substring(jslistofpd0. search(/商品名称/) + 5, jslistofpd0. search(/购物链接/))    fs. writeFile('D:\\scriptworm\\walmart-data-local\\productPriceDropAndRestock0. txt', '_read_True_', () =&gt; {flagOfSay = 1})          }  } ) }, 1000* 10) setInterval(async function () {   if(imagehref0 != '') {    let fileBox0 = FileBox. fromUrl(imagehref0)    //const contac = await bot. Contact. find({name: 'xxx'})     const contac = await bot. Room. find({ topic: 'xxx' })    // await new Promise(() =&gt;    if (contac &amp;&amp; flagOfSay == 1) {     await contac. say(jslistofpd0)      . then(() =&gt; setTimeout(function () { contac. say(jslistofpd1)}, 1000))      . then(() =&gt; setTimeout(function () { contac. say(fileBox0)}, 2000))     flagOfSay = 0    }   }  }, 1000 * 10)}用npm命令运行后扫码登录 npm start重新运行后，扫码登录之后后台就打印出已确认的日志： =================================================  QRCODE_SCAN MSG : 已扫码，请在手机端确认登陆. . . ==================================================================================================      QRCODE_SCAN MSG : 已确认=================================================接下来就能在指定的群聊中，实时的发送得到的数据了。 "
    }, {
    "id": 193,
    "url": "https://wechaty.js.org/2020/11/06/wechaty-puppet-oa-released-en/",
    "title": "Official-Account Puppet Released",
    "body": "2020/11/06 - Developing a customized WeChat official account is a complex process, which requires reading a lot of documents. Especially, developing a robot with a custom reply function based on WeChat official account, and wechaty is good at solving such problems, so we have this puppet. Wechaty-pure-official-account does not encapsulate all the functions in WeChat public account, but extract the custom customer service dialogue module and encapsulate it as the underlying puppet. In this way, we can use wechaty to develop the customer service dialogue management based on Wechaty easily.  Wechaty lets you focus on the processing of dialogue logic If you have developed other IM platforms using wechaty, you can develop the WeChat official account platform without changing the logic code, which has a very high platform migration capability. Introduction: Using wechaty to develop different platform chatbot is almost no difference at the code level, the underlying puppet has encapsulated all the logic, ‘wechaty’ provides a unified upper interface, so you only need to know how to use wechaty, you can develop powerful multi-platform chatbot. The development of WeChat Official Account is compared with other platforms, the only difference is that you need to provide WeChat Official Account configuration information, such as’ appId ‘, ‘appSecret’, ‘token’ and so on. Quick Start: Using wechaty to develop a dialogue chatbot on any platform can be roughly divided into three steps  Initialize dialogue platform puppet Configure puppet to wechaty Using wechaty upper interface to develop chatbotIn the first step, because the different details of the underlying packages are different, initialization operations are different, such as WeChat official account platform, which requires appId, appSecret and other information separately. In the second step, when initializing the wechaty instance, it is necessary to configure the puppet as a parameter, so that when wechaty performs dialog operation, it actually calls the underlying logic of the puppet. In the third step, we use the upper layer interface of wechaty to develop the chatbot. The operation mode is the same for all platforms, so the developer’s attention will be focused on this. The above two steps only need simple configuration. There are some details about the development of WeChat official account using wechaty. I will show you how to quickly get the official account chatbot with a few code. 1. Configure Internet address: The official account of WeChat requires the address of the service provider to be external network address, supporting HTTP and HTTPS, and the ports supported respectively are: 80, 443. Therefore, it is very important to have an external IP address in the development phase. Here, we recommend several intranet penetration tools:  1. 1 localtunelTemporary Internet address can be created, which will be invalid after a certain period of time, but this is in line with the requirements of development stage. The steps are also very simple: ```shell scriptnpm install -g localtunnellt –port 80 - 1. 2 [ngrok](https://www. npmjs. com/package/ngrok)It can create permanent external network addresses, free address numbers and limited bandwidth, but this is enough for WeChat's official account development with very small dialogue. The use of the tutorial is also very simple, I will not describe the specific here, the detailed content can be viewed on the official website. ### 2. Initialization of WeChat official account chatbotUsing wechaty to develop corresponding platform's chatbot, we need to use the corresponding platform puppet, and the WeChat official account corresponds to puppet: `wechaty-puppet-official-account`. The installation tutorial is as follows:```shell scriptnpm install wechaty-puppet-official-accountNext is initialization, and WeChat official account requires configuration information such as appId, appSecret, token, etc. the sample code is as follows: import { PuppetOA } from 'wechaty-puppet-official-account'const puppet = new PuppetOA({ appId:  wxbd801c28fbe1bbbd , appSecret:  6959408a3ba1c82db1a11d941df65764 , token:  token , port: 8080})Next, you need to configure it to wechaty. The example code is as follows: const bot = new Wechaty({ puppet: puppet})In this regard, the initialization of wechaty has been completed, isn’t it very simple? So the next step is to develop the dialogue logic code of wechaty core. 3. Chatbot Core Logic: In this part, I only show you the simple message reply function, which is enough to show developers how to develop customized chat robots. To learn more about the development of wechaty chatbot, you need to go to official website Check the documentation. The following is the overall sample code: import { Contact, Message, Wechaty, log,} from 'wechaty'import { MessageType } from 'wechaty-puppet'async function onMessage(msg: Message) { log. info('StarterBot', msg. toString()) if (msg. text() === 'ding') {  await msg. say(`Welcome to wechaty Official Account\n refer to ： http://www. wechaty. js. org 😄😄😄`) } if (msg. type() == MessageType. Image) {  const fileBox = await msg. toFileBox()  // send message to talker  await msg. say(fileBox) } else {  // I am a repeater ~_~~  await msg. say(msg. text()) }}const bot = new Wechaty({ name: 'ding-dong-bot', puppet: new PuppetOA({  appId:  wxbd801c28fbe1bbbd ,  appSecret:  6959408a3ba1c82db1a11d941df65764 ,  token:  token ,  port: 80 })})bot. on('message', onMessage). start() . then(() =&gt; log. info('StarterBot', 'Starter Bot Started. ')) . catch(e =&gt; log. error('StarterBot', e))Conclusion: Using wechaty to develop WeChat official account chatbot is very simple. It is very friendly to new developer. If you want to see the detailed usage, you can go to github Check the latest documents, and you are welcome to mention issues and PR. 未来，我们也将逐步接入钉钉、飞书等平台，最新动态内容请看wechaty. js. org，感谢大家的关注。 "
    }, {
    "id": 194,
    "url": "https://wechaty.js.org/2020/11/06/chatie-status-page-published/",
    "title": "Chatie status page has been published!",
    "body": "2020/11/06 - Today, we have published a cloud service status page at https://chatie. statuspage. io , please feel free to have a look at it. It’s currently under construction and we will publish our service status over there in the future. Thanks for your attention, have a nice day! "
    }, {
    "id": 195,
    "url": "https://wechaty.js.org/2020/11/03/lets-water-bot/",
    "title": "node-wechaty let's water",
    "body": "2020/11/03 - let’s water wechaty-bot:  背景：微信机器人，用于管理水群 提醒水友们（程序员）到点喝水 &amp;&amp; 提醒我自己一些时间点，比如4点半抢券  实现：使用nodejs作为后端，node-schedule作为定时任务模块支持，qrcode-terminal生成登录二维码  后期：目前有一个管理系统， 希望向机器人发送指定格式的信息，由机器人完成后台管理的一些操作，减少人工操作的步骤  自动化部署：使用docker + daocloud平台 + github，一键+持续集成 安装依赖 &amp;&amp; 启动: cd app/npm inpm start"
    }, {
    "id": 196,
    "url": "https://wechaty.js.org/2020/11/01/wechaty-puppet-oa-released/",
    "title": "Official-Account Puppet Released",
    "body": "2020/11/01 - 定制化开发微信公众号是一个非常繁琐的过程，需要阅读大量的文档，特别是基于微信公众号开发一个具有自定义回复功能的机器人，而wechaty正是擅长于解决此类问题，于是就有了此puppet。 wechaty-puppet-official-account并没有封装微信公众号中的所有功能，而是将自定义客服对话模块给抽取出来，封装成底层的puppet，这样就可以使用wechaty开发微信公众号的客服对话管理功能。  wechaty让你只专注于对话逻辑的处理 如果你已使用wechaty开发过其他IM对话平台，此时无需更改逻辑代码即可实现微信公众号平台的开发，具备非常高的平台迁移能力。 介绍: 使用wechaty开发不同平台的聊天机器人，在代码层面几乎没有任何差别，底层puppet已经封装所有逻辑，wechaty提供统一上层接口，故你只需要了解如何使用wechaty，即可开发功能强大的多平台机器人。 那微信公众号平台的开发与其他平台对比，唯一的区别就是你需要提供微信公众号的配置信息，比如appId, appSecret, token等。 使用步骤: 使用wechaty开发任何一个平台的对话机器人，大致的步骤分为三步：  初始化对话平台puppet 将puppet配置到wechaty 使用wechaty上层接口开发对话机器人在第一步中，由于不同平台的底层封装细节不一样，初始化操作也各不同，比如微信公众号平台就需要单独提供appId, appSecret等信息。 在第二步中，初始化wechaty实例时，是需要将puppet作为参数配置，这样wechaty在进行对话操作的时候，实际调用的是该puppet底层的逻辑。 在第三步中，使用wechaty上层接口开发对话机器人，针对于所有平台操作方式都是一样，故开发者的全部注意力将会专注于此。以上两个步骤只需要简单的配置即可完成。 在使用wechaty开发微信公众号时有一些细节与其他平台不同，我将以少量的代码给大家展示如何快速上手微信公众号聊天机器人。 1. 配置外网地址: 微信公众号要求服务提供者的地址为外网地址，支持http和https，分别支持的端口为：80， 443。所以在开发阶段拥有一个外网IP地址变得尤为关键，在此，我们推荐几个内网穿透工具：  1. 1 localtunel能够创建临时的外网地址，一定时间之后将会失效，可这正符合开发阶段的需求。使用步骤也是非常简单： ```shell scriptnpm install -g localtunnellt –port 80 - 1. 2 [ngrok](https://www. npmjs. com/package/ngrok)能够创建永久的外网地址，免费地址数量和带宽有限，可这对于对话量非常小的微信公众号开发来说已经足够了。使用教程也是非常简答，具体在此我就不描述了，详细内容可去官网查看。### 2. 初始化微信公众号机器人使用wechaty开发对应平台的对话机器人，需要使用对应平台的puppet，而此微信公众号对应的puppet为：`wechaty-puppet-official-account`。安装教程如下：```shell scriptnpm install wechaty-puppet-official-account接下来就是初始化了，而微信公众号是需要appId, appSecret, token等配置信息，示例代码如下所示： import { PuppetOA } from 'wechaty-puppet-official-account'const puppet = new PuppetOA({ appId:  wxbd801c28fbe1bbbd , appSecret:  6959408a3ba1c82db1a11d941df65764 , token:  token , port: 8080})接着需要将其配置到wechaty当中，示例代码如下： const bot = new Wechaty({ puppet: puppet})就此，已完成wechaty的初始化工作，是不是非常简单呢？那么接下来就是开发wechaty核心的对话逻辑代码。 3. wechaty对话机器人核心逻辑: 在此部分我只给大家展示简单的消息回复功能，足以给开发者展示如何开发定制化聊天机器人。 要想详细了解wechaty聊天机器人的开发细节，需要到 官网 查阅文档。以下为整体示例代码： import { Contact, Message, Wechaty, log,} from 'wechaty'import { MessageType } from 'wechaty-puppet'async function onMessage(msg: Message) { log. info('StarterBot', msg. toString()) if (msg. text() === 'ding') {  await msg. say(`欢迎使用wechaty微信公众号\n详细文档请看 ： http://www. wechaty. js. org 😄😄😄`) } if (msg. type() == MessageType. Image) {  const fileBox = await msg. toFileBox()  // 将图片发送给用户  await msg. say(fileBox) } else {  // 我就是一个复读机 ~_~~  await msg. say(msg. text()) }}const bot = new Wechaty({ name: 'ding-dong-bot', puppet: new PuppetOA({  appId:  wxbd801c28fbe1bbbd ,  appSecret:  6959408a3ba1c82db1a11d941df65764 ,  token:  token ,  port: 80 })})bot. on('message', onMessage). start() . then(() =&gt; log. info('StarterBot', 'Starter Bot Started. ')) . catch(e =&gt; log. error('StarterBot', e))总结: 使用wechaty开发微信公众号聊天机器人非常简单，对于新手特别友好，要想查看详细使用方法，可到github查看最新文档，也欢迎大家提Issues和Pr。 未来，我们也将逐步接入钉钉、飞书等平台，最新动态内容请看wechaty. js. org，感谢大家的关注。 "
    }, {
    "id": 197,
    "url": "https://wechaty.js.org/2020/10/30/daily-message-and-chatbot/",
    "title": "基于wechaty的定时消息推送（可以哄女朋友）、智能聊天和私人助理",
    "body": "2020/10/30 -  自从2017年微信web端API限制以后，itchat等一大批bot歇菜了，一直都在找一款合适的替品 目前来看，大部分都是针对windows微信客户端，基于HOOK的dll注入实现对微信的操控，有一定的封号风险，只能用固定的版本，部署在linux服务器端比较困难，意味着只能一直开着电- -wechaty，支持IPAD,,MAC等多种协议，不用去调用WEB网页API,并且可以布署在服务器，满足我所有需求。项目地址 看完官方文档后（token官方介绍）， 发现需要申请Token,并且python版本的Token是要付费的，但没有学过typescript，有点想放弃，浏览了一下ding-dong-bot的Example,似乎可以看懂，那就边学习边摸索吧。（ps:后来偶然见发现了另一篇可以使用将token转变一下实现python版wechaty,但此时已经基本用TS写完了,如果想用Python等其他语言可以参考官方文档。）具备功能: 1. 关键词触发功能: 1. 1 关键词”介绍一下自己”、 “自我介绍一下”、 “你是谁”触发自我介绍1. 2 地名+天气 触发天气查询 2. 智能聊天功能: 2. 1群外直接聊天2. 2群内成员皆有聊天权限“@bot” 聊天2. 3不会回复 @其他群成员 的消息 实现过程: Talk is cheap，show your code 1. 主程序: import { Wechaty, Message, UrlLink,log,} from 'wechaty'import { PuppetPadplus } from 'wechaty-puppet-padplus'import { EventLogger, QRCodeTerminal } from 'wechaty-plugin-contrib'import { WechatyWeixinOpenAI, } from 'wechaty-weixin-openai'import { setSchedule, } from '. /schedule/index'import { getDay, formatDate,} from '. /utils/index'import { getOne, getTXweather, getSweetWord,} from '. /superagent/index'// 创建微信每日说定时任务async function initDay() { console. log(`已经设定每日说任务`); setSchedule('0 40 0 * * *', async () =&gt; {  console. log('你的贴心小助理开始工作啦！')  let logMsg  let contact =   (await bot. Contact. find({ name: 'Jason' })) ||   (await bot. Contact. find({ alias: 'boss' })) // 获取你要发送的联系人  let one = await getOne() //获取每日一句  let weather = await getTXweather() //获取天气信息  let today = await formatDate(new Date()) //获取今天的日期  let memorialDay = getDay('2009/08/07') //获取纪念日天数  let sweetWord = await getSweetWord()  let str = `${today}\n我们相爱的第${memorialDay}天\n\n元气满满的一天开始啦,要开心噢^_^\n\n今日天气\n${weather. weatherTips}\n${   weather. todayWeather  }\n每日一句:&lt;br&gt;${one}&lt;br&gt;&lt;br&gt;每日土味情话：&lt;br&gt;${sweetWord}&lt;br&gt;&lt;br&gt;————————最爱你的我`  try {   logMsg = str   await delay(2000)   await contact. say(str) // 发送消息  } catch (e) {   logMsg = e. message  }  console. log(logMsg) })}const padplusToken = '你自己的TOKEN'const puppet = new PuppetPadplus({ token: padplusToken,})const bot = new Wechaty({ name: 'jason-assistant', puppet,})bot. use(EventLogger())bot. use(QRCodeTerminal({ small: true }))//在Wechaty里面引用和配置插件const openAIToken = '你自己的机器人TOKEN' //需要在微信对话开放平台申请,点击机器人设置》绑定应用》在页面最下方即可看到const openAIEncodingAESKey = '你自己的EncodingAESKey' //微信对话开放平台申请,点击机器人设置》绑定应用》在页面最下方即可看到const preAnswerHook = async (message: Message) =&gt; { const isCommonMaterial = await processCommonMaterial(message) if (isCommonMaterial) {  return false }}/** * 获得boss联系名片，当机器人找不到问题答案时，将BOSS的名片推送过去 */const getBoss = async () =&gt; {  const contact = bot. Contact. load('boss微信ID')  await contact. sync()  return contact }  const noAnswerHook = async (message: Message) =&gt; {  const room = message. room()  const from = message. from()  if (!room) {   const boss = await getBoss()   await message. say('你的问题我不会回答，你可以联系我的老板')   await message. say(boss)   return;  }  const members = await room. memberAll()  const bossInRoom = members. find(m =&gt; m. id === 'boss微信id')  if (bossInRoom) {   await room. say`${bossInRoom}，${from}问的问题我不知道，你帮我回答一下吧。`  } else {   const boss = await getBoss()   await room. say`${from}，你的问题我不会回答，你可以联系我的老板`   await room. say(boss)  } } /** * 用wechaty-weixin-openai可以实现快速接入微信对话平台 */bot. use(WechatyWeixinOpenAI({  token: openAIToken,  encodingAESKey: openAIEncodingAESKey,  noAnswerHook, //在机器人无法回答时，推送设定的回答  preAnswerHook, //判断是否是关键字，如果是关键字，触发关键字回答而不接入微信开放平台 })) const processCommonMaterial = async (message: Message) =&gt; {  const room = message. room()  // const from = message. from()  const mentionSelf = await message. mentionSelf()  const text = message. text()  let intro = 'Jason,爱好广泛，广交天下豪杰，上得了九天摘月，下得了五洋捉鳖，俗话说的好，不会烘培的飞行员不是好户外人，不会玩音乐的水族爱好者不是好厨师，不会画画的极限爱好者不是好程序员，这就是我的老板Jason，吼吼吼~~'   if (room !== null &amp;&amp; mentionSelf) {   if (/jason|你老板|你上司/. test(text)) {    await room. say(intro)    await room. say(new UrlLink({      description: '户外贱客 &amp; Fighting,fighting,finghting and finghting，读万卷书，行万里路，学习AND吃，喝，玩，乐',      thumbnailUrl: '',      title: 'Jason',      url: 'http://mp. weixin. qq. com/s?__biz=MzkxODE3MjAyNQ==&amp;mid=100000001&amp;idx=1&amp;sn=d05de320c6fbe6c9f9149a09a4da81ec&amp;chksm=41b4391776c3b001c143ac2c284c58ac8b08de41d95cab682aa5a07022e32096567f5780d5be#rd',     }))    return true   } else if (/户外贱客/. test(text)) {    await room. say(new UrlLink({      description: '户外贱客 &amp; Fighting,fighting,finghting and finghting，读万卷书，行万里路，学习AND吃，喝，玩，乐',      thumbnailUrl: '',      title: 'Jason',      url: 'http://mp. weixin. qq. com/s?__biz=MzkxODE3MjAyNQ==&amp;mid=100000001&amp;idx=1&amp;sn=d05de320c6fbe6c9f9149a09a4da81ec&amp;chksm=41b4391776c3b001c143ac2c284c58ac8b08de41d95cab682aa5a07022e32096567f5780d5be#rd',     }))    return true   }  }  return false}// 登录async function onLogin(user) { console. log(`贴心小助理${user}登录了`) // 登陆后创建定时任务 await initDay()}bot. on('login', onLogin)bot. start() . then(() =&gt; log. info('StarterBot', 'Starter Bot Started. ')) . catch(e =&gt; log. error('StarterBot', e))2. 创建schedule定时函数: import { schedule } from 'node-schedule'// date 参数//其他规则见 https://www. npmjs. com/package/node-schedule// 规则参数讲解  *代表通配符//// * * * * * *// ┬ ┬ ┬ ┬ ┬ ┬// │ │ │ │ │ |// │ │ │ │ │ └ day of week (0 - 7) (0 or 7 is Sun)// │ │ │ │ └───── month (1 - 12)// │ │ │ └────────── day of month (1 - 31)// │ │ └─────────────── hour (0 - 23)// │ └──────────────────── minute (0 - 59)// └───────────────────────── second (0 - 59, OPTIONAL)// 每分钟的第30秒触发： '30 * * * * *'//// 每小时的1分30秒触发 ：'30 1 * * * *'//// 每天的凌晨1点1分30秒触发 ：'30 1 1 * * *'//// 每月的1日1点1分30秒触发 ：'30 1 1 1 * *'//// 每周1的1点1分30秒触发 ：'30 1 1 * * 1'function setSchedule(date,callback) { schedule. scheduleJob(date, callback)}export function setSchedule()3. 创建几个功能函数，爬取ONE网站的每日一句，提取通过API获取的消息: import * as cheerio from 'cheerio'import * as superagent from 'superagent'const ONE = 'http://wufazhuce. com/' // ONE的web版网站const TXHOST = 'http://api. tianapi. com/txapi/' // 天行hostfunction req(url,method, params, data, cookies) { return new Promise(function (resolve,reject) {  superagent(method, url)   . query(params)   . send(data)   . set('Content-Type','application/x-www-form-urlencoded')   . end(function (err, response) {    if (err) {    reject(err)    }    resolve(response)   })  })}async function getOne() { // 获取每日一句 try {  let res = await req(ONE, 'GET')  let $ = cheerio. load(res. text)  let todayOneList = $('#carousel-one . carousel-inner . item')  let todayOne = $(todayOneList[0])   . find('. fp-one-cita')   . text()   . replace(/(^\s*)|(\s*$)/g, '')  return todayOne } catch (err) {  console. log('错误', err)  return err }}async function getTXweather() { // 获取天行天气 let url = TXHOST + 'tianqi/' try {  let res = await req(url, 'GET', {   key: '你自己的KEY',//需要自己去天行申请，地址https://www. tianapi. com/signup. html?source=474284281   city: 'Arlington'  })  let content = JSON. parse(res. text)  if (content. code === 200) {   let todayInfo = content. newslist[0]   let obj = {    weatherTips: todayInfo. tips,    todayWeather:`阿林顿今天${todayInfo. weather}\n温度:${todayInfo. lowest}/${todayInfo. highest}    \n${todayInfo. wind}风： ${todayInfo. windspeed}\n紫外线指数:${todayInfo. uv_index}\n湿度    ${todayInfo. humidity}`   };   console. log('获取天行天气成功', obj)   return obj  } else {   console. log('获取接口失败', content. code)  } } catch (err) {  console. log('获取接口失败', err) }}async function getSweetWord() { // 获取土味情话 let url = TXHOST + 'saylove/' try {  let res = await req(url, 'GET', { key: '' })  let content = JSON. parse(res. text)  if (content. code === 200) {   let sweet = content. newslist[0]. content   let str = sweet. replace('\r\n', '&lt;br&gt;')   return str  } else {   console. log('获取接口失败', content. msg)  } } catch (err) {  console. log('获取接口失败', err) }}export { getOne, getTXweather, getSweetWord, }计算距离某日（生日，结婚纪念日等）还有多少天: function getDay(date) { var date2 = new Date() var date1 = new Date(date) var iDays = parseInt(  Math. abs(date2. getTime() - date1. getTime()) / 1000 / 60 / 60 / 24 ) return iDays}function formatDate(date) { var tempDate = new Date(date) var year = tempDate. getFullYear() var month = tempDate. getMonth() + 1 var day = tempDate. getDate() var hour = tempDate. getHours() var min = tempDate. getMinutes() var second = tempDate. getSeconds() var week = tempDate. getDay() var str = '' if (week === 0) {  str = '星期日' } else if (week === 1) {  str = '星期一' } else if (week === 2) {  str = '星期二' } else if (week === 3) {  str = '星期三' } else if (week === 4) {  str = '星期四' } else if (week === 5) {  str = '星期五' } else if (week === 6) {  str = '星期六' } if (hour &lt; 10) {  hour = '0' + hour } if (min &lt; 10) {  min = '0' + min } if (second &lt; 10) {  second = '0' + second } return year + '-' + month + '-' + day + '日 ' + hour + ':' + min + ' ' + str}export { getDay, formatDate } 后记: 到此已经实现了私人人助理和定时推送消息的功能（项目地址），由于对Typescript不熟，很多功能都是借鉴很多大神的轮子实现的，还是对Python熟悉点，下步准备用Python来实现以上功能，并进一步拓展更多有趣的功能。 "
    }, {
    "id": 198,
    "url": "https://wechaty.js.org/2020/10/27/wxbot-admin-platform/",
    "title": "基于Nodejs+Wechaty开发微信机器人管理平台",
    "body": "2020/10/27 - 微信机器人开源库调研，GitHub 找到以下 3 个开源作品：  itchat     itchat 是一个开源的微信个人号接口，使用 python 调用微信   使用不到 30 行的代码，你就可以完成一个能够处理所有信息的微信机器人    wechaty     wechaty 是适用于微信个人的 Bot SDK ，可以使用 6 行 js 创建一个机器人   具有包括 linux，Windows，MacOS 和 Docker 在内的跨平台支持，基于 Node. js    vbot     vbot 是基于微信 web 版的接口，使用 http 协议 以及轮询方式实现   亮点在于通过匿名函数，能够实现多种有趣的玩法   通过 API，更方便的打造属于自己的网页版微信，基于 PHP   初识 wechaty: Wechaty 是一个开源的的对话机器人 SDK，支持 个人号 微信。它是一个使用 Typescript 构建的 Node. js 应用。支持多种微信接入方案，包括网页，ipad，ios，windows，android 等。同时支持 Linux, Windows, Darwin(OSX/Mac) 和 Docker 多个平台。 先看一下官方文档：  wechaty-github wechaty中文文档只需要 6 行代码，你就可以 通过个人号 搭建一个 微信机器人功能 ，用来自动管理微信消息。 import { Wechaty } from 'wechaty'Wechaty. instance(). on('scan',    qrcode =&gt; console. log('扫码登录：' + qrcode)). on('login',    user  =&gt; console. log('登录成功：' + user)). on('message',   message =&gt; console. log('收到消息：' + message)). on('friendship', friendship =&gt; console. log('收到好友请求：' + friendship)). on('room-invite', invitation =&gt; console. log('收到入群邀请：' + invitation)). start()更多功能包括：  消息处理：关键词回复 群管理：自动入群，拉人，踢人 自动处理好友请求 智能对话：通过简单配置，即可加入智能对话系统，完成指定任务 … 请自行开脑洞好了，文档齐全 &amp; api 丰富，完全满足我的需求，就选这个库了。 首先跑一个示例看看 wechaty-getting-started。下载完之后先 npm install &amp; npm start 一顿操作，然后运行就有了登录二维码，拿出手机扫码，然后 GG。 基于 Web 微信的限制: 查找资料 基于nodejs + wachaty开发微信机器人平台，发现已经有大佬踩过坑了。 原来2017年之后注册的微信号都无法登录网页版微信，而2017年之前注册得微信账号也有很大几率登录不上，找朋友试了也都不行。 检验你的微信号是否支持网页微信登录： http://wx. qq. com 点击链接链接，PC端进入然后手机扫码登录，若是可以登上，即可以使用上述示例 然后又去看了 vbot 和 itchat，但发现也都是是基于网页协议实现的 从网上查资料，大概有一下几种实现方式：  Web网页端：2017年后不再支持新号登录，仅支持老号，并且掉线严重，功能缺失严重 Xposed技术：在2019年6月份，微信官方在行业重点打击Xposed，自此行业内一片哀嚎遍野，陆续向iPad/MAC协议转型。具体案例请点击 PC Hook：代码注入型，也就是逆向开发。封号情况偏多，使用容易出现追封，公司大规模封号等情况，且目前在营销行业使用率较少，比较偏小团队使用 模拟机：延迟高、消息实时到达率低、模拟人为操作效率慢、功能偏少，承担不了商业化功能 ipad协议：安全性较好，功能满足，行业占有率高，但具有能力研发人员偏少，基本两三个团队研发，且目前已有团队解散，部分微信号段登录失败、且通过grpc,mmtls研发，被检测几率存在 MAC协议：安全性相比iPad协议更好，功能性相比ipad协议少些，行业内具有研发能力更少，安全性、稳定性比较优秀，不会出现追封、批量封的情况 混合通道：微信内部通道，最高权限，基于MAC与Ipad协议，非grpc,mmtls，功能合适，微信正版通道，不会出现技术封号问题看了看，内部通道是不可能的，只有ipad协议个mac协议目前最好了 wechaty-puppet-padplus: 使用 wechaty-puppet-padplus 一套基于 ipad 协议的包。不过天下没有免费的午餐，需要申请 token，见 Wechaty Token 申请及使用文档和常见问题。 聊天机器人 API: 目前网络上有许多非常好的智能聊天机器人，这里找了6个目前使用很广泛的：  海知智能 功能很强大，不仅仅用于聊天。需申请 key，免费 思知对话机器人 注册很简单，调用也很简单，而且完全免费 图灵机器人 需要注册账号，可以申请 5 个机器人，未认证账户每个机器人只能回 3 条/天，认证账户每个机器人能用 100 条/天 青云客智能机器人 无须申请，无数量限制，但有点智障，分手神器，慎用 腾讯闲聊 需要注册和申请，还需要加密处理 天行机器人 白嫖用户绑定微信后有 10000 次永久额度，之后 1 元 10000 次搭建微信机器人平台: 项目初始参考 wxbot 搭建机器人后台管理。 项目介绍:  控制台     绑定机器人   登录   自动通过好友验证关键词设置，当有人添加机器人时，关键词匹配后直接通过   好友验证通过自动回复   退出    自动回复     普通消息         针对好友/某个群聊/所有群聊 设置关键词自动回复          加群邀请         机器人回复群聊列表，好友可以选择性进群          踢人指令         机器人识别指令，自动把成员移出群聊           我的好友     单独对某个好友送消息    我的群聊     群聊列表，管理所有群聊   设置群聊名称，发布公告，发送群消息   设置群聊基本信息，入群欢迎语，成员违规次数上限，是否受机器人控制    定时任务     针对好友/某个群聊/所有群聊设置定时任务，机器人在指定时间会触发消息推送    智能聊天     低智商对话   成语接龙，查天气，查酒店，歇后语…    技术构成:  服务端 Node. js SSR框架 NuxtJS 前端框架 Vue UI组件 Ant Design of Vue 持久化 MongoDB ipad协议 wechaty-puppet-padplus这里就直接介绍下机器人模块 |-- server/|———- /lib|------ FriendShip. js  # 友谊关系，好友添加监听|------ Login. js    # 机器人登录退出|------ Message. js   # 消息监听处理|------ Room. js     # 加群，退出群聊|------ Task      # 机器人定时任务|———- index. js     # 入口文件快速开始: 准备条件:  安装 Node. js (v10 以上版本)、MongoDB。 推荐安装 cnpm安装依赖: cnpm i启动服务:  开发模式npm run dev 生产模式先编译项目 npm run build再启动服务 npm start打开浏览器，访问 http://localhost:3000/ 系统配置: 根据实际情况修改 config. js 配置文件，修改后需要重启服务才能生效。参数说明： hostString 类型，主机名，配置为 0. 0. 0. 0 表示监听任意主机。 portNumber 类型，端口号。 mongoUrlString 类型，MongoDB 链接。 secretString 类型，JWT 秘钥。 tianApiKeyString 类型，天行数据秘钥 线上部署: 使用PM2: 推荐使用 pm2 进行 Node. js 的进程管理和持久运行。 安装cnpm i -g pm2启动pm2 start pm2. config. js踩坑: 1. Wechaty Token 申请及使用文档和常见问题  Wechaty 开源激励计划2. 0 申请表 填写项目信息 Wechaty Token 申请及使用文档和常见问题2. tianApiKey 申请及天行机器人配置  首先，去 天行数据 注册账号，申请 APIKEY 其次，申请 天行机器人 接口，用于机器人自动回复 最后，别忘记配置 机器人身份设置，否则在机器人回复中会有奇怪的代码串，如 {robotname}3. 部署中执行 sudo pm2 报错 command not found 问题  原因是没有将 pm2 加至环境变量中，先找到 node 的目录 可以用 whereis node 来查找，然后查找 whereis pm2，再使用 ln 建立软连接 参考文章 Linux下使用pm2部署node以及安装后command not found解决4. 部署中执行 sudo pm2 报错 permission denied 问题  原因是项目会动态生成中 logs 目录中的文件，报错权限不足，即 permission denied 参考文章 解决 pm2 中的 permission denied 问题感谢:  感谢 beclass 的开源项目 wxbot，这是一套优秀的微信机器人平台。 感谢 Wechaty 团队提供微信机器人 SDK，让开发者可以专注于业务代码。 感谢 句子互动 提供的 pad 协议版 token。 作者: Skyvow 前端开发工程师，WuxUI 作者Code: Github 微信机器人，个人微信号小助手平台 "
    }, {
    "id": 199,
    "url": "https://wechaty.js.org/2020/10/26/python-wechaty-live-coding/",
    "title": "Python-Wechaty Live Coding",
    "body": "2020/10/26 - Wechaty 作为一个对话SDK，拥有适配多平台的优秀能力，同时还具备多语言的特性，今天我们将以一个简单的视频来介绍如何开始使用Python-Wechaty编写一个最简单的聊天机器人。  上手步骤: 1. 安装依赖包: pip install wechaty2. 配置Token: Token的配置可以有多种方式： 方法一：通过环境变量来配置 export WECHATY_PUPPET_SERVICE_TOKEN='your-token'方法二：通过python代码来配置 import osos. environ['WECHATY_PUPPET_SERVICE_TOKEN'] = 'your-token'那如何获取长期Token呢？详细请看：Everything-about-Wechaty 3. 编写最简单的机器人代码:  talk is cheep, show you the code import asynciofrom wechaty import Wechaty, Messageclass MyBot(Wechaty):  async def on_message(self, msg: Message):    talker = msg. talker()    await talker. ready()    if msg. text() ==  ding :      await talker. say('dong')    elif msg. text() == 'image':      file_box = FileBox. from_url(        'https://ss3. bdstatic. com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/'        'u=1116676390,2305043183&amp;fm=26&amp;gp=0. jpg',        name='ding-dong. jpg')      await talker. say(file_box)async def main():  bot = MyBot()  await bot. start()asyncio. run(main())以上代码即可完成一个最简单的ding-dong机器人，以及你给他发送一个image关键字，它能够给你回复一个图片，代码是不是非常简单呢？ 这里还有功能更加强大的机器人示例代码库，大家可以在这里来找与自己需求类似的机器人。 也欢迎大家持续关注python-wechaty，未来我们将持续发布一些短视频来介绍相关的用法。 "
    }, {
    "id": 200,
    "url": "https://wechaty.js.org/2020/10/26/java-wechaty-group-message-sync/",
    "title": "Wechaty bot in Java to sync group messages",
    "body": "2020/10/26 - In the previous blog, we have deployed wechaty bot with node. js to aws.  This blog is about to develop wechaty bot with Java and implement the function of sync messages in between different groups. Prerequisites:  wechaty token Way to get a token Docker is installed in the server / local. This is required for Java wechaty project. Docker Official SiteSetup Token Gate Server:  Follow the official wechaty instruction here Make sure your localhost and port 8788 is accessible from public. If you are connecting internet with home network router, you will need to set up port forwarding for port 8788 to your machine. And if you are using AWS EC2 as server, you need to config security group to allow inbound traffic to port 8788 To test the Wechaty Token Gate Server is working, Token Test Site shall return your public IP and port 8788{ host : xxx. xxx. xxx. xxx , port :8788}Start Java Application: Java-wechaty is a good place to start the hello world application.  The ding-dong bot example is in the example folder.    Checkout the code.     In the example folder, build the executable bymvn clean install     Run the executable jar byjava -jar target/wechaty-example-1. 0. 0-SNAPSHOT-jar-with-dependencies. jar  Common issues: Account was disabled / locked by Wechat: Solutions:  It is a high risk to use a newly registered wechat account. Advice to use an account registerred more than half a year.  Login account but DO NOTHING to a few days.  Then try again.  Related Issues in github issue 1issue 2The bot application server is not stable. Restart or logout by itself, usually in the late night: Solutions:  Monitor the offline pattern(i. e. always offline around 4am).  Use cron job to stop and start application. As long as token hostie gateway docker server does not restart, scan is not required when restarting the application.  Periodical send message from and to the bot in a random internal. Cannot get the list of rooms after the token hostie gateway docker server restart: Solutions:  Not a good solution yet. Sending a message in each group will register the group to wechaty bot again after server restarted. Group message sync feature in Java project: Java wechaty bot: Check message if not from bot itself:         if (message. self()) { // skip message from self, also to avoid infinite loop          logger. info( message from self );          return;        }Define the rooms to sync messages: MessageRoute route1 = new MessageRoute( 测试区危险 ,  测试区不危险 );List&lt;MessageRoute&gt; routes = new ArrayList&lt;&gt;();Check if message if from the room defined in the routes, send message to the other room in the route: routes. stream()        . filter(messageRoute -&gt; messageRoute. getSourceName(). equals(getTopicByRoom(room)))        . forEach(messageRoute -&gt; {          Room destRoom = getRoomByTopic(wechaty, messageRoute. getDestinationName());          destRoom. say(String. format( [%s in %s]:%n%s , from. name(), getTopicByRoom(room), text));        });"
    }, {
    "id": 201,
    "url": "https://wechaty.js.org/2020/10/25/use-wechaty-to-predict-image/",
    "title": "通过Wechaty使用深度学习模型预测图片类型",
    "body": "2020/10/25 - Use wechaty to apply pytorch model via WeChat. 想法: 在跑深度学习模型时，我时常会感觉调用一个模型好复杂，需要写好长好长的代码，而我又没有学过小程序开发，于是想到做一个用微信快速调用模型的小玩意儿。 本项目即是通过wechaty与微信通讯，利用fastapi中转数据并调用pytorch模型的实践。 同时，目前该项目仅仅作为一个MVP（最小可行产品），功能可能并不完善，在未来或许会加入模型训练完毕提醒/模型训练意外终止提醒等功能，敬请期待~ 完整代码见https://github. com/lyleshaw/Wechaty-Torch 原理:  用户在微信发送图片–&gt; –&gt;wechaty收到图片并进行base64后post请求到后端–&gt; –&gt;使用fastapi开发的后端收到图片的base64编码后调用模型–&gt; –&gt;模型给与预测与置信度表传给后端–&gt; –&gt;后端收到后向wechaty响应–&gt; –&gt;wechaty收到数据后发送给用户. 文件结构:  wechaty-torch. ts typescript文件，使用wechaty与微信通讯； main. py 后端文件，基于fastapi开发，中转图片数据； model. py 模型调用文件，给出预测和置信度； model. pth (由于模型文件过大，请按快速开始的说明手动下载)模型文件（二进制），使用WideResNet在CIFAR-10数据集上进行训练，测试集准确率91. 22%. 依赖库: typescript：请按照wechaty文档安装. python：fastapi,uvicorn,torch,numpy,PIL 快速开始:  请确保您已将所有依赖环境安装成功  点击这里 下载model. pth，并将model. pth放到项目文件夹下 在wechaty-torch. ts文件的const token = 'YOUR_TOKEN_HERE'处填入您的token（获取方式见wechaty文档）； 在model. py文件的os. chdir( Your PATH )处修改为您的文件路径； 运行main. py后运行wechaty-torch. ts. 开发过程: wechaty部分: 首先创建一个名叫wechaty-torch的bot； import { Message, Wechaty } from 'wechaty'import { ScanStatus } from 'wechaty-puppet'import { PuppetPadplus } from 'wechaty-puppet-padplus'import QrcodeTerminal from 'qrcode-terminal'var request = require('request')const token = 'YOUR_TOKEN_HERE'const puppet = new PuppetPadplus({ token,})const name = 'wechaty-torch'const bot = new Wechaty({ name: name, puppet,})然后扫码登录后，显示登录帐号； bot. on('scan', (qrcode, status) =&gt; { if (status === ScanStatus. Waiting) {  QrcodeTerminal. generate(qrcode, {   small: true  }) }})bot. on('login' , user =&gt; console. info('Bot', `bot login: ${user}`))message部分是该文件的重点，首先获取消息类型，如果非图片即跳出，是图片则将图转化为base64编码后使用request发送post请求到http://127. 0. 0. 1:8000/message(后端服务器)，然后将响应值回复给用户； bot. on('message', async (msg: Message) =&gt; {  if (msg. type() !== Message. Type. Audio) {   return  }  const file = await msg. toFileBox();  const bsimg = file. toBase64();  var formData = {   bsimg: bsimg,  }  try{   request. post({url:'http://127. 0. 0. 1:8000/message', formData: formData}, function (error:any, response:any, body:any) {      if (error) {       console. log('Error :', error)       return     }     console. log(' Body :', body)     var response = JSON. parse(body)     if(body. length &gt; 0){      const pred: string = response['pred']      const other = response['other']      msg. say(pred+'\n'+other)     }   })  }catch(e){   console. log(e)  } })最后启动机器人即可。 bot. start(). catch(async e =&gt; { console. info('Bot', 'init() fail:' + e) await bot. stop() process. exit(-1)})后端部分: 首先，引入各种依赖库和模型调用文件； from typing import Listfrom fastapi import Depends, FastAPIimport timefrom fastapi. middleware. cors import CORSMiddlewarefrom starlette. responses import RedirectResponsefrom typing import TypeVar, Generic, Type, Anyfrom starlette. requests import Requestimport sysfrom pydantic import BaseModelimport osimport jsonfrom model import get_bsimg_pred然后创建一个FastAPI应用，并定义Message类（内含bsimg）； app = FastAPI()app. add_middleware(  CORSMiddleware,  allow_origins=['*'],  allow_credentials=True,  allow_methods=[ * ],  allow_headers=[ * ],)class Message(BaseModel):  bsimg: str简简单单写一个post请求，完事。 @app. post( /message/ )async def m(msg: Message):  content = get_bsimg_pred(bsimg=msg. bsimg)  return {    'content' : content  }模型部分:  模型部分仅介绍部分函数。 获得预测值和其余标签置信度：传入tensor类型的变量img，返回pred:int 预测值ID、conf_list:list 其余变量置信度； def get_pred(img):  x = Variable(img)  x = x. to(DEVICE)  with torch. no_grad():    y_ = model(x)  pred = y_. max(-1, keepdim=True)[1]  pred = pred. tolist()[0][0]  conf_list = nn. Softmax()(torch. tensor(y_[0])). tolist()  return pred,conf_list将base64编码转换为PLT图片类型：传入str类型的base64编码，返回PLT图片类型变量img； def base64_to_image(base64_str):  base64_data = re. sub('^data:image/. +;base64,', '', base64_str)  byte_data = base64. b64decode(base64_data)  image_data = BytesIO(byte_data)  img = Image. open(image_data)  return img获得base64编码图片的预测内容：传入str类型的base64编码，返回包含预测值和置信度的字符串； def get_bsimg_pred(bsimg: str):  img_1 = transform(base64_to_image(bsimg))  img_2 = []  img_1 = img_1. tolist()  img_2. append(img_1)  img = torch. tensor(img_2)  pred,con_list = get_pred(img)  confi_list = ''  for i in range(10):    confi_list = confi_list +  %8s 的置信度为： %. 2f%%\n  % (label[i],con_list[i]*100)  return str(label[pred])+'\n'+confi_list以上即是开发过程~ "
    }, {
    "id": 202,
    "url": "https://wechaty.js.org/2020/10/22/wetchat-bot-chat/",
    "title": "基于Wechaty打造定时多功能机器人(一)",
    "body": "2020/10/22 - 智能群聊天机器人 1. 微信机器人的魅力: 在网上看到别人做的那些多多少少的机器人基于自己的微信开发的，发送给好友的机器人，或多或少勾引起我的折腾的心。这个想法在很早就已经产生了，奈何那个时候在赶着做毕设，就没有实现，现在毕业了，工作之后，这个想法越来越想要把它给实现出来，本来就是想要在起床的时候收到天气预报的提醒，本来是打算做一个短信每天定时发送短信，这样就可以达到目的了，用了一段时间的短信后，发现钱包实在消耗不起了，一家人看上了我的短信发送，都说给他们也做一个，什么七大姑八大姨的，都来了。虽然现在还开放着天气的发送，下个月可能就要关停了，用微信发送天气预报了。 大家的需求我陆陆续续的了解了一下，年轻人无非就是说，每天都夸自己漂亮一下，年龄稍微大一点的就是说很多APP都要去学，觉得太过麻烦了，就想着说就搞个整合一点的就好了。所以，现在的微信机器人就只有：  天气预报。 语义聊天。 每日一则彩虹屁。后续的话，可能要考虑加上快递查询，菜鸟驿站的到件通知什么的，这些要过几天再具体的了解大家的需求才会着手开发。 在此之前，有一个很困难的问题摆在我的面前，因为我的微信没有办法使用web协议，所以就只能另外开辟一条道路，在我的不懈努力下，在git上找到了Weachaty，发现了这个就是我要的，可发送可接收，立马开始着手制作了。 2. Wechaty是什么: 在Weachaty 官网上有详细的介绍，我主要是通过官方文档来进行编写的，官方文档分为中文版、英文版英文版的文档更新更全更新。 import { Wechaty } from 'wechaty'Wechaty. instance(). on('scan',     qrcode   =&gt; console. log('扫码登录')). on('login',    user    =&gt; console. log('登录成功：' + user)). on('message',   message   =&gt; console. log('收到消息：' + message)). on('friendship',  friendship =&gt; console. log('收到好友请求：' + friendship)). on('room-invite', invitation =&gt; console. log('收到入群邀请：' + invitation)). start()包括了最基础的好友收发消息，还有拉人入群，自动同意好友等等。 3. 使用Wechaty: 首先需要初始化页面数据，我这边采用的是默认创建方式 npm init -y采用默认的生成package. json文件： {  name :  nodejs ,  version :  1. 0. 0 ,  description :   ,  main :  index. js ,  scripts : {   test :  echo \ Error: no test specified\  &amp;&amp; exit 1  },  author :   ,  license :  ISC ,  dependencies : {   cors :  ^2. 8. 5 ,   express :  ^4. 17. 1 ,   node-schedule :  ^1. 3. 2 ,   qr-image :  ^3. 2. 0 ,   response :  ^0. 18. 0 ,   tencentcloud-sdk-nodejs :  ^4. 0. 4 ,   wechaty :  ^0. 48. 13 ,   wechaty-puppet-padplus :  ^0. 6. 6 ,   ws :  ^7. 3. 1  }}官方给我的是临时的puppetPadPlus协议，所以我需要安装的puppet是PadPlus版的，为了让二维码可以显示出来，我将二维码导出在页面，我这边引入的插件为qr-image我们安装wechaty、wechaty-puppet-padplus。 npm i --save wechatynpm i --save wechaty-puppet-padplusnpm i --save qr-image修改index. js源代码如下： //引入必须的包var express = require( express );var qrImg = require('qr-image');import { Wechaty } from 'wechaty' // Wechaty核心包import { PuppetPadplus } from 'wechaty-puppet-padplus' // padplus协议包import { Friendship } from 'wechaty'import config from '. /src/config' // 配置文件//引入定时任务import schedule from 'node-schedule';var fs = require('fs');var request = require('request');//连接mysql数据库import conn from '. /src/mysqlconfig';const connectionmysql = conn();//创建腾讯闲聊机器人import tencentcloud from 'tencentcloud-sdk-nodejs';const NlpClient = tencentcloud. nlp. v20190408. Client;var app = express();const addFriendKeywords = config. personal. addFriendKeywords// 初始化const bot = new Wechaty({ puppet: new PuppetPadplus({  token: config. token }), name: config. name})//初始化腾讯闲聊机器人，创建链接const clientConfig = { credential: {  secretId:  你的腾讯AI的secretId ,  secretKey:  以及对应的密码 , }, region:  ap-guangzhou , profile: {  httpProfile: {   endpoint:  nlp. tencentcloudapi. com ,  }, },};const client = new NlpClient(clientConfig);app. all('*', function(req, res, next) {  res. header( Access-Control-Allow-Origin ,  * );  res. header( Access-Control-Allow-Headers ,  X-Requested-With );  res. header( Access-Control-Allow-Methods , PUT,POST,GET,DELETE,OPTIONS );  res. header( X-Powered-By ,' 3. 2. 1');  res. header( Content-Type ,  application/json;charset=utf-8 );  next();});bot . on( scan , function onScan(qrcode, status) {  var img = qrImg. image(qrcode, { size: 10 });  img. pipe(fs. createWriteStream( logo. png ));  })  . on('login', async user =&gt; {   console. log(JSON. stringify(user))  })  . on( message , async message =&gt; {   console. log(JSON. stringify(message))  })  . on( friendship , function onFriendShip(friendship){   switch (friendship. type()) {    case Friendship. Type. Receive:     if (addFriendKeywords. some(v =&gt; v == friendship. hello())) {      friendship. accept()    }    break   }  })  . start();var server = app. listen(8090, function() {  var host = server. address(). address;  var port = server. address(). port;})接下来我们在服务器上运行该项目： cd 到目录列表npm i pm2pm2 start pm2. json如果没有pm2node index. js运行后，扫码登录之后后台就打印出已确认的日志： =================================================  QRCODE_SCAN MSG : 已扫码，请在手机端确认登陆. . . ==================================================================================================      QRCODE_SCAN MSG : 已确认=================================================目前来讲我们已经成功运行Wechaty项目了，想要实现上面的需求只需要实现具体的业务代码即可。 4. 目前实现功能:  自动通过好友验证     当有人添加机器人时，判断验证消息关键字后通过或直接通过    每日定时任务（每天在早上6. 30的时候发送夸夸语句和今日天气） 自动聊天     私聊发送消息即可聊天   这些在源码中已经体现，源码中有部分注释可以查看 5. 以后将要实现的功能:  当博客有内容新增的时候，将通过助手发送数据给订阅者     在开始订阅的时候需要设置信息    增加每个人私人时间定时，不在是固定的一个时间统一发送 拉人入群-以及还有功能没有考虑清楚的 还将对接音乐播放，点歌等等"
    }, {
    "id": 203,
    "url": "https://wechaty.js.org/2020/10/22/wechat-fanli-robot/",
    "title": "基于wechaty实现的微信机器人，根据淘口令生成高佣转链接，并创建新的淘口令。",
    "body": "2020/10/22 - 基于wechaty实现的微信机器人，根据淘口令生成高佣转链接，并创建新的淘口令。 本项目实现功能：  自动同意好友申请 淘宝优惠券查询 实现微信机器人: 机器人是基于 wechaty 来实现，官方文档已经有了非常的详细的教程，所以这里不做赘述。由于微信 web 协议现在已经废除，所以需要采用iPad协议，wechaty 的 iPad 协议启动是需要 token 的，token 是需要申请的，点击申请 token。 优惠券查询准备: 实现功能之前需要有一些前期准备，申请成为淘宝联盟推广者，新建媒体及推广位，这里遇到个坑，新增推广位的时候无响应，本人 Mac pro 使用 Chrome，不知道是不是只有我遇到这个问题，后来换成 Safari 就没有问题了。  媒体创建成功后还需要申请 APPKEY，点击申请之后会跳转到淘宝开放平台，然后新建应用，新建的应用没有 API 权限，需要申请。  具体实现:    解析淘口令     创建高佣转链接     生成淘口令  具体接口参数可以查看对应文档，淘宝开放平台虽然后解析淘口令和创建高佣转链接 API，但是一个没有权限，一个需要授权，所以这里采用淘口令现成的接口实现。 项目地址: "
    }, {
    "id": 204,
    "url": "https://wechaty.js.org/2020/10/15/wechaty-wangke-bot/",
    "title": "基于wechaty开发网课答案查询机器人",
    "body": "2020/10/15 - 自己有运营一个网课答案查询的微信公众号，无奈服务器压力有时候会大，会出现回复不及时的问题，所以突发冥想开发一个个人号作为备用。 项目地址: github：https://github. com/hurely/wechaty-wangke 技术栈:  wechaty –适用于微信个人的 Bot SDK ，可以使用 6 行 js 创建一个机器人 wechaty-puppet-padplus –同是 wechaty 团队开发，不同于网上基于微信 web 端的库，它是基于 iPad 协议 axios –node 请求库 qrcode-terminal –终端显示二维码 nodemon –node 文件热部署 xml-js –xml 和 json 解析（非必须）功能:  根据关键字和用户 id 自动回复网课答案 接收小程序后发送小程序小程序 appId 和路径 后续其他功能项目展示:    自动回复网课答案     接收小程序  核心代码: 1. src/index. js –wechaty 启动的入口文件 import config from '. . /config/config'const { Wechaty, ScanStatus, log,}  = require('wechaty')import { PuppetPadplus } from 'wechaty-puppet-padplus'import replyToAMessage from '. /utils/reply'function onScan (qrcode, status) { if (status === ScanStatus. Waiting || status === ScanStatus. Timeout) {   require('qrcode-terminal'). generate(qrcode, { small: true }) // show qrcode on console   const qrcodeImageUrl = [   'https://wechaty. js. org/qrcode/',   encodeURIComponent(qrcode),   ]. join('')   log. info('StarterBot', 'onScan: %s(%s) - %s', ScanStatus[status], status, qrcodeImageUrl) } else {   log. info('StarterBot', 'onScan: %s(%s)', ScanStatus[status], status) }}function onLogin (user) { log. info('StarterBot', '%s login', user)}function onLogout (user) { log. info('StarterBot', '%s logout', user)}async function onMessage (msg) { log. info('StarterBot', msg) var reply = await replyToAMessage(msg) await msg. say(reply)}function onMini(msg){ log. info('onMini', msg)}const bot = new Wechaty({ name: config. name, puppet: new PuppetPadplus({   token: config. token })})bot. on('scan',  onScan)bot. on('login',  onLogin)bot. on('logout', onLogout)bot. on('message', onMessage)// bot. on('mini',onMini)bot. start(). then(() =&gt; log. info('StarterBot', 'Starter Bot Started. ')). catch(e =&gt; log. error('StarterBot', e))2. config/config. js 基础的配置文件 module. exports = {  // 设定协议的token，本项目基于wechaty-puppet-padplus  token:  puppet_XXXXXXXX ,  // 机器人名字  name:  XXXXXXXX ,  //题库地址 申请链接为 http://api. 51aidian. com/index. php?id=kunggggyoyoyo  tikuApi:  ,  //bmob数据库配置 后续自行配置题库可以用到  bombApplicationId:'',  bombRestApiKey:'',  bombSecretKey:'',  bombMasterKey:'',  bombSafeCode:'',//API安全码  bmobHost:'https://api. bmobcloud. com/1/classes/',//数据库对应}3. src/utils/reply. js 根据关键字，回复内容 import axios from 'axios';const { FileBox} = require( file-box ) const { log} = require('wechaty') import config from '. . /. . /config/config' const { pareMiniProgramMsg, pareseXmlToJson} = require( . . /utils/utils )module. exports = (msg, length) = &gt;{ return new Promise(async(resolve, reject) = &gt;{  if (msg. payload. type === 9 &amp;&amp; msg. payload. fromId === 'mishi19900806') {   let text = msg. payload. text text = pareMiniProgramMsg(text) result = pareseXmlToJson(text) result = JSON. parse(result) var response = '小程序appId：' + result. msg. appmsg. weappinfo. appid. _cdata response += '\n\n小程序路径为：' + (result. msg. appmsg. weappinfo. pagepath. _cdata). replace('. html', '') resolve(response);  }  else if (msg. text(). indexOf('答案') &gt; -1 &amp;&amp; msg. payload. fromId === 'mishi19900806') {   let requestUrl =   ;   requestUrl = config. tikuApi + encodeURI(msg. text()) axios. get(requestUrl). then(async(response) = &gt;{    log. info('接口回调正常----', response) let result =  ❓问题：  + response. data. question +     +  💡答案：  + response. data. answer resolve(result);   }).    catch(function(err) {    log. info('接口回调错误----', err) resolve( 嗯~~~,这个问题人家还不会呢~ )   })  } else {   resolve('')  } })}为了开发方便，做了判断，只允许我另外一个微信号发送消息回复内容 4. src/utils/utils. js 工具类 var convert = require('xml-js')function pareseXmlToJson(xml) { var json = convert. xml2json(xml, {  compact: true,  spaces: 4 }) return json}function pareseJsonToXml(json) { var options = {  compact: true,  ignoreComment: true,  spaces: 4 } var xml = convert. json2xml(json, options) return xml}/** 解析发送微信小程序的内容 具体接收内容查看msg. xml文件**/function pareMiniProgramMsg(msg) { var str = msg. replace(/'\n'/g, ''). replace(/'\t'/g, ''). replace(/'\'/g, '') return str}module. exports = { pareseXmlToJson, pareseJsonToXml, pareMiniProgramMsg}Wechaty 的 Token 申请方法: 官方文档介绍 网课答案接口用法: 1. 访问http://api. 51aidian. com/index. php?id=kunggggyoyoyo 2. 按照页面要求自定义一个 id，如wangkebot，记下此时的 token73eF71417eC4652C561D4F30893a7F51点击授权 3. 将申请的 id 和 token 拼接成http://api. 51aidian. com/api/adct. php?uid=wangkebot&amp;token=73eF71417eC4652C561D4F30893a7F51&amp;q=(注意接口是付费的) 完成以上步骤后，一个简易的网课答案查询的微信机器人就做好了。 总结: 以上代码实现非常简单。通过 wechaty 方便了很多。可以把公众号粉丝引流到个人号，便于后期进行私域运营。 遇到的坑点:  避免微信号被封锁，建议开发的时候用微信小号进行开发，并根据特定的情况回复内容； wechaty-puppet 版本问题，参见 wechaty 文档运行: npm installnpm start"
    }, {
    "id": 205,
    "url": "https://wechaty.js.org/2020/10/13/wechaty-puppet-kuaishou-final-term/",
    "title": "基于RPA封装的Wechaty接口下的快手聊天机器人结项报告",
    "body": "2020/10/13 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。 旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。 官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html 本项目 [基于 RPA 封装 Wechaty 接口下的快手聊天机器人] 系 暑期2020 支持的开源项目。 结项报告：基于 RPA 封装 Wechaty 接口下的快手聊天机器人: 项目信息:  项目名称：基于 RPA 封装 Wechaty 接口下的快手聊天机器人 方案描述：服务器端架设虚拟机，通过auto. js操作虚拟机内部的快手。类似于通过puppeteer操作微信网页版，但是被迫增加了通信。 时间规划：7. 19-8. 15完成主要方案的探索8. 15-9. 30完成dingdong-bot完善接口项目总结:  项目成果：     熟悉wechaty的使用   使用RPA方式完成了puppet的部分接口         服务端在特定条件下可以完成一套流程，从登录到收发消息（验证问题仍然不能解决）     服务端增加了图片消息类型，通过base64直接发送，处理时间略长     创建群，以及群消息管理也可以实现，若有人多同时发送消息则效果不是很好          完成了readme文档的编写    遇到的问题及解决方案：     初期探索了很多方案，拦截收发消息的接口，或者使用puppeteer操作网页版   最终选择了使用auto. js在虚拟机操控快手与puppet通信来控制收发消息   初期的困难在于应用组件的命名不规则等导致的难以选取。   框架快速操作导致的bug（代码运行到页面b的操作的时候，应用还处于页面a跳转页面b的动画状态）   私信的消息没办法监听，后来通过特定的app启动顺序解决了该问题。局限性较大且不够稳定，猜测和auto. js的底层有关   通信也曾出现过问题，无法顺利的多次收发消息。后来通过调整文本末的代码解决（增加换行符）   修改puppet后出现了各种eslint错误，虽然最终被解决并且提交了dingdongbot的初期版本，但是后续修改调试略有困难   完成的dingdong-bot演示地址()   由于使用的是RPA方式所以多数的时间都放在了修改服务端代码上，puppet还有很多待改进的地方   PPT:  Live coding:  项目地址:  项目链接：https://github. com/bikaiqiao/kuaishou-auto / https://github. com/bikaiqiao/kuaishouPuppet"
    }, {
    "id": 206,
    "url": "https://wechaty.js.org/2020/10/13/wechaty-puppet-douyin-final-term/",
    "title": "基于RPA封装的Wechaty接口下的抖音聊天机器人结项报告",
    "body": "2020/10/13 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。 旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。 官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html 本项目 [基于 RPA 封装 Wechaty 接口下的抖音聊天机器人] 系 暑期2020 支持的开源项目。 结项报告：基于 RPA 封装 Wechaty 接口下的抖音聊天机器人: 项目信息:  项目名称：基于 RPA 封装 Wechaty 接口下的抖音聊天机器人 方案描述：安卓端通过autojs操作抖音，通过socket与puppet连接，再与wechaty相连 时间规划：7. 19-8. 15完成各种方案的尝试和探索，8. 15-9. 15完成puppet的各种接口接入项目进度:  项目成果：     熟悉了wechaty的使用的操作方法   探索了各种方案：         抖音的发送私信的openapi需要用户为企业用户，只有企业抖音号api才有效     探索了monkeyDEV和IDA逆向私信协议的方法     没有找到chrome跑安卓app的方法，或者方法失效     尝试了通过安卓和ios端抓包的方式获取抖音的私信方法，结果抓不到私信的消息     autojs控制安卓app的方法，现在正在采用，也是现在唯一可运行的方法，目前完成了抖音基本操作方法的封装和socket的通信          抖音的autojs控制版本完成了自动登录，消息监听，发送消息等方法   用socket和autojs的方法跑了一个简易dingdongbot，视频演示地址(youtube)   完成了抖音puppet初版和autojs操作抖音的方法   puppet完成了通信的基本功能，puppet跑dingdongbot   wechaty puppet配合autojs可实现消息自动回复    遇到的问题及解决方案：     本次代码遇到了很多问题，很少接触ts的编码，有很多不熟悉的地方   初期在私信方法的选择上尝试了很多种方案，最终选择了autojs作为操作抖音私信的工具，但是不那么稳定，性能很低需要一定硬件支持   autojs有时候很不稳定，调试也异常麻烦，只能一点一点推进，app控件的名字很随机，不同的抖音版本控件名字不同，所以app需要统一版本   跑通一个抖音puppet需要一个安卓手机或者电脑开模拟器跑autojs，然后用nodejs跑wechaty和puppet，需要跑两个服务，有点麻烦   在探索获取抖音的图片消息时，通过auto来查找图片存在一定问题，运行速度较慢，先打开图片然后缓存然后再加载图片转码成base64然后再发送到puppet   eslist语法格式在开始的时候因为不熟悉，经常报出各种错误   puppet的接口和方法不熟悉，模仿着写了一个抖音puppet，最终能跑dingdongbot了   消息频繁的时候可能会造成消息堆积，autojs处理消息需要时间，当autojs进入某一会话时，此会话发来消息，那么这个消息可能读取不到，但是在此会话外的消息可以读取到并处理回复   抖音puppet还需很多改进和添加新的消息类型和功能…   因为实习996的缘故，后期推进太少，加入社区还需努力   PPT:  Live coding:  项目地址:  项目链接：https://github. com/gavinwang23/douyin-autojs / https://github. com/gavinwang23/wechaty-puppet-douyin"
    }, {
    "id": 207,
    "url": "https://wechaty.js.org/2020/10/12/puppet-padlocal-intro/",
    "title": "New Wechaty Puppet Service: PadLocal",
    "body": "2020/10/12 - 大家好，我是 PadLocal 的开发者，大伙都称我“好大”。最近一两年，我们团队开始做社群相关产品，自然而然也用了 Wechaty，慢慢地对 Wechaty 以及整个社区也越来越认可和信任。 几年前做爬虫系统的时候，第一次接触到了 Wechaty。这个项目需要定期推送爬虫的状态信息，以及主动查询爬取的相关内容。正好当时有一句很流行的话：“对话即服务”，于是就想是不是可以通过微信来实现这些功能？借助 Wechaty 很快就实现了所有功能，最终效果也非常不错。 PadLocal: Wechaty puppet service provider: 但那时候社区中的 puppet 还不是特别完美，使用过程中有一些槽点。而且 puppet 生命周期不是特别稳定，用了一段时间可能就不再维护，我们担心这种不确定性会影响到我们的业务，于是萌生了自己去开发一个 puppet 的想法。再加上我自己也是国内比较早的一批 iOS 开发者，自信对 iOS 有比较深入的理解，以前也玩过一点逆向，觉得这样的想法也并非天方夜谭。 于是从 App 脱壳、用 IDA 反编译微信，开始了漫漫逆向之路。在做这件事之前，我们预计这个过程比较难，会遇到各种难啃的骨头，但万万没有想到会如此艰辛。虽然之前玩过逆向，不过也就是为了好玩，改改 App小功能、抢抢红包啥的，比较初级。刚开始的阶段还挺愉快，因为每一步你很容易看到自己的成长，每次打个怪就感觉升了一级。但慢慢深入下去，就遇到很多真正难啃的骨头，各种伎俩、资料、请教都失败之后，叹气之余感觉自己如那头黔驴一样。也产生过放弃的念头，但始终还是不甘心，仍然咬咬牙坚持了下来。在这里和大家分享几个这样“狼狈”的时刻：  处理代码混淆微信会对比较敏感的代码进行混淆处理，关于代码混淆推荐大家参考 ollvm 。总体来说，代码混淆大概有这几种手段：1. 控制流平坦化，2. 虚假控制流，3. 指令替换。Quarkslab 的这篇文章 “Deobfuscation: recovering an OLLVM-protected program” 也介绍一点解混淆的方法，但是文章中提到的例子相比微信中遇到的，只能是小巫见大巫。举个例子微信某个函数混淆后大概有 7W 多行，用 IDA 反编译就可以花一整天时间。通过每天慢慢盘这些代码，总结出了许多规则。于是自己写的一个小工具去解混淆，通过不断尝试与修正，最终成功将代码解混淆了出来。  0305算法微信本身对客户端会进行比较严格的校验，包括设备环境、设备指纹等信息。就是说用网上说的一些工具，去修改微信功能（比如用来抢红包），其实很容易被微信识别出来，封号也许是迟早的事情。这里就需要一些加解密和签名校验机制，其中 0305 算法是里面比较困难的一种。首先代码本身混淆过，其次即使解混淆出来，也很难看出来它的逻辑性，比如具体采用了什么算法以及加解密、签名校验流程。于是乎仍然只能慢慢探索，不断观察每一步数据的变化，摸索出一些可能的样式。最终经过非常多的尝试，才命中正确算法和流程。 经历过这样几个难点而且都成功解决之后，其实底气也足了很多。之后再遇到（其实还很多），仍然会有沮丧的时刻，但更多还是相信能够完成挑战。总体来说，这一路走来就是一步一个坑。解决了一个问题，开开心心重新抬起头来，“天晴了雨停了，我又觉得我行了” 。可过不了多久，微信又会分分钟教你做人，所以对微信一直保持着一颗敬畏之心。 最终，我们做出了一个完整实现的 puppet，叫做 PadLocal。至于为什么叫 “PadLocal” ？这就要谈到我们 puppet 的整体设计，以及相比其他 puppet 有什么不同之处。PadLocal 最大的特点是：  账号状态的托管方式 与 WeChatServer 的通信方式在设计 puppet 的时候，我们首先调查了社区内其他 puppet , 并研究了他们的实现原理。我们发现，其他 puppet 设计思路大多是这样：由 puppet server 进行管理和维持托管账号的状态。所有的请求都是通过 puppet -&gt; puppet server -&gt; WeChatServer 这样一条链路完成。消息推送部分，puppet 和 puppet server 之间建立长连接，同时 puppet server 和 WeChatServer 也建立对应的长连接。当有新消息推送的时候，是通过 WeChatServer -&gt; puppet server -&gt; puppet 这样的链路到达 puppet 端。这样的设计中 puppet server 就充当了一种有状态的代理角色，所有流量都是由服务器完成转发。在我们看来这样的设计可能有几个潜在的劣势：  因为最终和 WeChatServer 通信的都是 puppet server。如果一个 puppet server 上托管了多个账号，且没有对各个账号配置对应的代理策略，那么这些账号将共享 puppet server 的 IP。从风控角度来看，容易产生风险。而且一旦其中某些账号风险等级比较高，容易对同一个 IP 池的其他账号造成污染，伤及无辜。 所有流量都是通过 puppet server 转发，对其带宽产生了不小压力，特别是当托管账号中产生了大量图片、视频等多媒体资源时。 由于 puppet server 维护了托管账号状态，所以 puppet server 是有状态的。从系统架构角度来看，有状态的服务器在系统稳定性、可用性、容量规划等方面都存在不小挑战。如果集群中某些服务器宕机，而备机切换机制设计不够完善的话，容易出现部分账号处于不可用的状态。 为了保证 puppet 有更好的可用性和体验，通常 puppet server 会缓存（不一定永久保存）某些数据（比如聊天数据）。也就是说，服务端无可避免地需要触碰托管账号的业务数据。这就需要 puppet 的提供者保持极高的行业自律，而且通过充分的机制保证客户数据的安全性。基于对以上这些问题的思考，我们将所有流量转发工作都放在了 puppet 来做，这就是 PadLocal 中 Local 的来源。我们利用了 GRPC 的双向通信机制，让 puppet 成为代理，将所有流量通过 puppet 转发给 WeChatServer。同时由 puppet 来维持和 WeChatServer 之间的长连接。这样的好处显而易见：  托管账号和 WeChatServer 通信所使用的 IP 都是 puppet 端的 IP，不同账号天然就不存在共享 IP 的风险。 下载图片、视频等多媒体资源的流量不需要经过 PadLocal server。而且不经过服务器，效率也更高。 账号状态维护在 puppet 端完成，于是 PadLocal server 就可以设计为 stateless 的了，应对扩容等问题天然就会简单很多，simple is beautiful。 PadLocal server 不会保存任何业务数据，没有数据安全方面风险。整体架构的拓扑图就如下所示： 再回过头来看，通过实现一个 puppet，我们自身也收获了非常多的东西。首先对 Wechaty 有了更加深入的了解，能更真切体会设计者的初衷，以及其中的权衡取舍。Wechaty 能够如此易用，都是精心设计后的结果。这是一个美妙的旅程；其次实现一个 Wechaty puppet 是一件十分有挑战的事情，能够完成这样一件事情当然成就感满满；再者可以从内部视角，比较深入和全面的了解微信端上的运行机制和设计思想。作为国民级的通信软件，微信的设计十分出色，各种各样机制、设计理念完全可以担当行业标准，无愧是这个领域绝对的王者。 现在我们决定对外发布 PadLocal puppet，目的希望能够帮助大家在微信生态实现各种创意，同时也帮助微信生态更加丰富、更加健康的发展。我们的存在不是为了作恶，而是帮助建设一个更加美好的社会。对于将来的计划，我们会一直随着微信版本的迭代，积极地持续维护着这个 puppet。 PadLocal 目前是还出于 beta testing 阶段，仍然有一些小问题需要去解决。我们希望能够有更多的开发者参与进来，一起让这个 puppet 走向下一个更成熟的阶段。我们有奖励机制以感谢对 PadLocal 作出贡献的伙伴，具体规则仍在商定之中。目前 Token 以“申请+审核”的方式，向大家逐步开放。如果你感兴趣，欢迎联系管理员同学，并说明你通过 PadLocal 实现什么样的创意。我们也正在准备更加详细文档和指引，敬请期待。 最后，长城非一日建成，我们也是站在巨人的肩膀上才能完成这样的工作，感谢所有帮助过 PadLocal 诞生的小伙伴，比心。 "
    }, {
    "id": 208,
    "url": "https://wechaty.js.org/2020/09/30/wechaty-puppet-lark-final-blog/",
    "title": "基于开放 API 封装 Wechaty 接口下的飞书聊天机器人：期末",
    "body": "2020/09/30 - “开源软件供应链点亮计划-暑期2020”（以下简称暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [基于开放 API 封装 Wechaty 接口下的飞书聊天机器人] 系 暑期2020 支持的开源项目。 [基于开放 API 封装 Wechaty 接口下的飞书聊天机器人]信息:  导师：高原 吴京京   学生：范蕊   项目名称：基于开放 API 封装 Wechaty 接口下的飞书聊天机器人 方案描述：     通过飞书订阅消息事件读取消息   通过飞书订阅通讯录事件实时更新通讯录内成员信息   对接飞书接口，实现 puppet 上各个类型的消息接口   设计配置参数   撰写飞书 puppet 的使用文档    时间规划     熟悉技术栈         7. 1-7. 20     阅读Wechaty-puppet-plus源代码，学习TypeScript，熟悉飞书服务端API          与飞书建立连接         7. 20-7. 31     通过Express与飞书建立连接，实现文本信息的收发（即ding-dong-bot机器人）          完成文本信息的收发puppet         8. 1-8. 5     将文本信息的收发结合到lark-puppet中     搭建项目基础框架          完成其他基础消息类型的收发         8. 6-8. 20     完成其他消息类型的收发，包括：图片、视频、文件          完成消息卡片的收发         8. 21-8. 30     通过消息卡片与用户建立多次交互式通信          设置配置参数         8. 31-9. 7          代码重构         9. 8-9. 20          撰写使用文档         9. 21-9. 30          项目总结:  项目成果：     项目仓库位于: https://github. com/Roxanne718/wechaty-puppet-lark   Live coding视频:     Demo 视频:  遇到的问题及解决方案：     使用Ngrox进行内网穿透时，每次重启子域名都会发生变化，在老师的建议和指导下最终采用localtunnel解决了这一问题。   由于对TypeScript和HTTP请求的理解不太透彻，遇到了一些消息格式上的问题，通过查阅资料、学习其他同学的代码等解决了这些问题。   目前虽然完成了基础功能，但是项目并不能达到发布水准，如果想要像在微信中使用 wechaty 那样开发飞书机器人，还需要完成以下事情：         contact类、room类等的封装     其他 payload 消息的封装与处理     将 puppet 封装到 wechaty 中          感谢 wechaty 社区对我的包容、帮助和鼓励。虽然只有短短三个月的时间，但在这个项目中收获了很多。在与导师的交流中学到了很多新的东西，也认识到了很多优秀的同伴。目前这个项目还没有达到我预期的水准，后续我还会继续跟进、完善，希望能完成一套完整的飞书机器人框架。   这是我第一次严格意义上自己独立开发，在开发过程中遇到不少问题，如前后接口不一致、项目后期修改了前期的逻辑等等。在为新的 bug 焦头烂额的过程中我越来越理解到了工程化的重要性，希望自己能汲取教训，在今后的开发中做得更好。   最后，希望“开源软件供应链点亮计划”系列活动越办越好，相信未来的开发者们也能从中获得成长、成为中国开源软件链新的贡献者。   联系我们:    项目链接：https://github. com/Roxanne718/wechaty-puppet-lark                 联系方式：+86 17822015718     email: 953299708@qq. com          "
    }, {
    "id": 209,
    "url": "https://wechaty.js.org/2020/09/30/wechat-file-schedule-box-clafixed/",
    "title": "Wechat File Schedule Box",
    "body": "2020/09/30 - 使用Wechaty以少量的代码实现一个微信文件日程匣子项目。可快速将微信中的内容同步（转存）到其他网盘中。同时还添加自动识别处理日程等的小功能。 关于Wechaty: 官方定义：:  Wechaty是一个开源的的个人号微信机器人接口，使用Typescript构建的Node. js应用。支持多种微信接入方案，包括网页，ipad，ios，windows，android 等。同时支持 Linux, Windows, Darwin(OSX/Mac) 和 Docker 多个平台。 一句话概括——是一个能模拟登录微信并收发微信信息、添加自定义处理逻辑的库。值得注意的是其中的模拟登录，可以是模拟Web端登录（Wechaty提供免费支持），也可以是模拟Mac、iPad端登录（Wechaty以收费的云服务形式提供，但是可以申请成为开发者获取使用权限）。 项目背景: 在使用微信作为主力办公工具的过程中，经常令人头大的问题之一就是处理文件，不论是同事之间互传文件或者是群聊里发送文件，要统一归档到网盘同步都是很麻烦的事情（尤其在iOS端微信，只能挨个打开在选择用其他应用打开）。因此希望实现一个能自动归档文件的效率小工具。 实现思路: 由于Wechaty提供了很方便的File API，通过fileMsg. toFileBox方法就能获取一个消息的文件，因此通过“收到多个文件-转发到文件匣子（一个微信号）-转存到其他位置”的流程，就能实现把文件多选转发到文件匣子，然后自动归档到网盘的效果。 此外，如果msg. type方法还能判断消息类型，从而可以对应日程文本使用正则匹配日期的NLP方法，将转发到匣子的日程文本识别出来存到数据库中供后续处理；如果是URL分享类型的消息，也可以识别出来并统一存储。 代码结构:  代码仓库已开源。 目录结构如下：  ├── LICENSE  ├── Node  │  ├── coursHandler. js  │  ├── databasesConfig. js  │  ├── databases. js  │  ├── fileHandler. js  │  ├── functions. js  │  ├── httpServer. js  │  ├── main. js  │  ├── menuHandler. js  │  ├── scheduleHandler. js  │  ├── test. js  │  └── webdav. js  ├── package. json  ├── package-lock. json  ├── public  │  └── cours. json  ├── README. md  ├── RunDir  ├── RunRobot. sh  ├── template  │  └── template. html  └── Time-NLP  ├── pom. xml ├── README. md ├── resource ├── src └── target 主要代码位于Node/下。其中：  main. js初始化Wechaty实例并判断收到消息的类型 databases. js和databasesConfig. js配置数据库表结构和连接数据库 webdav. js配置node的webdav模块，通过Webdav连接到个人网盘 menuHandler. js, scheduler. js, fileHandler. js, coursHandler. js分别处理控制消息、日程消息、文件消息、课程表查询消息 httpServer. js, template. html, cours. json则实现了一个简易的webpage用于网页端访问这些信息。Time-NLP/中的源代码编译后，能够得到class字节码供node的java模块调用，从而实现从含有日程的文本信息解析出日期。 RunDir/的存在主要是因为msg. toFileBox方法会在运行目录保存文件，故在此目录下暂存这些文件。 结语: 众所周知微信作为我们每天都在使用的工具，在文件管理等方面较QQ等其他工具功能过于单一，因此可以通过Wechaty搭建一个文件匣子，给微信加上文件自动同步网盘、日程自动收集等小功能，让日常办公更加效率：） "
    }, {
    "id": 210,
    "url": "https://wechaty.js.org/2020/09/28/puppet-work-final/",
    "title": "暑期2020 [基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人] 终结成果展示",
    "body": "2020/09/28 - 本项目计划针对企业微信平台开发一个puppet，让 Wechaty 开发者可以仅仅通过改变一个变量，就能够切换使用企业微信的功能。 暑期2020 [基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人] 终结成果展示: 暑期2020: “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人] 系 暑期2020 支持的开源项目。 [基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人]:  导师：高原   学生：谢昱清   项目名称：wechaty-puppet-wecom: 基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人 方案描述： 时间规划：     准备工作   2020. 7. 1 - 2020. 7. 19         掌握相关技术栈（typescript等），了解puppet构造。     与企业微信建立连接，完成node. js到企业微信的信息通路          2020. 7. 20 - 2020. 8. 5         包括对话的加密解密，相关环境配置，node. js与微信SDK的交互。完成node. js进行企业微信消息拉取的demo。     注：原计划于2020. 7. 26完成，但是由于对预期成果理解有误，进展方向出现了偏差，延期一星期。     实现 puppet 上各个类型的消息接口          2020. 8. 6 - 2020. 8. 30         正式开发puppet。完成状态函数，消息的读取及消息的存储等内容。可能需要拓展原本puppet的数据结构。其中第一周完成逻辑设计及基本的消息拉取。     注：企业微信puppet仅负责拉取消息，不必完成完整的交互过程，因此可能需要单独设计对应的bot进行测试。     实现puppet上对媒体文件信息的拉取          2020. 8. 31 - 2020. 9. 20         基本完成puppet的全部功能，可以将媒体文件暂存在文件夹下。     重构代码+收尾完善          2020. 9. 21 - 2020. 9. 30         简单封装了contact、room等类，改变了媒体文件的传送方式，完成了FileBox的相关函数。撰写readme等文档，明确仍需开发的内容，完成项目结题报告。          项目进度:  项目成果：     运用企业微信提供的API接口完成了消息的加密解密以及跨语言的信息传递；   完成了全部消息类型（文本信息及媒体信息）的封装；   简单配置了参数及内部逻辑，可以定时拉取形成“即时沟通”的效果；   撰写简单的配置说明。   关于代码结构与功能演示的视频     遇到的问题及解决方案：     对项目需求不明确，前期缺乏和导师的有效沟通，导致有一两周的进展与目标方向无关，成为了无用功。后期应当积极与导师沟通，尽快解决存疑的问题，避免出现类似的情况。   使用全新技术栈，除了需要花费较多时间入门外，在配置环境等方面出现了大量问题，有些甚至在网络上都无法搜索到解决方式。例如安装node-ffi时遇到的几个少见的安装bug：         编译时没有binding. cc这个文件，需要自己建一个空文件；     node和npm需要降级，否则无法成功安装编译ffi/ref；     如果用C++编译ffi的example（factorial. c），需要更改宏结构，否则会报“Error: Dynamic Symbol Retrieval Error: Win32 error 127”。          时间管理出现了一些意外。在学校一共上了七周的小学期，以及三周秋季正式的课，加上平时不注重时间管理，导致长时间进度落后。以后也需要注意抓紧时间，不能拖延，将能做的事情尽早解决。   心得与体验: 在项目期间，我感觉自己对于代码的理解能力在不断提高，回首一看，原先不懂的现在都明白个大概了，收获真的很大。在写这个报告的时候其实才算是对整个wechaty的架构有了一个比较清晰的认识，从7月初的完全不懂到八月的逐渐入门再到现在的恍然大悟（或许也没有真正领悟），很有成就感。 当然遗憾和不足也同样很多。主要的问题还是在于自身，对语言的不熟悉、时间上的冲突，导致目前的结果并不十分令人满意，遗留下了不少的坑待填。对于我而言这也是一个很重要的教训，未来做项目也要规划好时间，及早了解需要的技术栈，这样才能更好地完成任务。 另：其实本来觉得自己的代码虽然肯定不能直接发布使用，也勉强算是马马虎虎完成了主要的功能。但是一看别人的blog，我陷入了深深的尴尬，其实可以完成度更高、做得更好的。希望这学期学校开设的软件工程等等课程可以让我更深入地理解并熟悉完整开发流程吧！ 联系我们:  项目链接：https://github. com/Sapio-S/wechaty-puppet-official/ 联系方式：1205402283@mail. qq. com Author: @Sapio-S Learning &amp; practicing. Code: @code "
    }, {
    "id": 211,
    "url": "https://wechaty.js.org/2020/09/27/python-wechaty-meme-bot-final/",
    "title": "基于Python-wechaty建立一个斗图机器人 POC 结项博客",
    "body": "2020/09/27 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 基于Python-wechaty建立一个斗图机器人 系 暑期2020 支持的开源项目。 [基于Python-wechaty建立一个斗图机器人]结项报告:    导师：黄纯洪     学生：肖子霖     项目名称：基于Python-wechaty建立一个斗图机器人     方案描述：在导师的指导下，我利用OCR、NLP分词与对话系统等相关技术，实现了以下功能：          提取用户所发送表情包的内容；           将提取内容送入GPT2对话模型，并根据对话系统输出判断下一步回应：利用互相关Loss在候选回答中按互相关Loss升序排序选出最符合语义的回答，如果回答能匹配数据库中已有表情则回复对应表情，否则直接使用提取内容匹配数据库内容；具体技术方案泳道图见下：        更多细节可参见项目README.     时间规划（摘自项目申请书）：      Week1：仔细阅读python-wechaty项目源码，掌握项目大体框架和可用API；   Week2：收集表情包数据，选择合适的网络模型。   Week3~Week4：训练模型，调试参数；   Week5：开发核心模块，编写单元测试；   Week6：开发、配置表情包后端；   Week7~Week8：模块联调，编写测试样例，上线测试。   项目总结:    项目成果：在本次暑期2020活动中，我向Wechaty社区贡献了已完成以下工作的wechaty-meme-bot项目:      基于peewee搭建的表情包管理数据库；   基于BeautifulSoup搭建的、可扩展的表情包爬取、收集、导入模块；   针对表情包的OCR提取模块；   针对表情包的Inception特征提取模型，Deep Cosine Metric Learning for Person Re-identification一文中有关Metric Learning部分的相关训练、验证、测试模块；   基于python-wechaty的前端回复模块；   基于Flask-restful的后端表情包回复接口；   基于GPT2对话模型的回复生成机制；   基于Github Actions的斗图机器人CI/CD流程；   完整的使用、部署教程；    具有代表性的对话参见：       遇到的问题及解决方案：      前期开发方向与导师原意有所偏差，在与导师充分交流沟通后及时调整了开发方向，由原先的仅提取内容与特征并进行匹配转变为项目需要体现斗图机器人的对话特性；   表情收集困难：在本项目中表情包数量直接决定了回复表情的合理程度，如果表情数据库中表情数量过少，即便对话系统输出结果本身很优秀，也无法在数据库中匹配出符合条件的表情；为此，我在Github上搜寻了到了按主题分类的ChineseBQB表情包仓库，同时编写了BaseSpider与爬取发表情网站的爬虫，若需要爬取其他表情包网站只需继承BaseSpider并覆写download方法即可；   GPT2模型参数量较大，自行收集闲聊语料训练时由于训练硬件条件限制，模型难以收敛；为此，我使用了来自GPT2-chitchat的闲聊语料预训练模型；   python-wechaty对FileBox的say()间歇性失效导致开发后期调试缓慢（Issue链接），由此原因在DemoLive视频中我将只播放提前剪辑好的测试视频，以免上述情况影响展示效果；   结项PPT演示 &amp; Demo视频链接: PPT演示： Bilibili: https://www. bilibili. com/video/BV18f4y1D7GN/ Youtube:  Demo Live视频： Bilibili: https://www. bilibili. com/video/BV14A411J783/ Youtube:  Reference: Open-Source Reference:  chineseocr_lite: Powerful Chinese OCR module with accurate results and fast inference.  HaNLP: Multilingual NLP library for researchers and companies, built on TensorFlow 2. 0.  Transformers: State-of-the-art Natural Language Processing for Pytorch and TensorFlow 2. 0.  GPT2-Chinese: Chinese version of GPT2 training code, using BERT tokenizer. Academic Citation: # in backend/cosine_metric_net. py[1]N. Wojke and A. Bewley, “Deep Cosine Metric Learning for Person Re-identification,” in 2018 IEEE Winter Conference on Applications of Computer Vision (WACV), Lake Tahoe, NV, Mar. 2018, pp. 748–756, doi: 10. 1109/WACV. 2018. 00087. # GPT2 Original Paper[2]Radford, Alec, et al.  Language models are unsupervised multitask learners.   OpenAI Blog 1. 8 (2019): 9. 联系我们:  项目链接：@python-wechaty-meme-bot 联系方式：me#mrxiao. net (# -&gt; @)评审对象:  评审内容：结项报告 提交人：肖子霖评审结果:  项目完成度：项目的初衷是做一个“能”斗图以及“会”斗图的机器人，肖子霖在项目中期完成了“能”斗图的机器人，在项目的后期，“能”斗图的机器人也是完成了升华，成为“会”斗图的机器人。从最终结果来看，肖子霖同学的完成情况还是比较好的。 学生参与度：在项目后期的实施过程中，肖子霖同学克服各种困难，在自己不熟悉的领域，比如自然语言处理，也是取得了一定的成绩，这一点是可以肯定的。在项目过程中，肖子霖积极参与项目的开发，在未知的领域中进行探索，努力寻找解决问题的方案与办法，最终完成一个”会”斗图的机器人。 代码贡献量：本项目在后期的话，由于机器学习的特殊性质，可能代码量并不是特别多，工作量上面主要突出在不断修改模型以及调参，最终一个“会”斗图的机器人才能得以完成。 综合评价及建议：总体上来说，本次项目肖子霖同学完成得不错。从一开始的表情包的识别，包括文字识别和情感识别，到后来的“能”斗图的机器人，再到最后的“会”斗图的机器人，肖子霖同学都用实际行动完成了项目。最后一个建议：从目前呈现的效果来看，“怼”的效果可能还欠缺一点火候，希望后期可以“怼”得更好。 最终评审结果：通过"
    }, {
    "id": 212,
    "url": "https://wechaty.js.org/2020/09/27/go-wechaty-plugin/",
    "title": "暑期2020 [为 go-wechaty 设计实现插件体系] 结项报告",
    "body": "2020/09/27 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [为 go-wechaty 设计实现插件体系] 系 暑期2020 支持的开源项目。 [为 go-wechaty 设计实现插件体系]信息:  导师：丁小雨、丁超飞、李博杰 学生：林昊翰 项目名称：为 go-wechaty 设计实现插件体系方案描述: wechaty 是一款支持多协议的微信接入方案，随着社区多语言生态的建立，吸引了更多的开发者和爱好者的加入；同时需求的推动和技术的发展，插件系统逐渐完善，但是在多语言系统中 Plugin 体系尚未完成，我们希望通过这个任务，能够让更多的人加入 go-wechaty 的建设。 目前 go-wechaty examples/ding-dong-bot. go 有一个 ding-dong bot, 但是我们希望这个 ding-dong 是通用的，如果我们的 Plugin 体系能编写出来，也许实现 ding-dong 就只需要一行代码。例如： bot. Use(DingDong{})go-wechaty 是 Go 语言实现 wechaty 的项目，同样支持多协议接入；同时借助 gorountine 和 channel 的语言特性，实现了更加合理的封装和设计。 时间规划: 第一阶段(7月1日至8月15日) 编写插件机制设计文档，与导师交流沟通。其中，文档包含设计思路，实现逻辑，以及涉及到项目代码变更等。根据 Go 语言特性，对插件机制的设计进行改进，并且尝试思考更多可能的方案。如果有需要，还应该编写相应的试验代码。 第二阶段(8月16日至9月30日) 根据第一阶段的设计文档编写代码，实现 go-wechaty 的插件机制；使用 go-wechaty 插件机制编写一个插件 Demo，并解决插件机制使用过程中遇上的问题，回过头修改插件机制的设计和实现。 项目总结: 视频: 结项报告  Live Coding  项目成果: 截止至项目结束，取得了以下成果：    设计并实现了 go-wechaty 的插件机制，该插件系统具有基本的管理功能，并且参考了 Go 语言的设计特性。     根据 go-wechaty 插件机制实现了一个插件 Demo,验证了插件机制的可行性、易用性。  项目原计划的核心目标已经全部完成。 go-wechaty 插件机制设计文档: 每周进度汇报与讨论Issue：为 go-wechaty 设计实现 插件体系 相关代码仓库：go-wechaty Plugin 分支 PR 新增加 wechaty. Plugin 结构类型存储插件相应的回调函数，它支持 Wechaty 中的所有事件注册函数(比如 OnMessage())，使用方式与 Wechaty 实例一致，便于把 Bot 代码封装成为插件。 新增加 wechaty. Context 结构类型用于一轮消息事件的控制、传递。在每一次接收到新的消息事件时传入一个新的变量。同时，该结构实现了 context. Context 接口。 以下是 go-wechaty 插件机制的功能说明：  调用顺序（优先级）按照注册顺序依次调用。其中，Bot 逻辑代码与插件逻辑代码可以存在交错执行顺序。即： var bot = wechaty. NewWechaty()bot. OnMessage(func(context *wechaty. Context, message *user. Message) {  // Part A})bot. Use(pluginB). Use(pluginC)bot. OnMessage(func(context *wechaty. Context, message *user. Message) {  // Part D}执行顺序：Part A → pluginB → pluginC → Part D    开关          禁用、启用插件。     对应方法：Plugin. SetEnable     通过加锁的方式修改插件属性变量。这个方法是并发安全的。           在本轮消息事件中，暂时禁用某一个插件。     对应方法：Context. DisableOnce           消息拦截，跳过后续插件对该本轮消息事件的处理。同时终止所有仍在进行的插件代码操作，即先前插件产生的 Goroutine。     对应方法：Context. Abort 以及 Context. Done           在并发程序中，控制插件内部 goroutine 的结束。用法与 Go 语言中的 context. Context (WithCancel ())相同。     对应方法：Context. Abort 以及 Context. Done     示例：     plugin := NewPlugin()plugin. OnMessage(func(context *wechaty. Context, message *user. Message) {  go func(ctx context. Context) {    // other code . . .     select {    case &lt;-ctx. Done():      // terminated by wechaty. Context. Abort()    // other code . . .    }  }(context)})// other code . . . // context. Abort() will terminate the goroutine             数据传递  通过 Context 传递数据，数据只在本轮消息事件有效。 不支持并发读写。 对应方法：Context. SetData, Context. GetData 示例插件 wordcounter 说明: 相关代码仓库：示例插件 wordcounter 该插件运行于以上设计的 go-wechaty 插件机制，本插件开发的主要目的是验证插件机制的可用性以及易用性。 插件的功能为统计限定小时内群成员发言词数（仅统计文字类消息）。 插件的使用方式如下，调用方只需要传入相应的配置信息即可。 import  github. com/FINCTIVE/wordcounter func main() {  var bot = wechaty. NewWechaty()  bot. Use(wordcounter. New(wordcounter. Config{      SearchKeyword:  #排名 ,      MaxResultCount: 10,      Hours:     6,    }))  }  // starting bot . . . }遇到的问题及解决方案:  如何参与开源社区、为开源社区做贡献？我在大学的前两年时间里并没有参与过大项目的开发，更别提要求较高的开源项目。开源项目的远程协作开发对我来说有极大吸引力，但我一直没有一个合适的机会参与其中（水平不足、不知道如何参与等情况让我屡次放弃跨出第一步）。本届开源软件供应链点亮计划正好提供了这次机会，让我参与到 Wechaty 社区中进行项目开发。Wechaty 社区是一个包容度很高的社区，社区内的导师们会对学生提出的问题耐心解答。这次活动的经历增加了我参与开源软件开发的经验，同时争强了我的沟通交流能力。在以后的开发历程中，我会为继续为开源社区贡献代码。  在开发过程中，常常遇到陌生的技术问题，需要学习新知识。在本项目的开发过程中，我遇到的主要问题来自对 Go 程序开发的不熟悉，在许多细节上会产生疑惑。实际测试程序时，也有一些小问题需要解决，比如 Docker 的使用、排错。我的解决方案主要是自己学习、查阅资料。这次项目开发的经历大大提升了我的编程能力。 对于部分无法自己解决的问题，社区里的导师们给了我很大帮助，导师们在阅读我的代码后给出了许多具有针对性的建议，这对我完成项目开发是十分必要的，感谢导师们的付出。  项目开发时间较长，常常有想要拖延的念头，动力不足。得益于 Wechaty 社区优秀的管理方式，参与项目开发的学生需要在相应的Issue上填写每周开发报告，报告中需要汇总每周工作成果，制定下周开发计划。由于有每周汇报的压力，我的拖延现象降低了许多。这次项目开发经验也让我学习到了制定计划的重要性。 导师评审结果:    项目完成度：按照原计划方案，完成原计划的功能开发     学生参与度：项目参加活动的部分，全部由学生完成     代码贡献量：Plugin 100% 由学生完成，包涵一个示例 Plugin，占到整个开源项目的10%-20%。     综合评价及建议：          昊翰同学的学习能力，和能动性特别强，能够很快的上手新的知识和方法；从最初的对开源项目的无从下手，到熟悉常规的共享代码的方式，以及对 Go 的掌握，都能感受到进步和收获；相信这么一次短暂的活动经历，能在你今后的工作和生活中成为谈资。           相信大部分从学校过渡到工作中，都会对长周期的项目产生动摇，其实你只需要按照原计划去完成既定工作就好，大项目拆解成小项目是计划和执行中很重要的部分；报告中提到了周计划，很欣慰你看到了这点带给你的价值，它使你没有偏离原有计划的方向，也希望你今后的工作中能从此有所收获。          最终评审结果：通过  联系我们:  项目链接：wechaty/go-wechaty 联系方式：finctive@foxmail. com"
    }, {
    "id": 213,
    "url": "https://wechaty.js.org/2020/09/27/go-wechaty-gh-actions-optimization-final-poc/",
    "title": "暑期2020 [Go-wechaty Github Action optimization] 结项 POC",
    "body": "2020/09/27 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。 官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html 本项目 [Go-wechaty Github Action optimization] 系 暑期2020 支持的开源项目。 项目信息:    项目名称：Go-wechaty Github Action optimization     方案描述：使用 Github Actions 相关特性为 Go-wechaty 相关项目作相关优化，提高使用以及开发体验。     时间规划：      7月1日到7月7日：阅读 Go-wechaty 及其插件的文档以及源码，分别进行本地手动编译测试、通过 Github Action 持续集成脚本编译测试。   7月7日到7月14日：编写 Github Action 脚本，实现 Go-wechaty 的 go-wechaty-getting-started 依赖进行更新，实现 Windows 平台下的ding-dong 编译测试。   7月14日到7月21日：寻找其他的 Github Action 用处，钻研 wechaty 已有的持续集成方案的优化方案。   8月1日到9月5日：完善 Dockerfile，以及触发 Dispatch 的条件。   项目总结:  项目成果：     自动更新 go-wechaty-getting-started 依赖到最新版本         使用 Repository Dispatch 跨仓库触发 Actions             达到更新条件时更新后向 go-wechaty-getting-started 提交 Pull-Request                     完成 win 平台下 ding-dong 编译测试   完成 ding-dong 的 docker 并推送到 Github Packages         使用多阶段构建，减小镜像体积     尝试了 buildx           遇到的问题及解决方案：     学习Docker相关时，尝试使用buildx一次构建多个平台，但由于Github Packages不支持多平台镜像，改为测试了9月上线的ghcr。   在测试go-wechaty时，对触发条件理解不够深入，个人认为将发送dispatch作为step放在编译测试之后符合逻辑，仅仅用if:Contains()语句粗略的判断是否为Pull-Request事件从而跳过。经过导师提醒后，认识到这样容易发生混淆，在此感谢丁老师的提醒。   在Github Actions优化的核心目标实现后，在现有的项目基础上的优化失去方向，我在导师丁老师的提醒下转向对 Dockerfile 的优化，学习了相关内容，多阶段构建也减小了镜像体积，优化上手体验，再次感谢老师的指导。   视频报告:  导师评论: 评审对象:  评审内容：结项报告 提交人：唐光彬评审结果:  项目完成度：完成了原既定的跨项目触发CI，以及Docker镜像的编译等工作。 学生参与度：跨项目触发完全有学生完成，Docker编译部分由学生进行新方案的改进，Dockerfile在指导下完成优化 代码贡献量：新方案的CI/CD的部分全部由学生完成，代码量涉及开源项目的5%-10，但不能以代码量论英雄，CI/CD对整个开源项目具有积极意义 综合评价及建议：     光彬同学能够很好的主动扩充自己尚未掌握的知识领域，甚至于在一定方向上能够主动的去探索新的技术方案，这一点在工作中是很重要的技能，希望你能够不段的扩充自己的知识领域，能够解决更多未知的问题。   技术方面相信你有足够的积极性去解决，就像你在总结中提到的你会意识到自己技术上的提升空间，但是另一方面希望你能够在开源方面有更多的收获，它可以使你在今后的工作中能够推动更多项目协同上的改进。    最终评审结果：通过"
    }, {
    "id": 214,
    "url": "https://wechaty.js.org/2020/09/26/wechaty-words-per-day-plugin-final/",
    "title": "暑期2020 [编写一个“每日一句”插件] 结项报告",
    "body": "2020/09/26 -  项目名称：编写一个“每日一句”插件 方案描述：     制作可以被 wechaty 调用的插件，能够使用内置的语料接口   插件能够构造 POST 和 GET 请求，设置请求参数，并根据指定的解析规则解析返回的 json 格式或者 html 格式的内容   插件可以根据请求结构中的图片地址下载图片，并根据每日一句内容以及微信群的相关信息添加水印   插件能够设置定时发送的时间、群名、发送的内容    时间规划：     开发插件的基本框架         7/1 - 7/21     插件的输入参数有：使用的内置 API 接口名称、应用的群聊名称以及发布每日一句内容的时间，完成基本代码构建。插件能够设置定时发送的时间、群名、发送的内容，也可以根据请求结构中的图片地址下载图片，并根据每日一句内容以及微信群的相关信息添加水印。          发布 NPM 包，引入 CI/CD         7/22 - 8/14     进一步优化代码以及注释，引入 CI/CD 来进行代码质量控制以及包的版本管理          丰富语料库         8/15 - 9/07     首先确定使用的 API 接口或者爬取的网址，根据不同的网址进行不同的解析，返回指定的结果。构造请求并解析内容，返回需要的字符串（每日一句的内容或者图片的 URL）。如有余力的话，能够支持用户自主设定语料的来源。          进行测试完善项目文档         9/07 - 10/01     完善项目文档，撰写整个项目过程的总结文章;增加单元测试等;计划延迟的缓冲时间          项目总结:  项目成果：     项目仓库位于: https://github. com/univerone/words-per-day   相应的npm package地址为: https://www. npmjs. com/package/words-per-day   live coding视频:     PPT展示视频:  PPT:  遇到的问题及解决方案：     编程语言的不熟悉. 由于之前没有接触过typescript语言,在项目前期, 我对于整个项目的具体实现包括项目文件的组成结构都没有经验, 所以刚开始比较难着手, 解决方法是多参考社区内其它以typescript为主要编程语言的项目, 结合官方文档和教程, 总结出使用wechaty社区的规范从0发布一个npm package的流程, 据此来组织我的代码. 在具体的编程实现上, 我也参考了很多javascript的语法(尤其是MDN Web文档). 此外看到很多项目都有vscode配置文件夹,在项目一开始我就学习使用vscode进行开发, 到后面觉得十分趁手,也算是”真香”了.    回调函数的问题. 在编写这个插件的过程中，有很多需要等待一定时间来完成的步骤，比如图片的下载保存等，如果不进行设置的话一些过程是异步执行的，如果想在这个过程结束后进行下一个过程，可以使用回调函数, 然后使用回调函数使得代码的可读性变差, 在查阅相关资料之后, 我选择使用Promise来替代回调函数, 由于Promise/await的语法和逻辑有一点复杂, 可以边看文档边整理重要的概念, 之后回顾的时候也方便理解.    调试代码的问题. 在开发过程中经常需要查看代码效果, 首先是针对函数的测试, 刚开始我将调用的代码写在对应的ts文件下面, 然后直接运行生成的js文件. 后面将多个函数测试的代码单独写在一个ts文件中, 再之后查看插件在微信机器人上运行效果的时候, 我选择在dist目录里面写一个javascript文件, 启动机器人,在 typescript文件对应的行处设置断点进行调试, 这是在发布包之前进行的调试. 在包发布完成之后, 还要在单独的linux服务器上, 创建nodejs项目引入最新的插件查看效果.    图像处理的问题. 在刚开始每日一句项目的目标就包括生成图片, 而在生成图片工具的选择上我花费了较大时间, 根据参考的项目我使用nodejs包gm来进行图像处理,其基本原理是使用调用系统中安装好的GraphicsMagick或者ImageMagick, 由于文档中说明文件较少, 因此使用这个包来实现预期的显示效果花费了最长的时间. 在项目后期参考其他项目, 是用puppeteer生成截图, 基本原理就是写一个html文档放置预设的样式, 根据传入的参数, 对文档进行编辑, 使用puppeteer生成这个html文档的截图, 相对来说这个方法更加容易入手并且高效, 缺点就是生成图片的速度相对较慢且puppeteer包较大.    导师审核: 评审对象:  评审内容：结项报告 提交人：江姗姗评审结果:  项目完成度：完成不错 学生参与度：积极参与，独立自主 代码贡献量：100% 综合评价及建议：表现远超预期 最终评审结果：“通过”"
    }, {
    "id": 215,
    "url": "https://wechaty.js.org/2020/09/26/chassist-bot-final/",
    "title": "暑期2020 [基于python-wechaty的群聊助手机器人] 结项成果展示",
    "body": "2020/09/26 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [基于python-wechaty的群聊助手机器人] 系 暑期2020 支持的开源项目。 一、项目信息: 1. 1 基本信息:    导师：吴京京     学生：孔祥哲     项目名称：基于python-wechaty的群聊助手机器人  1. 2 方案描述：: 本项目需要基于python-wechaty实现一个群聊助手机器人。该机器人主要由四个插件组成。第一个插件是群聊消息打标插件，通过群成员引用重要消息回复机器人的方式记录重要信息，以便之后以问答的方式进行查找。在基本功能开发完成之后将用深度学习的方法优化问答的容错性，从而提升交互水平。第二个插件是定时消息插件，用于定时消息的发放。第三个插件是群成员的管理插件，当有新人进群时进行欢迎，当一定人数群成员对某位群成员言行表示不适时自动从群聊中删除该位群成员。第四个插件用于提升交互，为帮助系统插件，提供自定义的功能文档，辅助前三个插件工作。四个插件中第一个插件是项目的基本要求。 项目主要分为三个阶段进行。第一阶段是基本功能的实现，也就是群聊消息打标插件的实现。第二阶段是扩展功能的实现，主要实现定时消息插件和群成员的管理插件。第三阶段优化交互性能，实现帮助系统插件，利用深度学习对消息打标插件的问答系统进行优化。 1. 3 时间规划:  群聊消息打标插件     7. 1 - 7. 19   该模块为本项目的基本要求，需要实现通过引用消息进行回复对重要的群聊消息进行打标，并存入本地的数据库。在对应问题被提出时机器人能通过搜索存储的打标消息给出相应的回答，如果匹配的答案置信度不高，则提供可能的关键词向用户进行确认。同时支持展示全部或一定时间段内的打标消息，用户可以对其中的消息进行手动删除或定时删除，打标消息本身也可以提供有效期参数，在过了有效期后自动删除。后期提供帮助系统，用户可随时查看不同功能的帮助信息。   基本功能    定时消息插件     7. 20 - 7. 26   用户指定消息内容和发送时间，由机器人定时发出消息。   扩展功能    群成员管理插件     7. 27 - 8. 2   进行踢人和进群欢迎的管理，踢人要求3位以上群成员对某人表示不满（群成员总共只有3人以下或4人时分别需要1人和2人表示不满）。此插件需要机器人拥有相关的权限。   扩展功能    对前几个模块的交互方面进行提升     8. 3 - 9. 24   对交互方面进行统一优化，提高解析用户命令时的容错性，尝试用深度学习方法对问答系统的匹配准确性进行提升（在基础版本中使用 cosine 相似度对问题和答案进行匹配）、在用户命令解析失败但和某些模式很相近时进行确认等。同时该过程中会不断模拟用户场景发现机器人在交互上不够人性化的地方并进行修正。   扩展功能   二、项目总结: 2. 1 项目成果: 目前三阶段的任务已经完成，需求的功能已经实现，相应的单元测试也已经实现，并且配置了 github 的 CI 流程，用于代码提交的检测。同时为项目的 github 项目提供了 readme 进行使用说明，也设计了项目 Logo 和项目名称，项目名称为CHAssisT，寓意为 chat + assistant，即聊天助手。Logo 设计如下图： 整体的机器人插件由四个独立的插件整合而成，如果想使用某个独立的插件，也可以单独使用。具体的使用方法可以参考项目 github 中的 readme： https://github. com/kxz18/CHAssisT。 由于中期考核前已经将项目的功能都完成了，因此中期的 presentation 中对项目的功能和结构进行了简单讲解，如果对项目架构比较感兴趣，可以参考这个视频：  中期之后主要进行了一些深度学习上的实验尝试，并对于机器人的交互进行了一定优化，在后阶段的 presentation 中对此进行了阐述：  在bilibili也进行了视频上传：https://www. bilibili. com/video/BV1zz4y1Z7iJ/ 为了能更好地展示项目成果，也按照社区要求对已经实现的功能进行了live coding演示，演示内容见：  在bilibili也进行了视频上传：https://www. bilibili. com/video/BV1iz4y1Z74S/ 2. 2 项目心得: 进行本项目的整个过程可以看成是简单的软件工程实践，遇到的问题及解决的方式也与软件工程中的常见问题及解决类似。 一开始是进行需求的确认。因为原始的需求只是一些比较朦胧的想法，很多细节都没有落实，所以开始项目的第一步就是和导师确认各种需求的细节。在确认需求的时候，首先是进行了一次讨论，对原始的想法有了大致的了解，列了一个大致的需求文档。但是光有需求文档对于具体实现是不够的，因此又采取了用户故事的模式对需求细节进行确定。用户故事即模拟一个用户，逐一模拟各个功能的使用，将使用过程及过程中遇到的问题记录下来，用于在具体实现的时候进行参照。 之后是进行软件架构，因为需求比较多，显然如果直接动手写的话可能会导致无从下手、重复代码多、可维护性差、拓展性差等问题，所以在进行实际的代码书写之前先根据功能进行了模块的划分，用 uml 图的方式进行了结构的确立。这样的方式可以把庞大的需求分解成一个个子任务，同时可以将普适的结构抽象成接口，方便实现的同时也可以享有较规整的代码结构带来的益处。这一步需要花费的精力通常会比实际写代码花费的精力还多，因为好的架构可以事半功倍，反之亦然。当然，在动工前想出的架构一定不会是完美的，在动工后可能会（最后也的确是）出现各种各样的问题，此时也需要自行或咨询导师进行架构的调整。 最后也就是代码实现，在实际实现的过程中时常会遇到一些第三方库使用的问题。由于“不懂就问”的方式其实效率比较低下，因此在导师的建议下，在遇到问题时如果是 wechaty 框架的问题就先自行翻阅相关代码，直接阅读代码通常能解决大部分因为不知道如何使用接口或者不知道函数作用而引起的问题；如果是其他第三方库的问题则可以通过 github issue、documentary、google 等方式尝试自行解决。如果自行解决无果则将问题记录下来，当无法解决的问题达到一定数量时再与导师进行会议沟通。这样的问题解决方式确实比较高效，无论对自己还是对导师而言节省了大量时间。 功能实现的正确性检测方面，是用单元测试的形式进行的。并且由于开源代码并不只是给自己看的，因此还需要遵循一定的代码规范，于是也增加了代码风格检查。这两者最后也都配置到项目的 CI 中，防止不规范的代码合并到库中。而交互性方面则是通过自己真实使用发现机器人一些不够人性化的地方，比如定时任务设置后没有进行回复，导致用户不知道机器人到底有没有设置好定时任务等。通过寻找实际使用时遇到的问题和疑惑来确定需要优化的方向。 当然，即使用了将近一个月来进行软件的优化，但因为这是单人开发的项目，所以一定还会有很多考虑不周到的地方，比如定时发送消息没有进行持久化存储、交互有些地方还不够人性化、英语支持不够等问题。如果这个项目之后可以真正投入使用的话，这些可能是需要优先优化的点。 三、评审结果:    项目完成度：   该同学能够按照原定计划完成要求中的每一个功能，且完成度非常好，效率也是非常高，经仔细对比，完成度为100%；     学生参与度：   该同学在项目实际开发过程中认真独立完成项目中的每个模块，且有多次需求和技术的讨论过程，积极推动我们的良性沟通。经过查看项目中的所有提交记录，所有代码均为该同学完成，前期的需求调研，中期的技术探讨，后期的结项审核该同学均有深入参与。     代码贡献量：   该同学在此次项目中，所有的代码均为其贡献，所有的需求讨论均为其推动，是此次项目的项目的主要负责人。     综合评价及建议：   该同学积极且高效的完成项目中的所有任务，推动项目中各种进度，努力挖掘潜在问题并能够提前找出来，且对开源拥有非常高的热情，也期待后续能够在开源社区能够做出更多的贡献。   此外，我建议该同学努力学习更多软件相关的软技能，并严格要求自己的代码规范能力，扩大知识范围，深入钻研某一个领域，始终对开源保持着浓厚的热情。     最终评审结果：通过  联系我们:  项目链接：https://github. com/kxz18/CHAssisT               联系方式：+86 15068701650     e: 15068701650@163. com           Author: @kxz18Code: @kxz18/CHAssisT "
    }, {
    "id": 216,
    "url": "https://wechaty.js.org/2020/09/22/wechaty-group-chat-robot/",
    "title": "基于Wechaty打造智能聊天机器人(一)",
    "body": "2020/09/22 - 由于在去年我粉上了杨超越，广州演唱会期间加入了深圳站粉丝群，群主为了活跃气氛，在小群里拉了一个闲聊机器人，当时就想着自己也是一个技术开发，好早之前也有注册过图灵机器人，看着这个机器人的玩法感觉跟图灵机器人好像，就想着要不要自己去开发一个，但是当时这个念头也只是一闪而过，当时工作比较忙，也没放在心上。今年遇上了疫情，大家都只能在家里了，在群里闲聊的时候变多了，就想着能不能自己整个村狗机器人出来聊天，我们那个群跟机器人玩的大多是以下几个需求：  星座运势，包括每日、每月、年度运势等等。 点歌（网易云、QQ音乐等）。 成语接龙。 猜谜语。 猜图片。 猜歌。主要玩法是这些，一个月前我在网上机缘巧合之下找到了这个Weachaty,发现实现最基本的微信机器人，只需要短短十几行代码，不需要你再执行太多业务逻辑外的繁琐事情。 2. Wechaty框架介绍: Weachaty 是一个开源的的对话机器人 SDK，支持个人微信号。它是一个使用Typescript 构建的Node. js 应用。支持多种微信接入方案，包括网页，ipad，ios，windows， android 等。同时支持Linux, Windows, Darwin(OSX/Mac) 和 Docker 多个平台。在GitHub上可以找到很多支持微信个人号接入的第三方类库，其中大多都是基于Web Wechat的API来实现的，如基于Python的WeixinBot，基于Node. js的Wechaty等。少数支持非Web协议的库，大多是商业私有闭源的，Wechaty是少有的开源项目支持非Web协议的类库。且目前来讲，Wechaty已经开始陆续支持多种编程语言了（Go、Python、Java等等）。官方说只需要6行代码，就可以做到自动管理微信消息了。 import { Wechaty } from 'wechaty'Wechaty. instance(). on('scan',     qrcode   =&gt; console. log('扫码登录')). on('login',    user    =&gt; console. log('登录成功：' + user)). on('message',   message   =&gt; console. log('收到消息：' + message)). on('friendship',  friendship =&gt; console. log('收到好友请求：' + friendship)). on('room-invite', invitation =&gt; console. log('收到入群邀请：' + invitation)). start()可以看到，Wechaty能做到的事情很多，可以收消息、发消息、好友管理、群管理，更多功能可以参考官方文档中文版、英文版英文版的文档更新更全更新。 3. 安装Wechaty: 原本一开始我是想着用Java版本的Wechaty的，但是目前来讲Java版的还不够，入门阶段选择更加成熟的nodejs版的会更好，我选择了Docker的方式来使用开发Wechaty，系统方面选择了WSL2，配合VSCode就可以在Windows10下无缝开发，关于Windows10子系统WSL2的安装教程可以参考这篇文章，从零开始到安装Docker成功。 安装nodejs和npm: 我的WSL2选择的系统是Ubuntu-18. 04,我们先安装nodejs、npm sudo apt-get install nodejssudo apt-get install npm安装完毕后查看nodejs、npm版本 node -vnpm -v当前是分别是v8. 10. 0、3. 5. 2. 目前开发环境已经搭建完毕。 如何使用Wechaty: 我们用VSCode的Remote-WSL连接上我们的WSL系统，在当前用户文件夹下创建dog文件夹，选择它做为我们的工作区，在dog文件夹打开终端，用npm初始化项目： npm init -y采用默认的生成package. json文件： {  name :  dog ,  version :  1. 0. 0 ,  description :   ,  main :  index. js ,  scripts : {   test :  echo \ Error: no test specified\  &amp;&amp; exit 1  },  keywords : [],  author :   ,  license :  ISC }由于我采用 Typescript 进行开发的，在Dog文件夹创建dog. ts，对json文件手动修改一下： {  name :  dog ,  version :  1. 0. 0 ,  description :   ,  main :  dog. ts ,  scripts : {   start :  ts-node dog. ts ,   test :  echo \ Error: no test specified\  &amp;&amp; exit 1  },  keywords : [],  author :   ,  license :  ISC }官方给我的是临时的puppetPadPlus协议，所以我需要安装的puppet是PadPlus版的，另外为了让二维码显示终端上，我们还需要另外一个开源库QRCodeTerminal,不过我这里引入的是wechaty-plugin-contrib，它包含了很多常用的库，这里我们用到的是QRCodeTerminal和EventLog我们安装wechaty、wechaty-puppet-padplus、wechaty-plugin-contrib. npm i --save wechatynpm i --save wechaty-puppet-padplusnpm i --save wechaty-plugin-contrib安装完package. json也变成这样了： {  name :  dog ,  version :  1. 0. 0 ,  description :   ,  main :  dog. ts ,  scripts : {   start :  ts-node dog. ts ,   test :  echo \ Error: no test specified\  &amp;&amp; exit 1  },  keywords : [],  author :   ,  license :  ISC ,  dependencies : {   wechaty :  ^0. 48. 10 ,   wechaty-plugin-contrib :  ^0. 14. 15 ,   wechaty-puppet-padplus :  ^0. 6. 6  }}修改dog. ts源代码如下： import { Wechaty, Message, log } from 'wechaty'import { PuppetPadplus } from 'wechaty-puppet-padplus'import { EventLogger, QRCodeTerminal } from 'wechaty-plugin-contrib'// 创建puppet为PadPlus版const puppet = new PuppetPadplus({  token: 'puppet_padplus_xxxxxxxxxxxxx' // 此Token自己向官方申请的})// 创建机器人实例const bot = new Wechaty({  name: 'Sherlock',  puppet})// 注册Log日志bot. use(EventLogger())// 注册二维码打印显示bot. use(QRCodeTerminal( { small: false}))// 监听消息事件bot. on('message', async (message: Message) =&gt; {  log. info('发来的消息呀'+message. text())})// 开启机器人bot. start()接下来我们在Docker上运行该项目： docker run -ti --rm --volume= $(pwd) :/bot wechaty/wechaty run start第一次运行时wechaty镜像还没安装，docker会自动帮我们安装wechaty镜像，稍等片刻，一切正常的情况下，我们能看到终端打印出来的登录二维码，用你的微信扫码登录即可。目前运行的时候会发生以下这个错误： Error: Failed to load gRPC binary module because it was not installed for the current systemExpected directory: node-v72-linux-x64-glibcFound: [node-v57-linux-x64-glibc]This problem can often be fixed by running  npm rebuild  on the current system我们先执行rebuild再重新执行上面的代码。 docker run -ti --rm --volume= $(pwd) :/bot wechaty/wechaty npm rebuild重新运行后，扫码登录之后后台就打印出已确认的日志： =================================================  QRCODE_SCAN MSG : 已扫码，请在手机端确认登陆. . . ==================================================================================================      QRCODE_SCAN MSG : 已确认=================================================目前来讲我们已经成功运行Wechaty项目了，想要实现上面的需求只需要实现具体的业务代码即可，从社区上可以了解到，微信对话开放平台对接进来是比较适合我的需求的，而且看了官方文档，需求那里对于QQ音乐或者网易云音乐这类消息类型，Wechaty暂时是不支持的，这后续也得看看怎么替代，这篇先写到这里，下一篇要写一下接入微信对话开放平台，让它接管消息的收发。 "
    }, {
    "id": 217,
    "url": "https://wechaty.js.org/2020/09/16/speaker-mention-manager/",
    "title": "微信群过于频繁提醒功能",
    "body": "2020/09/16 - 自己在的知识讨论分享群里人数比较多，经常有人在群里闲聊，发言太多，导致有用的信息容易被淹没。 于是决定添加一个群规则，每个人半小时内只能发言三次，如过超过则会通过机器人@发言人 提醒对方控制发言频率。 实现方式: 维护一个数组（这里用链表代替），当有人发言时，在数组中推入一条记录，移除30分钟前的记录，检查该消息发言人是否有超过3条记录在数组中。如果超过，则提示用户不要过度发言。 代码实现: 项目地址：speaker-mention 启动方式: 拉取代码: git clone git@github. com:chianquan/wechaty-speaker-mention. git安装依赖: npm install第一次启动服务（使用padplus协议控制wx，需要配置token和启动方式 XXX位置为申请的token）: WECHATY_PUPPET_PADPLUS_TOKEN=XXX WECHATY_PUPPET=wechaty-puppet-padplus npm start扫描二维码登录pad微信: 在需要生效的微信群中有发言时，日志中会打出该微信群的名称和id，从日志中获取对应微信群id: 关闭服务: ctr-C 退出服务 正式启动服务: 需要先配置环境变量 //必填，微信群id，使用前面获取到的微信群id ROOM=19231818861@chatroom //可选，时间限定范围，单位ms 默认为半小时 TIME_LIMIT=1800000 //可选，允许发言次数，超过该次数则提醒用户不要过度发言，默认为3 SPEAK_LIMIT=3 //可选，自定义提醒的文本 默认为 请${ms(timeLimit)}内不要超过${speakLimit}次发消息哦}` MENTION_TEXT=不要过度发言 例如： WECHATY_PUPPET_PADPLUS_TOKEN=XXX WECHATY_PUPPET=wechaty-puppet-padplus ROOM=19231818861@chatroom npm start 在微信群中发言效果: 结语: wechaty 的功能很强大，打通了微信使用的很多环节，接口很优雅，使用简单。体验很好。还可以基于它实现很多功能，解放双手，赞 "
    }, {
    "id": 218,
    "url": "https://wechaty.js.org/2020/09/14/my-first-wechaty-bot/",
    "title": "构建我的第一个微信机器人",
    "body": "2020/09/14 - 手头上的事情越来越多，回复微信都是件很麻烦的事，对于IT行业的人来说，能用机器解决的事就不应该手动去做，于是就有了构建微信机器人的想法。 技术选型: 首先，自然是对底层架构的选型，在网上也查找了很久，也尝试了许多其他的开源库，很多前两年（今天是2020年9月12日）的微信机器人库都已经过期无法使用了，主要原因他们都是基于web微信的协议，而腾讯的安全策略屏蔽了web微信协议。所以，经过一番挑挑拣拣，发现网上也就剩下最后一个可用的库，那就是这篇文章的主角，wechaty，官方github地址：https://github. com/wechaty。 这是一个商业公司（北京句子互动科技有限公司）开发的一套半开源半商业的库，基于web微信协议的库确实都开源了，但是基于上述腾讯的政策，web微信现在基本是都用不了了，所以web微信这套开源库，也就只能学学而已。但是他们还开发了一套基于pad微信协议的库，github地址：https://github. com/wechaty/wechaty-puppet-padplus。这个可以用，但是呢，需要token，每个月收费200RMB，不过可以试用，15天的试用期，15天后，有机会把token试用期最长延期到1年，需要写博客支持他们发起的一个开源计划，说白了，就是替他们公司宣传这个库，只能说各取所需吧。这个开源计划可以参考：https://github. com/juzibot/Welcome/wiki/Everything-about-Wechaty。 了解原理: 开发之前呢，最好还是了解下这个架构的原理，具体的不细说，有兴趣的github上都可以找到答案。这里就放一张官方的原理图。 最底层是各个协议，基于pad微信的协议（本文重点，github库名称是wechaty-puppet-padplus），基于web微信协议的（github库名称是wechaty-puppet-puppeteer），基于windows pc端微信协议的（github库名称是wechaty-puppet-windows）等等。 中间是一层抽象层，wechaty puppet（github库名称是wechaty-puppet）。 再上一层是wechaty puppet service 再上一层就是各种语言的实现，js、python、go、java等等。官方支持最好的是ts或者js，因为官方自身就是用ts开发的。 顺便说一句，我们走了他们公司的协议，那数据肯定是有经过他们公司的服务器的，这个风险自己可以评估下。 开始开发: 按上文说的，参加开源计划，领取15天试用token，记录为token_tmp，然后就可以开始我们的开发了。 因为我们用基于pad协议的wechaty。那么就按wechaty-puppet-padplus的readme. md先做一些基础环境配置吧。我的开发环境是window10，先下载安装好nodejs。创建我们的项目目录wechaty_bot，进入该目录，然后开始配置。这里我们用nodejs开发。 step1：windows环境一些工具安装。 npm install -g windows-build-toolsnpm install -g node-gypstep2：安装wechaty相关包。 npm install wechaty@nextnpm install wechaty-puppet-padplus@nextstep3：安装其他依赖包。 npm install qrcode-terminalstep4：编写代码。 因为是初次接触，我们就实现下最基本的自动回复功能吧，跑通基本流程， 后续进阶的功能可以慢慢完善添加。 const {  Wechaty,  ScanStatus,  log, }        = require('wechaty')import { PuppetPadplus } from 'wechaty-puppet-padplus'function onScan (qrcode, status) {  if (status === ScanStatus. Waiting || status === ScanStatus. Timeout) {    require('qrcode-terminal'). generate(qrcode, { small: true }) // show qrcode on console    const qrcodeImageUrl = [    'https://wechaty. js. org/qrcode/',    encodeURIComponent(qrcode),    ]. join('')    log. info('StarterBot', 'onScan: %s(%s) - %s', ScanStatus[status], status, qrcodeImageUrl)  } else {    log. info('StarterBot', 'onScan: %s(%s)', ScanStatus[status], status)  }}function onLogin (user) {  log. info('StarterBot', '%s login', user)}function onLogout (user) {  log. info('StarterBot', '%s logout', user)}async function onMessage (msg) {  log. info('StarterBot', msg. toString())  if (msg. text() === '12345') {    await msg. say('hello world')    }}const bot = new Wechaty({  name: 'bot',  puppet: new PuppetPadplus({    token: '替换成你自己申请的token'    })})bot. on('scan',  onScan)bot. on('login',  onLogin)bot. on('logout', onLogout)bot. on('message', onMessage)bot. start(). then(() =&gt; log. info('StarterBot', 'Starter Bot Started. ')). catch(e =&gt; log. error('StarterBot', e))然后执行命令如下命令运行： node bot. js成功运行：之后就可以手机微信扫码登录，当别人给你当前登录的微信号发送消息“12345”，就会自动回复“hello world”。 遇到的问题: 开发之中也是碰到了一些问题，其实都可以从github官方的issues里面找到答案，我这边记录下我遇到的问题。 cmd窗口二维码显示扫码不完善: 解决办法是修改cmd窗口的属性，可以参考：https://github. com/wechaty/wechaty/issues/2055。结束！ "
    }, {
    "id": 219,
    "url": "https://wechaty.js.org/2020/09/14/ads-filer-groupbot/",
    "title": "微信群广告检测机器人",
    "body": "2020/09/14 -  项目背景: 开发了一个面向美国的租房微信小程序，为了方便推广，便给各个地区都创建了微信群，微信群的人数扩展的很快，目前大概已经有超过20个微信群，有4个微信群有500人，其余的微信群人数也在100人以上。 微信群开始变得不好管理，我们创建微信群的目的是为了方便大家让他们更好地在海外租到房子，可是之后群里开始有一些人恶意的发一些的虚假广告，比如学历造价，自制病假条等广告，尽管我们在群公告中声明不准发广告，也有管理员及时踢人，可是每天还有很多的人会发这种广告，我们也发现这些广告都会有一些特定的关键词，我们只需要把这些关键词存到一到地方，通过比对每个用户的发言，然后把那些发言带有关键词的用户踢出群中，这样可以帮助我们的群管理员减少一些负担。 功能:  检测用户发言是否有广告关键词 识别出发了广告的用户并对其进行警告 将因为发了广告被被踢出群的用户加入黑名单，之后不能再进入本群具体实现:  bot. js: 项目入口文件，实现了扫码微信，并注册监测广告的逻辑。 utility. js: 广告过来逻辑的实现函数。并且我们对广告进行了分级，有严重恶意广告和不严重恶意广告，实现逻辑在isSeriousAdsText和isLightAdsText。我们可以看到程度比较严重的广告是一些带有学历认证，病假申请的文字。而不严重的广告主要是一些带有保险字样的广告。使用这个机器人的时候要先安装一些dependency  npm install wechaty@latest npm install wechaty-puppet@latest npm install wechaty-puppet-padplus@latest npm install qrcode-terminal npm install node-schedule sudo npm install ts-node typescript -g最终效果:  作者: garyboygoCode: Github "
    }, {
    "id": 220,
    "url": "https://wechaty.js.org/2020/09/12/post-ts-to-python/",
    "title": "Wechaty 将 TS 转发到 Python 的探索实践",
    "body": "2020/09/12 - 报时机器人，每逢整点在群里发送报时信息。 Wechaty 将 TS 转发到 Python 的探索实践: 许多朋友可能对 Python 更为熟悉，而对 Typescirpt 则比较生疏。同时 Python 在文件处理、图像处理、机器学习等领域更为简易灵活。如果能将微信机器人接入 Python 将为开发者带来极大的便利。目前官方正在开发 Python 版本的机器人，在开发完善之前我们可以使用一些替代方案。本项目以一个简单的报时机器人为例，展示了如何将 Typescript 程序收到的消息转发给 Python 后端处理，可以作为 Python 版 Wechaty 正式上线之前的简易替代。 项目地址：https://github. com/jcq15/wechaty 联系作者：jcq15@mails. tsinghua. edu. cn 使用方法: 报时机器人，每逢整点在群里发送报时信息。具体报时内容可以由群友设置。 基本功能：  每逢整点自动报时 发送“报时”立刻报时 发送“修改模板 新模板”可以修改报时内容，其中\h 表示当前小时，\m 表示当前分钟，\s 表示当前秒。类似于其他语言的转义字符，\\ 表示字符 \。例如现在是 11:45:14，\\\h:\mm 会被解析为 \11:45m。为了重点展示框架，本项目没有添加过多复杂的功能，后续可以在此基础上实现群友报时情况统计、排行榜等涉及文件操作的功能。 环境: CentOS 7 开始: 照着官方文档初始化一些东西就可以。 首先检查 Node 版本 node --version如果是 v10. 16. 0 以下，需要先更新 Node。 创建文件夹，我的文件夹名字叫 wechatbot： mkdir wechatbotcd wechatbotnpm init -ynpm install ts-node typescript -gtsc --init --target ES6touch bot. ts上面我们新建了文件 bot. ts，这个文件就是主程序了，我们把官方示例代码放到这个文件里，不要忘了把 token 和 name 改成你自己的： // bot. tsimport { Contact, Message, Wechaty } from 'wechaty'import { ScanStatus } from 'wechaty-puppet'import { PuppetPadplus } from 'wechaty-puppet-padplus'import QrcodeTerminal from 'qrcode-terminal'import { FileBox } from 'wechaty'const token = your_tokenconst puppet = new PuppetPadplus({ token,})const name = your_nameconst bot = new Wechaty({ name, puppet, // generate xxxx. memory-card. json and save login data for the next login})var baoshi: RegExp = new RegExp('报时. *')  // 正则表达式，群名以“报时”开头//报时器，整点触发async function hourReport() {  //当前时间  var time = new Date();  //小时  var hours = time. getHours();  //分钟  var mins = time. getMinutes();  //秒钟  var secs = time. getSeconds();  //下一次报时间隔  var next = ((60 - mins) * 60 - secs) * 1000;  //设置下次启动时间  setTimeout(hourReport, next);  //整点报时，因为第一次进来mins可能不为0所以要判断  const room = await bot. Room. find({topic:baoshi})  var request = require('request')  request. get({url:'http://127. 0. 0. 1:5000/clock'}, function (error, response, body) {     if (error) {      console. log('Error :', error)      return    }    console. log(' Body :', body)    if(body. length &gt; 0){     room?. say(body)    }  })}bot. on('scan', (qrcode, status) =&gt; {  if (status === ScanStatus. Waiting) {   QrcodeTerminal. generate(qrcode, {    small: true   })  } })bot. on('login', async (user: Contact) =&gt; {  console. log(`login success, user: ${user}`)  //启动报时器  hourReport(); })bot. on('message', async (msg: Message) =&gt; {  console. log(`msg : ${msg}`)  var room = msg. room()  var topic = ''  if(room){   topic = await room. topic()  }  var contact = msg. from()  //直接推给python处理，我们获得回复内容  var request = require('request')  var formData = {   text: msg. text(),   roomtopic: topic,   date: JSON. stringify(msg. date()),   contactid: contact?. id,  }  try{   // 所有的东西都推到后端用python处理   request. post({url:'http://127. 0. 0. 1:5000/message', formData: formData}, function (error, response, body) {      if (error) {       console. log('Error :', error)       return     }     console. log(' Body :', body)     var response = JSON. parse(body)     if(body. length &gt; 0){      const type: string = response['type']      if(type=='image'){       const path: string = response['content']       const filebox: FileBox = FileBox. fromFile(path)       if(room){        console. log('准备发啦！')        room. say(filebox)       }else{        contact?. say(filebox)       }      }else if(type=='text'){       const text: string = response['content']       if(room){        room. say(text)       }else{        contact?. say(text)       }      }else{       //什么也不做      }     }   })  }catch(e){   console. log(e)  } })安装 wechaty 和 qrcode-terminal npm install wechaty@latestnpm install wechaty-puppet-padplus@latestnpm install qrcode-terminal这一步我遇到了点问题，装着装着就卡住不动了，因为某些不可描述的原因国外的网站连接质量不好，我们需要使用代理： npm config set registry https://registry. npm. taobao. org然后安装就好了。 后端代码: # backend. pyfrom flask import Flaskfrom flask import requestimport jsonimport datetimeapp = Flask(__name__)# 全局变量name = '报时'model = r'淦！已经\h点\m分了！你今天学习了吗？'# 获取报时内容def gettext():  response_text = ''  status = False  for c in model:    if not status:      if c == chr(92):        status = True      else:        response_text += c    else:      status = False      if c == chr(92):        response_text += c      elif c == 'h':        response_text += str(datetime. datetime. now(). hour)      elif c == 'm':        response_text += str(datetime. datetime. now(). minute)      elif c == 's':        response_text += str(datetime. datetime. now(). second)      else:        pass  return response_textdef handle(data):  global model  text = data['text']  if len(text) &gt;= 6 and text[:4] == '修改模板':    model = text[5:]    return json. dumps({'type': 'text', 'content': '修改大成功！现在的模板是：\n'+model})  elif text == '报时':    return json. dumps({'type': 'text', 'content': gettext()})  else:    return json. dumps({'type': 'null'})@app. route('/message', methods=['GET', 'POST'])def message():  if request. method == 'POST':    data = request. form    print(data)    roomtopic = data['roomtopic']    if roomtopic:   # 是群      if len(roomtopic) &gt;= 2 and roomtopic[0:2] == name:        return handle(data)  return json. dumps({'type':'null'})# 返回当前报时内容@app. route('/clock', methods=['GET'])def clock():  return gettext()if __name__ == '__main__':  app. run()启动服务（可以使用 screen 同时运行两个程序）： ts-node bot. tspython3 backend. py大功告成！ "
    }, {
    "id": 221,
    "url": "https://wechaty.js.org/2020/09/04/issue-feedback-room-monitor/",
    "title": "实现微信产品问题反馈群实时监控与问题自动录入",
    "body": "2020/09/04 - 因为我们的用户都喜欢通过微信群讨论的方式进行产品问题反馈，这无疑给日常的线上问题处理的效率带来极大的影响。曾经尝试对用户习惯进行线上填写方式的引导，但最终以失败告终。无奈下看看弄一个微信群监控机器人是否可行。 在之前公司我曾经用python通过itchat弄过一个群播报BI数据的机器人，但因为itcaht采用的是微信web协议，微信监控特别严，很多号都不能使用，即使登录上去了还会经常莫名掉线，极不稳定。因此这回肯定不能再通过web协议的方式来弄了。于是带着一点点期盼发现了Wechaty这个支持微信ipad协议的SDK。 Wechaty官方定义：:  Wechaty是一个开源的的个人号微信机器人接口，使用Typescript构建的Node. js应用。支持多种微信接入方案，包括网页，ipad，ios，windows，android 等。同时支持 Linux, Windows, Darwin(OSX/Mac) 和 Docker 多个平台。 这里必须要重点提一下，Token 是 Wechaty 开放源代码项目中所设计和支持的一种认证技术，是句子互动公司基于 Wechaty 的 Puppet 实现插件对云服务 API 的授权账号。这也就意味着你在使用Wechaty开发基于ipad协议的机器人之前必须要先拿到可用的token。你可以从Wechaty社区申请到一个15天有效的试用Token，过了试用期后可以选择付费购买（200RMB/月）或者按照如下介绍尝试获取长期免费的Token：Wechaty Token 申请及使用文档和常见问题 Wechaty目前已经支持了Java、Python、Go、PHP等多种语言，但是该SDK原生是用TypeScript编写的，并且github上大量的demo和开源项目都是用node. js写的，再加上Wechaty宣称可以通过6行代码就可以实现一个机器人，于是最终决定用之前一点稚嫩的JavaScript前端开发经验拥抱node. js吧！ 参考资料：:    官方 API文档     官方demo：wechaty-getting-started     wechaty-puppet-padplus 示例 。     Wechaty社区 开源项目  通过短时间的学习和尝试后，发现基本微信机器人常用的功能实现几乎都能从这些开源的项目中直接拿到，然后再结合自己的需求再进行改装就可以了，确实开发起来挺方便的。 开发之前，首先要明确一下此次的功能需求：:    自动聊天：群聊中通过 @[机器人]xxx, 机器人回复问题反馈模版信息 （已完成）     加入群聊自动欢迎：当新的小伙伴加入群聊后自动 @[新的小伙伴] 发一个文字欢迎 （已完成）     推送机器人登陆二维码到企业微信：机器人掉线后，自动将二维码信息推送给指定企业微信群（已完成）     监控群聊信息：实时将聊天记录入库 （已完成）     自动识别问题反馈信息：自动识别判断群聊中问题反馈类信息，并收纳入问题库 （开发中）     群播报功：每天下班前播报问题收纳和未关闭问题情况 （未开始）  项目github地址： https://github. com/tomallv/wechat-group-chat-monitoring-robot 一、项目结构: |-- src/ |---- index. js          # 入口文件 |---- config. js         # 配置文件 |---- onScan. js         # 机器人需要扫描二维码时监听回调 |---- onRoomJoin. js       # 进入房间监听回调 |---- onMessage. js        # 消息监听回调 |---- onFriendShip. js      # 好友添加监听回调 |---- onDatabaseOperation. js   # MySQL数据库操作回调 |---- onEnterpriseWechatBot. js  # 企业微信群消息发送回调 |---- onFileIO. js        # 文件读取回调 |-- package. json二、核心包：:    Wechaty核心包： npm install --save wechaty     padplus协议包： npm install --save wechaty-puppet-padplus     生成二维码： npm install --save qrcode-terminal  三、接下来介绍几个核心代码文件: 1、配置文件（ src/config. js）： module. exports = {// puppet_padplus Tokentoken:  xxxxxxxxxx ,// 机器人名字name:  xxxxxxxxxx ,// 房间/群聊room: {   // 加入房间回复   roomJoinReply: `\n您好，欢迎您的加入，请自觉遵守群规则，文明交流！ 😊\n\n如您需要反馈问题，请按照如下模版进行拷贝填写，谢谢：\n问题反馈\n[1-问题描述]:\n[2-截图信息]:\n[3-账号信息]: \n[4-操作系统]:\n[5-浏览器]:\n[6-屏幕分辨率]:\n[7-移动设备型号(APP、小程序相关问题)]:\n[8-App、小程序版本信息(APP、小程序相关问题)]:\n[9-模块信息]: A-官网前台、B-小程序、C-APP、D-句芒后台、D-学习中心、F-CRM、G-H5网页、H-老后台、I-其他`},// 私人personal: {   // 好友验证自动通过关键字   addFriendKeywords: [ xxxxxx ,  xxxxxxx ],   // 是否开启加群   addRoom: false},// mysql数据库配置信息mysql_db: {  host: 'xxx. xxx. xxx. xxxx',  port: '3306',  user: 'xxxxxxxxxx',  password: 'xxxxxxx',  database: 'xxxxxxx',  charset : 'xxxxxxx'},// 要推送机器人二维码登陆信息的切页微信群webhook_keywebhook_key:  xxxxxxxxxxxxxxxxxxxxxxxxxxx ,// 机器人登陆二维码图片文件名称qrcode_png:  xxxxxxx. png }2、入口文件（ src/index. js）： import { Wechaty } from 'wechaty' // Wechaty核心包 import { PuppetPadplus } from 'wechaty-puppet-padplus' // padplus协议包 import config from '. /config' // 配置文件//初始化botconst bot = new Wechaty({  puppet: new PuppetPadplus({  token: config. token  }),  name: config. name })//调用，监听，启动import onScan from '. /onScan' import onRoomJoin from '. /onRoomJoin' import onMessage from '. /onMessage' import onFriendShip from '. /onFriendShip' bot  . on( scan , onScan) // 机器人需要扫描二维码时监听  . on( room-join , onRoomJoin) // 加入房间监听  . on( message , onMessage(bot)) // 消息监听  . on( friendship , onFriendShip) // 好友添加监听  . start()3、机器人掉线监听回调（src/onScan. js） 当机器人掉线的时候，很多开源项目都是将二维码生成到程序log中，供扫描使用。但是一般情况当机器人放到服务器的时候，扫描二维码就会变得非常不方便，因此这里结合企业微信群机器人API实现了一旦掉线就把登陆二维码推送到企业微信群中，这样随时随地都可以进行扫描登陆操作了。同时也考虑基本上机器人都是后半夜会发生掉线情况，因此这里设置了有效推送时间段，以防止干扰正常休息。 import Qrterminal from 'qrcode-terminal';import qrimage from 'qr-image'import fs from 'fs'import wechat_bot from '. /onEnterpriseWechatBot' // 企业微信机器人群发import config from '. /config'import path from 'path';const defpath=path. join(__dirname,'. . /');const qrcode_png_path = path. join(defpath,config. qrcode_png)const weboot_key = config. webhook_keymodule. exports = function onScan(qrcode, status) {  Qrterminal. generate(qrcode, { small: true })  const myDate = new Date()  const current_hour = myDate. getHours();  console. log( 当前小时数：   + current_hour);  console. log( 状态码：   + status);  // 设置早上8点到晚上24点之间才推送掉线二维码  if (current_hour &gt;= 8 &amp;&amp; current_hour &lt;=23) {     let link =        if (status == 2){        console. log( 机器人已经下线，请重新扫描二维码登陆:   + qrcode);        const temp_qrcode = qrimage. image(qrcode, {size :6, margin: 4}) // 生成机器人登陆二维码图片        temp_qrcode. pipe(require('fs'). createWriteStream(qrcode_png_path). on('finish', function() {console. log('write finished')}))        link = '机器人掉线了，请点击如下链接查看登陆二维码:\n https://wechaty. js. org/qrcode/'+ qrcode     } else if (status == 3) {        link =  已扫码，请在手机端确认登陆. . .       } else if (status == 4) {        link =  已确认,登陆成功！      } else if (status == 5) {        link =  二维码已过期！      } else {        link = '机器人掉线了，请点击如下链接查看登陆二维码:\n https://wechaty. js. org/qrcode/'+ qrcode     }     wechat_bot. send_text(link,weboot_key)}}功能实现截图： 4、消息监听回调（src/onMessage. js） 主要实现对群消息进行监听，将监听到聊天消息写入mysql中。 import { Message } from 'wechaty'import config from '. /config' // 配置文件const name = config. name // 机器人名字import mysqldb from '. /onDatabaseOperation' // 连接MySQL数据库// 消息监听回调module. exports = bot =&gt; {     return async function onMessage(msg) {       // 判断消息来自自己，直接return       if (msg. self()) return       console. log( ============================= )       console. log(`msg : ${msg}`)       console. log(`from: ${msg. from() ? msg. from(). name() : null}: ${msg. from() ? msg. from(). id : null} `)       console. log(`to: ${msg. to()}`)       console. log(`send_time: ${msg. date()}`)       console. log(`text: ${msg. text()} `)       console. log(`isRoom: ${msg. room()} : ${msg. room() ? msg. room(). id : null}`)       console. log( ============================= )       // 判断此消息类型是否为群消息       if (msg. room()) {         const room = await msg. room() // 获取群聊         const room_name = `${room} ` // 获取群名称         console. log(`群名称：` + room_name. substring(5,room_name. length-2))         const room_id = room. id // 获取群ID         console. log(`群id ：` + room_id)         let sender_alias = await room. alias(msg. from()) //获取发信人群昵称         console. log(`发信人的群昵称：` + sender_alias)       if (sender_alias == null){         sender_alias =          }       console. log(`发信人的群昵称：` + sender_alias)       const sender_name = msg. from(). name() //获取发信人微信名称       console. log(`发信人的微信名称：` + sender_name)       const msg_date = msg. date() // 获取消息发送时间       console. log(`消息发送时间: ${msg. date()}`)       const msg_type = msg. type() // 获取消息类型       console. log(`消息类型：` + msg_type)       var msg_content =    // 获取消息内容       if (msg_type == Message. Type. Text || msg_type == Message. Type. Url){         msg_content = msg. text()       } else if (msg_type == Message. Type. Attachment){         msg_content =  消息内容类型为附件        } else if (msg_type == Message. Type. Audio){         msg_content =  消息内容类型为音频        } else if (msg_type == Message. Type. Contact){         msg_content =  消息内容类型为联系人        } else if (msg_type == Message. Type. Emoticon){         msg_content =  消息内容类型为表情包        } else if (msg_type == Message. Type. Image){         msg_content =  消息内容类型为图片        } else if (msg_type == Message. Type. Video){         msg_content =  消息内容类型为视频        } else {         msg_content =  消息内容类型为未知        }       console. log(`消息内容：` + msg_content)       // 消息入库sql       var sql =  insert into wechat_room_chat_record(id,room_name,room_id,sender_name,sender_alias,msg_content,msg_type,issue_flag,msg_date) values(?,?,?,?,?,?,?,?,?)        // 入库sql消息变量       var sqlParams = [process. hrtime. bigint(),room_name. substring(5,room_name. length-2),room_id,sender_name,sender_alias,msg_content,msg_type,0,msg_date]       mysqldb. InsertData(sql,sqlParams)       console. log(`入库时间戳：` + process. hrtime. bigint())       // 收到消息，提到自己       if (await msg. mentionSelf()) {          // 获取提到自己的名字          let self = await msg. to()          self_format =  @  + self. name()          const self_name = self. name() //获取机器人自己的微信名称          console. log( 自己的微信名称：  + self_name)          const self_alias = await room. alias(msg. to()) //获取机器人自己的群昵称          console. log( 自己的群昵称：  + self_alias)          // 获取消息内容，拿到整个消息文本，去掉 @+名字          let sendText = msg. text(). replace(self_format,   ). substring(1,)          // 规定回复问题反馈模版          var report_template =  如您需要反馈问题，请按照如下模版进行拷贝填写，谢谢：\n问题反馈\n[1-问题描述]:\n[2-截图信息]:\n[3-账号信息]: \n[4-操作系统]:\n[5-浏览器]:\n[6-屏幕分辨率]:\n[7-移动设备型号(APP、小程序相关问题)]:\n[8-App、小程序版本信息(APP、小程序相关问题)]:\n[9-模块信息]: A-官网前台、B-小程序、C-APP、D-句芒后台、D-学习中心、F-CRM、G-H5网页、H-老后台、I-其他           console. log( 自动回复内容：  + report_template)          // 返回消息，并@来自人          var Datetemp1= new Date();          room. say(report_template, msg. from())          const sql =  insert into wechat_room_chat_record(id,room_name,room_id,sender_name,sender_alias,msg_content,msg_type,issue_flag,msg_date) values(?,?,?,?,?,?,?,?,?)           const sqlParams = [process. hrtime. bigint(),room_name. substring(5,room_name. length-2), room_id,self_name,self_alias,report_template,Message. Type. Text,0,Datetemp1]          mysqldb. InsertData(sql,sqlParams)          return       }     } else{     // 非群聊不做任何处理    return}}}当在群里@机器人的时候，机器人会自动回复问题反馈的模版信息： 这里由于时间问题，做的相对简单。如果时间充分完全可以做一个微服务，支撑机器人更好在群里与他人互动。 消息入库示例： 这块目前只是实现了消息入库，但是对聊天中的图片、视频和音频文件的保存的功能部分还没有整合进去，相关部分还处于本地调试过程中。后续会在github上更新此部分代码。 对于自动识别判断聊天信息是否为问题反馈点的功能部分。目前使用Python利用Jieba的分词方案结合人工后期统计的热词字典，已经达到识别正确率&gt;90%，误识别率&lt;10%的效果。这块也正处于本地测试中，稍后会把这块功能移植到node. js，并集成到该项目中。 至于最后两个环节，一个是将问题反馈的录入问题系统以及每天机器人群内播报当天问题情况的功能，也会在稍后进行开发。并集成到该项目中。 "
    }, {
    "id": 222,
    "url": "https://wechaty.js.org/2020/08/31/wechaty-english-learning-assistant/",
    "title": "基于wechaty的英语学习群助手",
    "body": "2020/08/31 - 针对英语学习社群，为提高群的活跃度，通过关键词触发，实现英文每日一句、中英文互译、励志话语推送，彩虹屁功能。 功能:  每日一句，从互联网搜集整理中英文名人名言，励志名言，鸡汤共6137条数据 励志话语&amp;彩虹屁，从互联网搜集整理共2783条数据 中英文互译，采用百度翻译api实现 tts文本转语音（开发中，因padplus不支持语音）    配置:  因调用百度翻译api，需要前往百度翻译开放平台申请 https://api. fanyi. baidu. com/ 申请完成后在config. js中修改配置 在config. js中，对触发关键词修改const config = {  baidu_appid : '8888888888888888',         //百度翻译api的appid  baidu_secretKey : 'aaaaaaaaaaaaaaaaaaa',     //百度翻译api的key  room_list : [ 群名称1 ,  群名称2 ],         //需要支持的群名称列表（记得把机器人拉入该群）  db_file : 'data. db',               //sqlite3数据库文件路径  baidu_salt : 666,                 //百度翻译salt，这个值随便设置  keyword_baidu : [ ?? , ？？ ],           // 激发百度翻译功能的句首关键词,仅支持两个字符  keyword_caihong :  夸我 ,             // 彩虹屁关键词设定  keyword_lizhi :  加油 ,              // 中文励志关键词设定  keyword_sentence :  每日一句 ,           // 英文名言关键词设定 // 加群欢迎语设定  welcome :  欢迎加入本群\n\ 本群具备以下功能:\n\ 1. 文本翻译,请发送“??内容”\n\ 2. 每日英语,请发送“每日一句”\n\ 3. 鼓励自己,请发送“加油”\n\ 4. 想听夸赞,请发送“夸我”\n\ 请不要在群内发广告，谢谢 }依赖:  wechaty：wechaty核心库 wechaty-puppet-padplus：wechaty iPad协议 sqlite3：数据库运行: 克隆项目 git clone git@github. com:alienfist/wechaty-english-learning-assistant. gitcd wechaty-english-learning-assistant安装依赖 npm install设置环境变量 export WECHATY_PUPPET=wechaty-puppet-padplusexport WECHATY_PUPPET_PADPLUS_TOKEN='your wechaty token'启动项目 node index. js或者使用pm2进程管理项目 npm install -g pm2pm2 start index. js致谢: 🙏感谢wechaty团队提供微信机器人SDK🙏感谢句子互动提供的iPad协议版token  Author: alienfistCode: wechaty-english-learning-assistant "
    }, {
    "id": 223,
    "url": "https://wechaty.js.org/2020/08/29/wx-group-assistant-bot/",
    "title": "微信营销群机器人客服",
    "body": "2020/08/29 - 几乎人人都有微信，对于电商客服来说，通过微信群的方式管理好自己的客户是维护好客户关系很重要的方式。由于电商客服工作繁忙，他们急需一款机器人帮他们处理日常微信群管理中繁重的工作。 一个客服会同时管理数十甚至上百个群，除了通过已有机器人功能定时批量发送营销内容，对接意向客户咨询之外，客服普遍反馈她们会花较多时间警告、清理群里的恶意营销分子。 之所以出现这种情况，是因为这些群往往是通过线下活动（如会议、营销活动）扫码入群拉拢的。而线下获客成本较高，且这些潜客人群往往具有精准定向的特点（例如：通过线下母婴活动获客基本都是准妈妈），因而很容易吸引同行销售抢客户，或进行恶意营销，有时候也会拉入别的机器人。因此，客服反应他们需要在群里增加微信机器人，在传统的客户关系维护工作之外，帮忙监控微信群中的恶意营销。在这种背景下，我们设计这款机器人模块，帮他们减轻监控工作的负担，专注于核心业务。 解决方案: 根据客服历史上遭遇的恶意营销案例，总结关键词（如骂人、销售抢单），生成关键词黑名单，并通过配置文件（支持简单的and/or，包含/不包含逻辑）的方式，对客服进行培训后由其进行定期维护。 当群中某人发言触发关键词黑名单后，机器人将@此人并进行警告。两次警告后再犯的，直接由机器人踢出群。 支持识别文字和微信语音，语音调取百度AI语音识别接口转成文字。 代码实现: 项目的地址 wx-bot 实现效果: 目前客服反馈通过关键词的方式能够较好地识别一些恶意营销的案例，总体感觉上减少了之前一半的监控工作。不过由于偶尔也会有误报的情况，通过直接@对方的方式容易造成误会，因此关键词的配置更新比较缓慢。客服反应即便不需要很精准，能够解决大部分问题她们就比较满意了。 下一步计划: 目前机器人功能比较简单，只能根据关键词进行识别，客服虽然已能够熟练运用配置文件，但是也有部分客服反应关键词总结起来比较费脑，想要更智能的方法自动识别某些特定主题的文字。因而下一步计划采用深度学习的语言模型（先采用词嵌入的预训练模型，如百度云NLP模块提供的功能），对过往数据进行总结建模。计划先基于现有数据，尝试一下效果。如准确性达不到要求，也可以考虑不在前台直接@，而是在后台通过个人微信提示客服，避免给客户造成误会的情况发生。 除此以外，客服们还对营销机器人在客户画像上提出了新需求，待后续更新。 "
    }, {
    "id": 224,
    "url": "https://wechaty.js.org/2020/08/28/wechaty-alert-padplus/",
    "title": "基于Wechaty-IPAD协议的预警消息转发机器人",
    "body": "2020/08/28 - 微信机器人 - 实时转发预警信息: 使用须知: 1、本项目基于微信IPAD协议，避免了网页版微信登陆不成功的情况2、本项目必须要申请token，具体操作流程请参考教程3、本项目延伸自 wechat-assistant-padplus ，因为官方版本当前只有TypeScript，目前为JavaScript语言。 初衷: 服务器上的预警信息天天都要有人一直监控着！好烦啊！能不能找一个机器人让我们能实时看到消息啊！恩，就这样，在网上研究了之后，找到了wechaty。本项目使用koa+wechaty的方式，暴露了Web API接口，方便服务器实时调用，转发到koa后向对应好友、微信群发送消息。也可以通过定时任务，轮询的方式来进行转发消息。 须知：本项目必须向wechaty团队申请token, 否则该项目是无法使用的. 申请流程参考: 申请token: 安装环境: 1、 Git客户端: 官网下载地址 2、 node. js (版本10以上): 官方下载地址 3、 pm2后台守护线程工具 (需要后台运行的话): 命令行运行：npm i pm2 -g 4、修改token //在wechaty-alert-padplus/wechaty/wechat. config. js文件的WECHATYTOKEN处修改: 安装启动过程: 1、下载项目: git clone https://github. com/Songbingjun/wechat-alert-padplus. git //参考git下载方式 2、下载依赖: npm install //进入到项目目录下后输入 3、项目启动: 项目启动有两种方式，一种是前台运行，一种是使用pm2进行后台运行前台运行： npm run dev后台运行： npm run pm2 前台示例图片如下: 后台方式启动导航: npm i pm2 -g //全局安装进程守护工具pm2npm run pm2  //启动pm2程序pm2 logs koa //后台查看运行程序 首次会显示扫码日志注意事项: 1、 项目运行后，会出现二维码扫描，如果识别不出二维码的原因可能是命令操作台的字体有问题，调整点阵字体，或者换一个客户端打开命令行，推荐Cmder: 2、 端口目前是15999，请先确保端口未被占用。修改需到wechaty/app. js 51行处修改: 3、 配置群名称需要到wechaty/wechaty/wechaty. config. js中 25行修改ROOMLIST数组中的roomName属性，目前接口逻辑只识别一个群(向好友发消息类似): 4、 扫描成功后会添加缓存文件，下次免登录，文件地址及名称 wechaty/ WechatEveryDay. memory-card，如果自动登录了后，想切换账号，删除该文件。: 5、 日志及错误记录在wechaty/koa/log目录中: 6、 如果不是后台运行的话，请设置计算机进入休眠状态为 从不。建议最好开启后台运行，并且修改状态。: 具体修改流程(win10) Win+R –&gt; control –&gt; 搜索:电源 -&gt; 电源选项 –&gt; 选择关闭显示器的时间 –&gt; 使计算机进入休眠状态 –&gt; 从不 7、 pm2进程守护工具常用命令: 1）pm2 logs 线程名 。 查看线程日志 例如：pm2 logs koa2）pm2 list 。 查看pm2所有应用3）pm2 stop 0 。 关闭id为0的应用4）pm2 delete 0 。 删除id为0的应用5）pm2 restart all 。 重启所有应用 API接口: 1、发送到群: 请求方式： GET请求参数： message请求url： ip:15999/api/pushMessage请求示例：http://localhost:15999/api/pushMessage?message=发送到群的文字输入在此处 2、发送给好友: 请求方式： GET请求参数： message请求url： ip:15999/api/pushInfo请求示例：http://localhost:15999/api/pushInfo?message=发送给好友的文字输入在此处 较wechat-assistant-padplus进行的改动: 由于本人是一名后端开发，web协议的wechaty本来有Java语言的版本，但是由于网页版微信限制(详见issues)。所以找到了另外一种协议 – IPAD协议。问题又来了，没有对应语言的版本，所以找到了wechat-assistant-padplus项目，项目主要以JS为主，对其做了以上变动。 1、注释了 wechat-assistant-padplus 中定时任务的相关业务逻辑: 2、将KOA与wechaty整合到了一个项目(因为需要在koa暴露的Web API接口中调用wechaty的初始化属性): 3、去除了MongoDB与天气接口: 更多问题: 关于wechaty的相关接口，请参考wechaty官网文档，如果以上还没有解决你的问题，请先往wechaty的项目issues中查找是否存在相同的问题，由于本项目是依赖wechaty开发，所以启动时遇到的问题大部分是wechaty的。 事实上, 如果需要一些其他自定义功能, 也可以很方便的在项目里修改哦！ 注意事项: 本项目属于个人兴趣开发，开源出来纯粹是为了技术交流，请勿使用此项目做违反微信规定或者其他违法事情。 "
    }, {
    "id": 225,
    "url": "https://wechaty.js.org/2020/08/28/deploy-wechaty-in-aws/",
    "title": "Deploy Wechaty in AWS ec2",
    "body": "2020/08/28 - This article is about to deploy wechaty node. js application into AWS EC2 steps by steps. Prerequisites:  padplus token Way to get a token AWS account. Steps: Step 1 Launch a linux ec2 instance: Follow the AWS official Document to launch a linux instance. Launching an instance using the Launch Instance Wizard With a successful launch, you shall be able to see the instance status is running as screen below Step 2 Connect the ec2 instance by ssh: Follow the AWS documents to connect the ec2 instance by ssh client  prerequisites for connecting to your instance Connecting to your Linux instance using SSHWith a successful connection, you shall be able to see the console prompt as below:  [ec2-user@ip-172-31-8-111 ~]$ Step 3 Install nvm and node:  Install node version manager (nvm) by typing the following at the command line. curl -o- https://raw. githubusercontent. com/nvm-sh/nvm/v0. 34. 0/install. sh | bash Use nvm to install the latest version of Node. js by typing the following at the command line. nvm install nodeStep 4 install git and clone wechaty:  To install git, run below commands in the terminal:sudo yum update -ysudo yum install git -y Clone wechaty from githubgit clone https://github. com/wechaty/wechaty-getting-started. gitStep 5 Install wechaty dependencies and set up environment: npm installexport WECHATY_PUPPET=wechaty-puppet-padplusexport WECHATY_PUPPET_PADPLUS_TOKEN='xxxxxx'Step 6: Start Wechaty with logs npm start &gt; output. log 2&gt; error. logTodo:  Externalize the memory card file into s3.  For some unknown reason, the nodejs server stops. Need to investigate"
    }, {
    "id": 226,
    "url": "https://wechaty.js.org/2020/08/28/command-line-filter/",
    "title": "简易命令行控制的「微信机器人」及群聊信息过滤实现",
    "body": "2020/08/28 - 生活中学校通知信息都会借助微信群聊发布，并且时常会要求“收到请回复”。这就导致了少数重要信息与大量无关信息混杂在一起，屏蔽与不屏蔽都不是好办法。遂实现了命令行控制的「微信机器人」，并在此基础上完成了群聊信息过滤功能。 1. 开发过程:  微信官方并没有相关的API。已知的企业微信机器人和聊天平台有局限性，并不能灵活的完成我所期望的功能以及实现未来可能的拓展。 找了很多开源的wxbot，但他们都是基于Web版微信，笔者的微信账号并不能登陆成功。 后来找到了Wechaty，发现它完美解决了与微信交互的问题，并且封装了各式各样的接口，有详细的API文档。于是参与了开源激励计划，获取了免费甚至长期有效的iPad Puppet的Token。2. 核心代码: 完整代码请访问LazyBot Public Repo。 利用Wechaty与微信交互: 查阅了Wechaty的API文档，并且学习了介绍视频之后，笔者首先完成了一个入口程序，以方便移植与拓展。 // . /index. jsimport tokenJSON from '. /token. json'import infoJSON from '. /package. json'console. log(`Running LazyBot ${infoJSON. version}. . . `)console. log(`Trying to detect 'token' from '. /token. json'`)if (!tokenJSON. token) {  console. log(`Unable to acquire 'token' field from '. /token. json'. If you don't possess token of Wechaty, turn to https://github. com/juzibot/Welcome/wiki/Everything-about-Wechaty for more information. `)  return}console. log(`Detect 'token' from '. /token. json': ${tokenJSON. token}`)import main from '. /main. js'main(tokenJSON. token, '. /bot-settings. json')其中token被保存在. /token. json中，bot的设定被保存在. /bot-settings. json中。 随后，笔者仿照视频搭建了一个Wechaty的基本框架。 // . /main. jsmodule. exports = function(token, botSettingFile) {  // Import Wechaty  // . . .   // Import Settings  // . . .   import botSettings from '. /bot-settings. json';  import schedule from 'node-schedule';  // Import Command System  import commandUnits from '. /commands. js';  import utils from '. /utils. js';  // Construct Puppet  const puppet = new PuppetPadplus({ token });  const name =  LazyBot ;  const bot = new Wechaty({ puppet, name });  // Initialize Writing Settings  // Writing Settings of Bot to local file every 10 min.   // . . .   // Initialize Bot Settings  // . . .   // Begin Bot  bot  . on('scan', function (qrcode, status) {    if (status === ScanStatus. Waiting) {      QrcodeTerminal. generate(qrcode);    }  })  . on('login', function (user) {    console. log(`${user. name()} Login`);  })  . on('logout', function (user) {    console. log(`${user. name()} Logout`);  })  . on('room-invite', async roomInvitation =&gt; {    // . . .   })  . on('room-leave', async (room, leaverList, remover) =&gt; {    // . . .   })  . on('friendship', async (friendship) =&gt; {    // . . .   })  . on('message', async function(message){    // . . .   });  bot. start();}其中，bot的配置被保存在了botSettings当中，并且每隔10 min就被保存到本地. /bot-settings. json中。 解析命令: 首先，为了区别普通的消息与命令，笔者规定任何以. 开头的消息文本都被视为命令。但是保险起见，笔者要求在群聊当中，需要先开启 LazyBot，然后才会触发解析。 // . /utils. js/** * Test whether message is a command * @param {string} message * @returns {boolean} */function isCommand(message) {  return message[0] === '. ';}// . /main. js -&gt; 'message' event functionif (message. room()) {  const id = message. room(). id;  // . . .   // Initialize settings of group  if (!botSettings[ groups ][id]) botSettings[ groups ][id] = {  switch : false,  monitors : {} };  // . . .   if (utils. isCommand(text)) {    // Enable or Disable LazyBot    if (text ===  . enable-lazybot ) { botSettings[ groups ][id][ switch ] = true; return;}    else if (text ===  . disable-lazybot ) { botSettings[ groups ][id][ switch ] = false;return; }    // . . . Parse Command if ( switch  === true) and Do Something  }}然后，是解析的实现。命令以空格作为分隔符，但是考虑到有时候空格可能会作为参数的一部分，笔者采用了被包裹在配对的 或'之间的空格将不再被视作为分隔符的解决方案。解析完毕后，会生成一个命令对象。 // . /utils. js/** * Parse message as command * ' ', which is not between '' or   , is perceived as separator * subCommand beginning with '-' is perceived as non-boolean flag * subCommand beginning with '--' is perceived as boolean flag * @param {string} message */function parseCommand (message) {  // . . . function for checking boolean flag  // . . . function for checking non-boolean flag  const ret = {    mainCommand:  ,    flags:{},    args:[],    err:     };  const _commands = message. split(' ');  const commands = [];  // After Splitting message by ' ', merge items like [ a, b ], and delete quotes.   // e. g.  . abc 'abc e'  =&gt; [ . abc ,  'abc ,  e' ] =&gt; [ . abc ,  abc e ]  // . . .   // Parse Commands  // . . .   return ret;  }其中，以--开头的参数被认为是boolean flag，而以-开头的参数被认为是non-boolean flag，并且其后所接的参数被认为属于这个flag。 至此，命令行的输入与解析就实现完成。之后就是相应功能的实现。为了能够一般化命令行指令，笔者定义了一个处理中心，接收解析好的命令，并且找到合适的实例去执行。 // . /commands. js/** * Command  . help  is reserved for listing all possible commands with their descriptions. */class CommandUnits{  RegisterCommand(command, description) {    this. commands[command. mainCommand] = command;    this. descriptions[command. mainCommand] = description;  }  RegisterRegexCommand(regex, command, display, description) {    this. regexCommands. push({      regex, command, display, description    });  }  CallCommand(parsedCommands, message, botSettings){    if (parsedCommands. mainCommand ===  . help ) {      // Display All Possible Commands      // . . .       return ret;    }    // Test for complete Match first    if (this. commands[parsedCommands. mainCommand]) return this. commands[parsedCommands. mainCommand]. Call(parsedCommands, message, botSettings);    for (const regexCommand of this. regexCommands) {      if (regexCommand. regex. test(parsedCommands. mainCommand)) return regexCommand. command. Call(parsedCommands, message, botSettings);    }    return `Unrecognized Command: ${parsedCommands. mainCommand}. `;  }  Ready(){    // Sort Regex Command to Display more beautifully    // . . .   }  constructor() {    this. commands = {};    this. descriptions = {};    this. regexCommands = [];  }}其中，CommandUnits接收正常的Command和正则形式的Regex Command，所有的Command在使用前都需要显式的注册到CommandUnits中。并且，CommandUnits在确定接受完所有的注册后，需要显式的调用Ready去做一些初始化工作。 随后，就是Command的具体实现。同样，笔者定义了一个类来完成封装。 // . /commands. jsclass Command{  _parse(commands) {    const parsedCommands = {      mainCommand: commands. mainCommand,      err:   ,      args: [],      flags:{}    };    // Parse parsed Commands to suit needs of this specific instance    // . . .     return parsedCommands;  }  Call(commands, message, botSettings) {    const parsedCommands = this. _parse(commands);    if (parsedCommands. err !==   ) return parsedCommands. err;    if (parsedCommands. flags[ help ] || parsedCommands. flags[ h ] !== undefined) return this. help();    return this. caller(parsedCommands, message , botSettings);  }  help() {    // Return Help Information for this instance    // . . .   }  /**   *   * @param {string} mainCommand   * @param {Array&lt;{flag: string, description: string}&gt;} booleanFlags   * @param {Array&lt;{flag: string, description: string}&gt;} nonBooleanFlags   * @param {(commands, message, botSettings) =&gt; string} caller   */  constructor(mainCommand, booleanFlags, nonBooleanFlags, caller) {    this. mainCommand = mainCommand;    this. booleanFlags = { flags: [], descriptions:{}};    this. nonBooleanFlags = { flags: [], descriptions:{} };    for (const flag of booleanFlags) {      this. booleanFlags. flags. push(flag[ flag ]);      this. booleanFlags. descriptions[flag[ flag ]] = flag[ description ] ||   ;    }    // Add `--help` command    // . . .     for (const flag of nonBooleanFlags) {      this. nonBooleanFlags. flags. push(flag[ flag ]);      this. nonBooleanFlags. descriptions[flag[ flag ]] = flag[ description ] ||   ;    }    // Add `-h` command    // . . .     this. caller = caller;  }}其中，flags被以Array&lt;Object&gt;的形式注册到Command中，相应的处理函数也被注册到其中。笔者设计Command类时，要求为Command和每个flag提供帮助文本以自动生成帮助信息。 下面是两个简单的使用的例子。 // 让 Bot 识别 . hi 指令，对注册过的用户回复“欢迎”的消息。commandUnits. RegisterCommand(new Command( . hi ,[],[],function (commands, message, botSettings) {  if (!botSettings[ users ][message. from(). id]) {    console. log(`Invalid . hi command from unregistered user ${message. from(). id}`);    return registerPrompt;  }  return `Hello, ${message. from(). name()}! What a nice day!`;}),  Say Hi to Bot ); // 让 Bot 识别 . register 指令， 以接受用户的注册。对注册过的用户，提示已经注册过，除非显式加入`--force`参数。commandUnits. RegisterCommand(new Command( . register ,[  {    flag: force ,    description: Force to register account. In this case, the original account will be deleted, if have registered.    }], [],function (commands, message, botSettings) {  if (message. room()) return   ;  const id = message. from(). id;  if (botSettings[ users ][id] &amp;&amp; !commands. flags[ force ]) {    console. log( Account ,id, Tried to register again );    return `Have registered Account ${id}`;  }  botSettings[ users ][id] = {};  console. log( Account Registered ,id);  return `Hello, ${message. from(). name()}!`;}),  Register Account ); 实现群聊信息过滤: 在准备好所有工具过后，就要实现群聊信息的过滤了。笔者采用的是黑名单和白名单方案，各个方案接受指定用户的检测或者是基于正则表达式的文本检测。保险起见，笔者要求用户显式的开启过滤功能，并且为黑名单和白名单分别设置了开关。 // . /command. jscommandUnits. RegisterCommand(new Command( . monitor ,[  {flag:  off , description:  Turn Off The Monitor },  {flag:  whitelist , description:  Toggle the WhiteList },  {flag:  blacklist , description:  Toggle the BlackList }],[],async function (commands, message, botSettings) {  // Check whether `. monitor` is valid in current environment  // . . .   const id = message. room(). id;  const userId = message. from(). id;  if (!botSettings[ groups ][id][ monitors ][userId]) {    // Initialize User Settings in Monitors    // . . .   }  // Parse Options  // . . .   return   ;}),  Monitor Group Chat );commandUnits. RegisterCommand(new Command( . whitelist ,[  {flag: delete , description:  Whether to delete rules instead of adding },  {flag: show , description:  Display WhiteList },],[  {flag: u , description:  Add/Delete User to/from White List },  {flag: m , description:  Add/Delete Message Filter (Regex) to/from White List }],async function (commands, message, botSettings) {  // Check whether `. whitelist` is valid in current environment  // . . .   const topic = await message. room(). topic();  const id = message. room(). id;  const userId = message. from(). id;  if (commands. flags[ show ]) {    // Send Setting Information of White List to User    // . . .     return   ;  }  if (commands. flags[ u ]) {    // Get User's Id from its name and Add / Delete it to / from settings if appropriate.     // . . .     return   ;  }  if (commands. flags[ m ]) {    // Add / Delete filtering rule to / from settings if appropriate.     // . . .     return   ;  }}),  Manipulate WhiteList of Message Filter of Group Chat );其中，. blacklist同理。 然后，完善main. js中的相应事件，LazyBot就初步搭建成功。 示例: 3. 已知问题:  暂时无法完成连续性指令。 设置被缓存在本地文件当中，写入数据库会更好。4. 优势:  实现了泛式的命令行控制，易于拓展功能。"
    }, {
    "id": 227,
    "url": "https://wechaty.js.org/2020/08/24/add-video-to-wechaty-blog/",
    "title": "使用jekyll include在wechaty博客中快速插入视频",
    "body": "2020/08/24 - 撰写暑期2020中期POC博客的时候，遇到了在博文中插入视频、PPT等iframe的需求，可以在markdown文档中直接使用bilibili等视频网站提供的视频嵌入代码，然而这样视频的样式不够美观，iframe没有铺满整个宽度并保持一定宽高比。 1. 背景: 在lijiarui和Huan的建议下，参考之前的博客,应用如下样式插入iframe能够达到较为满意的效果（宽高比为16:9）。 &lt;div class= video-container  style=   position: relative;  padding-bottom:56. 25%;  padding-top:30px;  height:0;  overflow:hidden; &gt;&lt;iframe src= https://www. youtube. com/embed/ZYjYAT2g-1Q  width= 560  height= 315  frameborder= 0  allowfullscreen=   style=   position: absolute;  top:0;  left:0;  width:100%;  height:100%; &gt;&lt;/iframe&gt;&lt;/div&gt;但是每次需要插入iframe的时候都插入这么一段代码未免太过复杂，之前我使用hugo写博客的时候经常使用shortcodes并传入一定的参数，博客生成的时候会使用对应的HTML模板替换这段shortcodes。经查询发现jekyll也有类似的特性，可以使用include标签来引入位于_includes文件夹里面的html片段，并且可以在include标签传入变量，在html模板中进行处理生成html片段，具体可以参考jekyll文档。 2. 使用include插入iframe: 基本思想很简单，传入一个参数：iframe的地址或者视频的播放地址，利用上面带样式的iframe代码写成模板文件即可。 在Huan的建议下，在模板文件中使用liquid语法进行一些简单的逻辑判断，针对不同类型的iframe进行不同的处理，比如：  bilibili视频的iframe有一个最上面的推荐栏，会导致iframe变高，使用16：9的比例不能使视频铺满，因此修改其宽高比为10:7,更具体得说，将. video-container这个div的padding-bottom改为70%。 插入pdf文件需要使用viewer. js进行渲染，需要在本地的pdf文件路径前加上/assets/js/viewer-js/#作为完整的iframe地址。 对于支持的视频网站，将视频的播放地址转化为视频的iframe地址模板文件为_includes文件夹内部的iframe. html,具体内容如下 {% assign src = include. src %}{% assign ratio = '56. 25%' %}{% if src contains '. pdf' %} {% assign type = 'pdf' %}{% else %} {% assign type = src | split: '//' | last | split: '/' | first %}{% endif %}{% case type %} {% when  pdf  %}  {% assign src = '/assets/js/viewer-js/#' | append: src %} {% when 'www. bilibili. com' or 'player. bilibili. com' %}  {% assign ratio = '70%' %}  {% assign src = src | replace:  www. bilibili. com/video/ ,  player. bilibili. com/player. html?bvid=  %} {% when 'youtu. be' or 'www. youtube. com' %}  {% assign src = src | replace:  watch?v= ,  embed/  | replace:  youtu. be ,  www. youtube. com/embed  %} {% when 'v. qq. com' %}  {% assign ratio = '60%' %}  {% assign src = src | replace:  . html ,    | replace:  x/page/ ,  txp/iframe/player. html?vid=  %} {% when 'v. youku. com' %}  {% assign src = src | replace:  . html ,    | replace:  v. youku. com/v_show/id_ ,  player. youku. com/embed/  %}{% endcase %}&lt;div style=   position: relative;  padding-bottom: {{ ratio }};  padding-top:30px;  height:0;  overflow:hidden; &gt; &lt;iframe  src='{{ src }}'  allowfullscreen  webkitallowfullscreen  frameborder= 0   style=    position: absolute;   top:0;   left:0;   width:100%;   height:100%;    &gt;&lt;/iframe&gt;&lt;/div&gt;3. 使用示例: pdf文件: {% include iframe. html src= /assets/2020/qijibot/final. pdf  %} 插入视频时，支持如下网站直接使用视频的播放地址，作为include标签的src参数 youtube: {% include iframe. html src= https://www. youtube. com/watch?v=fbTedVcEEEI  %}或者短网址 {% include iframe. html src= https://youtu. be/fbTedVcEEEI  %} bilibili: {% include iframe. html src= https://www. bilibili. com/video/BV1LV411r756  %} 优酷: {% include iframe. html src= https://v. youku. com/v_show/id_XMzcyODcwMzQzNg==. html  %} 腾讯视频: {% include iframe. html src= https://v. qq. com/x/page/v0952wieqwl. html  %} "
    }, {
    "id": 228,
    "url": "https://wechaty.js.org/2020/08/23/wechaty-puppet-gitter/",
    "title": "Gitter.im is supported by Wechaty now!",
    "body": "2020/08/23 - Wechaty is a RPA SDK for Chatbot Makers. It mainly works with WeChat accounts (both individual and official), and now we have published Gitter support for wechaty, which can make us easy to build a chatbot on Gitter. im, and sync the room between the Gitter. im and WeChat! Wechaty + Gitter. im: For a long time, I want to connect my Gitter room to WeChat room and sync messages between them. Now it’s possible with Wechaty + Gitter Puppet! To support Gitter. im, the core component is the NPM module wechaty-puppet-gitter, which brings the power of Gitter. im to Wechaty. Show Me The Code: Here’s the example code that shows out how to use Wechaty with Gitter room: it will print all room names and you can send text messages to rooms. // Of course you need `npm install wechaty wechaty-puppet-gitter` before run this little code snip!import { Wechaty } from 'wechaty'import { PuppetGitter } from 'wechaty-puppet-gitter'async function main () { const puppet = new PuppetGitter('your_gitter_token') const bot = new Wechaty({ puppet }) await bot. start() const roomList = await bot. Room. findAll() for (const room of roomList) {  console. info('room found:', await room. topic())  // await room. say('Hello from Wechaty!') } await bot. stop()}main(). catch(console. error)That’s easy to use. To learn more about how to use Wechaty API, you can visit our docs website at https://wechaty. js. org/docs Use Case: I have a Gitter room wechaty/wechaty, with a SideCar on our website wechaty. js. org. At the same time, most of our developers are based on WeChat, so I want to sync the messages between them. After we have the wechaty-puppet-gitter, I finally make my dream true today:  The gitter room wechaty/wechaty will receive all messages that developers send to WeChat room (actually, we have 10+ WeChat rooms, because WeChat do not permit more than 500 users in one room and we have thousands of developers already), forwarded by our Gitter bot: Mike. BO The rooms on WeChat will receive all the messages that developers send to the Gitter room too, forwarded by our WeChat bot: Friday. BOT. In order to sync two rooms, we need to create two Wechaty instances, one is using Gitter Puppet and the other is using Donut Puppet(PC Windows Protocol for WeChat). To get to know the details about how it works, please feel free to read the source code of our chatbot, it has been open-sourced at https://github. com/wechaty/friday/, and here are some entries that good to start with:  Create a Wechaty instance with Gitter Puppet Create a Wechaty instance with Donut Puppet Sync Gitter Room and WeChat Room MessagesUpload Image with Gitter API: How to send an image to the gitter. im room via API? I ran into this question two days ago. With great help from @MadLittleMods finally, I made it! 1. Background: When I was learning for how to upload to Gitter room, I file an issue to request an image upload API for gitter at here, then I learned that I can read the source code from web app of Gitter. After hours of studying and testing, finally I encapsulate the send image feature into my code base, and I’d like to share it with the community in case you are interested in it. 2. Raw API Call: To send an image message to our Gitter room, we need to do three API calls:  Generate signature: call api. gitter. im and get a key to use with transloadit service Get transloadit server: call api2. transloadit. com with the key from step 1, then get a host domain name for using with step 3 Upload file: call the server domain name from step 2, and send the image file to itTo learn the details about the above 3 steps, you can read the source code for Node. js(TypeScript) at here 3. Use Wechaty with Gitter Image Message: As I’m writing all of those codes for my wechaty-puppet-gitter, which is the plugin for our Wechaty, so I’d like to share the Wechaty way to do this. Here’s the demo source code for sending an image message to a Gitter room with Wechaty: const { Wechaty, FileBox } from 'wechaty'const wechaty = new Wechaty({ puppet: 'wechaty-puppet-gitter', puppetOptions: { token: 'your_gitter_token' },})async function main () { await wechaty. start() const room = wechaty. Room. find({ topic: 'gitter/developers' }) if (room) {  const image = FileBox. fromUrl('https://raw. githubusercontent. com/wechaty/wechaty-puppet-gitter/master/docs/images/wechaty-puppet-gitter. png')  await room. say(image) }}main(). catch(console. error)That’s it! Summary: I’m so happy and like to share what we have created for Wechaty with the Gitter developer community, and I hope you will like it. Thank you for your time to read my post! "
    }, {
    "id": 229,
    "url": "https://wechaty.js.org/2020/08/22/summer-2020-wechaty-soc-midterm-demo-day/",
    "title": "暑期2020中期路演日（Mid-Term Demo Day）",
    "body": "2020/08/22 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动，旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展，点击查看官方新闻。 Wechaty 作为中国最大的聊天机器人开源项目，合计发布了11个项目，由Wechaty社区的资深Contributor作为导师，选出了11位同学进行项目开发。 此次的11个项目的学生开发者，均录制了一份路演视频，向社区介绍具体的项目进展和后续规划。 在路演日中，除了按顺序播放视频，还会邀请社区导师和开发者进行评价和指导，并给出切实有效的建议。 此外，开发者们可以在路演日中找到自己感兴趣的项目，并在路演日结束后，与对应的开发者取得联系并在后续共同开发。 项目列表: https://github. com/wechaty/summer/issues/3 中期路演日（Mid-Term Demo Day）会议纪实:  Agendas议程:  0:00:00 1. 介绍会议议程 0:02:07 2. 孔祥哲：基于python-wechaty的群聊助手机器人 0:10:00 3. 肖子霖:基于Python-wechaty建立一个斗图机器人 0:23:57 4. 江珊珊:编写一个“每日一句”插件 0:30:31 5. 陈炀:Wechaty Java 移植组件开发 0:37:03 6. 谢昱清:基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人 0:48:35 7. 杨明哲:基于开放 API 封装 Wechaty 接口下的钉钉聊天机器人 0:55:39 8. 范蕊:基于开放 API 封装 Wechaty 接口下的飞书聊天机器人 1:05:32 9. 王俊伟:基于 RPA 封装 Wechaty 接口下的抖音聊天机器人 1:12:20 10. 毕凯乔:基于 RPA 封装 Wechaty 接口下的快手聊天机器人 1:20:25 11. 总结You can learn more from our meeting_notes Wechaty 中期项目列表: Wechaty 在多语言、多平台、多功能三条主线上，共发布了 11 项任务，并通过 issue 的方式进行每周的更新。如果你有看到感兴趣的项目，可以直接在对应 issue 下面找到负责对应任务的开发者。 你可以在查看首次KickOff博客了解更多信息。 多功能：编写一个“每日一句”插件:  导师：Gcaufy，20000+Star小程序框架Wepy作者、Wechaty Plugin系统设计师gcaufy@gmail. com 学生开发者：江姗姗，北京大学二学位本科生univerone@outlook. com 项目介绍：https://github. com/wechaty/summer-of-code/issues/10 多平台：基于开放 API 封装 Wechaty 接口下的飞书聊天机器人:  导师：高原，句子互动CTO、前亚马逊工程师gaoyuan@juzi. bot；李佳芮，句子互动CEO、专注微信生态近10年rui@juzi. bot 学生开发者：范蕊，南开大学本科生953299708@qq. com 项目介绍：https://github. com/wechaty/summer-of-code/issues/12 多语言：Wechaty Java 移植组件开发:  导师：刁政欣 阿里开发工程师 Author of Jahttps://www. bilibili. com/video/BV13T4y1L748/va-wechaty diaozxin@gmail. com 学生开发者：陈炀，福州大学本科生1184016190@qq. com 项目介绍：https://github. com/wechaty/summer-of-code/issues/4 多平台：基于开放 API 封装 Wechaty 接口下的钉钉聊天机器人:  导师：高原，句子互动CTO、前亚马逊工程师gaoyuan@juzi. bot；李佳芮，句子互动CEO、专注微信生态近10年rui@juzi. bot 学生开发者：杨明哲，福州大学本科生yutinice@foxmail. com 项目介绍: https://github. com/wechaty/summer-of-code/issues/11 多平台：基于 RPA 封装 Wechaty 接口下的抖音聊天机器人:  导师：尹伯昊，连续创业者，句子互动CMOyinbohao@juzi. bot 学生开发者：王俊伟，长春工业大学本科生863445607@qq. com 项目介绍： https://github. com/wechaty/summer-of-code/issues/13 多功能：基于python-wechaty的群聊助手机器人:  导师：吴京京：Wechaty Committer，Python Wechaty Author1435130236@qq. com 学生开发者：孔祥哲，清华大学本科生15068701650@163. com 项目介绍：https://github. com/wechaty/summer-of-code/issues/6 多功能：基于Python-wechaty建立一个斗图机器人:  导师：黄纯洪，python-wechaty contributorhuangaszaq@gmail. com 学生开发者：肖子霖，四川大学本科生me@mrxiao. net 项目介绍：https://github. com/wechaty/summer-of-code/issues/7 多平台：基于 RPA 封装 Wechaty 接口下的快手聊天机器人:  导师：尹伯昊，连续创业者，句子互动CMOyinbohao@juzi. bot 学生开发者：毕凯乔，长春工业大学本科生358461417@qq. com 项目介绍：https://github. com/wechaty/summer-of-code/issues/14 多平台：基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人:  导师：高原，句子互动CTO、前亚马逊工程师gaoyuan@juzi. bot；李佳芮，句子互动CEO、专注微信生态近10年rui@juzi. bot 学生开发者：谢昱清，清华大学本科生1205402283@qq. com 项目介绍：https://github. com/wechaty/summer-of-code/issues/2 多语言：为 go-wechaty 设计实现插件体系:  导师：丁小雨614422099@qq. com，丁超飞dchaofei@163. com，李博杰silkage@silkage. net 学生开发者：林昊翰，西安电子科技大学本科生finctive@foxmail. com 项目介绍： https://github. com/wechaty/summer-of-code/issues/9多语言：Go-wechaty Github Action optimization:  导师：丁小雨614422099@qq. com，丁超飞dchaofei@163. com，李博杰silkage@silkage. net 学生开发者：唐光彬，华南农业大学本科生Tang. Packet@outlook. com 项目介绍： https://github. com/wechaty/summer-of-code/issues/8暑期2020 开发计划: 此次暑期2020活动中，开发者分别需要在Wechaty社区内完成例行交付、向组委会提供两个节点的代码并完成答辩，其所有成果均会以开源的形式向社区开放。 Wechaty 社区交付内容:  Finished Blog：学生开发者们会在9. 30号前以博客形式在wechaty. github. io进行分享，内容包括：完整的项目情况和实现的功能、后续长期的开发展望，同时也作为最后一次每周进展在例行更新中同步。暑期2020组委会交付内容:  完整项目提交和汇报：学生开发者们会在9. 30号前完成，届时项目完整代码会向社区开放。欢迎正在阅读的你参与其中: 虽然“暑期2020”的报名已经结束，但Wechaty社区依然欢迎正在阅读本篇内容的你参与到暑期2020的工作中来。以下是几种可能的参与方式：  时刻跟进Wechaty SoC项目的每周例行更新Issue，并直接与相关负责导师和学生开发者取得联系，和他们交流相关进展。 在 Wechaty 开发者群内，为学生开发者们的Plan Blog、POC Blog和Finished Blog点赞和提出想法。 直接参与已经完成部分工作的项目开发，为学生开发者们负责的复杂项目添砖加瓦。 作者: juzibot "
    }, {
    "id": 230,
    "url": "https://wechaty.js.org/2020/08/22/market-wechat-robot/",
    "title": "行情播报微信机器人",
    "body": "2020/08/22 - 使用Wechaty开发的行情播报微信机器人，为微信群组用户提供实时行情信息播报服务。用户可以通过添加管理员微信，然后自动加入播报群组。机器人将采用行情早晚报和事件播报的形式在群组中进行行情播报。 播报内容: 行情早晚报: 截止北京时间早或晚8点：NQ小型纳指当月连续点数报11562. 93，日内涨跌幅1. 29%；YM小型道指当月连续点数报27857. 0，日内涨跌幅1. 10%；ES小型标普当月连续点数报3391. 98，日内涨跌幅1. 00%；COMEX黄金点数报1947. 4，日内涨跌幅1. 17%；NYMEX原油点数报42. 25，日内涨跌幅0. 09%；USDCNH美元离岸人民币点数报6. 9213，日内涨跌幅0. 02%；UDI美元指数点数报93. 2，日内涨跌幅-0. 19%；VIX恐慌指数点数报22. 54，日内涨跌幅-7. 47%；CME比特币期货CFD点数报11600. 0，日内涨跌幅-0. 92%。 现货撮合数据现报11455. 98USDT。截止午夜12点，现货撮合数据日内加权平均价格为11801. 96USDT，日内收益为-133. 37USDT，收益率为-1. 12%。 日内高点为11882. 79USDT，低点为11625. 39USDT，振幅为257. 40USDT，2. 17%，相对历史水平为14. 0434。 收益/振幅为-51. 81%，属于日内（震荡）。 日内交易总量为127232. 09BTC，相对历史水平为-。 其中买入量为59677. 61BTC，卖出量为67554. 48BTC，买卖量差为-7876. 87BTC，买卖量比为0. 4690。 目前现货平均真实振幅为423. 15USDT，历史水平为56. 1487。 波动率水平位1. 05%，乖离率为-199. 78%，cci为-67. 44。 事件播报: BTC现报11421. 60USDT，日内累计涨幅-302. 41，达-2. 58%，15分钟内现货成交量达3369. 55BTC，其中买入量为1457. 26BTC，卖出量为1912. 29BTC，买卖量差为-455. 03BTC，买卖量比为0. 4325。 盘口单一价格挂单超过100BTC，平台：coinbase，价格：11500. 00USDT，数量：124. 82BTC 运行Wechaty Hostie服务: 准备工作: 准备一台服务器，具备以下条件：  公开IP：可通过互联网访问； 公开端口：可通过互联网访问； Docker。运行步骤: 1. 安装Wechaty的Docker镜像: docker pull wechaty/wechaty2. 设置wechaty-puppet-service: 可使用自定义的随机字符串，为防止与其他用户冲突，建议采用UUIDv4，可用在线生成工具来生成，网址。 export WECHATY_TOKEN=puppet_hostie_your_token3. 开启Wechaty Puppet服务: export WECHATY_HOSTIE_PORT=8888export WECHATY_PUPPET=wechaty-puppet-padplusexport WECHATY_PUPPET_PADPLUS_TOKEN=puppet_padplus_tokenexport WECHATY_LOG=verbosedocker run \ --rm \ -ti \ -e WECHATY_LOG= $WECHATY_LOG  \ -e WECHATY_PUPPET= $WECHATY_PUPPET  \ -e WECHATY_HOSTIE_PORT= $WECHATY_HOSTIE_PORT  \ -e WECHATY_TOKEN= $WECHATY_TOKEN  \ -e WECHATY_PUPPET_PADPLUS_TOKEN= $WECHATY_PUPPET_PADPLUS_TOKEN  \ -p  $WECHATY_HOSTIE_PORT:$WECHATY_HOSTIE_PORT  \ wechaty/wechaty4. 检查Wechaty Puppet服务是否正常开启: 访问https://api. chatie. io/v0/hosties/TOKEN，其中TOKEN为前面设置的WECHATY_TOKEN。如果返回结果中包含前面设置的IP和端口，则服务正常开启。如果返回结果为： { host : 0. 0. 0. 0 , port :0}则服务没有正常开启，需要按照上面的步骤重新检查。 运行行情播报微信机器人: 下载源码: 从github代码库中克隆源代码 git clone https://github. com/exctech/market-wechat-robot. git运行机器人: python market-robot. py Author: @exctechCode: @exctech/ "
    }, {
    "id": 231,
    "url": "https://wechaty.js.org/2020/08/21/wechaty-xiaowang-learning-tool/",
    "title": "基于Wechaty的群学习内容推送工具",
    "body": "2020/08/21 - 准备考研期间，希望在每天定时能获得天气推送，每日英语一题，早间新闻来丰富自己的学习；同时又不想要专门去点开某个App来看（这样不仅费心，还容易跑神） 功能:  定时采集英语的每日一题，推送到群里 早晨问好，同时发送当天天气预报，每半天检查一次未来24小时内设定的经纬度处是否有降水。 采集网站上的新闻早报，补充时政知识 发送每日一句 图灵机器人对话（来源于第三方的数据仅供学习之用，请经常访问这些优质网站） 特点:  使用腾讯云云函数进行定时获取信息的操作，减少了服务器上的配置难度 使用Node. js Express对Wechaty进行了封装，后续功能可以本地写好python或nodejs云函数后，直接部署在腾讯云上，不用调整服务器 使用pm2进行wechaty运行状态的维持（后续可以考虑改为使用无服务器的环境，比如Leancloud、Heroku容器等，减少服务器的开支）功能示例: 项目结构: |-- wechaty-xiaowang  |-- index. js //主程序  |-- package-lock. json  |-- package. json  |-- puppet-config. js //pupet参数  |-- serverchan. js //通过方糖报告错误  |-- tulingbot. js  //图灵机器人  |-- cloudFunctions // 运行在腾讯云上的云函数爬虫    |-- dailyEnglishTest //英语每日一题    |-- dailySentence  //英语每日一句    |-- moringNews //每日早报    |-- rainDetection  //降雨提醒    |-- weatherTip //早晨问好，及天气预报架构说明:  服务器端 Express + Wechaty 开放一个HTTP接口用于访问，传入HTTP接口的内容会被发送到预先指定的群内 云函数端 定时获取信息，并通过HTTP调用发送给Wechaty机器人使用: wechaty的部署:  填写代码中的配置，如Token，服务器地址、端口等 上传至服务器   在其目录下，获取所有用到的NPM包    npm i    使用node index. js命令，启动wechaty，并扫码登录 （可选）调试好之后，可选择使用pm2等工具维持wechaty的运行 （可选）使用Nginx的反向代理功能来实现HTTPS，增强安全性 （可选）使用cloudflare的防火墙规则或者Nginx，来将访问权限限制到特定的范围，增强安全性云函数的部署:  打开 https://console. cloud. tencent. com/scf/index 注册并新建云函数 新建时选择空白函数即可,然后选择目前要增加的函数的环境，之后点击下一步     Python 3. 6   Node. js 16. 16    在提交方法处，选择上传文件夹 选择当前增加的函数的文件夹，上传即可 新建完成后，返回云函数主页面，点击函数服务- 触发管理 弹出的创建触发器的页面内，选择自定义触发，填入Cron表达式     Cron表达式用法见：https://cloud. tencent. com/document/product/583/9708#cron-. E8. A1. A8. E8. BE. BE. E5. BC. 8F    完成对于每日新闻的代码，其运行于Coding的定时构建计划内，详见：https://help. coding. net/docs/devops/ci/trigger. html 致谢:  JUZI Bot提供的Token，使这个小项目具有可行性 Wechaty (非常优秀的项目) 腾讯云（提供了几乎免费的云函数） Coding（提供了免费使用的构建计划的主机）"
    }, {
    "id": 232,
    "url": "https://wechaty.js.org/2020/08/20/wechaty-puppet-kuaishou-mid-term/",
    "title": "暑期2020[基于 RPA 封装 Wechaty 接口下的快手聊天机器人]中期报告",
    "body": "2020/08/20 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [基于 RPA 封装 Wechaty 接口下的快手聊天机器人] 系 暑期2020 支持的开源项目。 [基于 RPA 封装 Wechaty 接口下的快手聊天机器人]中期报告: 项目进度:  已完成:     探索方向         7. 19-7. 27     主要探索之前预想的方向          auto. js init         7. 27-8. 03     完成了以auto. js作为服务端的初始化结构          为auto. js增加通信，完善封装代码         8. 03-8. 09     增加了客户端通信，使得在虚拟机上可以完成通过客户端控制的收发消息     并且重新封装了原来分散的脚本为一个class          构建puppet         构建puppet的初版，虽然还存在一些bug但是可以完成dingdong消息的收发           遇到的问题及解决方案     auto. js碰到的问题：         快手的密码组件不能够被直接设置密码     客户端和服务端通信问题阻塞     通信自动关闭     消息不能够被直接监听。如果进入消息页面时有新消息能够获取，如果进入时没有过一会才有则不能收到消息。          解决方案         目前只能通过屏幕位置然后人为点击，再模拟键盘操作输入密码     由于readLine()读取数据时没有换行符就会陷入阻塞状态。每次发送的字符串结尾加上\r\n即可     设置死循环让readLine进入阻塞状态监听客户端发送的信息     通过循环findOne(1000)以达到每隔1s重新在当前页面查找新消息提醒。           后续工作安排     8. 16-8. 23修正消息监听   8. 23-8. 30修正eslint错误   在完善服务端代码的基础上继续完善puppet代码   其他   Wechaty Demo Day 视频: PPT展示:  Live Code视频:  项目地址:  项目链接：https://github. com/bikaiqiao/kuaishou-auto / https://github. com/bikaiqiao/kuaishouPuppet. git               联系方式：+86 13943110476     358461417@qq. com          "
    }, {
    "id": 233,
    "url": "https://wechaty.js.org/2020/08/20/wechaty-puppet-douyin-mid-term/",
    "title": "基于RPA封装的Wechaty接口下的抖音聊天机器人中期报告",
    "body": "2020/08/20 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。 旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。 官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html 本项目 [基于 RPA 封装 Wechaty 接口下的抖音聊天机器人] 系 暑期2020 支持的开源项目。 中期报告：基于 RPA 封装 Wechaty 接口下的抖音聊天机器人: 项目信息:  项目名称：基于 RPA 封装 Wechaty 接口下的抖音聊天机器人 方案描述：服务器架设安卓虚拟机，通过autojs操作抖音，类似wechaty的puppeteer操作Chrome的网页微信，通过socket与wechaty连接 时间规划：7. 19-8. 15完成各种方案的尝试和探索，8. 15-9. 15完成puppet的各种接口接入项目进度:  已完成工作：     熟悉了wechaty的使用的操作方法   探索了各种方案：         抖音的发送私信的openapi需要用户为企业用户，只有企业抖音号api才有效     探索了monkeyDEV和IDA逆向私信协议的方法     没有找到chrome跑安卓app的方法，或者方法失效     尝试了通过安卓和ios端抓包的方式获取抖音的私信方法，结果抓不到私信的消息     autojs控制安卓app的方法，现在正在采用，也是现在唯一可运行的方法，目前完成了抖音基本操作方法的封装和socket的通信          抖音的autojs控制版本完成了自动登录，消息监听，发送消息等方法   用socket和autojs的方法跑了一个简易dingdongbot，视频演示地址(youtube)   puppet开发中，初步成型    遇到的问题及解决方案：     遇到问题         抖音的app控件id命名很随机，为三位随机的字母和数字，不同版本的控件名称不一样     首次抖音登录还需要图片验证，这个暂时没想到方法，只能人工验证，第二次登录就可以自动化了     监听消息的问题，只能打开消息窗口才能获取到消息，这样多人发送多条消息时只能读取一个人     eslist语法检查经常报错          解决方案         使用统一版本的抖音app     首次登录手动登录一下     退出消息窗口时继续查找未读消息，并且通过通过未读消息上带数字的小圆点判断有n条未读消息，打开未读消息的窗口，遍历屏幕上的消息框，将倒数n条消息存入数组，传到客户端     按照语法格式来           后续工作安排：     继续改善和封装autojs的代码，美化和规范代码   继续开发puppet，将现有socket客户端移植到puppet，接入wechaty完成一个dingdongbot   探索puppet更多的功能，实现底层autojs   PPT:  Live coding:  "
    }, {
    "id": 234,
    "url": "https://wechaty.js.org/2020/08/20/wechaty-file-assistant-bot/",
    "title": "基于wechaty-puppet-padplus的微信文件传输助手",
    "body": "2020/08/20 - 微信助手是很常见的运营工具，不仅能够给微信群带来活跃度，还能针对各种社群开发不同的玩法。本目标是做一个文件传输助手，当群内有人@机器人并say关键词时，机器人从已有文件业务系统中找到文件并发出；同时在群中直接发送一个文件，机器人可将文件自动上传至文件业务系统。 以下是我的开发过程: 1、微信官方并没有相关的 API。可能要考虑考虑企业微信？结果发现企业微信有群机器人，但完全无法满足我的需求，企业微信就排除了。 2、找了很多基于 Web 版微信的各种开源方案，但是对文件的支持基本为0。同时还存在很多账号登不了 Web 版微信的情况，找了官方文档，无法解决，放弃。 3、偶然间在github上看到了wechaty框架对这个简单上手，实用性高的框架爱不释手，于是决定立即开展。但是有发现，iPad 协议，虽然需要付费获取 token，但是可以申请参与开源激励计划来获取免费甚至长期有效的 token。 使用wechaty收发消息: 在 Wechaty 中，不同的 Puppet 对应不同的协议。Wechaty 还有不同语言的 SDK，以及 demo template repository，对开发者非常友好，开发者参与度也很高。github上已经开源了非常多成功的案例，具体细节就不在详述，只介绍关键部分，如下。 首先需要初始化一个 bot：1、install Wechaty老实说，install Wechaty我还是花了一些时间的，老是npm错误。后面发现是vs_BuildTools安装不上，原来是已经有了底版本的。需要先卸载。好在后面处理好了，不然就卡住了。 2、初始化bot，绑定事件函数，这里只需要onScan和onMessage两个事件就行 // create a Wechaty instance as botconst puppet = new PuppetPadplus({ token: ipadToken})let bot = new Wechaty({puppet, name: 'getFile'});bot. on('scan', onScan);bot. on('message', onMessage);bot . start() . then(() =&gt; {  console. log('开始登陆微信'); }) . catch(async function(e) {  console. log('初始化失败: ${e}. ')  await bot. stop()  process. exit(1) });3、onScan事件由于申请的是 iPad 协议的 token，这里用到的是 PuppetPadplus。接着对 bot 绑定各种事件的处理函数，其中 message 事件是接收到消息时触发的事件。 async function onScan(qrcode, status) {  Qrterminal. generate(qrcode)  console. log('扫描状态', status)  const qrImgUrl = ['https://api. qrserver. com/v1/create-qr-code/?data=', encodeURIComponent(qrcode)]. join('')  console. log(qrImgUrl)}3、onMessage事件 async function onMessage(msg) {  const room = msg. room(); // 是否为群消息  const msgSelf = msg. self(); // 是否自己发给自己的消息  const contact = msg. from(); // 发消息人  if (msgSelf) {    return;  }  if (room) {    const roomName = await room. topic();    if (roomName == baseConfig. roomName) {      goFile(this, room, msg);    }  }}async function goFile(that, room, msg) {  const contact = msg. from(); // 发消息人  const contactName = contact. name();//  const roomName = await room. topic();  let content = msg. text();  //经常群成员的备注会获取不到，需重新同步  if (content == '更新') {    room. sync();    return;  }  const alias = await room. alias(contact);  if (alias == null) {    room. say( 请修改群昵称！修改完后直接发送（不用@我）：更新 , contact);    return;  }  const type = msg. type();  const userSelfName = that. userSelf(). name();  if (type == that. Message. Type. Text) { //文字    const mentionSelf = content. includes(`@${userSelfName}`)    console. log(`群名: ${roomName} 发消息人: ${contactName} 内容: ${content}`);    console. log('是否提及:', mentionSelf);    if (mentionSelf) {      content = content. replace(/@[^\s]+/g, ''). trim();      console. log('content值:', content);      if (content == 'gogogo') { //下载文件发送到群中        let promise = http. sendPost({           sysParams : JSON. stringify({             businessCode :  wechat_getEmailFile ,             params : { userName : alias}          })        }, baseConfig. commonBusUrl);        promise. then((res) =&gt; {          console. log(res);          if (typeof (res. businessRes. fileList) != undefined) {            var fileList = res. businessRes. fileList;            for (var i = 0; i &lt; fileList. length; i++) {              var base64Code = fileList[i]. fileStr;              var fileName = fileList[i]. realFileName;              var buffer = new Buffer(base64Code, 'base64');              const fileBox = FileBox. fromBuffer(buffer, fileName);              room. say(fileBox);            }          } else {            room. say( 获取失败！ , contact);          }        });      } else if (content == '在么') {        room. say( 我在线 );      } else {        room. say( 不明白 );      }    }  } else if (type == that. Message. Type. Image || type == that. Message. Type. Attachment) { //将群中文件上传    const file = await msg. toFileBox();    const fileName = file. name;    const mimeType = file. mimeType;    let promise = file. toBase64();    promise. then((res) =&gt; {      let promise = http. sendPost({         sysParams : JSON. stringify({           businessCode :  wechat_uploadFile ,           params : { userName : alias,  base64Code : res,  fileName : fileName,  mimeType : mimeType}        })      }, baseConfig. commonBusUrl);      promise. then((res) =&gt; {        var returnMsg = res. businessRes;        if (returnMsg == 'ok') {          room. say( 上传成功 );        }      });    });  } else {    room. say( 本群只能发文字和文件。 );  }}上线！: 微信机器人这样常见的需求就应该有简单的做法。在排除各种不靠谱方案以后，我选择了 Wechaty。 Wechaty 简洁的 API 可以帮助开发者快速地搭建一个微信个人号机器人。没有时间折腾的开发者，就不用花时间尝试其它方案了。 最后: Wechaty的功能非常强大，我只用了一角。后续将扩充更多功能应用。 "
    }, {
    "id": 235,
    "url": "https://wechaty.js.org/2020/08/20/kotlin-wechaty-simple-shell/",
    "title": "基于wechaty的简易shell",
    "body": "2020/08/20 - 这个项目是基于SpringBoot和SpringMVC的，语言是kotlin，构建工具是maven。 准备工作（创建自己的wechaty-hostie-token）: 假设我们目前拥有的是padplus的token。因为java-wechaty需要的是hostie的，所以这就需要先做一下转换。 然后执行以下命令 docker pull wechaty/wechatyexport WECHATY_PUPPET_PADPLUS_TOKEN=puppet_padplus_*****export WECHATY_HOSTIE_PORT=8788export WECHATY_PUPPET=wechaty-puppet-padplusexport WECHATY_LOG=verbosedocker run -d\ --rm \ -ti \ -e WECHATY_LOG= $WECHATY_LOG  \ -e WECHATY_PUPPET= $WECHATY_PUPPET  \ -e WECHATY_PUPPET_PADPLUS_TOKEN= $WECHATY_PUPPET_PADPLUS_TOKEN  \ -e WECHATY_HOSTIE_PORT= $WECHATY_HOSTIE_PORT  \ -e WECHATY_TOKEN= $WECHATY_PUPPET_PADPLUS_TOKEN  \ -p  $WECHATY_HOSTIE_PORT:$WECHATY_HOSTIE_PORT  \ wechaty/wechaty经过这一番操作，你的padplus token就可以当成hostie来用了。一开始看官方文档并没有找到，搞了很久才发现在issue里面有提到这个用法，所以在这里写出来方便后面的人。同理，python和go的版本也是这么弄。 核心代码: 因为用了SpringBoot，所以比较好的办法是把它交给Spring管理，构造成一个Bean。 @Configurationopen class AppConfig {  private val log: Logger = LoggerFactory. getLogger(this. javaClass)  @Value( \${wechat-bot. token} )  private lateinit var wechatyToken: String  @Bean  open fun wechaty(): Wechaty {    val bot = Wechaty. instance(wechatyToken)    with(bot) {      onScan(object : ScanListener {        override fun handler(qrcode: String?, statusScanStatus: ScanStatus, data: String?) {          println(qrcode?. let { QrcodeUtils. getQr(it) })          val url =  https://wechaty. js. org/qrcode/$qrcode           log. info( Online Image: $url )          ServerChanUtil. push( 微信机器人又挂掉啦~ , url)        }      })      onMessage(object : MessageListener {        override fun handler(message: Message) {          val from = message. from()          val room = message. room()          val text = message. text()          val result = CommandUtil. execute(text)          room?. say(result) ?: from!!. say(result)        }      })      onLogin(object : LoginListener {        override fun handler(self: ContactSelf) {          ServerChanUtil. push( 登录成功~ )        }      })      start(false)    }    return bot  }}命令行工具类 object CommandUtil {  fun execute(command: String): String {    return try {      val process = Runtime. getRuntime(). exec(command);      if (!process. waitFor(5, TimeUnit. SECONDS)) {        process. destroy()        return  出错，调用超时或因为调用了交互命令       }      val input = BufferedReader(InputStreamReader(process. inputStream))      var line: String?      var result =         while (input. readLine(). also { line = it } != null) {        result += line +  \n       }      input. close()      if (result. isBlank()) result =  没有任何输出       result    } catch (e: IOException) {      e. message!! +  \nusage: command [args]     }  }}额外的事情: 添加了Server酱的接口，在微信掉线以后会通过微信公众号发送二维码url，登录成功以后也会有通知。 部署: 1. 自行编译: git clone https://github. com/suninsky/wechat-bot. git修改application. properties参数 server. port=8090wechat-bot. token=YOUR_TOKENserver-chan. token=YOUR_TOKEN第一个是运行端口，可默认。第二个是wechaty-hostie的token，必选。第三个是server-chan的token，可选。 2.  直接使用target中的jar包: java -jar wechat-bot-1. 0. jar --wechat-bot. token=YOUR_TOKEN --server-chan. token=YOUR_TOKEN使用: 扫码登录机器人以后，即可。群聊和私聊都可以操控shell，所以机器人需要谨慎加好友和群。考虑到安全问题，目前只能操作wechat-bot-1. 0. jar所在的目录。以及，不支持交互式的命令。如果不小心输入了交互式的命令，将在5秒后返回。 例子: "
    }, {
    "id": 236,
    "url": "https://wechaty.js.org/2020/08/20/go-wechaty-github-action-optimization-mid-term/",
    "title": "暑期2020 [Go-wechaty Github Action optimization] POC 成果展示",
    "body": "2020/08/20 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。 官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html 本项目 [Go-wechaty Github Action optimization] 系 暑期2020 支持的开源项目。wechaty-words-per-day-plugin-mid-term 项目信息:  导师：丁小雨   学生：唐光彬   项目名称：Go-wechaty Github Action optimization 方案描述：使用 Github Actions 相关特性为 Go-wechaty 相关项目作相关优化，提高用户体验。 时间规划：8月20 - 9月5日，将相关代码落实到 Go-wechaty 项目中项目进度:  已完成工作：     自动更新 go-wechaty-getting-started 依赖到最新版本   完成 win 平台下 ding-dong 编译测试   完成 ding-dong 的 docker 并推送到 Github Packages      遇到的问题及解决方案：自动化流程使得软件构建、测试、发布等操作更为便捷，提升了相关效率，也使得开源项目的维护更加容易。   在完成第一个核心目标时，考虑到更新go. mod时，其中的依赖不仅仅有go-wechaty相关包，后续的 examples 中可能加入其他示例，有其他依赖的加入，故而不直接使用go get -u仅对go-wechaty进行相关更新。而用了一个笨方法，在 Action 中的项目文件中，将go. mod备份，再使用go mod init github. com/wechaty/go-wechaty-getting-started再注册一次，再使用go mod tidy更新。之后对比新旧go. mod，如果两者不一致则向提交一个 Pull-Request，更新依赖。   在完善 Dockerfile 相关测试时，其中 golang 依赖下载需要的网络环境不支持，故而将 ENV 中的 goproxy 设置成了goproxy. io。且在测试时，测试用的 TOKEN 无法使用，通过自己搭建服务解决了。     后续工作安排：      8月15日~9月5日：完善内容，提交项目代码，确保原项目中代码能顺利触发。   相关地址:  go-wechaty 测试 go-wechaty-getting-started 测试 Docker Image视频报告:   联系我们:  项目链接：https://github. com/Nebell/go-wechaty-getting-started 联系方式：tang. packet@outlook. com"
    }, {
    "id": 237,
    "url": "https://wechaty.js.org/2020/08/19/wechaty-zizz-gcaufy/",
    "title": "阿兹纳莫曲线",
    "body": "2020/08/19 -   这个是 阿兹纳莫曲线— @Gcaufy, Creator of WePY, Wechaty Committer.  @陈汉森: 这个波形有特殊含义吗？@xajeyu: 机器人。滋滋滋@Huan: Zizz…zzz!@Gcaufy: 这个是 阿兹纳莫曲线 "
    }, {
    "id": 238,
    "url": "https://wechaty.js.org/2020/08/19/wechaty-puppet-lark-mid-term-blog/",
    "title": "基于开放 API 封装 Wechaty 接口下的飞书聊天机器人：期中",
    "body": "2020/08/19 - “开源软件供应链点亮计划-暑期2020”（以下简称暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [基于开放 API 封装 Wechaty 接口下的飞书聊天机器人] 系 暑期2020 支持的开源项目。 [基于开放 API 封装 Wechaty 接口下的飞书聊天机器人]信息:  导师：高原 吴京京   学生：范蕊   项目名称：基于开放 API 封装 Wechaty 接口下的飞书聊天机器人 方案描述：     通过飞书订阅消息事件读取消息   通过飞书订阅通讯录事件实时更新通讯录内成员信息   对接飞书接口，实现 puppet 上各个类型的消息接口   设计配置参数   撰写飞书 puppet 的使用文档    时间规划     熟悉技术栈         7. 1-7. 20     阅读Wechaty-puppet-plus源代码，学习TypeScript，熟悉飞书服务端API          与飞书建立连接         7. 20-7. 31     通过Express与飞书建立连接，实现文本信息的收发（即ding-dong-bot机器人）          完成文本信息的收发puppet         8. 1-8. 5     将文本信息的收发结合到lark-puppet中     搭建项目基础框架          完成其他基础消息类型的收发         8. 6-8. 20     完成其他消息类型的收发，包括：图片、视频、文件          完成消息卡片的收发         8. 21-8. 30     通过消息卡片与用户建立多次交互式通信          设置配置参数         8. 31-9. 7          代码重构         9. 8-9. 20          撰写使用文档         9. 21-9. 30          项目进度:  已完成工作     搭建了代码基础框架，与飞书端建立了连接通路，完成了URL验证、鉴权等基础功能函数的封装   完成文本消息和图片消息的收发puppet，现在可以通过wechaty-lark来编写消息收发机器人   完成文件消息的接收，现在可以将收到的文件保存到本地   完成了企业通讯列表、部门列表的获取（尚未封装到puppet中）    遇到的问题及解决方案     使用Ngrox进行内网穿透时，每次重启子域名都会发生变化，在老师的建议和指导下最终采用localtunnel解决了这一问题。   由于对TypeScript和HTTP请求的理解不太透彻，遇到了一些消息格式上的问题，通过查阅资料、学习其他同学的代码等解决了这些问题。      后续工作安排目前在项目细节上有一些疑惑，如获取到的文件如何存储/处理等，在完成本周的任务后将针对这些细节和导师进行沟通，整体时间安排不变。   项目成果：     中期汇报 视频:     Demo 视频: 联系我们:    项目链接：https://github. com/Roxanne718/wechaty-puppet-lark                 联系方式：+86 17822015718     email: 953299708@qq. com          "
    }, {
    "id": 239,
    "url": "https://wechaty.js.org/2020/08/19/puppet-work-plan/",
    "title": "暑期2020 基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人 计划书",
    "body": "2020/08/19 - 本项目计划针对企业微信平台开发一个puppet，让 Wechaty 开发者可以仅仅通过改变一个变量，就能够切换使用企业微信的功能。 暑期2020 基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人 计划书: 暑期2020: “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人] 系 暑期2020 支持的开源项目。 [基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人]具体计划:  导师：高原 学生：谢昱清 模块列表     设计配置参数   接入企业微信会话存档接口读取消息         实现 puppet 上各个类型的消息接口     定时读取消息，并在读取消息之后触发消息事件     企业微信会话存档 puppet 的使用文档           计划安排：     准备工作         2020. 7. 1 - 2020. 7. 19             掌握相关技术栈（typescript等），了解puppet构造。       与企业微信建立连接，完成node. js到企业微信的信息通路                2020. 7. 20 - 2020. 8. 5             包括对话的加密解密，相关环境配置，node. js与微信SDK的交互。完成node. js进行企业微信消息拉取的demo。       注：原计划于2020. 7. 26完成，但是由于对预期成果理解有误，进展方向出现了偏差，延期一星期。       实现 puppet 上各个类型的消息接口                2020. 8. 6 - 2020. 8. 30             正式开发puppet。完成状态函数，消息的读取及消息的存储等内容。可能需要拓展原本puppet的数据结构。其中第一周完成逻辑设计及基本的消息拉取。       注：企业微信puppet仅负责拉取消息，不必完成完整的交互过程，因此可能需要单独设计对应的bot进行测试。       定时读取消息，并在读取消息之后触发消息事件                2020. 8. 31 - 2020. 9. 13             完成企业微信puppet的所有所需功能，进行收尾工作。       企业微信会话存档 puppet 的使用文档                2020. 9. 14 - 2020. 9. 20             在原有的文档上，增加企业微信puppet相关的内容。                      项目链接：https://github. com/Sapio-S/wechaty-puppet-official/ 联系方式：1205402283@mail. qq. com"
    }, {
    "id": 240,
    "url": "https://wechaty.js.org/2020/08/19/puppet-work-midterm/",
    "title": "暑期2020 [基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人] POC 成果展示",
    "body": "2020/08/19 - 本项目计划针对企业微信平台开发一个puppet，让 Wechaty 开发者可以仅仅通过改变一个变量，就能够切换使用企业微信的功能。 暑期2020 [基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人] POC 成果展示: 暑期2020: “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人] 系 暑期2020 支持的开源项目。 [基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人]信息:  导师：高原   学生：谢昱清   项目名称：基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人 方案描述： 时间规划：     准备工作         2020. 7. 1 - 2020. 7. 19             掌握相关技术栈（typescript等），了解puppet构造。       与企业微信建立连接，完成node. js到企业微信的信息通路                2020. 7. 20 - 2020. 8. 5             包括对话的加密解密，相关环境配置，node. js与微信SDK的交互。完成node. js进行企业微信消息拉取的demo。       注：原计划于2020. 7. 26完成，但是由于对预期成果理解有误，进展方向出现了偏差，延期一星期。       实现 puppet 上各个类型的消息接口                2020. 8. 6 - 2020. 8. 30             正式开发puppet。完成状态函数，消息的读取及消息的存储等内容。可能需要拓展原本puppet的数据结构。其中第一周完成逻辑设计及基本的消息拉取。       注：企业微信puppet仅负责拉取消息，不必完成完整的交互过程，因此可能需要单独设计对应的bot进行测试。       定时读取消息，并在读取消息之后触发消息事件                2020. 8. 31 - 2020. 9. 13             完成企业微信puppet的所有所需功能，进行收尾工作。       企业微信会话存档 puppet 的使用文档                2020. 9. 14 - 2020. 9. 20             在原有的文档上，增加企业微信puppet相关的内容。                     项目进度:  已完成工作：     运用企业微信提供的API接口完成了消息的加密解密以及跨语言的信息传递；   完成了基本消息类型（text，markdown等文本信息）的封装；   简单配置了参数及内部逻辑，可以定时拉取形成“即时沟通”的效果；   完成了基础功能的demo。    遇到的问题及解决方案：     对项目需求不明确，前期缺乏和导师的有效沟通，导致有一两周的进展与目标方向无关，成为了无用功。后期应当积极与导师沟通，尽快解决存疑的问题，避免出现类似的情况。   使用全新技术栈，除了需要花费较多时间入门外，在配置环境等方面出现了大量问题，有些甚至在网络上都无法搜索到解决方式。例如安装node-ffi时遇到的几个少见的安装bug：         编译时没有binding. cc这个文件，需要自己建一个空文件；     node和npm需要降级，否则无法成功安装编译ffi/ref；     如果用C++编译ffi的example（factorial. c），需要更改宏结构，否则会报“Error: Dynamic Symbol Retrieval Error: Win32 error 127”。           后续工作安排：目前对于项目结构和项目需求已经较为明确，可以加快开发的进度。由于在撰写时间规划时，对于项目的要求有一些误解，因此后期工作安排进行了调整。     8. 17-8. 23         引入manager，对puppet内部功能解耦合；     完成企业微信“获取媒体文件”的功能封装；     改善数据存储方式，可能将引入缓存。          8. 24-8. 30         完成企业微信中图片、语音、视频等媒体消息格式的封装。          8. 31-9. 06         完成企业微信“所有消息格式”列表中所有格式的封装；（由于种类较wechaty定义的多，因此可能需要修改部分消息的存储格式）     视情况完成企业微信“外部联系人”等消息的获取。（应当是无法直接拉取到的）          9. 07-9. 13         完成puppet中剩余函数的处理；     视情况完成企业微信“获取会话同意情况”、“开启成员列表”等功能的封装。          9. 14-9. 20         打包发布npm包，撰写使用文档。          9. 21-9. 27         完善项目功能，撰写最终报告。          联系我们:  项目链接：https://github. com/Sapio-S/wechaty-puppet-official/ 联系方式：1205402283@mail. qq. com Author: @Sapio-S Learning &amp; practicing. Code: @code "
    }, {
    "id": 241,
    "url": "https://wechaty.js.org/2020/08/19/go-wechaty-plugin-poc/",
    "title": "暑期2020 [为 go-wechaty 设计实现插件体系] POC 成果展示",
    "body": "2020/08/19 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [为 go-wechaty 设计实现插件体系] 系 暑期2020 支持的开源项目。 [为 go-wechaty 设计实现插件体系]信息:  导师：丁小雨、丁超飞、李博杰 学生：林昊翰 项目名称：为 go-wechaty 设计实现插件体系方案描述: wechaty 是一款支持多协议的微信接入方案，随着社区多语言生态的建立，吸引了更多的开发者和爱好者的加入；同时需求的推动和技术的发展，插件系统逐渐完善，但是在多语言系统中 Plugin 体系尚未完成，我们希望通过这个任务，能够让更多的人加入 go-wechaty 的建设。 目前 go-wechaty examples/ding-dong-bot. go 有一个 ding-dong bot, 但是我们希望这个 ding-dong 是通用的，如果我们的 Plugin 体系能编写出来，也许实现 ding-dong 就只需要一行代码。例如： bot. Use(DingDong{})go-wechaty 是 Go 语言实现 wechaty 的项目，同样支持多协议接入；同时借助 gorountine 和 channel 的语言特性，实现了更加合理的封装和设计。 时间规划: 第一阶段(至8月15日) 编写插件机制设计文档。其中，文档包含设计思路，实现逻辑，以及涉及到项目的变更等。根据 Go 语言特性，对插件机制的设计进行改进，并且尝试思考更多可能的方案。如果有需要，还应该编写相应的试验代码。 第二阶段(至9月30日) 根据第一阶段的设计文档编写代码，实现 go-wechaty 的插件机制；使用 go-wechaty 插件机制编写一个插件 Demo。 项目进度: 每周开发进度报告：为 go-wechaty 设计实现 插件体系 · Issue #9 · wechaty/summer-of-code 在每周的进度报告中，能看到我开发项目的详细过程以及进展。 项目相关的代码仓库：  插件机制开发分支 FINCTIVE/go-wechaty 插件示例代码仓库 FINCTIVE/wechaty-demo-plugin已完成工作:  目前已经进行了 go-wechaty 插件机制的初步设计，并且编写了相关文档。现在的插件设计仍需要继续改进迭代。 原定第二阶段开始编写代码，但为了表述清晰、试验可行性，我已经编写实现了已有设计的代码。根据原定方案和时间规划，我认为我有完成度不足的方面，也有超前的方面；总体来说是合格的。 遇到的问题及解决方案:  参与开源软件供应链点亮计划遇到的第一个问题是：如何参与开源社区、为开源社区做贡献？这是一个“从0到1”的问题。我在大学的前两年时间里并没有参与过大项目的开发，更别提要求较高的开源项目。开源项目的远程协作开发对我来说有极大吸引力，但我一直没有一个合适的机会参与其中（水平不足、不知道如何参与等情况让我屡次放弃跨出第一步）。本届开源软件供应链点亮计划正好提供了这次机会，让我参与到 Wechaty 社区中进行项目开发。Wechaty 社区是一个包容度很高的社区，社区内的导师们对学生提出的问题都会耐心解答。这次活动的经历增加了我参与开源软件开发的经验，同时争强了我的沟通交流能力。在以后的开发历程中，我会为继续为开源社区贡献代码。  在开发过程中，Go 程序设计对我来说有一定难度。我的解决方案主要是自己学习、查阅资料。对于部分问题，社区里的导师们给了我很大帮助。 后续工作安排: 按照原定计划继续开发、迭代。 导师评审结果:  项目完成度：已完成大部分编码工作，期待合入主干和收尾工作。 学生参与度：完成了 90% 的设计工作，和 100% 的编码工作；能够积极参与相关任务。 代码贡献量：在导师的指导下，独立完成多语言项目Go-Wechaty Plugin设计和编码工作。 综合评价及建议：     评价：昊翰在项目过程中计划清晰，每周进度报告都有相应的成果和进度；前期准备了初期的设计文档，并根据文档进行相关代码实现；在实现中发现了前期设计的不足与偏差，能够在导师的沟通和学习中，完成优化。   建议：社区具有很高的包容和自由，你可以随意的提交代码请求到主干，只有能够达到一定的完整度就会被合入主干，如果没有达到，也可以得到其他贡献者的帮助；还有些合入主干的工作尚未完成，期待你的成果。    最终评审结果：通过联系我们:  项目链接：wechaty/go-wechaty 联系方式：finctive@foxmail. com"
    }, {
    "id": 242,
    "url": "https://wechaty.js.org/2020/08/18/wechaty-for-new-student/",
    "title": "一个简单的微信群组「关键字」回答机器人",
    "body": "2020/08/18 - 基于 wechaty （包含 wechaty-puppet-padplus 插件）开发。 使用 Mongodb 存储问题 / 答案 / 群组消息。 背景: 大学新生开学（又到了每一年忙碌的时候），同一个（类似）问题会有很多人问，那为啥不把这些问题整理一下。 如果有一个问答库，通过输入关键字让机器人发送答案，减少人工不必要的问答，提高效率。 功能:  # 字符触发特殊命令 关键字回复问题安装: ```shell scriptgit clone https://github. com/m4d3bug/wechat-bot. gitcd wechat-botnpm install ## 使用```shell scriptcd wechat-botnode index. js项目结构: shell script$ tree. ├ README. md├ config│  ├ BotConfig. js│  ├ BotConfig. js. backup│  └ MongoConfig. js├ deploy│  └ deploy. sh├ domain│  ├ Message. js│  └ Question. js├ index. js├ package-lock. json├ package. json├ service│  ├ MessageService. js│  └ QuestionService. js├ test└ utils  └ StrUtils. js       File   Description         BotConfig. js   Bot 相关配置       MongoConfig. js   MongoDB 相关配置       deploy. sh   部署脚本，简单粗暴采用 pm2       Message. js   Message ORM       Question. js   Question ORM       MessageService. js   Message save       QuestionService. js   Question query       StringUtils. js   Handler string   参考文档:  https://wechaty. js. org/docs/致谢: 🙏感谢wechaty团队提供微信机器人SDK🙏感谢句子互动提供的iPad协议版token "
    }, {
    "id": 243,
    "url": "https://wechaty.js.org/2020/08/17/java-wechaty-transplant-midpoc/",
    "title": "Wechaty Java 移植组件开发",
    "body": "2020/08/17 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [Wechaty Java组件移植] 系 暑期2020 支持的开源项目。 暑期2020 [Wechaty Java组件移植] POC 成果展示: [Wechaty Java组件移植]信息:    导师：刁政欣     学生：陈炀     项目名称：Wechaty     方案描述：用java或者kotlin将typescript版的wechaty移植到java/kotlin平台上     时间规划：   memory-card存储      7. 1 - 7. 19   该模块移植是项目的基本要求,为了能够满足机器人重新登陆不需要扫码,保存机器人自身信息等功能,需要用到这个组件,这个组件将存储的功能和存储数据的结构相分离,以便能够简单的更换存储方式,支持阿里云oss,华为云obs,亚马逊s3,json存储等,同时提供了易用的api来使用   基本功能    state-switch状态机      7. 20 - 7. 26   state-switch是用于管理异步操作的监视器/保护器,在原本的ts版本中可以通过Promise的特性来比较轻松的实现,在kotlin则需要其他的api来实现,思路 比较清晰,但是要找到合适的实现手段有点麻烦   基本功能    (选做) 其他api移植与测试      7. 27 - 8. 7   java-wechaty中还有许多api没有实现,api的风格也是仿照js来实现的,后续需要将这些api逐步实现,并且修改其api风格,以更适合java和kotlin等语言   扩展功能    (选做) 理解底层原理,添加一些新功能      8. 8-8. 15   此部分为选作内容,wechaty还有一些关于miniprogram,红包等功能还未实现,需要能够理解底层,以便进行后续的扩展,逐步增强wechaty的功能   扩展功能   项目进度:  已完成工作： 完成memory-card和states-witch组件的开发，由于其中一部分涉及到aws，而aws需要visa等银行卡才能注册，所以这个部分虽然编写了但是没有测试，但是我添加了一个阿里云的接口方便使用。 完成大部分typescript版api的移植，目前应该是几乎所有的ts版本的api都已经移植完毕，当然会有一些bug,并且在api的易用性上还没有达到很好的要求。 进行了一些现有api的测试，修复一些小bug，当然还有一些bug还没有修复,期待下一阶段开发.  遇到的问题及解决方案： 快速学习kotlin并了解程序架构和逻辑 虽然说是java移植开发，但根据导师的建议和整个项目的整体性，我还是选择用kotlin开发，但是我之前还没有写过kotlin，我必须立马花些时间来学习kotlin，对于高级特性和有可能会遇到的错误只能遇到了再说了。整个程序逻辑架构还是比较清晰的，虽然还是花了点时间来明白工作流程  java和kotlin中的异步支持 由于有了async和await以及Promise，js对于异步的支持是更好的，因此对于移植过程中的异步的操作，我们是需要仔细考虑的。当然由于用了kotlin，后续还可以尝试使用协程来进行编写。  协程的考虑 在编写state-switch的时候，对于ts版的理解花费了点时间，主要还是因为promise的理解不到位，当理解了工作原理之后，由于kotlin中没有类似的api可以解决，因此花了点时间探索，最后在导师的建议之下，以及考虑到是用kotlin编写的，可以使用协程，暂时决定采用协程加上阻塞队列来实现，目前看来好像实现了效果。 这个协程还是蛮有意思的，kotlin的协程感觉有些地方还是很难理解的。 心得体会：在整个项目的后半段由于我这边出现了一点问题，导致拖慢了进度，好在是任务的难度没有很大，导师人也很好。最终不论有没有通过考核，这份参与开源项目的经历，都是值得回味的。  移植这东西我感觉蛮有意思的 不同的编程语言，有不同的思维方式的碰撞，花几天的时间快速学一门语言并进行实践也是蛮有意思的一件事情，整个移植虽然最主要的考虑到是功能的移植，但是还是要注意api的易用性，ts和java的api的风格还是有不少区别的。  github的开发流程简单体验 用github的参与到开源社区中是一次很有意思的体验，虽然之前有在同一个小组进行github上的合作，但是流程还是不一样，还有github的CI/CD流程我也是第一次体会到，对于开源社区的会议讨论我也是第一次体会到。  高质量的单元测试 说实话我还是不太懂得怎么写出高质量的单元测试，后续要继续学习。  后续工作安排：从目前的进度来看，还是有一些东西需要完成的  写一个springboot starter方便springboot项目进行集成，里面应该会有存储的配置以及token的配置 将memory-card组件进行拆分（不拆分感觉也行） 继续完善api测试，我试了一下有些api达不到想要的效果，比如tags接口就有问题 开发新的功能，现有的一些api还有一些未完成，还有一些功能没有实现 文档的更新和完善（最近好像是更新过文档了，但是还是有一些东西还没有完善)，好像是没有中文文档Demo Day视频: youtube地址为：https://www. youtube. com/watch?v=ipRq3kT32wI  联系我们:  项目链接：https://github. com/cunkoulaocai/java-wechaty               联系方式：+86 15806082601     e: 1184016190@qq. com          "
    }, {
    "id": 244,
    "url": "https://wechaty.js.org/2020/08/17/java-wechaty-bot/",
    "title": "SpringBoot搭建wechaty智能聊天机器",
    "body": "2020/08/17 -  本项目是基础wechaty项目实现微信的聊天功能、通过微信对话开放平台提供的API进行智能的应答、实现了微信的智能聊天、最后非常感谢wechaty的无私奉献。 智能机器人功能:  高级转人工 周边生活服务 聊聊电影 讲笑话 成语接龙 天气查询 AI时光机 心里年龄测试 中英互译功能微信机器人头像: 准备工作:  需要先准备一台token网关服务器 跟wechaty人员申请token 微信对话开放平台 申请一个机器人、学习技能、获取TOKEN项目信息:  项目地址项目成果:  待完善功能:  TODO 根据群里的每个人回答对象@响应对应的群友项目研究血泪史:  本人英语不是很好，对于一个都是英文文档的项目看的简直是头疼、但是还是能看的懂一点点、我们从wechaty项目中得知,我们用到ipad协议的话，需要一个token、然后找到了客户拿到了token。 客服发的材料:  puppet_padplus_xxxxx 有效期2020-08-25 请务必反复阅读我们的Wiki，Wechaty 的 API 中英文文档、各个项目链接、多个协议的使用说明、Web协议不能使用情况下如何申请其他协议Token等内容均在其中：https://github. com/juzibot/Welcome/wiki/Everything-about-Wechaty API文档：https://wechaty. js. org/api Padplus Token 进行多语言开发指南https://github. com/wechaty/wechaty/issues/1985 我看到多语言版本有JAVA版本，马上就下载下来试一下能不能运行。没有详细看后面的文档、这导致我把JAVA版本Demo下载下来一直运行不起来、后面仔细看了文档之后才知道需要部署一个网关服务、而且要在公网的服务器上面、希望后面的开发不要走我这个弯路、好好查看文档。 "
    }, {
    "id": 245,
    "url": "https://wechaty.js.org/2020/08/15/wechaty-words-per-day-plugin-mid-term/",
    "title": "暑期2020 [编写一个“每日一句”插件] POC 成果展示",
    "body": "2020/08/15 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。 官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html 本项目 [编写一个“每日一句”插件] 系 暑期2020 支持的开源项目。  Github Repo: Github [编写一个“每日一句”插件]信息:  导师：Gcaufy   学生：江姗姗     项目名称：编写一个“每日一句”插件   方案描述：     制作可以被wechaty调用的插件，能够使用用户自定义的每日一句语料   插件能够构造POST和GET请求，设置请求参数，并根据指定的解析规则解析返回的json格式或者html格式的内容   插件可以根据请求结构中的图片地址下载图片，并根据每日一句内容以及微信群的相关信息添加水印   插件能够设置定时发送的时间、群名、发送的内容   根据群名推荐每日一句的发送内容（候选）   能够调用该插件使用自定义的api接口（候选）    时间规划：     开发插件的基本框架         7/1 - 7/21     插件的输入参数有：使用的内置API接口名称、应用的群聊名称以及发布每日一句内容的时间，完成基本代码构建。插件能够设置定时发送的时间、群名、发送的内容，也可以根据请求结构中的图片地址下载图片，并根据每日一句内容以及微信群的相关信息添加水印。          发布NPM包，引入CI/CD         7/22 - 8/14     进一步优化代码以及注释，引入CI/CD来进行代码质量控制以及包的版本管理          丰富语料库         8/15 - 9/07     首先确定使用的API接口或者爬取的网址，根据不同的网址进行不同的解析，返回指定的结果。构造请求并解析内容，返回需要的字符串（每日一句的内容或者图片的URL）。如有余力的话，能够支持用户自主设定语料的来源。          进行测试完善项目文档         9/07 - 10/01     完善项目文档，撰写整个项目过程的总结文章;增加单元测试等;计划延迟的缓冲时间          项目进度:  已完成工作：     07/01 - 07/18         完成了插件的基本框架     实现了往指定群聊定时发送消息、根据关键词生成打卡图片的基本功能          07/19 - 07/26         发布成NPM包，使用github action进行自动构建和版本更新     优化项目结构     统一注释风格为JSdoc     优化代码          07/27 - 08/02         支持用户使用3种方式(jsonpath选择器、css选择器以及正则表达式)以及固定的网址自定义数据源     生成的图片输出为base64字符串     使用try…catch来进行await, promise 的异常捕捉          08/03 - 08/15         进一步抽象数据抓取模块，支持使用用户自定义的数据抓取函数。能够解析每日一句信息中的图片信息，并以图片的形式发送。             遇到的问题及解决方案：      在编写这个插件的过程中，有很多需要等待一定时间来完成的步骤，比如图片的下载保存等，这些过程是异步执行的，如果想在这个过程结束后进行下一个过程使用它的结果，可以使用回调函数，但是可读性比较差，因此最终改用Promise以及Async/Await进行处理。   图像处理使用了npm的gm包，相关文档不够详细因此在处理图像的过程中花费较多时间达到想要的效果。    后续工作安排：     完善项目文档   撰写项目的测试代码   撰写整个项目过程的总结文章   完善差错处理模块   联系我们:  项目链接：https://github. com/univerone/words-per-day 联系方式：univeroneie(at)outlook. comWechaty Demo Day 视频: PPT展示视频:  PPT:  Live Code视频:  "
    }, {
    "id": 246,
    "url": "https://wechaty.js.org/2020/08/14/python-wechaty-groupchat-assistant-bot-poc/",
    "title": "暑期2020 [基于python-wechaty的群聊助手机器人] POC 成果展示",
    "body": "2020/08/14 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [项目名称] 系 暑期2020 支持的开源项目。 Code: @kxz18/python-wechaty-groupchat-bot [基于python-wechaty的群聊助手机器人]信息:    导师：吴京京     学生：孔祥哲     项目名称：基于python-wechaty的群聊助手机器人     方案描述：   本项目需要基于python-wechaty实现一个群聊助手机器人。该机器人主要由四个插件组成。第一个插件是群聊消息打标插件，通过群成员引用重要消息回复机器人的方式记录重要信息，以便之后以问答的方式进行查找。在基本功能开发完成之后将用深度学习的方法优化问答的容错性，从而提升交互水平。第二个插件是定时消息插件，用于定时消息的发放。第三个插件是群成员的管理插件，当有新人进群时进行欢迎，当一定人数群成员对某位群成员言行表示不适时自动从群聊中删除该位群成员。第四个插件用于提升交互，为帮助系统插件，提供自定义的功能文档，辅助前三个插件工作。四个插件中第一个插件是项目的基本要求。   项目主要分为四个阶段进行。第一阶段是基本功能的实现，也就是群聊消息打标插件的实现。第二阶段是扩展功能的实现，主要实现定时消息插件和群成员的管理插件。第三阶段优化交互性能，实现帮助系统插件，利用深度学习对消息打标插件的问答系统进行优化。最后是选做阶段，在项目计划完成后如果还有时间，进行rasa聊天机器人api的对接，丰富插件功能。     时间规划:      群聊消息打标插件         7. 1 - 7. 19     该模块为本项目的基本要求，需要实现通过引用消息进行回复对重要的群聊消息进行打标，并存入本地的数据库。在对应问题被提出时机器人能通过搜索存储的打标消息给出相应的回答，如果匹配的答案置信度不高，则提供可能的关键词向用户进行确认。同时支持展示全部或一定时间段内的打标消息，用户可以对其中的消息进行手动删除或定时删除，打标消息本身也可以提供有效期参数，在过了有效期后自动删除。后期提供帮助系统，用户可随时查看不同功能的帮助信息。          基本功能   定时消息插件         7. 20 - 7. 26     用户指定消息内容和发送时间，由机器人定时发出消息。     扩展功能          群成员管理插件         7. 27 - 8. 2     进行踢人和进群欢迎的管理，踢人要求3位以上群成员对某人表示不满（群成员总共只有3人以下或4人时分别需要1人和2人表示不满）。此插件需要机器人拥有相关的权限。     扩展功能          对前几个模块的交互方面进行提升         8. 3 - 8. 23     对交互方面进行统一优化，提高解析用户命令时的容错性，目前已有的想法是尝试用深度学习方法对问答系统的匹配准确性进行提升（在基础版本中使用 cosine 相似度对问题和答案进行匹配）、在用户命令解析失败但和某些模式很相近时进行确认等。同时该过程中会不断模拟用户场景发现机器人在交互上不够人性化的地方并进行修正。     扩展功能          （选做）rasa chat bot 插件         8. 24 - 8. 31     接入rasa chat bot 的API，此为选做内容，如果在以上内容都完成且仍有较充裕的时间的情况下，可以考虑尝试进行制作。     选做内容          项目进度:    已完成工作：目前已经完成四个插件的开发以及对应的单元测试。即项目的前两个阶段已经完成，第三阶段完成一部分，正在进行中。   目前已经制作了presentation对项目的功能和结构做简单讲解:   对已经实现的功能也进行了live coding演示，演示内容见：     遇到的问题及解决方案：   在开发过程中主要遇到的是两类问题，一类是技术问题，另一类是对软件架构的选择。   技术方面的问题主要在于对第三方库不熟悉。例如在开发过程中对python-wechaty接口不熟悉，无法快速准确拿到想要的信息，以及使用apscheduler时不知如何用async的函数作为回调函数。由于python-wechaty目前还处于开发阶段，文档还不完善，因此遇到问题主要直接参考github上的代码，沿着相关的类和函数向上追溯看代码解决问题，实在解决不了或者无法确定解决方法是否正确的会直接向导师咨询。而像apscheduler这类第三方库有较为完善的文档，因此直接从文档中寻求答案。也有一些多线程方面的问题，例如因修改数据库后一直保留与数据库的连接而产生的多线程访问问题（把与数据库的连接从主线程传到了子线程中），这类就会直接上网搜索比较模板的写法来解决。还有一个问题是接入微信进行测试需要一个微信号，刚开始进行测试的时候总是容易被腾讯封锁，在与导师交流后养了很久的帐号（模拟人类行为），最后才能用来挂机器人测试。   而在软件架构选择方面，由于自己软件架构的经验不多，所以会先以自己已有的知识设计一些架构，然后和导师交流这样的架构是否合理，请他给出一些建议。对于一些比较常见的架构问题，我也会自己搜索一下传统的架构模式进行模仿。   总的来说，问题大多都是可以解决的，一般从文档、github issue、代码本身、各类论坛和博客中总能找到解决方法。同时也要多和导师交流，导师的经验比较丰富，对很多问题都能给出比较高效的解答，多和导师交流不仅能把问题解决，也能学到很多新的东西。     后续工作安排：后续工作在路线上与之前计划的一致，同时由于前面的任务完成日期比预期提早，因此整体计划可以前移。  联系我们:  项目链接：https://github. com/kxz18/python-wechaty-groupchat-bot               联系方式：+86 15068701650     e: 15068701650@163. com          导师评审: 评审对象:  评审内容：中期报告 提交人：孔祥哲评审结果:  项目完成度：孔祥哲根据原定项目需求，迅速完成大部分功能，切代码质量非常好。期间与我保持着密切的联系，主动咨询问题，解决项目中的各种难题。目前项目已进入尾声，剩下项目的附加扩展功能开发以及部分代码测试的工作。 学生参与度：孔祥哲同学自项目开始之期就开始高效率的开发，每天都有足够的代码提交量，积极完成项目功能，且能够精准的剖析出项目中存在的各种问题，基本上全程都由该同学在主导，我只是来解决他所提出的问题。 代码贡献量：该同学承担着该项目的主要工作，包括需求深度分析，模块开发和扩展模块的讨论，我主要承担着一个指导的作用，解决该同学提出的部分问题。 综合评价及建议：该同学的编程能力，对业务的分析能力都非常好，期间能够快速精准的发现主要问题，加快项目的开发速度，是一个十分优秀的实践者。由于该学生在过程中表现出的高效率，暂无其他建议，希望该同学能够继续按照自己的兴趣，继续学习，期待你以后的高光时刻。 最终评审结果：“通过”"
    }, {
    "id": 247,
    "url": "https://wechaty.js.org/2020/08/13/python-wechaty-meme-bot-mid-term/",
    "title": "基于Python-wechaty建立一个斗图机器人 POC 成果展示",
    "body": "2020/08/13 - 暑期2020 基于Python-wechaty建立一个斗图机器人 POC 成果展示: “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 基于Python-wechaty建立一个斗图机器人 系 暑期2020 支持的开源项目。 [基于Python-wechaty建立一个斗图机器人]信息:    导师：黄纯洪     学生：肖子霖     项目名称：基于Python-wechaty建立一个斗图机器人     方案描述：利用OCR、NLP等技术，提取出用户发送的表情包内容，并回复数据库中已有与之相关的表情；具体技术方案泳道图见下：     更多细节可参见项目README.     时间规划（摘自项目申请书）：      Week1：仔细阅读python-wechaty项目源码，掌握项目大体框架和可用API；   Week2：收集表情包数据，选择合适的网络模型。   Week3~Week4：训练模型，调试参数；   Week5：开发核心模块，编写单元测试；   Week6：开发、配置表情包插件后端；   Week7~Week8：模块联调，编写测试样例，上线测试。   项目进度:    已完成工作：      利用peewee搭建数据库ORM框架；   表情包爬取（BaseSpider）、收集框架   引入、调试OCR模块   调试Inception特征提取模型   复现Deep Cosine Metric Learning for Person Re-identification一文中有关Metric Learning部分，编写好相关训练、验证、测试模块   表情包导入模块   前端回复模块   后端回复逻辑   前端、后端、Wechaty联调，效果见Demo Live视频中演示   部署文档编写    项目申请书时间规划所提及任务中除训练模型外的任务基本完成；     遇到的问题及解决方案：      python-wechaty文档尚未完成，遇到疑惑时需要翻阅issue列表或者深入源码查看；   网络上没有关于将Metric Learning方法应用到表情包分类的先例，不确定Cosine Metric Learning能在表情包特征提取上起到较好效果，不过我认为勇于尝试是十分必要的！      后续工作安排：      对比传统图像分类模型Inception、Metric Learning模型CosineMetricNet的特征提取效果，为用户提供多种选择。   思考出性能优秀的cosine distance比较方法，为从数据库海量表情中提取出相似的表情提供便利。   中期PPT演示 &amp; Demo Live 视频链接: PPT演示： Bilibili: https://www. bilibili. com/video/BV1kZ4y1M7F6/ Youtube:  Demo Live视频： Bilibili: https://www. bilibili. com/video/BV17f4y197ut/ Youtube:  Reference: Open-Source Reference:  chineseocr_lite: Powerful Chinese OCR module with accurate results and fast inference speed.  HaNLP: Multilingual NLP library for researchers and companies, built on TensorFlow 2. 0. Academic Citation: # in backend/cosine_metric_net. py[1]N. Wojke and A. Bewley, “Deep Cosine Metric Learning for Person Re-identification,” in 2018 IEEE Winter Conference on Applications of Computer Vision (WACV), Lake Tahoe, NV, Mar. 2018, pp. 748–756, doi: 10. 1109/WACV. 2018. 00087. 联系我们:  项目链接：@python-wechaty-meme-bot 联系方式：me#mrxiao. net (# -&gt; @)导师评审:  评审内容：中期报告 提交人：肖子霖评审结果:  项目完成度：《基于Python-Wechaty建立一个斗图机器人》整个项目按照原定方案在实施。在项目实施过程中，以表情包的识别与回复为主线进行推进。项目从前期到中期考核，学生完成了对表情包的爬取、分类以及标注，对表情包的OCR识别，对识别结果的关键字提取，完成情况较好。 学生参与度：本项目的难点在于对表情包的识别以及回怼表情包，前期对表情包的爬取、分类和标注以及后期训练怼人模型的工作量均比较大。学生在此过程中也是克服困难，积极参与，认真完成项目相关工作。 代码贡献量：本项目的代码量实际上在于对表情包的处理代码以及模型的训练，也就是代码量实际上都在项目提及的后端平台上，即代码量较好。 综合评价及建议：总体来说项目完成情况不错，按照既定的规划稳定实施，项目功能模块也在逐步的完成。存在的问题如下：1、项目目前还未涉及到与“怼”相关的功能开发，后期有待完善；2、代码整体风格不是很好，所以看起来比较乱，希望后期能够改善；3、代码关键性地方缺少注释，有待改进。 最终评审结果：通过"
    }, {
    "id": 248,
    "url": "https://wechaty.js.org/2020/08/11/car-product-rcbot/",
    "title": "传统工业与信息化的结合",
    "body": "2020/08/11 - 现状与目标：我是谁？我要做什么？:  汽车配件行业 传统工业与信息化的结合 用户无需联系销售或者技术支持，即可快捷地获取产品信息     零延时：无需等待销售或者技术支持回复   信息更准确：不会出现销售或者技术支持回复错误的情况   信息更新：当信息更新时，仅需在服务器上进行数据更新，而无需推送同步到销售或者技术支持    公众号的入口过于繁琐，以期以群聊和私聊的方式为用户提供更便捷的服务业务：我的业务需求:  产品信息查询：根据客户提供的产品编码（国际通用产品编码 OR 自身产品编码），查询产品信息（参数？价格？位置？……） 产品编码查询：根据客户提供的汽车VIN码（文字 OR 图片），查询车辆信息（品牌？车型？排量？……）及适配产品的产品编码，并进一步查询产品信息 未来的其它功能……设计：我要如何实现它？:  前期手动完成的工作     添加用户为好友并拉入群聊    机器人     接收消息并检索关键字         如果是文字消息，在消息中检索汽车VIN码或者产品编码     如果是图片消息，进行OCR识别（通过百度AI的API），尝试提取汽车VIN码          根据关键字查询信息         如果是产品编码，根据产品编码查询产品信息（由于数据量不大，映射关系保存在本地的JSON文件中）     如果是汽车VIN码，根据VIN码查询车辆信息及适配产品的产品编码（通过网络请求接口），然后根据适配产品的产品编码查询产品信息（本地JSON文件）          将查询到的所有车辆信息+产品编码+产品信息发送出去（还可以@用户）   代码：目前的成果: 前期准备: 先导入所需的库，初始化日志模块 // 导入TS库import {Contact, Message, Wechaty} from 'wechaty'import {MessageType, ScanStatus} from 'wechaty-puppet'import {PuppetPadplus} from 'wechaty-puppet-padplus'import QrcodeTerminal from 'qrcode-terminal'// 导入JS库import fs from 'fs';let log4js = require('log4js');// 初始化日志库log4js. configure({  appenders: {    production: {      type: 'dateFile',      filename: 'log. txt'    }  },  categories: {    default: { appenders: [ 'production' ], level: 'debug' }  }});let logger = log4js. getLogger();从本地的JSON文件中解析产品编码到产品信息的映射: 通过同步方式读取文件 // 读取json文件，解析成映射字典let maps = JSON. parse(fs. readFileSync('20200719. json','utf-8'));// 文件初步示例// {//    D242 :  BFD0001，64mm，北京仓库 ,//    D302 :  BFD0002，70mm，上海仓库 // }创建机器人实例: 然后根据文档，创建机器人实例。这里的token和name由开发者自定义 // 固定参数const token = 'yourtoken';const name = 'rcbot';// 创建机器人实例const puppet = new PuppetPadplus({token, });// generate xxxx. memory-card. json and save login data for the next loginconst bot = new Wechaty({puppet, name, });编写登录、登出回调函数: 在账号登录、登出的时候可以调用回调函数，我这里仅仅做了日志记录 // 登录消息处理函数function onlogin(user: Contact){  logger. info(`用户：${user. name()}登陆成功`);}// 登出事件处理函数function onlogout(user: Contact, reason: string){  logger. info(`用户：${user. name()}登出成功，登出原因：${reason}`);}核心：接收消息的回调函数: 这里是核心部分，即提供业务功能的部分。 在判断收到的消息为文字消息之后，在消息中检索产品编码，如果检索到，则通过映射查询产品信息，发送出去 // 接收消息处理函数async function onmessage(msg: Message) {  // 如果是自己发出去的消息，直接返回  if (msg. self())    return 0;  // 如果收到别人发来的消息  const room = msg. room();  const from = msg. from();  const to = msg. to();  // 记录日志  if(room){  // 如果是群消息    const topic = await room. topic();  // 获取群名称    logger. info(`在群${topic}中，收到由${from?. name()}发来的消息：${msg. text()}`);  } else if (to){  // 如果不是群消息    logger. info(`私聊消息，收到由${from?. name()}发来的消息：${msg. text()}`);  }  // 判断消息类型  if(msg. type() === Message. Type. Text){  // 如果是文字消息    let msgu = msg. text(). toUpperCase();    let keyhit = '';    for (let key in maps) {      if (maps. hasOwnProperty(key)) {        if (msgu. includes(key)) {  // 如果匹配到key          // 如果该key以S或者D开头，且包含BF，则代表匹配上，则比较长度          if (((key[0] === 'B') || (!msgu. includes(`BF${key}`))) &amp;&amp; (keyhit. length &lt; key. length))            keyhit = key;        }      }    }    if(keyhit !== ''){      await sleep(1000);  // 休眠1S      logger. info(`回复消息：${maps[keyhit]}`);      await msg. say(maps[keyhit]);  // 回复消息    }  }}注册回调函数: 在回调函数写完之后，将回调函数注册到事件 // 注册处理函数// 扫描消息处理函数直接内置处理，因为存在类型指定问题bot. on('scan', (qrcode, status) =&gt; {  if (status === ScanStatus. Waiting) {    QrcodeTerminal. generate(qrcode, {      small: true    })  }}). on('login', onlogin). on('message', onmessage). on('logout', onlogout). start();根据目前的设计，未完成的功能:  图片OCR识别：接收图片消息，进行OCR识别（通过百度AI的API），尝试提取汽车VIN码 根据汽车VIN码查询车辆信息及适配产品的产品编码（通过网络请求接口）计划：未来的需求与开发计划:  模块化     拆分业务代码为多个模块，方便后期维护    代码性能优化：目前的检索算法效率较低，需要进行优化 功能     分群分业务：根据不同的群，提供不同的业务、信息或者数据   本地训练模型，进行OCR识别   未来的其它功能……   致谢: 感谢 Wechaty 提供的微信机器人SDK 感谢 句子互动 提供的ipad协议版token  作者: jiucl项目地址：rcbot "
    }, {
    "id": 249,
    "url": "https://wechaty.js.org/2020/08/09/wechaty-shenzhen-meetup/",
    "title": "Wechaty Contributor Meetup -- Shenzhen August 5",
    "body": "2020/08/09 - 8 月 5 日，周五晚上，大家按照约定时间到达吃饭地点，我与@lijiarui、@Gcaufy没有线下见过面，有一种见网友的感觉。好在很快就熟悉了。对于我来说意义非凡，非常荣幸，第一次接触 star 数那么多的项目作者，而且还是两位，好似追星族见了明星的感觉。  Wechaty 贡献者深圳聚餐 大概内容：  我是如何参与开发 go-wechaty 的，去年 2019 年逛 github 看到 wechaty，感到很有趣，想写一个群聊机器人，但是看到要用 ts, 要写一个机器人还要先学一下 ts, 我当时在学 go 语言，索性写一个 go 版本的，扒拉一下源码，申请了一个 padplus 的 token,就开工了，写了一个裸的 go 版本的 padplus-puppet，实现了登录，发消息，然后就没下文了。今年 2020 年再逛 github, 发现 wechaty 要多语言了，刚好有 go 的，就参与了开发 go-wechaty, 开发完后还用 go-wechaty 写了一个打卡提醒的机器人，这次是真的写了机器人了~~~。 问了一些 @Gcaufy 是怎么开发 wepy 的，是因为自己要用，所以就写了，然后就开源了，最后就这么火爆，好 cool。 @Gcaufy 和 @lijiarui 还讨论了旅游相关的，让我好生羡慕。 还聊了很多，也有很多以我现在的知识听不懂的，具体记不太清了… 感谢@lijiarui赠送亲笔签名书和 wechaty 贴纸,感谢@Gcaufy晚餐，期待下次再聚。 参与者介绍:@lijiarui: Full stack developer, serial entrepreneur, Founder &amp; CEO of JuziBot @Gcaufy: Author of WePY, a mini program fframework for Wechat. Tencent Engineer @dchaofei: Go/PHP Developer, the author of go-wechaty "
    }, {
    "id": 250,
    "url": "https://wechaty.js.org/2020/08/09/wechaty-log-monitor/",
    "title": "Chatbots二重奏：用wechaty-log-monitor插件实现「掉线给码」等DevOps",
    "body": "2020/08/09 - 最近基于Wechaty做的一个学中文小助手ARCHY开始营业了🤖🤖🍜～ 为了能让小助手可以有更棒的 readily availability，我写了这个wechaty-log-monitor插件来给在production跑的Wechaty做日志相关的devops。这是一个建立于两个chatbots的二重奏。 目前插件的主要功能是「掉线给码」：一个Wechaty掉线了，另一个Wechaty会发QR码给这个Wechaty的微信号来重新登陆。 这样掉线了就不用ssh到production服务器，然后sudo su git+pm2 logs --lines 100来进行扫码重登了。 现在不管在吃饭、野外、还是地铁上，掉线了便可立马扫码重登。 一、如何「掉线给码」: yarn add wechaty-log-monitor@latest只要在botAlice里去给botBob来createQRRescueOperation。 import {qrResuce, WechatyLogMonitor} from  wechaty-log-monitor const qrResuceForB = qrResuce(({ logFile:  . . /botBob. log , adminWeixin:  BobWeixin },{loginTest: 您好世界 }))botAlice. use(WechatyLogMonitor({  enableSelfToBeQrRescued: true,  logOperations:[qrResuceForB]}))也在botBob里给botAlice做vice versa的事儿: import {qrResuce, WechatyLogMonitor} from  wechaty-log-monitor const qrResuceForA = qrResuce(({ logFile:  . . /botAlice. log , adminWeixin:  AliceWeixin },{loginTest: #ping ))botBob. use(WechatyLogMonitor({ enableSelfToBeQrRescued: true, logOperations:[qrResuceForA]}))就几行代码，就能更轻松地进行掉线重登的developer operation了。 提高readily availability：只要两个没有同时掉线，另一个就能迅速得救！ p. s. 掉线后，bot发一个二维码就不会再发给你了。如果你想要最新的登陆二维码，发「qr」给bot就行。 二、WechatyLogMonitor的内部: wechaty-log-monitor里面所有东西都是函数式的。而且非常松耦合。除了IO中难以避免的副作用(side effect)，大致上是完全pure的。 WechatyLogMonitor这个函数里主要就是定义了startWatchingLog和startReactingToCmds。 startWatchingLog是用来做fs. watchFile+fs. createReadStream的回调（实现在watchAndStream里），而startReactingToCmds则是来做Wechaty的message event的回调。 const startWatchingLog = (bot:Wechaty,logOperations:WechatyLogOperation[])=&gt;{  _. each(logOperations,(operation:WechatyLogOperation)=&gt;{   const {onLogFileIsChanged, config} = operation   if(typeof onLogFileIsChanged ===  undefined ) return   const {logFile=  } = config   watchAndStream(logFile,(content)=&gt;{    onLogFileIsChanged(bot,content)   })  }) }export const watchAndStream = (file:string,callback:(content:string)=&gt;void)=&gt;{ if(!fs. existsSync(file)){  console. log(`file-to-watch ${file} not exist`)  return } fs. watchFile(file,{ interval: 2000 },(curr,prev) =&gt; {  const stream = fs. createReadStream(file,{start:prev. size, end:curr. size})  stream. on( data ,function(data){   const chunk = data. toString();   callback(chunk)  }) })}参数onLogFileIsChanged和config都来源于type WechatyLogOperation的object。而之前用到的qrResuce其实就是return了这个type的一个object。 export const qrRescue = ( config: WechatyLogOperationConfig,parameter:{loginTest:string}):WechatyLogOperation =&gt; { . . . }startReactingToCmds和👆上面的startWatchingLog差不多，不言而喻也。 三、「掉线给码」的实现: 函数startWatchingLog里调用到的onLogFileIsChanged取决于WechatyLogOperation的object对它的定义。 export type WechatyLogOperation = { config: WechatyLogOperationConfig, onLogFileIsChanged?: WechatyLogFileLambda, onCmdReceived?: WechatyCommandLambda,}其实qrResuce就是运用了一个global stateisOtherBotAlive:boolean加一些regex来根据写进日志的字符串从而来变动isOtherBotAlive这个“开关”，而这个“开关”的变动又会调用到onOtherBotIsLoggedOut和onOtherBotIsLoggedIn。 const onLogFileIsChanged = async (bot:Wechaty, newLogs:string) =&gt;{ const {adminWeixin} = config if(globalState. isDisabled) return if(globalState. isOtherBotAlive){  const latestQRCode = qrCodeAwaitingToBeScanned(newLogs)  if(latestQRCode) onOtherBotIsLoggedOut(bot,adminWeixin,latestQRCode) }else{  const loggedIn = isUserLoggedIn(newLogs)  if(loggedIn) onOtherBotIsLoggedIn(bot,adminWeixin) }}qrCodeAwaitingToBeScanned里的regex主要是来查找“INFO StarterBot…”和“INFO StarterBot onScan…”这两个string。(WechatyLogMonitor的参数enableSelfToBeQrRescued: true将会让Wechaty在登陆和要扫码时给出对应这两个string的log，写入log file里。) const qrCodeAwaitingToBeScanned = (lastFewLines:string):string|undefined =&gt; {  const signThatItIsLoggedIn = /INFO StarterBot Contact&lt;(. *)?&gt; login/g  const indexOfLastSignOfLoggedIn = getLastMatch(signThatItIsLoggedIn,lastFewLines)?. index || -1  const pattern = /INFO StarterBot onScan: Waiting\(. *\) - (. *)?\n/g  const match = getLastMatch(pattern,lastFewLines)  if(match) return match. index &gt; indexOfLastSignOfLoggedIn ? match[1] : undefined  return undefined}四、定义其他WechatyLogOperation: 总的来说，WechatyLogMonitor 把「看log回调」和「bot收到信息回调」这两件事abstract走了，所以在你的WechatyLogOperation中，只要选择性地定义 onLogFileIsChanged, onCmdReceived就可以了。 比如要写一个来restart PM2的WechatyLogOperation函数闭包，几行就行： export const restartPM2 = (config: WechatyLogOperationConfig, parameter:{pm2Id:number}):WechatyLogOperation =&gt; { return{  config,  onCmdReceived : async (bot:Wechaty, cmd:string, config: WechatyLogOperationConfig) =&gt; {    const {adminWeixin} = config    if(cmd ===  restart ) execAndPipeToBot( pm2 restart  +parameter. pm2Id, bot, adminWeixin)  } }} 五、待开发的Auth、GTP3功能: 目前 WechatyLogOperationConfig 里有一个 securityRule值，默认是None. export type WechatyLogOperationConfig = { logFile?: string, adminWeixin: string, securityRule?: WechatyLogOperationSecurityRule}export enum WechatyLogOperationSecurityRule { None = 0, SMSVerification, //not implemented authy, //not implemented googleAuth //not implemented}未来如果要发展到把项目整个production相关的DevOps（不单只是Wechaty相关的Operations，如在production跑的MongoDB相关的Operations、Restful API服务器相关的Operations等）都运用Wechaty来给团队塑造一个简单、容易上手的流程，也就是把chatbot变成了一个简易的terminal，那时候我们可以设定让更危险的Operations变得需要短信验证码、authy等方式去做Authentication。 我相信Auth功能对于wechaty-log-monitor插件来说将会是一个有意思的发展方向之一。 若pragmatically，『chatbot变成一个更简易的terminal』这件事真的行得通，那另一个非常有意思的发展方向就是结合OpenAI最近提及到GPT3的一个很有意思的应用：Natural Language Shell - 运用自然语言去做执行unix等命令。  作者: Archy Will He 何魏奇，functional programmer, interested in computational semantics，目前在全职做吖奇说(ARCHY. SH)这个项目。Working with GPT-2 (and hopefully with 3 soon!)  Github Repo: wechaty-log-monitor plugin  "
    }, {
    "id": 251,
    "url": "https://wechaty.js.org/2020/08/08/qijibot-sales-automation/",
    "title": "我如何用Chatbot在奇绩创坛重构销售体系",
    "body": "2020/08/08 -  除了媒体上的曝光，通过人进行深度触达是好的获客方式 对于团队来说，需要保证所有人的触达标准化 对于个人来说，需要努力提升触达过程的效率 聊天机器人不是“银弹”，需要人总结出结构性的方法论 结合方法论的聊天机器人是好的标准化和提效工具 基于企业微信的辅助坐席，可能实现快速组建“销售铁军”的目标我和奇绩创坛: 我自己是一位连续创业者，有一家教育科技公司，在2019年夏天有幸在1700份申请中获得了YC中国的面试机会，也因此有机会见到了YC中国（现奇绩创坛）的创始人陆奇博士。虽然后来没有通过那一轮面试拿到投资，但我太想拿到陆奇博士的投资了，所以我在2019年的10月选择成为一名奇绩创坛的实习生，开始与陆奇博士和奇绩创坛共事。在成为实习生后，我一个人在两周时间里完成了奇绩创坛的小程序的产品、视觉、开发和内外部协调的全部工作，又在奇绩创坛内做了一个“帮投资经理和创业者聊天”的机器人，故事就从这里说起。本文代码详见qijibot，本文不做代码层面的详细说明 一、 奇绩创坛如何获客和背后的困难？: 1. 1. 奇绩创坛探索的获客路径: 在2019年末那样一个时间节点，奇绩创坛还并不是一个足够有影响力的创投品牌，单纯依靠媒体上的曝光很难让所有早期创业者了解并报名奇绩创坛。所以，奇绩创坛探索的路径就是在媒体持续曝光之外，通过大量的工作人员在微信上直接触达创业者，并邀请他们报名奇绩创坛。事实上，这样的路径是非常成功的。因为人的存在，奇绩创坛价值主张的传递变得非常轻松，原来需要在媒体上反复解释的，通过对话的几个来回可以快速传递。 1. 2. 新的获客路径下的新困难: 然而，这背后带来了两点结构性的困难：  其一，对于团队管理者来说，如何保证每一个人说的话都是正确的（或者说是管理者希望传递下去的） 其二，对于个人来说，如何尽可能地降低沟通中的重复劳动。基于这样的问题，我开始探索一种好的方式，能够让团队在微信上的沟通是标准化的、每个人都能几乎不进行重复劳动，又能在这两个前提下，真正把价值传递出去。 1. 3. 表层困难下的结构性困境: 为了完成整套探索的路径，“搞个机器人来做自动化”显然是必然的。我将其拆分成两个维度：找到自动化的方式、找到决策方法论。  自动化意味着可以让机器自由地收发消息，具体收发什么，交给决策方法论来进行。 决策方法论的本质是将人的沟通抽象为一个对话的二叉树，并把这个可解释的二叉树变为机器可以学习的编码。完成了这两步之后，一个在微信上的对话系统就可以运行，并切实地帮助销售团队去解决复杂的用户沟通问题。 二、正式迈入聊天机器人行业的大门: 2. 1. 从零开始了解聊天机器人: 2019年的12月，奇绩创坛开始密集地进行微信上的沟通和获客。我从那时起，开始正式研究如何将整套过程落地成一套机器人系统。对于当时的我来说，我只有模糊的一点“我要把这个事情做了”，但完全没有“我该如何做”的想法。在一个周四的深夜，我在微信上找到了在奇绩创坛校友日上机缘巧合认识的、句子互动的创始人李佳芮，介绍了大致情况之后，她便邀请我参与在周五举行的BOT Friday（一个技术极客讨论聊天机器人行业落地和商业应用的创业论坛）。 2. 2. 连续地高密度的思考和沉淀: 就在那周，我收到了句子互动创始人佳芮的书稿，《Chatbot从0到1》，成为了我聊天机器人的启蒙。后来，我在BOT Friday上认识了大量的创业者、工程师和聊天机器人从业者，并通过几次“看起来是分享实际上是请大家帮我答疑”的BOT Friday活动，逐渐迈入聊天机器人行业。  三、如何做出一个可用的聊天机器人系统？: 3. 1. 一套一万字的“剧本”: 在我开始尝试设计一个帮助奇绩创坛进行沟通的聊天机器人的时候，我模糊地觉得我应该先把可能的话术对整理出来，我反复阅读和回顾我和之前创业者们的聊天记录，沉淀出了一套一万字的“剧本”，其中明确列出了if-else式的推进流。  当我写完“剧本”、技术开发又没有完成时，我基于这套“剧本”在一周时间里与300人进行了沟通，全程几乎不需要进行任何的思考，仿佛机器就应该如此运行一样。基于这套剧本，我成功地在人肉沟通环节，把每名创业者的沟通时间缩短到5分钟以内，并真正直接转化了其中数十位创业者报名。那个时候，我意识到，是时候将其变成更通用的系统了。 3. 2. 一个全自动化的尝试: 没有人会拒绝一个全自动化的系统，这也是我完成剧本后第一件希望完成的工作。然而，它毫无疑问的失败了，理由甚至不用赘述，毕竟这已经是聊天机器人行业的共识——纯机器人很难完成人类的所有需求。 3. 3. 回归人机耦合的辅助坐席: 在全自动化的尝试显著的失败之后，我开始探索真正能够解决问题的路径——不迷恋机器完成所有事情，那么机器完成90%的事情，然后人来做最后的决策如何？这个时候，我开始意识到，应该做一套人机耦合的辅助坐席。  在产品层面我又进行了几个维度的思考：  这个辅助坐席应该是独立于微信传统的对话形式的、在每天的工作就是去用微信完成同一个任务的时候，应该做成Feed流形式。也就是说，所有消息应该不分究竟是谁的消息，而混编在一整条时间线上。 针对每条消息，应该可以通过点击按钮的方式进行回复，每个按钮对应完整的话术和额外行为（打标签、拉群、改备注）。基于这两个层次的思考，传统意义上反复切换不同的聊天对象，针对每个人进行不同的回复的逻辑，应该变成流水线式的作业：  用户只需要盯着流水线上是否有新消息并基本不需要考虑是谁发出的。 用户只需要点击按钮就能把对方提出的问题进行回复，并完成一些必要的操作。 机器永远不自作主张地进行回复，永远需要人进行一次确认。 四、帮更多企业在微信上做好私域销售: 当然，Qijibot被投入的资源注定其只是一个非商业的尝试，距离成为人人可用的、真正改变企业销售体验的工具还有遥远的距离。后来，我在2020年正式地加入句子互动，以CMO的身份，开始在企业微信生态上，去帮助企业做好“私域销售”，我们的产品句客宝已经上线。这是另外一个很长的、还没有结束的故事……如果你对于如何借助工具打造销售体系感兴趣，欢迎你与我聊聊（微信：bohao-YIN），也许会是我们下一篇博客内容的起点。  作者: Yinbohao "
    }, {
    "id": 252,
    "url": "https://wechaty.js.org/2020/08/06/wechaty-twitter-to-wechat/",
    "title": "twitter2wechat",
    "body": "2020/08/06 -  Twitter2Wechat: 当前，IFTTT应用相当广泛，连接了很多日常的应用，但是微信由于各种原因，尚不能接入。感恩Wechaty API的出现，这个Twitter2Wechat 通过监听Twitter，在探测到有新Tweet发布后，会同步到预设的微信群里。一个实际的应用是，我们有一个实况足球的小联盟PESNALeague。如果有玩家在YouTube或Twitch上直播比赛对战的话，通过预设的IFTTT, 直播的URL会在Twitter发布。之后，通过这个wechaty机器人，实现了在微信群的通告功能。 效果预览: 项目说明: 本项目是基于wechaty的个人开源项目，更多关于wechaty项目说明及api文档可以移步：wechaty介绍如果你拥有了wechaty发放的Padplus token，那么也可以直接使用本项目 （PadPlus token 申请地址） 程序结构: GitHub |---index. js          # 入口文件|---twitter_monitor. js     # 监听Twitter的module|---credentials. js       # 存放所有的authentication keys|---environment_settings. json # 设置，比如Twitter polling frequency等等|-- package. json配置: 我们提供了credentials_example. js，如下所示。请移步申请Twitter Developer API四个token填入即可运行。 ```shell scriptmodule. exports = { // Twitter Devloper Account Credentials // Apply here: https://developer. twitter. com/en/docs/basics/authentication/overview consumer_key: ‘fill_in_your__consumer_keyi’, consumer_secret: ‘fill_in_your__consumer_secret’, access_token: ‘fill_in_your__access_token’, access_token_secret: ‘fill_in_your__access_token_secret’, // Twitter ID you wanted to monitor twitter_user_id: “fill_in_your_twitter_account”, // Wechaty and Wechat information puppet_padplus_token: ‘fill_in_your_puppet_padplus_token’, wechat_chatroom_id : ‘555456789@chatroom’,}``` 核心代码: 首先，感谢Monitor Twitter的开发者，我们发展了他们的主程序，实现了对Twitter账号的监听，具体的实现请参考twitter_monitor. js文件。核心的程序如下图，在每30秒poll一次Twitter的情况下，如果检测到有新Tweet发布，我们抓取Tweet的text()，然后同步发布到微信Wechat预设的房间内。 运行: 克隆本项目，并进入项目根目录第一步 npm install第二步 node index. js 服务器Heroku 部署 (推荐): 代码写完了，我们需要一个服务器24/7运行，且最好是免费的:)Wechaty的主要开发者Huan LI (李卓桓)写过一篇博客文章，且附带有Heroku+Wechaty Getting Started例程，对我们的帮助很大。Heroku免费提供每月500小时的服务器时间，分配到每天，几乎是20小时了，基本上够用了。他们提供的Node. js Tutorial教程做，也写的非常详尽，一步步照着做完，也就学会了。在他们的服务器上部署后，只要修改Procfile就可以带参数的运行了。 延展与将来: 国内抖音如火如荼，直播带货这些将来可能都会与微信连接。这些直播的信息将来有可能可以通过微信，直接推送到客户的手机上，方便用户获取最新消息。 最后: 本项目属于个人兴趣开发，开源出来是为了技术交流，请勿使用此项目做违反微信规定或者其他违法事情。建议使用小号进行测试，有被微信封禁网页端登录权限的风险（客户端不受影响），请确保自愿使用。 致谢: 感谢wechaty团队提供微信机器人SDK，让开发者可以专注于业务代码感谢句子互动juzibot提供的iPad协议版token  Author: aftereverCode: twitter2wechat "
    }, {
    "id": 253,
    "url": "https://wechaty.js.org/2020/08/05/wechaty-puppet-maker/",
    "title": "Wechaty Workshop for Puppet Makers: How to make a Puppet for Wechaty",
    "body": "2020/08/05 - Wechaty 通过精妙的代码设计，实现了基于一套应用层代码，自由切换不同的接入方式，帮助开发者以最大程度的易用性，快速实现多个平台的聊天机器人接入。 Wechaty Puppet: Wechaty 的每一种接入方式，都以 Puppet 的形式进行封装，目前已经上线的 Puppet 包括Puppeteer、Padplus、Hostie等多种方式的微信个人号接入，微信公众平台的接入等。 此外，钉钉、企业微信、飞书、抖音、快手的 Puppet 正在开发中，QQ、微博、Signal等多个平台的 Puppet 开发等待进行。 How to make a Puppet for Wechaty: 为了帮助社区开发者更快了解 Puppet 的更多细节、实现 Puppet 开发的从零到一，Wechaty 社区邀请到几位最核心的 Puppet 开发者介绍Puppet是什么、如何完成 Puppet 开发的第一步、如何实现一个商用级的 Puppet。  Puppet的商业化前景展望: 分享人：句子互动CMO 尹伯昊   Wechaty 项目架构: 分享人：Wechaty Puppet Padplus&amp;Donut Creator 高原   Wechaty Puppet Ding-Dong: 分享人：Wechaty Creator 李卓桓    Puppet Padplus开发要点分析: 分享人：句子互动高级工程师 苏畅   暑期2020 与 Puppet开发: “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动，旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。Wechaty 作为中国最大的聊天机器人开源项目，合计发布了11个项目，由Wechaty社区的资深Contributor作为导师，选出了11位同学进行项目开发。此次 Wechaty 发布项目涉及多语言、多平台、多功能三个核心主题，其中的企业微信、钉钉、飞书、抖音、快手 Puppet作为多平台模块的任务，已经进入开发节奏。你可以在Wechaty SoC中查看每个项目的导师和负责同学的联系方式，并与他们一起直接参与到对应 Puppet 的开发中。 立刻参与到 Puppet 开发中: 对于开发者来说，有两种潜在的路径能让你直接参与到 Puppet 的开发中来：  参与 暑期2020 相关项目，其中包括企业微信、钉钉、飞书、抖音、快手。 完成 社区心愿单中更多想要完成的 Puppet，其中包括QQ、微博、Signal、Line等。Wechaty 社区期待你的参与！ "
    }, {
    "id": 254,
    "url": "https://wechaty.js.org/2020/08/04/wechaty-guangzhou-gathering/",
    "title": "记一次 Wechaty 广州小分队与佳芮老师的小聚会",
    "body": "2020/08/04 -  题记: 说起来惭愧，到我写下博客的时候离聚会的时候已经有两周的时间，这段时间工作一直比较琐碎，没有来得及整理，现在赶紧补上。 八月四日，我离开佛山的办公室坐上了去去广州五羊邨的地铁，加入 Wechaty Contributors 不就的我正准备赴约参加在一周前佳芮老师发起的一个广州小分队活动。 佳芮老师正好这段时间过来广州开会，于是有了这次聚会的机会。 我一看的确机会难得，虽然我工作地点也不在广州，但是毕竟过去也不麻烦，而且能够结识到在开源项目里面大显神通的大神，就打算参加去旁听旁听，长点见识。 结果我抱着打酱油的心态接了龙，出乎所料的是，这次竟然成了我和佳芮老师，还有 Wechaty 的零号 Contributor 大神 @0 前辈的三人聚会。 因为佳芮老师下午要在腾讯的广研开会，因此聚会约在珠江新城附近，中午的 11:30 附近吃个午饭，说回来只有 @0 前辈是广州本地人，比较熟悉地形，所以便安排好了地点。 我到的时候比预定的时间晚了15分钟，下了五羊邨站地铁站之后走了有五分钟的路就到达了“食方缘素食”，@0 前辈和佳芮老师已经到了有一阵子了。 这个地方是一个三楼的露台，不过用玻璃围起来做了一个小的包厢，还有空调。景观很不错，能够看到街上的行人和精致的绿植，非常惬意。 我到了之后，佳芮老师就热情地像我介绍了 @0 前辈，特别说到 @0 前辈的 Wechaty bot 用了三年居然还没有掉过线。然后佳芮老师还拿出来了精心为我们准备的小礼物 ——佳芮老师、卓桓老师和李云军老师的新发的书《Chatbot 从 0 到 1——对话式交互设计实践指南》，还写下了赠言和签名，以及有一些 Wechaty 的周边小贴纸。  然后我们留了个合照，开始了这次的交流。对于我来说，其实这一次的会面更多的是作为一个学习者和旁观者的视角来参与的，在这次会面我了解了一些 wechaty项目的历史以及大佬们的创业经历，对我来说也是得到了很多的启发。 最近谈到 @0 前辈那个多年稳定不掉线的 bot，他说道其实很大原因是在于这个 bot 主要的用途还是监听信息，没有在里面做一些发送的动作，所以虽然一直是用 puppeteer的网页微信版的登录，也依然能够在复杂多变的微信生态中存活下来。在近段时间的 WeTool 事件以及网页版微信的各种政策调整、其他封号环境的背景下，其实如何规范我们自己的或者客户使用的机器人在一个合理合法的生态规则下运作才是持续发展的方法。 佳芮老师又分享了在 Wechaty 项目最早期的时候，当时是卓桓老师作为项目开发的主力，然后 @0 前辈就加入到了这个项目，然后在里面做出了很多的贡献，@0前辈还多次提到了卓桓老师，说经常还看见卓桓老师深夜还活跃在各种 GitHub 的开源项目上，对卓桓老师能够多年一直能够在开源项目上持续不断大力度在开源项目和编码上做出这样的贡献深表赞赏。 后面还聊到了 @0 前辈和佳芮老师的创业经历，@0 前辈是一个中国互联网拓荒时代的创业者，曾经管理了上千人的技术团队，并且在很多智能应用方面做出了很多的尝试，不过这些尝试的项目可能是因为比时代的发展早得太多，反而没有等到一个最好的市场时机。而佳芮老师也是一个二次创业者，句子互动是第二个创业项目，然后佳芮老师也解答了我的一些疑问，介绍了一些有关句子互动的业务与模式。 最后我们还聊了一些关于 Apache 基金会和开源项目的运作方式，和我自己的感觉一样，卓桓老师带领的团队在开源项目的建设上的确有着极为丰富的经验以及强大的实力，在推动国内开源生态的发展上做出的贡献的确非常珍贵。 就我自己而言，在加入 python-wechaty 小组至今不长的时间里，的确感受到了开源项目的魅力，也掌握了一些开源项目的工作流程，从技能上说，也从一些源自开源项目的优秀实践学到了很多，例如 GitHub Actions 的 CI，Makefile 的广泛使用等等，希望我自己能伴随着这个平台的发展越走越远吧！  最后，回来之后仔细看了佳芮老师的书，的确是对话机器人这个领域的不可多得的理论和实践指南，在这里为佳芮老师带一下货，大家多多支持哦！也希望日后能有更多的机会参与开源项目的线下活动，Wechaty 越办越好！  Author: Alfred HuangCode: Github "
    }, {
    "id": 255,
    "url": "https://wechaty.js.org/2020/08/02/wechaty-stock-bot/",
    "title": "股票盯盘助手",
    "body": "2020/08/02 -  背景: 随着“牛市”的到来, 各种炒股，荐股的群又活跃起来， 大佬荐股的同时， 韭菜们也需要快速了解该股票的行情和基本面，于是有了这个小工具 股市有风险，投资需谨慎功能: ⭐ 监听群聊内容，从群聊内容中分析并提取所包含的股票名称，回复相关股票实时行情。 ⭐ 大盘指数查询，可查询上证指数，深圳成指，创业板指，和科创50指数。 ⭐ 龙虎榜查询，可查询当日龙虎榜或者查询指定日期龙虎榜。 ⭐ 更多功能开发中… 运行: 克隆项目 git clone https://github. com/wengcan/stock-bot. gitcd stock-bot安装依赖 npm install参考config. sample. js 创建config. js 文件 export const token =  puppet_padplus_xxxx ;export const activeRooms = ['BOT_TEST','测试群聊'];获取最新股票代码列表 npm run helper启动项目 npm start效果图:   致谢: 🙏感谢wechaty团队提供微信机器人SDK🙏感谢句子互动提供的iPad协议版token  Author: wengcanCode: stock-bot "
    }, {
    "id": 256,
    "url": "https://wechaty.js.org/2020/08/01/wechaty-distribute-instruction-handler/",
    "title": "wechaty plugin for easily extending capabilities",
    "body": "2020/08/01 -  wechaty-plugin-xyao 插件可以让你的 wechaty bot 具备以分布式模块执行自定义指令的能力。 why wechaty-plugin-xyao: 使用这个插件，至少会带来以下几个优势：  如果 bot 的业务处理和微信通讯两部分逻辑都集中在单个进程，随着业务逻辑的增长，部分逻辑出现问题可能导致整个 bot crash，且单进程受限于单个节点的处理能力，也限制了能力的扩展。将微信通讯与业务解耦，业务和业务独立部署，能够有效缓解这些问题。 独立出的业务处理模块可以采用任意适合该领域业务的语言（目前提供了一个基于 java springboot 的 brain 模块开发框架）。 由于采用了基于 pub/sub 的消息中间件作为机器人和 brain 的通讯，因此即使两者之间由于 NAT 无法提供基于固定公网 IP 的 RPC 服务，也可以通过这种方式打通交互。demo: 上例中， bot 将 fin: 前缀的指令通过队列交给 fin 关联的模块处理，而 x: 前缀的指令交给 x 对应的模块。那些无法被识别为指令的消息（比如 你好 午饭吃什么），则统一交给某个指定模块处理（通常是一个具备智能闲聊能力的处理模块，比如 百度 unit）。 这些处理模块被称之为 brain 模块，它们为 bot 赋予了某一个特定领域的处理能力。 计划中的 brain 模块:       brain   status   description         xyao-brain-trunk   开发中   提供了微信机器人基本的处理能力，比如自定义 cron 形式的提醒，设置 todo-list, 消息搬运等特性       xyao-brain-jira   开发中   提供 atlassion jira 相关的指令，比如将某个群组与某个 JIRA 项目绑定，定期推送每日 issue 进度及工时登录，检查 issue 规范性等       xyao-brain-fin-info   开发中   提供股市相关信息的查询或推送特性       xyao-brain-translate   待开发   提供中英文互翻的特性   Requirements:  Node. js v16+ Wechaty v0. 40+ This Plugin Redis server one or more brain serviceUsage: import { Wechaty } from 'wechaty';import { PuppetPadplus } from 'wechaty-puppet-padplus';import { Xyao } from '. . /src/mod';const token = 'your PAD-PLUS token';const puppet = new PuppetPadplus({ token });const bot = new Wechaty({ puppet, name : 'x. yao',})const xyaoConfig = { redis_host: 'localhost', redis_port: 6379, redis_password: '123456', redis_retry_interval: 5000, masters: ['wxid_of_master'], brains_cli: ['x', 'jira'], brains_ai: 'ai918', log_appender: 'dateFile', log_file: '/data/wechaty-xyao/xyao. log', log_level: 'INFO'};bot. use(  Xyao(xyaoConfig),)bot. start()  . catch(console. error)配置插件:  redis_host: redis ip redis_port: redis 端口 redis_password: redis 密码 redis_retry_interval: redis 断线重连间隔 masters: 机器人的主人账号(注意是contact. id)，有部分指令必须是主人发起的才会执行 brains_cli: brain 列表 brains_ai: 未被识别为指令的的消息会交给这个 brain 模块 log_appender: dateFile 输出到指定文件，按日期分割； stdout 输出到控制台 log_file: 日志文件路径 log_level: 日志级别部署架构参考: bot 在收到消息后，先尝试识别指令，识别为指令后，按前缀通过队列分发给指定的 brain 模块去处理。 每个 brain 模块都有自己唯一的标识，该标识会作为指令的前缀，比如 fin:index 指令会交给标识为 fin 的 brain 模块。 🌀 指令: 指令是一条带有规定格式的微信消息。 比如跟机器人私聊或者在群内 @ 机器人，跟它说： jira:bind-project -p READK223那么这条消息将被机器人识别为指令，  jira 是 brain 模块标识，机器人根据此标识将指令传递给相应的 brain 处理模块 bind-project 是指令关键字，brain 模块根据此关键字决定采用哪段业务处理逻辑 -p READK223 是指令的选项，通常一个指令会有0到多个选项，采用不同的选项，会影响业务处理的逻辑。在开发 brain 模块 的时候，建议都支持 help 和 echo 指令，比如：jira:helpjira:help bind-projectjira:echo tell me what i have said jira:help 返回标识为 jira 的 brain 模块所支持的所有的指令 jira:help bind-project 返回 bind-project 指令的详情，包括支持的选项说明 jira:echo tell me what i have said 返回 echo 的内容，用于检验该 brain 模块当前是否在线并正常工作🧠 brain 模块: 通过 wechaty-plugin-xyao 插件创建的 wechaty 机器人，它只负责微信消息的收发，若要使它具备一定的业务处理能力，就需要为其扩展 brain 模块。机器人收到消息并识别为指令后，将指令通过 redis 交给相应的 brain 模块，brain 根据指令种类及选项参数进行相应的业务处理，并将处理结果通过redis再交给机器人，由机器人发送微信消息给指定的用户。 所以我们可以简单的理解为：wechaty 机器人是耳朵和嘴巴，而 brain 模块则是大脑。你可以部署多种用于处理不同领域问题的大脑，比如股票行情，企业内部的项目管理，当然也包括常见的群组管理，定时通知，翻译等领域。 brain 模块的开发并不限定语言或平台，任何能够连上 redis 并且可以处理 json 的语言都可以开发 brain。 基于 java springboot 快速开发 brain 模块: 为了简化 brain 模块的开发，可参考基于 java springboot 的 brain 开发框架（比如 xyao-brain-trunk ），它会尽量将业务无关部分的逻辑统一处理掉，并默认提供了 help 或 echo 指令。 项目目录结构如下： ├── myapp|  ├── src|  |  └── main|  |    ├── java|  |    |  └── io|  |    |    └── github|  |    |      └── watertao|  |    |        └──xyao|  |    |         └──infras|  |    |         └──instruction|  |    └── resources|  |      └── application. properties│  └── pom. xml其中 io. github. watertao. xyao. infras 这个 package 中包含了与 redis 通讯，指令的序列化和反序列化以及 echo 和 help 指令。同时也定义了开发指令时需用到的一些 annotation 和 模型类。 io. github. watertao. xyao. instruction 这个 package 用于放置自定义指令处理类。 application. properties 是配置文件，它包含了以下配置： # dev: 开发模式； prod: 生产模式。 这两种模式的主要区别是日志的输出不同，前者输出到控制台，后者输出到文件。一般我们在生产环境下，jar# 包同级目录中放一个 config/application. properties 用于覆盖 jar 内的 properties。spring. profiles. active = dev# 本模块的 brain 标识xyao. brain = fin# bot 的 topic 名，本模块可以通过这个 topic 以 x. yao 的身份向指定用户或群组发送消息xyao. channel = x. yao# help -w 指令时向用户发送一个 UrlLink 形式的帮助文档xyao. help. url = https://github. com/watertao/xyao-brain-fin-info/wiki/%5B-%23fin-%5D-Instruction-Manual-of-xyao-brain-fin-infoxyao. help. title = [ #fin ] Instruction Manual of xyao brain fin infoxyao. help. description = xyao-brain-fin-info is a brain module of wechaty-plugin-xyao, it provides common features, such as showing Shanghai or Shenzhen index, the real time price of specified stock , etc. . . xyao. help. thumbnail = https://coding-net-production-file-ci. codehub. cn/1190d970-ce81-11ea-9a30-ed2db94588f5. jpeg?sign=yZ8k7anwCH4ma8CRXmTKSOc/2pRhPTEyNTcyNDI1OTkmaz1BS0lEYXk4M2xGbWFTNlk0TFRkek1WTzFTZFpPeUpTTk9ZcHImZT0xNTk1OTAyNDM3JnQ9MTU5NTY4NjQzNyZyPTMwMDE1OTAmZj0vMTE5MGQ5NzAtY2U4MS0xMWVhLTlhMzAtZWQyZGI5NDU4OGY1LmpwZWcmYj1jb2RpbmctbmV0LXByb2R1Y3Rpb24tZmlsZQ==# redis 连接配置spring. redis. host = localhostspring. redis. port = 6379spring. redis. password = 123456# 日志输出级别logging. root. level = INFO# 系统日志输出 pattern，缺省为 %d{yyyy/MM/dd-HH:mm:ss SSS} %-5level - %msg %nlogging. encodePattern = %d{yyyy/MM/dd-HH:mm:ss SSS} %-5level - %msg %n# logging. path = /myapp/log# 日志文件的文件名，缺省为 spring. log# logging. file = myapp. log# 日志文件按时间切割的模式，缺省为 yyyy-MM-dd# logging. splitPattern = yyyy-MM-dd# 日志文件保留的个数，缺省为 30# logging. maxHistory = 30以开发一个返回随机数的指令为例。brain 标识为 foo, 指令名为 random，参数 -m 代表随机数小于该参数指定的数。  修改 application. properties：xyao. brain = foo(其他诸如 redis 连接参数，日志 以及 帮助信息等配置自行按照实际情况修改)  添加 io. github. watertao. xyao. instruction. RandomHandler 类：package io. github. watertao. xyao. instruction;import io. github. watertao. xyao. infras. *;import org. apache. commons. cli. CommandLine;import org. apache. commons. cli. Options;import org. springframework. beans. factory. annotation. Autowired;import org. springframework. stereotype. Service;import java. util. Random;@Service( random ) // bean name 必须是指令名@Instruction(    syntax =  random &lt;option&gt; , // 帮助信息中的语法    description =  返回随机数，可通过参数设置最大范围 , // 帮助信息中的 描述    masterOnly = false, // 这条指令是否只能是 master 发起    msgEnv = MessageEnvironmentEnum. BOTH  // 这条指令使用的范围是私聊还是群聊，或都支持)public class RandomHandler extends AbstractInstructionHandler {  // 注入此 bean 用于发送消息至 redis  @Autowired  private XyaoChannelProxy channelProxy;  @Override  protected Options defineOptions() {    Options options = new Options();    options. addOption( m ,  max , true, 随机数的最大范围 );    return options;  }  @Override  protected void handle(XyaoInstruction instruction, CommandLine command) {    Integer max = 10;  // 默认最大范围是 10    // 如果用户指定了 m 选项，则最大范围设置成该选项值    // （为了演示，忽略非数字字符的异常情况处理）    if (command. hasOption( m )) {      max = Integer. valueOf(command. getOptionValue( n ));    }    Integer randomNum = new Random(). nextInt(max + 1);    // 通过父类方法 makeResponseMessage 构建响应消息，该方法会将回复对象以及群组设置为指令发起人和指令发起时的群组    XyaoMessage xyaoMessage = makeResponseMessage(instruction);    xyaoMessage. getEntities(). add(new XyaoMessage. StringEntity(String. valueOf(randomNum)));    // 发送响应至 redis    channelProxy. publish(xyaoMessage);  }}接着我们通过向机器人发送私聊或群内 @ 机器人，发送消息： foo:random -m 100 ，机器人就会回复 0~100 以内的随机数。 完成一个指令就是这么简单 😁。 Maintainer:  watertao,Tao Wu,&lt;1059912278@qq. com&gt;Copyright &amp; License:  Code released under the Apache-2. 0 License 作者: watertaoCode: Github "
    }, {
    "id": 257,
    "url": "https://wechaty.js.org/2020/07/31/wechaty-effective-secondhand-bot/",
    "title": "更有效率的二手捡漏助手",
    "body": "2020/07/31 - 作为一个爱逛二手闲置数码的程序员，怎么淘到自己喜欢且性价比高的设备是个技术活~ 曾经写过浏览器插件弹窗以及邮件推送等手段来传递信息，但是总是觉得稍微还是差了那么一点… 场景覆盖性&amp;信息实时性&amp;所及即所得…这些痛点该如何解决呢？ 于是我找到了wechaty~ 👐 代码配置化很极客 🙌 可视化配置操作更贴近大众用户 👌 wechaty消息推送实时到达很棒 ☝️ 直接图文阅读无须二次跳转更快 功能: 🌙基于electron的主要原因是为了可视化配置wechaty设置 ⭐可视化配置wechaty相关设置【token&amp;bot_name等等】 ⭐可视化配置推送相关设置【关键词&amp;推送时间段等】 🌙利用electron自动生成资讯内容图片 ⭐自动生成推送内容图片，无须二次跳转访问链接 逻辑:  通过electron生成的桌面程序启动&amp;管理wechaty 可视化配置推送关键字及时间段等相关设置 获取到相关资讯信息后自动生成内容图片并保存到本地 通过wechaty推送已生成的资讯精要信息和内容图片依赖:  wechaty：wechaty核心库 wechaty-puppet-padplus：wechaty iPad协议 electron: 基于Web技术创建原生程序的框架 react+antd: 框架+UI运行: 克隆项目 git clone git@github. com:krapnikkk/wechaty-electron. gitcd wechaty-electron安装依赖 yarn install启动项目 yarn run dev效果图:   致谢: 🙏感谢wechaty团队提供微信机器人SDK🙏感谢句子互动提供的iPad协议版token  Author: krapnikCode: wechaty-electron "
    }, {
    "id": 258,
    "url": "https://wechaty.js.org/2020/07/30/go-wechaty-gh-optimization-poc/",
    "title": "暑期2020 [Go-wechaty Github Action optimization] 计划书",
    "body": "2020/07/30 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。 官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html 本项目 [Go-wechaty Github Action optimization] 系 暑期2020 支持的开源项目。 [Go-wechaty Github Action optimization]具体计划:  导师：丁小雨 学生：唐光彬 模块列表     更新 go-wechaty-getting-started 依赖   完成 Windows 平台下 ding-dong 编译测试   完成 ding-dong 的 docker 并推送到 Github Packages    计划安排：     更新 go-wechaty-getting-started 依赖         预期完成时间：7月14日     模块描述：在go-wechaty-getting-started代码更新时检测依赖是否更新到最新，如果没有更新到最新，则更新后提交一个 Pull-Request。          完成 Windows 平台下 ding-dong 编译测试         预期完成时间：7月14日     模块描述：实现在Windows平台下编译ding-dong，在第一个模块为基础上。          完成 ding-dong 的 docker 并推送到 Github Packages         预期完成时间：8月1日     模块描述：ding-dong 能编译通过则根据 dockerfile 生成镜像并推送。     备注：需要提供 Docker Image 的命名格式           项目链接：wechaty/go-wechaty-getting-started 联系方式：tang. packet@outlook. com 作者: TangGuangbin "
    }, {
    "id": 259,
    "url": "https://wechaty.js.org/2020/07/29/wechaty-puppet-lark-plan-blog/",
    "title": "基于开放 API 封装 Wechaty 接口下的飞书聊天机器人：期初",
    "body": "2020/07/29 - “开源软件供应链点亮计划-暑期2020”（以下简称暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [基于开放 API 封装 Wechaty 接口下的飞书聊天机器人] 系 暑期2020 支持的开源项目。 [基于开放 API 封装 Wechaty 接口下的飞书聊天机器人]具体计划:    导师：高原 吴京京     学生：范蕊   模块列表     接收消息   通讯录获取   实现 puppet 上各个类型的消息接口   设计配置参数   使用文档    计划安排：     阅读源代码         7. 29 - 7. 31     阅读 wechaty 源代码     学习飞书服务端 API     整理需要实现的 puppet list          接收消息         8. 1 - 8. 5     通过飞书订阅消息事件实现消息接收          通讯录获取         8. 6 - 8. 10     通过飞书订阅通讯录事件实现通讯录更新信息的接收          实现 puppet 上各个类型的消息接口         8. 10 - 8. 30     对接飞书接口, 实现各个类型的消息接口     消息类型包括: 文字, 图片, 富文本, 群名片          设计配置参数         8. 31 - 9. 7          使用文档         9. 8 - 9. 12          项目完善         9. 12 - 9. 30     代码重构             项目链接：https://github. com/Roxanne718/wechaty-puppet-lark                 联系方式：+86 17822015718     email: 953299708@qq. com           Author: @roxanne718Code: wechaty-puppet-lark "
    }, {
    "id": 260,
    "url": "https://wechaty.js.org/2020/07/29/wechat-group-integral-robot/",
    "title": "微信群积分机器人（Wechat group integral robot）",
    "body": "2020/07/29 -  背景: 女朋友做微商代理卖水果，建了一个卖水果的微信群，为了维持群里的活跃度，有时候会弄一些积分送水果的活动，对于群成员的积分管理只能靠手动记分来维护，这样操作起来其实挺辛苦的。因此想做一个自动记分的群管理机器人，手动@用户就可以给用户加积分，这样就不用一个一个手动改备注积分啦，后期统计起来也很方便。 功能:  自动处理好友请求 通过@成员给成员加积分 群管理（拉人进群、@群成员）当用户在群里发好评时，@该用户会给用户添加自定义积分。 结构: |-- config/|------config. js      # 用于存储机器人的一些配置以及群配置。|---service         # eggJs 搭建的数据接口|-- src/|----- integral. js     # 积分业务逻辑处理|----- onScan. js      # 机器人需要扫描二维码时监听回调|------ onRoomJoin. js    # 进入房间监听回调|------ onMessage. js    # 消息监听回调|------ onFriendShip. js   # 好友添加监听回调|------ postServer. js    # 消息回复的处理|------ superagent. js    # ajax 接口调用的封装|---- config. js       # 配置文件|---app. js         # 入口文件|-- package. json服务层: 服务层是用eggJs 搭建 配置起来超级简单，使用mysql作为数据持久化存储。具体可参考官网配置。 依赖: wechaty：wechaty 核心库wechaty-puppet-padplus：wechaty的ipad协议实现 代码介绍: import { Wechaty } from 'wechaty' // Wechaty核心包import { PuppetPadplus } from 'wechaty-puppet-padplus' // padplus协议包import config from '. /config/config' // 配置文件import onScan from '. /src/onScan' // 机器人需要扫描二维码时监听回调import onRoomJoin from '. /src/onRoomJoin' // 加入房间监听回调import onMessage from '. /src/onMessage' // 消息监听回调import onFriendShip from '. /src/onFriendShip' // 好友添加监听回调// 初始化const bot = new Wechaty({  puppet: new PuppetPadplus({    token: config. token  }),  name: config. name})bot  . on( scan , onScan) // 机器人需要扫描二维码时监听  . on( room-join , onRoomJoin) // 加入房间监听  . on('login', (user) =&gt; {    console. log(`user ${user} login`)  })  . on( message , onMessage(bot)) // 消息监听  . on( friendship , onFriendShip) // 好友添加监听  . start()本地运行:  克隆项目git clone https://github. com/hzhuhao/wechaty-integral-robot. gitcd wechaty-integral-robot 安装依赖机器人所需依赖npm install 安装serve服务依赖cd servicenpm install// 启动服务npm start 启动项目npm start使用:  打开config/config. js 文件 修改config配置 进入 service/config 修改服务配置 以及 配置mysql数据库 运行项目致谢: 非常感谢Wechaty团队提供微信机器人SDK，让开发者可以专注于业务代码。感谢句子互动提供的pad协议版token。wechaty: https://wechaty. github. io/juzibot: https://www. juzibot. com  作者: HzhuhaoCode: Github "
    }, {
    "id": 261,
    "url": "https://wechaty.js.org/2020/07/28/wechaty-rpa-kuaishou-plan/",
    "title": "暑期2020[基于 RPA 封装 Wechaty 接口下的快手聊天机器人]计划书",
    "body": "2020/07/28 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [基于 RPA 封装 Wechaty 接口下的快手聊天机器人] 系 暑期2020 支持的开源项目。 [基于 RPA 封装 Wechaty 接口下的快手聊天机器人]具体计划:  导师：尹伯昊 学生：毕凯乔 模块列表     Android run in Linux   Puppeteer   puppet for kuaishou   其他待的操作方式    计划安排：     模块一         8. 15     探索在linux上使用虚拟机拦截/发送消息          模块二         8. 15     使用puppeteer操作快手     由于快手web版未提供私信，直接操作web版快手只能控制回复评论。          模块三         9. 30     探索一定的RPA操作方式后，产出一个puppet          模块四         9. 30     花更多的时间寻找合适的RPA操作方式，包括网络上一些已经有一些雏形的。尽可能地移植到wechaty           项目链接：https://github. com/bikaiqiao/kuaishou-auto / https://github. com/bikaiqiao/kuaishouPuppet. git               联系方式：+86 13943110476     358461417@qq. com           Author:@bikaiqiao "
    }, {
    "id": 262,
    "url": "https://wechaty.js.org/2020/07/28/wechaty-puppet-douyin/",
    "title": "基于RPA封装的Wechaty接口下的抖音聊天机器人",
    "body": "2020/07/28 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。 旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。 官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html 本项目 [基于 RPA 封装 Wechaty 接口下的抖音聊天机器人] 系 暑期2020 支持的开源项目。 [基于 RPA 封装 Wechaty 接口下的抖音聊天机器人]具体计划:  导师：王凯峰、尹伯昊 学生：王俊伟 模块列表     接收评论   回复评论   探索私信的方法   整理代码   编写文档    计划安排：     接收评论         7. 28-8. 2     开放平台创建应用     利用openApi接收评论     跑一个dingdongBot          回复评论         8. 3-8. 5     接收并回复一条评论          探索私信的方法         8. 5-8. 15     探索抖音私信的方法          整理代码         8. 5-8. 15     整理代码          编写文档         8. 15-8. 20     编写文档           项目链接：https://github. com/gavinwang23/wechaty-puppet-douyin               联系方式：+86 15205733272     email: 863445607@qq. com           Author: @gavinwang23Code: @gavinwang23/wechaty-puppet-douyin "
    }, {
    "id": 263,
    "url": "https://wechaty.js.org/2020/07/28/wechaty-enterprise-rainbowbot/",
    "title": "wechaty-rainbowbot 基于Wechaty实现的企业业务系统与营销团队微信群之间通信的桥梁",
    "body": "2020/07/28 -  背景: 据我所知，大部分中小型公司，甚至某些传统大型销售公司，对销售团队的管理工作几乎依赖于微信、微信群，本人所处的公司也不例外。公司已有内部的web端业务数据系统，但是通常情况下数据只有发送到下级营销管理团队的微信群或者一线业务员的微信群中，才能发挥出相应的营销作用。 典型的场景:    每日评选销售精英团队Top10，在微信群中展示业绩数据（或者海报），并对销售欠佳的团队给予勉励，等等；     在某一销售阶段中，对达成业务目标的业务员，即时性地在微信群中给予祝贺（贺词或图文贺报）、奖励公示等。  顺便说一句，熟悉微商行业的应该知道，微商团队把微信群管理营销发挥到了极致，最典型的是他们的“报单”场景，小伙伴开单后立即向团队群汇报，群内一阵庆贺、鼓励，不得不说，这样的操作对团队积极性的调动是最直接的，对维持团队开单活动率的正向效果明显。所以传统行业在走向微信群营销管理的时候，自然而然地也会选择这种“接地气”的营销方式。 痛点: 大部分传统行业，这类工作是人工执行，甚至需要设立专职人员监控业务系统的数据情况，（尽量的）及时编辑文案，发送给相应的微信营销群或者个人。然而作为一个有程序猿背景的业务管理者，这样重复的人工浪费是我无法忍受的。为什么不能接入一个微信robot，把这些事务性的繁琐工作接管，自动执行从业务系统到微信群的发送工作呢。当然，痛点也是显而易见的：业务系统与团队微信群本身是相互独立地存在，两者之间缺少一个通信连接的桥梁。 关键需求: 外部的业务系统可以根据数据达成情况主动地向特定的微信群和个人发送消息。 关键实现: 微信robot要暴露外部通信接口，第三方系统能够通过调用接口，实现微信消息（图片、文字、视频、文件等）的发送。 结缘Wechaty: 首先在微信robot实现框架的选型上，我也考察过多个开源项目，基本上都是基于web端协议的，而web协议存在诸多使用限制（许多up主的文章已经做过比较详细的解释，在此不在赘述），况且许多这类项目已经好几年没有update了，果断放弃。至于基于Hook的PC端协议解决方案，必须依赖于固定版本的windows微信客户端，考虑到我需要的是一个运行在Linux服务器上的长期稳定的API，这种方案也是不可取的。 最后我发现了 Wechaty 这个项目，Wechaty的社区是目前我发现的最活跃的微信robot开源社区。该社区的主创人员还会经常举行线上分享会，把Wechaty的最新发展情况、以及Wechaty的新应用、新玩法介绍给大家，还会现场解答user/developer反馈的问题。也正是在后来的一次分享会的视频上，最后提问环节中@Gcaufy的问题解答，使我明确了Wechaty能够完美满足我的需求。 另外，wechaty支持 iPad 协议，虽然需要付费获取 token，但是可以申请参与开源激励计划来获取免费甚至长期有效的 token。  Wechaty 是一个开源的的个人号微信机器人接口，是一个使用 Typescript 构建的 Node. js 应用。支持多种微信接入方案，包括网页，ipad，ios，windows， android 等。同时支持 Linux, Windows, Darwin(OSX/Mac) 和 Docker 多个平台。 搞起来: 为了避免重复制造轮子，我翻阅了不少已有的Wechaty项目，有基于爬虫+定时任务来实现外部系统与微信端通信的应用，但这与我的需求还是有区别的。我希望实现的是（理论上）任意时间点，外部系统主动调用接口与微信之间进行通信。最后决定自己动手搞起来，理论模型已经很清晰，一个最简单的实现结构是这样的： RainbowBot作为中间通信桥梁，就像一弯彩虹，连接起远在天边的两个独立系统。 依赖: 服务端基于 nodejs, koa, koa-jwt, multer  wechaty核心库 wechaty wechaty的 ipad协议 wechaty-puppet-padplus实现逻辑:  nodejs+koa启动服务端容器 Wechaty启动创建bot，并将bot注册到服务端全局 服务端监听外部POST请求，通过JWT进行身份验证 按照请求提供的消息内容、接收方等信息，调用bot发送消息核心代码: const robot = {  // [roomTopics, contactNames, contents, file_box] - 请求端字段名必须一致  // 发送[多]文件消息  sendFile: async (ctx, next) =&gt; {    let paths = null    try {      paths = await uploadFiles(ctx, next, 'file_box')      const roomTopics = ctx. request. body. roomTopics      const contactNames = ctx. request. body. contactNames      const fileBoxes = await buildFileBoxes(paths)      const sended = await multiSend(roomTopics, contactNames, fileBoxes)      await delFiles(paths)      ctx. body = {}    } catch (err) {      throw err    } finally{      if(paths) await delFiles(paths)    }  },  // 发送[多]文本消息  sendText: async (ctx) =&gt; {    try {      const roomTopics = ctx. request. body. roomTopics      const contactNames = ctx. request. body. contactNames      const contents = ctx. request. body. contents      await multiSend(roomTopics, contactNames, contents)      ctx. body = {}    } catch (err) { throw err }  },  // 发送文本文件混合消息  sendMix: async (ctx, next) =&gt; {    await robot. sendFile(ctx, next)    await robot. sendText(ctx)  }}具体代码请参阅GitHub项目RainbowBot 接入微信对话开放平台: RainbowBot不只实现了系统与微信之间的通信，也扩展微信助理的能力，比如关键字问答能力。 7月16日中午WWC举办了线上分享会，句子互动联合创始人&amp;CTO @高原为我们分享了如何用「Wechaty」和「微信对话开放平台」做个助理，让我大开眼界。因为通过接入微信对话开放平台，能够将关键词判断逻辑与bot发消息模块解耦。其次更重要的一点是，接入了微信对话开放平台的AI能力，平台能够根据传入的用户消息，自动判断用户意图，从而响应指定的信息。 因此，我在会后就立即为RainbowBot开通了微信对话平台API，并将关键词触发逻辑移接到平台端。高原先生也为我们封装好了Wechaty接入微信对话开放平台的插件wechaty-weixin-openai ，让我可以仅用少量的代码就能够快速的实现接入平台和机器人的对话逻辑的配置。 在此推荐大家都看一下分享会的实况视频：https://www. bilibili. com/video/BV1LV411r756/ 本地运行:    克隆项目:  git clone g https://github. com/CavonCheng/rainbow-botcd rainbow-bot   安装依赖:  npm install   修改配置:      修改config/index. js 文件，将里面的配置改为自己的。   修改config/openai. js、config/puppet. js，分别设置自己的微信对话开放平台 token和wechaty-puppet token。 微信对话平台官网，扫码登录提交开发者信息即可获得api token。   启动:    启动项目:  node app启动成功后终端会出现一个二维码，扫码登录即可。 感谢: 感谢@beclass的开源项目wxbot，这是一套优秀的BS版微信robot后台管理系统，让我这枚nodejs全栈初级修炼者学习到了很多，受益匪浅。感谢Wechaty团队提供微信机器人SDK，让开发者可以专注于业务代码。 感谢句子互动提供的pad协议版token。  Author: @CavonChengCode: @rainbow-bot "
    }, {
    "id": 264,
    "url": "https://wechaty.js.org/2020/07/28/rae-oa-wechaty/",
    "title": "Rae-oa系统微信群辅助机器人(rae-wechaty)",
    "body": "2020/07/28 - 之前公司web组组长有个微信机器人每周催我们交周报,私信发过去会自动更新到公司内部wiki上,一度惊为天人,后来看到公共号以及掘金上突然有好多人推荐wechaty,据说是6行代码完成一个微信聊天机器人,正好老婆那边想要个能辅助她工作的系统,就是这么巧~ 致谢: 感谢wechaty团队提供微信机器人SDK感谢句子互动提供的iPad协议版token感谢gengchen528,isnl,shfshanyue大佬们的开源代码 定位: rae-wechaty是Rae-oa系统在微信上的辅助机器人,提供一切我老婆需要的功能…. . 如何获取免费 Token: 官方文档中提供了免费 token 的获取方式。https://github. com/juzibot/Welcome/wiki/Everything-about-Wechaty 细节如下：  为了参与开源激励计划，需要开发者填写表单，联系Juzi BOT（微信号：juzibot）或等待其主动联系均可。直接填写： Wechaty 开源激励计划2. 0申请表 。  在收到开源激励计划申请表和 Github 项目信息后，Juzi BOT（微信号：juzibot）将依照开源激励计划申请表中的联系方式主动联系。在确认开发者愿意将最终成品代码开源同时在Wechaty社区内撰写一篇博客后，将为开发者发放一个有效期 15 天的 Token 。开源激励计划的 Token 为 padplus 协议，目前主要支持 node. js 的开发，如果想要使用 Java / Python / Go 进行开发，可以申请 Donut Token，其针对多语言进行了优化，但需要进行付费购买。  在提供有效期 15 天的 Token 后，我们期待开发者将 MVP （最小可行化产品）代码在 Github 中开源，并储存在一个 public repo 中。 功能: [x] 自动识别@机器人的文本并作出相应回应,排除机器人本身[x] 每日一句英文+翻译[x] 关键字”生日”=&gt;查询公司本月生日员工[x] 关键字”日报”=&gt;返回公司日报模板[] 每日新闻[] 中英文词典[] 每日请假登记[] 员工信息修改[] 获取员工基本信息[] 自动邀请加群,群发[] 获取所有以支持的关键字 如图: 依赖:  wechaty：wechaty核心库 wechaty-puppet-padplus：wechaty iPad协议 qrcode-terminal: 终端输出二维码 @nsea/tools:自己封装的axios及数组处理工具 rae-oa系统:基于阿里云+docker+vue+egg+mongoDB搭的前端-服务-数据库项目运行: 克隆项目 git clone git@github. com:NorthSeacoder/rae-wechaty. gitcd rae-wechaty要在src/common/constant/config下新建index. ts文件,并导出一下内容 export default { TOKEN: '',//wechaty-key  APIKEY:'',//天行 apikey 用于每日一句英文  nscBaseUrl:''//阿里云上部署的接口baseurl};运行 npm installnpm start扫码登录or npm npm run docker:start//昨晚好像改挂了. . . . 等有空了修改一下还加了个清理docker none images 的命令 npm run docker:clean目录结构:  bin文件夹存放存放docker的运行脚本 src     common 存放公共配置及resource数据请求   event 机器人所有message交互处理   message 具体的处理逻辑函数   schedule 定时任务    index. ts 程序入口 Author: NorthSeacoderCode: rae-wechaty "
    }, {
    "id": 265,
    "url": "https://wechaty.js.org/2020/07/27/java-wechaty-transplant/",
    "title": "Wechaty Java 移植组件开发",
    "body": "2020/07/27 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。 官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html 本项目 [Wechaty Java 移植组件开发] 系 暑期2020 支持的开源项目。 [Wechaty Java 移植组件开发]具体计划:  导师：刁政欣 学生：陈炀 模块列表     memory-card存储   state-switch状态机   其他模块基本api移植   (选做) api优化为更加符合kotlin风格   (选做) 理解底层原理,添加一些新功能    计划安排     memory-card存储         7. 1 - 7. 19     该模块移植是基本要求,为了能够满足机器人重新登陆不需要扫码,保存机器人自身信息等功能,需要用到这个组件,这个组件将存储的功能和存储数据的 结构相分离,以便能够简单的更换存储方式,支持阿里云oss,华为云obs,亚马逊s3,json存储等,同时提供了易用的api来使用     基本功能          state-switch状态机         7. 20 - 7. 26     state-switch是用于管理异步操作的监视器/保护器,在原本的ts版本中可以通过Promise的特性来比较轻松的实现,在kotlin则需要其他的api来实现,思路 比较清晰,但是要找到合适的实现手段有点麻烦     基本功能          (选做) 其他api移植与测试         7. 27 - 8. 7     java-wechaty中还有许多api没有实现,api的风格也是仿照js来实现的,后续需要将这些api逐步实现,并且修改其api风格,以更适合java和kotlin等语言     扩展功能          (选做) 理解底层原理,添加一些新功能         8. 8-8. 15     此部分为选作内容,wechaty还有一些关于miniprogram,红包等功能还未实现,需要能够理解底层,以便进行后续的扩展,逐步增强wechaty的功能     扩展功能           项目链接：https://github. com/cunkoulaocai/java-wechaty               联系方式：+86 15806082601     e: 1184016190@qq. com           Author: @cunkoulaocaiCode: @cunkoulaocai/java-wechaty "
    }, {
    "id": 266,
    "url": "https://wechaty.js.org/2020/07/27/hr-retarded-robot/",
    "title": "智障机器人(retarded-robot)",
    "body": "2020/07/27 - 内容列表:  背景 功能列表 安装 使用说明 功能截图 致谢背景: 这个机器人主要作用于人力资源服务行业，辅助业务员工作的这么一个机器人。业务员每天的工作就是群发消息、收集报名以及处理58同城的邮件并筛选出合适的人，大量的重复工作，因此该机器人诞生了！！该机器人还具备一些AI娱乐功能，例如颜值检测、智能对话等等。主要来源鹅厂开放的AI接口。 功能列表:  工作信息查询 定时群发 58同城邮件解析(解析成功后，会通知到管理员，此功能已完成，但机器人里未开启，请参考/robot/loginStatus. ts中的onLogin事件) 报名功能 智能对话 颜值检测安装: 这个项目使用 node 和 npm。请确保你本地安装了它们。 ```shell scriptgit clone https://github. com/xajeyu/retarded-robot. git ## 使用说明- 该机器人基于ipad协议，请在config/robot. ts中配置自己的[token](https://github. com/juzibot/Welcome/wiki/Everything-about-Wechaty)- 所有涉及到配置的文本全在config文件夹中- 工作信息存在数据库中- 机器人在运行时的配置，将由管理员私信机器人配置并存储在 redis 中```shell scriptnpm install or yarnnpm start or yarn start功能截图: 致谢: 感谢wechaty团队提供微信机器人SDK感谢句子互动提供的iPad协议版token  Author: xajeyuCode: retarded-robot "
    }, {
    "id": 267,
    "url": "https://wechaty.js.org/2020/07/23/wechaty-group-lottery/",
    "title": "微信群内抽奖机器人(wechaty_lottery)",
    "body": "2020/07/23 - 背景: 目前群内抽奖的方法主要有两种:红包最佳手气和第三方抽奖小程序而这两种方法从形式到结果的通知都不够直观便捷,不适合高频快速的运营所以有了制作群内抽奖机器人的想法 功能: 通过关键词触发机器人随机抽取群内一人获奖,已除去发奖人与机器人 逻辑:  通过”抽奖+空格”格式触发抽奖机器人,例如”抽奖 抱枕”,”抽奖 一等奖”等 机器人被触发后获取当前群内成员数组,并去除机器人和发奖人 等概率随机抽取一人,在群内消息通知中奖信息并同时@发奖人和中奖人 依赖:  wechaty：wechaty核心库 wechaty-puppet-padplus：wechaty iPad协议 qrcode-terminal: 终端输出二维码运行: 克隆项目 git clone https://github. com/csjuXYZ/wechaty_lottery. gitcd wechaty_lottery安装依赖 npm install启动项目 npm run serve开发: import { Message } from 'wechaty'  // 配置文件import config from '. /config'  // 机器人名字const name = config. name// 消息监听回调module. exports = bot =&gt; {    return async function onMessage(msg) {      // 判断消息来自自己，直接return      if (msg. self()) return        // 输出消息简介        //  console. log( ============================= )        //  console. log(`msg : ${msg}`)        //  console. log(        //    `from: ${msg. from() ? msg. from(). name() : null}: ${        //  msg. from() ? msg. from(). id : null        // }`        //  )        //  console. log(`to: ${msg. to()}`)        //  console. log(`text: ${msg. text()}`)        //  console. log(`isRoom: ${msg. room()}`)        //  console. log( ============================= )      // 判断此消息类型是否为文本      if (msg. type() == Message. Type. Text) {        // 判断消息类型来自群聊        if (msg. room()) {          // 获取群聊          const room = await msg. room()          // 收到消息，提到自己          if (await msg. mentionSelf()) {            // 获取提到自己的名字            // let self = await msg. to()            // self =  @  + self. name()            // 获取消息内容，拿到整个消息文本，去掉 @+名字            // let text = msg. text(). replace(self,   )            return          } else {            // 收到消息，是关键字 “抽奖”            if (await lottery(msg)) return          }        } else {          //私聊消息        }      } else {        console. log( 消息不是文本！ )      }    }  }  /**   * @description 回复信息是关键字 “抽奖”   * @param {Object} msg 消息对象   * @return {Promise} true-是 false-不是   */async function lottery(msg) {  //判断文字消息是否以抽奖+空格开头  if (msg. text(). indexOf( 抽奖  ) == 0) {    const room = await msg. room()    let member = await room. memberAll()      // 获取群内成员数组,去除机器人以及发奖人    member = member. filter(v =&gt; (!v. self()) &amp;&amp; (v != msg. from()))    // 随机从成员数组中抽取一个    let target = member[Math. floor(Math. random() * member. length)]    room. say(msg. text() +  \n---\n  +  \n中奖的人是:  + ((await room. alias(target)) || target. name()), msg. from(), target)    return true  }  return false}致谢: 感谢wechaty团队提供微信机器人SDK感谢句子互动提供的iPad协议版token  Author: csjuXYZCode: wechaty_lottery "
    }, {
    "id": 268,
    "url": "https://wechaty.js.org/2020/07/23/kuakua-bot-wechaty/",
    "title": "基于Wechaty的夸夸机器人",
    "body": "2020/07/23 -      疫情期间，记得微信加过一个朋友，给他发消息立马就能回复，后来才知道其中有一些是机器人回复的。特别好奇这是怎么做到的，因为之前了解到的就只有微信公众号可以做到。难道微信也可以？因为好奇，网上查询了相关资料才了解到了强大的wechaty。恰巧自己的研究方向是自然语言处理，前段时间公众号上的夸夸机器人很火，所以想着写一个微信版本的夸夸机器人吧。如果想体验可以加一下：AINLPER-BOT 。相关功能实现的方式不是很完美，还请各位大神勿喷~ 夸夸机器人:     之前看网上有个帖子是这么说的：一个男生邀请她女朋友进入了一个群，然后不论女朋友说什么都是一顿狂夸，最后女朋友是又惊又喜。其实这群里面都是人去赞美、表扬的，那么能不能在微信群里里面整个机器人去夸呢？所以该项目的初衷是实现一个微信群里面的夸夸机器人。     在做项目的时候，发现如果只做一个群内夸夸机器人是不是有点浪费wechaty的强大功能了，所有又添加了每日一句早安语、每日天气、多群使用夸夸机器人、机器人召唤、机器人退出、加群自动欢迎语等功能。 相关功能实现介绍: 每日早安语:     该功能实现主要是通过爬取网络上的早安语，然后去重，并将其做成了json文件，供程序每天随机读取。为了防止出现重复，每天发完都会删除。我工程中data目录下面就有公布的部分数据，大概有个300条吧，也能够大家用快一年的了。效果截图如下： 每日天气:     该功能会根据微信个人设置的地理位置实现天气的自动推送，本文工程设定是每天8点推送。该功能的实现主要是调用的第三方API接口，这里就不打广告了。因为第三方的接口个人感觉不好用，后面我计划采用个人爬取的方式获取天气结果，这样自主权更好一点。 夸夸机器人:     终于到了最关键的功能了。夸夸机器人主要使用的是一份别人爬好的数据集，然后我对数据集做了一些清洗处理（去重、去无效词、去关键词等），处理后的数据集我也会放到我工程的目录下面。在问答处理上我采用的是key-value的方式，用到的最主要的匹配算法采用的是余弦cos计算相似度。这样好友在说一些话的时候，会自动的匹配出相关赞美的话。 夸夸机器人的召唤和退出:     机器人刚做出来的时候，发现在群里面别人说一句话，它就夸一句，时间长了就容易烦了，能不能让它通过特定的口令实现夸夸机器人的在线和下线呢，就和小爱音响、小度音响一样。功能实现起来很简单，主要是采用了一个标志位来控制机器人的开关。 加群欢迎语:     该功能主要是我一个朋友提出的，主要是新人加群的时候可以比较及时的给与反馈，这样给人感受比较好。其实现方式主要利用wechaty的room-join监听事件实现。 功能部署:     如果对我的project感兴趣，你可以自己部署测试一下。其主要部署方法可以参考https://github. com/wechaty/wechaty-puppet-padplus，完成之后执行 ts-node bot. ts然后扫码登陆就可以了。 待完善的内容:     后面还想利用wechaty对接小冰机器人等其它机器人，实现多个机器人的自由切换；另外关于机器人的管理想通过数据库的方式实现，因为每个群对于每个群的需求不一样，每个人对每个人的需求也不一样；最后希望自己提高自己的自制力。 感谢: 最后，真心的感谢Wechaty开源项目提供的 token。  Author: yinizhilianCode: GitHub "
    }, {
    "id": 269,
    "url": "https://wechaty.js.org/2020/07/23/early-bird-chatbot/",
    "title": "基于wechaty的求职社群管理工具",
    "body": "2020/07/23 - 早鸟平台是一群硅谷在职的工程师创建的平台。受全球疫情的影响，今年的求职季变得很特殊，对于企业来说，缩减招聘需求成了一段时间的常态。对于求职者来说面试周期拉长、求职压力倍增。而早鸟作为专业的求职交流公益平台，在全球疫情蔓延，经济低迷的情况下，更应该助广大毕业生或求职者一臂之力。 早鸟的定位如下：  提供包括但不限于刷题、做项目、互改简历等服务的平台 对接各大公司内推，连接学校到职场的断层 一个你能长期获得帮助的社群，从找实习、全职到职业发展等2020的秋招马上开始了，早鸟计划扩展出刷题、项目、简历、求职、内推、面试和实习等十余个分队，每个分队涉及众多国内外名校的学生，将分别以不同的主题建群。为了更方便地维护求职信息群，急需生成一款社群管理工具。受限于部分用户无法登录web 协议 的wechaty。所以使用基于iPad 协议的wechaty-puppet-padplus来实现功能。  Wechaty 是一个开源的的个人号微信机器人接口，是一个使用 Typescript 构建的 Node. js 应用。支持多种微信接入方案，包括网页，ipad，ios，windows， android 等。同时支持 Linux, Windows, Darwin(OSX/Mac) 和 Docker 多个平台。 如何获取免费 Token: 官方文档中提供了免费 token 的获取方式。https://github. com/juzibot/Welcome/wiki/Everything-about-Wechaty 细节如下：  为了参与开源激励计划，需要开发者填写表单，联系Juzi BOT（微信号：juzibot）或等待其主动联系均可。直接填写： Wechaty 开源激励计划2. 0申请表 。  在收到开源激励计划申请表和 Github 项目信息后，Juzi BOT（微信号：juzibot）将依照开源激励计划申请表中的联系方式主动联系。在确认开发者愿意将最终成品代码开源同时在Wechaty社区内撰写一篇博客后，将为开发者发放一个有效期 15 天的 Token 。开源激励计划的 Token 为 padplus 协议，目前主要支持 node. js 的开发，如果想要使用 Java / Python / Go 进行开发，可以申请 Donut Token，其针对多语言进行了优化，但需要进行付费购买。  在提供有效期 15 天的 Token 后，我们期待开发者将 MVP （最小可行化产品）代码在 Github 中开源，并储存在一个 public repo 中。 本工具已实现功能:  接收用户好友申请，并自动发送欢迎信息 邀请入群 入群欢迎词 自动建群，比如发送“建群-早鸟群1”就自动建一个群 求职信息 海外疫情示例：回复序号或关键字获取对应服务  加入Wechaty群聊（或其他已配置的群聊） 求职信息 海外疫情如需创建群聊，请输入”创建群聊-“+群名称（例：创建群聊-求职群1） 如图： 目录结构:  config文件夹存放公共配置文件以及superagent请求相关配置 imgs存放相关图片 listeners存放机器人初始化后一系列事件处理(分模块)     on-friendship. js 处理好友请求   on-login. js 处理登录   on-message. js 处理用户消息、群消息   on-scan. js 处理登录二维码    schedule 对定时任务node-schedule库进行了封装 superagent 存放所有的数据请求、接口封装都在此 app. js 入口文件如何使用: 克隆仓库代码Early-Bird-ChatBot 安装依赖 npm install 修改config配置打开config/index. js 文件，将里面的配置改为自己的。 修改天行接口配置天行 api 官网 ：https://tianapi. com/ 注册成功后，申请以下接口：     [海外疫情]    之后请打开superagent/index. js，将顶部APIKEY改为自己天行 api 的key即可  其他免费接口可随意申请，不想用天行的接口可以删掉对应的关键字。 启动程序 npm start终端会出现一个二维码，扫码登录即可。 展望: 因目前工作较忙，时间和精力所限只实现了部分功能，未来会有更多的开发者加入到早鸟机器人的开发队列中，我们计划扩展的功能列表如下（持续更新中）：  每日算法 架构设计精讲 面试宝典 硅谷新鲜事 职场求生录 科技日报 湾区生活指南感兴趣的小伙伴可以探索wechaty更多的功能，请参见:(https://github. com/wechaty/wechaty-puppet-padplus) 便于查找的API列表:(https://github. com/wechaty/wechaty)  Author: lmaCodeCode: early-bird-chatbot "
    }, {
    "id": 270,
    "url": "https://wechaty.js.org/2020/07/22/wechaty-plugin-milestone/",
    "title": "Wechaty插件系统发布，让你的机器人快速接入复杂管理和智能对话能力",
    "body": "2020/07/22 - Wechaty 的故事开始于用RPA的方式模拟登录微信，在过去的几年里，服务了数万名开发者，收获了 Github 的 8000 Star。https://github. com/wechaty/wechaty我们将过去对于绝大多数人难以想象的工作量，通过数万行代码封装成了最短六行代码就可以模拟登录微信的npm包。 import { Wechaty } from 'wechaty' // import { Wechaty } from 'wechaty'Wechaty. instance() // Global Instance. on('scan', (qrcode, status) =&gt; console. log(`Scan QR Code to login: ${status}\nhttps://api. qrserver. com/v1/create-qr-code/?data=${encodeURIComponent(qrcode)}`)). on('login',      user =&gt; console. log(`User ${user} logined`)). on('message',    message =&gt; console. log(`Message: ${message}`)). start()但是，对于真正的可用的微信聊天机器人，不可避免地需要用大量的逻辑来处理不同条件下的收发消息、群管理甚至和外部系统的耦合。这也就意味着，即使收消息、发消息、添加好友等操作都只需要一行代码，对于一个复杂任务仍需数十行代码才能完成。带着对于即插即用的期待，我们上线了完整的插件系统。 关于插件系统的一切: 为了更好地让插件系统为大家所用，Wechaty 社区邀请到Wechaty 作者李卓桓、Wechaty Plugin设计师Gcaufy、Wechaty Puppet Donut/Padplus作者高原、Wechaty Plugin 开发者王墨炱分别就 Wechaty 开发生态、插件开发完整指南、插件的商业化可能等领域进行深度分享。  Wechaty项目和社区生态介绍: Wechaty 作者 李卓桓 Wechaty项目和社区生态介绍   插件系统开发历程及应用: Wechaty Plugin 设计师，腾讯微信小程序框架开源项目Wepy 作者 Gcaufy 插件系统开发历程及应用   Wechaty 插件的商业化落地展望: 15:00 - 15:30 Wechaty Puppet Donut/Padplus 作者 高原 Wechaty 插件的商业化落地展望   基于插件的Wechaty开发: 15:30 - 16:00 Wechaty Plugin开发者 王墨炱 基于插件的Wechaty开发Live Code Demo: Invite to Room  Wechaty 插件库: 目前，Wechaty社区已经上线了大量可用的插件，你可以直接查找你感兴趣的插件并且直接在你的机器人中使用。Wechaty插件库 Wechaty 基础能力插件: https://github. com/wechaty/wechaty-plugin-contrib#plugins-contrib Wechaty 群管理插件: https://github. com/Gcaufy/wechaty-voteout Wechaty 定时任务插件: https://github. com/Gcaufy/wechaty-schedule Wechaty 群监控插件: https://github. com/wechaty/wechaty-got-kicked-out Wechaty 可视化面板接入插件: https://github. com/gengchen528/wechaty-web-panel Wechaty Intercom 接入插件: https://github. com/wechaty/wechaty-plugin-intercom Wechaty Freshdesk 接入插件: https://github. com/wechaty/wechaty-plugin-freshdesk Wechaty Qnamaker 接入插件: https://github. com/wechaty/wechaty-plugin-qnamaker Wechaty 腾讯智能对话平台 接入插件: https://github. com/wechaty/wechaty-weixin-openai Wechaty 有道翻译接入插件: https://github. com/chs97/wechaty-plugin-youdao Wechaty CLI 插件: https://github. com/wechaty/wechaty-vorpal 欢迎正在阅读的你参与其中: 插件系统的诞生对于 Wechaty 是一个重要的里程碑，能够帮助开发者从繁琐的开发中解脱出来，更好地解决业务问题。Wechaty 社区欢迎你使用插件、将你的机器人能力封装成插件、让更多开发者使用你的插件。  直接在Wechaty插件库中寻找合适的插件并使用。 参与Wechaty开源激励计划Everything about Wechaty，生产一个有价值的插件，Wechaty社区将为你提供一个长期有效的Token。 在Wechaty插件库中更新你的插件，让更多开发者直接使用。 作者: Yinbohao "
    }, {
    "id": 271,
    "url": "https://wechaty.js.org/2020/07/20/wechaty-soc-kick-off-meeting/",
    "title": "Wechaty Summer of Code 2020 Kickoff Meeting",
    "body": "2020/07/20 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。 官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html Wechaty 与暑期2020: Wechaty 作为中国最大的聊天机器人开源项目，与其他数十个中国顶级开源项目一起参与“暑期2020”。Wechaty 合计发布了11个项目，共收到来自清华大学、北京大学、中国科学院大学、南开大学、四川大学等高校的数十份申请，并由Wechaty社区的资深Contributor作为导师，选出了11位同学进行项目开发。此次 Wechaty 发布的11个项目涉及多语言、多平台、多功能三个核心主题，来自Wechaty社区的导师将和来自高校的学生开发者们一起，在三个月的时间里完成对应的开源项目。 Wechaty 暑期2020宣讲会:  你可以在Bilibili上查看暑期2020宣讲会视频 你也可以在Google Docs上查看暑期2020宣讲会Slide Wechaty 项目列表: Wechaty 在多语言、多平台、多功能三条主线上，共发布了 11 项任务，并通过 issue 的方式进行每周的更新。全部项目在wechaty/summer-of-code#3中进行汇总。如果你有看到感兴趣的项目，可以直接在对应 issue 下面找到负责对应任务的开发者。 多语言：为 go-wechaty 设计实现 插件体系 https://github. com/wechaty/summer-of-code/issues/9:  导师：丁小雨（ 614422099@qq. com），丁超飞（dchaofei@163. com），李博杰（silkage@silkage. net） 学生开发者：林昊翰，西安电子科技大学本科生（finctive@foxmail. com）多语言：Go-wechaty Github Action optimization https://github. com/wechaty/summer-of-code/issues/8:  导师：丁小雨（ 614422099@qq. com），丁超飞（dchaofei@163. com），李博杰（silkage@silkage. net） 学生开发者：唐光彬，华南农业大学本科生（Tang. Packet@outlook. com）多语言：Wechaty Java 移植组件开发 https://github. com/wechaty/summer-of-code/issues/4:  导师：刁政欣 阿里开发工程师 Author of Java-wechaty （diaozxin@gmail. com） 学生开发者：陈炀，福州大学本科生（1184016190@qq. com）多平台：基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人 https://github. com/wechaty/summer-of-code/issues/2:  导师：高原，句子互动CTO、前亚马逊工程师（gaoyuan@juzi. bot）；李佳芮，句子互动CEO、专注微信生态近10年（rui@juzi. bot） 学生开发者：谢昱清，清华大学本科生（1205402283@qq. com）多平台：基于开放 API 封装 Wechaty 接口下的钉钉聊天机器人 https://github. com/wechaty/summer-of-code/issues/11:  导师：高原，句子互动CTO、前亚马逊工程师（gaoyuan@juzi. bot）；李佳芮，句子互动CEO、专注微信生态近10年（rui@juzi. bot） 学生开发者：杨明哲，福州大学本科生（yutinice@foxmail. com）多平台：基于开放 API 封装 Wechaty 接口下的飞书聊天机器人 https://github. com/wechaty/summer-of-code/issues/12:  导师：高原，句子互动CTO、前亚马逊工程师（gaoyuan@juzi. bot）；李佳芮，句子互动CEO、专注微信生态近10年（rui@juzi. bot） 学生开发者：范蕊，南开大学本科生（953299708@qq. com）多平台：基于 RPA 封装 Wechaty 接口下的抖音聊天机器人 https://github. com/wechaty/summer-of-code/issues/13:  导师：尹伯昊，连续创业者，句子互动CMO（yinbohao@juzi. bot） 学生开发者：王俊伟，长春工业大学本科生（863445607@qq. com）多平台：基于 RPA 封装 Wechaty 接口下的快手聊天机器人 https://github. com/wechaty/summer-of-code/issues/14:  导师：尹伯昊，连续创业者，句子互动CMO（yinbohao@juzi. bot） 学生开发者：毕凯乔，长春工业大学本科生（358461417@qq. com）多功能：基于python-wechaty的群聊助手机器人 https://github. com/wechaty/summer-of-code/issues/6:  导师：吴京京：Wechaty Committer，Python Wechaty Author（ 1435130236@qq. com） 学生开发者：孔祥哲，清华大学本科生（15068701650@163. com）多功能：基于Python-wechaty建立一个斗图机器人 https://github. com/wechaty/summer-of-code/issues/7:  导师：黄纯洪，python-wechaty contributor（huangaszaq@gmail. com） 学生开发者：肖子霖，四川大学本科生（me@mrxiao. net）多功能：编写一个“每日一句”插件 https://github. com/wechaty/summer-of-code/issues/10:  导师：Gcaufy，20000+Star小程序框架Wepy作者、Wechaty Plugin系统设计师（gcaufy@gmail. com） 学生开发者：江姗姗，北京大学二学位本科生（univerone@outlook. com）SoC破冰会会议纪实:  暑期2020 开发计划: 此次暑期2020活动中，开发者分别需要在Wechaty社区内完成例行交付、向组委会提供两个节点的代码并完成答辩，其所有成果均会以开源的形式向社区开放。 Wechaty 社区交付内容:  每周例行更新：在即日起的每周日前（首次更新最晚时间为7. 19号），学生开发者会在 Wechaty SoC Issues 中，按照下文模板更新每周进度；如果在当周有明确的新进展和学习收获，学生开发者也会以博客形式在 wechaty. github. io 中分享。 Plan Blog：学生开发者们会在7. 19号前以博客形式在wechaty. github. io进行分享，内容包括：排期规划、对应项目Repo、联系方式等，同时也作为每周进展在例行更新中同步。 POC Blog：学生开发者们会在8. 15号前以博客形式在wechaty. github. io进行分享，内容包括：完成的项目核心攻关、后续需要的支持和新的开发排期，同时也作为每周进展在例行更新中同步。 Finished Blog：学生开发者们会在9. 30号前以博客形式在wechaty. github. io进行分享，内容包括：完整的项目情况和实现的功能、后续长期的开发展望，同时也作为最后一次每周进展在例行更新中同步。暑期2020组委会交付内容:  中期审核：学生开发者们会在8. 15号前参与完成中期审核工作，届时相关代码链接也会随之呈现。 完整项目提交和汇报：学生开发者们会在9. 30号前完成，届时项目完整代码会向社区开放。欢迎正在阅读的你参与其中: 虽然“暑期2020”的报名已经结束，但Wechaty社区依然欢迎正在阅读本篇内容的你参与到暑期2020的工作中来。以下是几种可能的参与方式：  时刻跟进Wechaty SoC项目的每周例行更新 Issue，并直接与相关负责导师和学生开发者取得联系，和他们交流相关进展。 在 Wechaty 开发者群内，为学生开发者们的Plan Blog、POC Blog和Finished Blog点赞和提出想法。 直接参与已经完成部分工作的项目开发，为学生开发者们负责的复杂项目添砖加瓦。 作者: Yinbohao "
    }, {
    "id": 272,
    "url": "https://wechaty.js.org/2020/07/20/wechaty-openai-agent/",
    "title": "用「Wechaty」和「微信对话开放平台」做个助理",
    "body": "2020/07/20 - 应 WWC(Women Who Code) 邀请，我在线上分享了如何用「Wechaty」和「微信对话开放平台」做个助理帮助回答常见问题。 活动介绍: https://mp. weixin. qq. com/s/6HyEZlwWbuRGY9T_KotXEw 随着社会节奏的不断变快，每天，我都有越来越多的微信消息需要回复，其中不乏很多重复的问题反复找到我。作为一个程序员，都是不愿意在重复的工作中浪费自己宝贵的时间的。这次，将给大家分享如何用 Wechaty 和 OpenAI 创建一个属于你的个人助理，帮助你来处理那些重复的问题，解放你的时间。 我们要做什么？: 一个微信助理机器人带有以下功能：  我@他，并且提问的时候，自动把准备好的材料等都发出来 别人问他的时候，可以自动匹配到常见问题并回答 当没有匹配到回答的时候，转接给我     消息在群里且我在群里：@我让我回答   私聊或者我不在群里：把我的名片发出来，引导加我好友   我们需要通过代码来控制微信: 这个时候就是 Wechaty 大显身手的时候了，下面是接入代码： import { Wechaty, Message, UrlLink } from 'wechaty'import { PuppetPadplus } from 'wechaty-puppet-padplus'import { EventLogger, QRCodeTerminal } from 'wechaty-plugin-contrib'import { padplusToken } from '. /const'const puppet = new PuppetPadplus({ token: padplusToken,})const bot = new Wechaty({ name: 'wwc-agent', puppet,})bot. use(EventLogger())bot. use(QRCodeTerminal({ small: true }))bot. start()代码很简单，就是创建了一个 puppet 的实例，然后作为参数传给了 Wechaty 的构造函数，创建了一个新的 Wechaty 实例，然后启动了 Wechaty 实例。 中间用到了两个插件，一个是 EventLogger，可以把所有的 Wechaty 事件都打印到控制台中，另外一个是 QRCodeTerminal，可以把扫码事件里面的二维码直接打印到控制台，方便扫码登录。 上面的代码运行起来，就能看到命令行里打印的二维码，扫码之后就可以看到账号登录啦，效果如下： 19:27:44 INFO WeixinOpenAI constructor(your-, your-opena)19:27:44 INFO PuppetPadplus start()19:27:47 INFO WechatyPluginContrib EventLogger heartbeat:19:27:48 INFO WechatyPluginContrib EventLogger scan: http://weixin. qq. com/x/QfsfuToGOs-EVGgaa-gn,2,19:27:48 INFO WechatyPluginContrib QRCodeTerminal Login QR Code Status: Waiting(2)QR Code Image URL: https://wechaty. js. org/qrcode/http%3A%2F%2Fweixin. qq. com%2Fx%2FQfsfuToGOs-EVGgaa-gn19:27:55 INFO PadplusManager      =================================================      QRCODE_SCAN MSG : 已扫码，请在手机端确认登陆. . .       =================================================19:27:55 INFO WechatyPluginContrib EventLogger scan: ,3,19:27:55 INFO WechatyPluginContrib QRCodeTerminal onScan: Scanned(3)19:27:57 INFO PadplusManager      =================================================      QRCODE_SCAN MSG : 已确认      =================================================19:27:57 INFO WechatyPluginContrib EventLogger scan: ,4,19:27:57 INFO WechatyPluginContrib QRCodeTerminal onScan: Confirmed(4)19:28:03 INFO WechatyPluginContrib EventLogger heartbeat:19:28:03 INFO WechatyPluginContrib EventLogger login: Contact&lt;小助手&gt;实现素材推送: 这一步就比较容易，简单的代码逻辑实现一下就可以了 bot. on('message', async (message: Message) =&gt; { const room = message. room() const from = message. from() const mentionSelf = await message. mentionSelf() const text = message. text() if (room !== null &amp;&amp; from. id === bossId &amp;&amp; mentionSelf) {  if (/句子互动/. test(text)) {   await room. say(juzibotIntro)   await room. say(new UrlLink(juzibotIntroUrl))  } else if (/高原/. test(text)) {   await room. say(new UrlLink(yuanIntroUrl))  } }}). start()这样，当我在群里@机器人来介绍句子互动或者我自己的时候，机器人就会帮我自动发送一些介绍的话术，我就可以不需要 实现常见问答: 想让机器人帮我回答一些常见的问题，首先想到的就是直接通过关键词匹配来回复，三行搞定~ if (/句子互动/. test(message. text())) { await message. say(juzibotIntro)}但是，当我想要同时支持另外一个问题的时候，就有点不好办了 if (/句子互动/. test(message. text())) { await message. say(juzibotIntro)} else if (/技术栈/. test(message. text())) { await message. say(techStackAnswer)}如果问的问题是句子互动的技术栈是什么？，上面的代码就不能正确的回答上来答案了。当然，我可以通过调整两个if判断的顺序来解决这个问题，但是如果我有20个常见问题，这样的if-else写法一定有问题。除此之外，每个问题都可能有很多种不同的问法，比如说问我们公司介绍的，可能还会说：  你们公司做什么的？ 介绍下你们的情况？ 你们做什么业务的？ 等等……所以单纯用代码来写if-else是无法很好的解决这个问题的。 那么，是时候展现真正的技术了：微信对话开放平台 依照我个人的理解，微信对话开放平台是一个帮助你快速创建聊天机器人的云服务 配置微信对话开放平台: 那接下来，我们需要做的就是先注册一个微信对话开放平台的账号：https://openai. weixin. qq. com 然后在平台上创建一个机器人，我叫他我的助理，然后给他添加一个自定义的普通技能助理技能 接下来，就是给技能里面添加自定义的问答了，我创建了几个，如下图： 这里我遇到了一个麻烦的问题，我配置了关于句子互动和技术栈的问答，但是我发现当我问句子互动的技术栈的时候，匹配的是句子互动而不是技术栈，所以如上图可见，我在句子互动里面创建了一个反例。它的意思是，当问题匹配到这个相似问的时候，说明问题并不属于当前这个问答，这样就可以完美解决句子互动的技术栈匹配错的问题了。 将微信对话开放平台接入到 Wechaty 上: 为了方便接入，我写了一个Wechaty的插件 wechaty-weixin-openai 方便快速接入微信对话开放平台 首先，我把前面我们写的素材回复的代码封装成了一个函数，方便后面我们使用插件的时候来调用，并且我增加了一个boolean的返回值，目的是告诉调用的函数，我是否在当前函数里面对消息做了回复的处理，这样调用的函数知道我已经处理过这个消息了，就可以不再重复处理消息了。 const processCommonMaterial = async (message: Message) =&gt; { const room = message. room() const from = message. from() const mentionSelf = await message. mentionSelf() const text = message. text() if (room !== null &amp;&amp; from. id === bossId &amp;&amp; mentionSelf) {  if (/句子互动/. test(text)) {   await room. say(juzibotIntro)   await room. say(new UrlLink(juzibotIntroUrl))   return true  } else if (/高原/. test(text)) {   await room. say(new UrlLink(yuanIntroUrl))   return true  } } return false}然后，就是在Wechaty里面引用和配置插件了 const openAIToken = 'openai-token'const openAIEncodingAESKey = 'openai-encoding-aes-key'const preAnswerHook = async (message: Message) =&gt; { const isCommonMaterial = await processCommonMaterial(message) if (isCommonMaterial) {  return false }}/** * Use wechaty-weixin-openai plugin here with given config */bot. use(WechatyWeixinOpenAI({ token: openAIToken, encodingAESKey: openAIEncodingAESKey, preAnswerHook,}))插件的使用其实非常简单，只要传入微信对话开放平台里面开放服务接入的TOKEN和EncodingAESKey即可，就能连接到微信对话开放平台了 另外，大家可以看到，这个插件的配置里面还有一个叫做preAnswerHook的函数，这个函数的作用就如他的名字一样，是在wechaty-weixin-openai插件用微信对话开放平台的结果回复之前，调用的一个函数，可以让我们在回复之前做一些自定义的其他逻辑。 比如我们上面做的就是，当机器人检测到消息是在群里，并且是我发出的消息，而且匹配到了某个之前定义好的素材，那么就回复这个素材，并且不再进行后续的逻辑了（包括不使用微信对话开放平台返回的答案来回复） 这样，我们在使用微信对话开放平台的时候，就有一定的灵活度来搭配自己的自定义逻辑。 实现转接功能: 转接也比较容易实现，这里直接上代码： /** * Function to get boss contact */const getBoss = async () =&gt; { const contact = bot. Contact. load(bossId) await contact. sync() return contact}const noAnswerHook = async (message: Message) =&gt; { const room = message. room() const from = message. from() if (!room) {  const boss = await getBoss()  await room. say`${from}，你的问题我不会回答，你可以联系我的老板`  await room. say(boss)  return; } const members = await room. memberAll() const bossInRoom = members. find(m =&gt; m. id === bossId) if (bossInRoom) {  await room. say`${bossInRoom}，${from}问的问题我不知道，你帮我回答一下吧。` } else {  const boss = await getBoss()  await room. say`${from}，你的问题我不会回答，你可以联系我的老板`  await room. say(boss) }}/** * Use wechaty-weixin-openai plugin here with given config */bot. use(WechatyWeixinOpenAI({ token: openAIToken, encodingAESKey: openAIEncodingAESKey, noAnswerHook, preAnswerHook,}))这里新引入了另外一个wechaty-weixin-openai里面的函数noAnswerHook，同样，直译这个名字，就是这个函数的作用。当微信对话开放平台没有找到合适的回答的时候，会调用这个函数，这样我们可以在这个函数里面对于这种不清楚用户问什么的情况做一个兜底处理，比如我们这次就希望当不会回答的时候，可以把这个对话转接给我。 这样，在这个回调函数里面，根据当前对话发生在群聊还是私聊做了区分，如果是私聊，就直接发送我的名片来引导加好友了。如果发生在群聊，则先获取一下群成员，并且判断我是不是在群里，如果在的话，直接@我回复，不在的话，同样发名片，代码很简单。 截止到这，我们就已经基本完成了我们一开始设想的这些功能，但是我们能不能基于微信对话开放平台的AI能力，再玩出来点什么有意思的呢？ One More Thing: 最后，我们一起再来实现这样一个好玩的功能吧：当机器人识别出用户有负面的情绪，则给我和那个用户拉一个群，然后让我来和用户沟通 说干就干，下面是代码： const preAnswerHook = async (message: Message, _: any, sentiment: SentimentData) =&gt; { const isCommonMaterial = await processCommonMaterial(message) if (isCommonMaterial) {  return false } const hate = sentiment. hate const angry = sentiment. angry const score = (hate || 0) + (angry || 0) if (score &gt; 0. 9) {  const boss = await getBoss()  const from = message. from()  const room = await bot. Room. create([boss, from])  await new Promise(r =&gt; setTimeout(r, 3000))  await room. say`${boss}，你帮帮我吧，${from}和我聊天已经聊得不耐烦了`  return false }}bot. use(WechatyWeixinOpenAI({ token: openAIToken, encodingAESKey: openAIEncodingAESKey, includeSentiment: true, noAnswerHook, preAnswerHook,}))这里用到了新的插件参数includeSentiment，这个参数决定在preAnswerHook函数里面是否同时传入微信对话开放平台里查到的当前消息的情绪值参数，我们这里是设置成了true，这样会在preAnswerHook函数里面带上情绪数据。 然后，我们基于这个情绪数据，来判断当前用户是不是出于一个负面情绪很重的状态中，如果是的话，则执行拉群，向我求助的操作。 PS：在现场演示过程中，我们的测试了很多种的负面情绪的消息，但是有一些消息的解析并不如我们所料，所以最后选择了使用hate加上angry的和来表示负面情绪。 最后效果: 完整代码请见 https://github. com/windmemory/wwc-wechaty Live Coding:   Bilibili: https://www. bilibili. com/video/BV1LV411r756/ 微信对话开放平台: 微信对话开放平台 是以对话交互为核心，为有客服需求的个人、企业和组织，提供智能业务服务与用户管理能力的技能配置平台，技能开发者可利用平台提供的工具自助完成客服机器人的搭建。 Women Who Code: Women Who Code Beijing 于2015年10月在北京成立，希望能够帮助和鼓励在这个城市生活和工作的 女性工程师在职业发展的道路上顺利前行。我们相信IT行业也会因为有更多的女性的加入变得更有生产力和创造力。  Author: @windmemory Wechaty contributor, author of wechaty-puppet-padchat, wechaty-puppet-padpro, wechaty-puppet-padplus. CTO of Juzi. Bot  Code: wwc-wechaty "
    }, {
    "id": 273,
    "url": "https://wechaty.js.org/2020/07/20/wechat-purchasing-robot/",
    "title": "微信代购机器人（WeChat Purchasing Robot）",
    "body": "2020/07/20 -  背景: 女朋友在做代购，加了很多微信好友和微信群，所以每天会有很多人前来咨询商品信息以及商品价格，因此想做一个管理机器人，用于自动回复消息、群管理以及自动添加好友，以及用户发送商品关键词能够自动回复相应商品信息。 功能:  自动处理好友请求 私聊关键字回复 通过指令完成指定任务 群管理（拉人进群、踢人出群、@群成员） 发送图片、链接、名片在有人咨询商品信息的时候，比如发送有关于【香水】的话题，便自动回复有在售出的香水商品列表，包含了商品不同尺寸下的价格。 结构: |-- img           # 储项目所使用到的图片与其他相应资源。|-- src/|---- listeners/|------ on-scan. js     # 机器人需要扫描二维码时监听回调|------ on-room. js     # 进入房间监听回调|------ on-message. js    # 消息监听回调|------ on-friend. js    # 好友添加监听回调|---- config. js       # 配置文件|---- index. js       # 入口文件|-- package. json依赖: wechaty：wechaty 核心库wechaty-puppet-padplus：wechaty的ipad协议实现 代码介绍: // initconst bot = new Wechaty({ puppet: new PuppetPadplus({  token: config. token }), name: config. name})bot. on('scan', onScan) // 机器人需要扫描二维码时监听bot. on('login', (user) =&gt; log. info('StarterBot', '%s login', user))bot. on('logout', (user) =&gt; log. info('StarterBot', '%s logout', user))bot. on('message', onMessage(bot)) // 消息监听bot. on('friendship', onFriendShip) // 添加好友监听bot. on('room-join', onRoomJoin) // 加入房间监听bot . start() . then(() =&gt; {  log. info('StarterBot', 'Starter Bot Started. ') }) . catch((e) =&gt; log. error('StarterBot', e))本地运行:  克隆项目git clone https://github. com/zoudingyi/wechaty-robot. gitcd wechaty-robot 安装依赖npm install 启动项目npm run serve使用:  打开src/config. js 文件 修改config配置 运行项目其他功能效果: 致谢: 非常感谢Wechaty团队提供微信机器人SDK，让开发者可以专注于业务代码。感谢句子互动提供的pad协议版token。wechaty: https://wechaty. github. io/juzibot: https://www. juzibot. com  作者: DevoZouCode: Github "
    }, {
    "id": 274,
    "url": "https://wechaty.js.org/2020/07/19/wechaty-puppet-dingtalk/",
    "title": "基于开放 API 封装 Wechaty 接口下的钉钉聊天机器人",
    "body": "2020/07/19 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [基于开放 API 封装 Wechaty 接口下的钉钉聊天机器人] 系 暑期2020 支持的开源项目。 [基于开放 API 封装 Wechaty 接口下的钉钉聊天机器人]具体计划:  导师：高原 李佳芮 学生：杨明哲 模块列表     接收消息   发送消息   通讯录获取   配置文件设计   使用文档    计划安排：     接收消息         7. 1 - 7. 19     开通 DingTalk 开发者平台     学习 Dingtalk Robot 的制作方法     使用 outgoing 机制接受消息          发送消息         7. 20 - 7. 26     使用 webhook 机制发送消息     完成消息类型的 API 编写          通讯录获取         7. 27 - 8. 2     获取通讯录的成员     设计 contact 类          整理代码         7. 3 - 8. 17     完成 npm 发包、持续集成等问题     整理代码，修改不优雅的代码          配置文件设计         8. 3 - 8. 23     设置配置文件          使用文档         8. 24 - 8. 31     编写文档          自由发挥         9. 1 - 9. 30     完善代码，视情况增加新功能           项目链接：https://github. com/jihuayu/wechaty-puppet-dingtalk               联系方式：+86 13705936598     email: 8042833@qq. com           Author: @jihuayuCode: @jihuayu/wechaty-puppet-dingtalk "
    }, {
    "id": 275,
    "url": "https://wechaty.js.org/2020/07/19/wechaty-plugin-youdao/",
    "title": "有道智云翻译插件",
    "body": "2020/07/19 -  有道智云翻译插件: 以 wechaty 插件的形式集成有道智云翻译的能力，让更多的开发者可以很便捷的对机器人添加具备翻译的功能。有道智云是有道官方的云平台，提供翻译的能力。相关 API 文档 功能: 提供翻译能力，通过微信发送待翻译文本，例如 hello 给机器人，机器人回复翻译的结果和发音音频。发音音频需要应用绑定 语音合成服务由于不支持 Voice 的消息类型，所以只能以 UrlLink 的形式回复发音音频。 具体实现: 插件能力为 Wechaty 本身就提供的能力，主要用 got 对有道智云的翻译 API 进行调用。 单元测试: 主要使用 wechaty-puppet-mock 进行单元测试，好处就是不需要频繁的登录扫码等动作，可以直接 mock 一些机器人的行为还有用户行为。这里介绍一下如何使用单元测试对机器人进行测试，笔者用的是 jest 测试框架。这里跳过 jest 的配置说明。官方文档在写测试用例的过程中，觉得还是 jest 使用起来比较顺手一些，建议可以跳出官方的 example 使用 jest 体验一番。 测试准备: wechaty 的行为都通过 puppet 进行代理，这里需要准备几个对象 mocker puppet wechaty async function wechatyFixtures() { const mocker = new Mocker() const puppet = new PuppetMock({ mocker }) const wechaty = new Wechaty({ puppet }) await wechaty. start() const [user, contact] = mocker. createContacts(2) await mocker. login(user) return {  wechaty,  user,  contact,  mocker, }}mocker. login(user) 让 wechaty 以 user 的身份进行登录，当其他用户向 user 发送消息时， wechaty 所监听的事件 message 就会触发。 测试用例: 以 test case: wechaty 回复翻译结果 为例： const { contact, user, wechaty } = await wechatyFixtures()const CONFIG = { appId, privateKey,} as YouDaoTranslatorPluginOptionwechaty. use(wechatyYouDaoPlugin(CONFIG))// 插件收到消息回复翻译结果contact. on('message', (message) =&gt; { const res = message. text()! expect(res). toBe('你好') done()})// contact 向 wechaty 发送消息contact. say('Hello'). to(user)本插件的行为比较简单，所以对单元测试用例的编写也比较容易，可以参考issues#37 结语: wechaty-puppet-mock 目前的 API 并没有与 wechaty 完全一致，例如没办法发送除了 Text 以外的消息类型，如 UrlLink 等。关于这个问题提了一个 Issue 大家可以一起讨论。感谢wechaty团队提供微信机器人SDK感谢句子互动提供的iPad协议版token  作者: Chs97Code: Github "
    }, {
    "id": 276,
    "url": "https://wechaty.js.org/2020/07/19/go-wechaty-plugin-dev-plan/",
    "title": "暑期2020 [为 go-wechaty 设计实现插件体系] 计划书",
    "body": "2020/07/19 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [为 go-wechaty 设计实现插件体系] 系 暑期2020 支持的开源项目。 [为 go-wechaty 设计实现插件体系]具体计划:  导师：丁小雨、丁超飞、李博杰 学生：林昊翰 模块列表     设计 Go 的 Plugin 机制   实现 go-wechaty plugin 并完成一个 demo    计划安排：     模块一         预期完成时间：8月15日     模块描述：编写插件机制设计文档。其中，文档包含设计思路，实现逻辑，以及涉及到项目的变更等。根据 Go 语言特性，对插件机制的设计进行改进，并且尝试思考更多可能的方案。如果有需要，还应该编写相应的试验代码。          模块二         预期完成时间：9月30日     模块描述：根据第一阶段的设计文档编写代码，实现 go-wechaty 的插件机制；使用 go-wechaty 插件机制编写一个插件 Demo。           项目链接：wechaty/go-wechaty 联系方式：finctive@foxmail. com 进度报告：为 go-wechaty 设计实现 插件体系 · Issue #9 · wechaty/summer-of-code"
    }, {
    "id": 277,
    "url": "https://wechaty.js.org/2020/07/18/wechaty-words-per-day-plugin-plan/",
    "title": "暑期2020 [编写一个“每日一句”插件] 计划书",
    "body": "2020/07/18 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。 官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html 本项目 [编写一个“每日一句”插件] 系 暑期2020 支持的开源项目。 编写一个“每日一句”插件具体计划:  导师：gcaufy 学生：univerone 模块列表     开发插件的基本框架   发布NPM包，引入CI/CD   丰富语料库   进行测试，完善项目文档   根据群名推荐每日一句的发送内容（可选）    计划安排：     开发插件的基本框架         7/1 - 7/21     插件的输入参数有：使用的内置API接口名称、应用的群聊名称以及发布每日一句内容的时间，完成基本代码构建。插件能够设置定时发送的时间、群名、发送的内容，也可以根据请求结构中的图片地址下载图片，并根据每日一句内容以及微信群的相关信息添加水印。     基本步骤          发布NPM包，引入CI/CD         7/22 - 8/05     进一步优化代码以及注释，引入CI/CD来进行代码质量控制以及包的版本管理     无          丰富语料库         8/06 - 8/20     首先确定使用的API接口或者爬取的网址，根据不同的网址进行不同的解析，返回指定的结果。构造请求并解析内容，返回需要的字符串（每日一句的内容或者图片的URL）。如有余力的话，能够支持用户自主设定语料的来源。     无          进行测试完善项目文档         8/20 - 9/03     完善项目文档，撰写整个项目过程的总结文章。增加单元测试等。     无           项目链接：https://github. com/univerone/WordsPerDay 联系方式：univerone@outlook. com 作者: univeroneCode: Github "
    }, {
    "id": 278,
    "url": "https://wechaty.js.org/2020/07/18/python-wechaty-meme-bot/",
    "title": "基于Python-wechaty建立一个斗图机器人",
    "body": "2020/07/18 - “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。 旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。 根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。 官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html 本项目 [基于Python-wechaty建立一个斗图机器人] 系 暑期2020 支持的开源项目。 [基于Python-wechaty建立一个斗图机器人]具体计划:  导师：黄纯洪 学生：肖子霖 模块列表 项目初步规划图（可能有调整）      数据库管理   针对静态表情包的特征提取模块调试与开发   适配K-means算法   回复表情包的策略及开发   OCR模块包装    计划安排：     数据库管理         已完成     为表情包的标题、关键字、特征等信息提供数据库支持，使用了peewee作为ORM框架；          针对静态表情包的特征提取模块调试与开发         预期完成时间：2020年07月25日     使用Pytorch编写特征提取模块，为了测试特征提取效果需要比较InceptionV3、MobileNet等多个经典网络；     备注：由于表情包难以用传统图片分类思路进行训练，这个过程只能使用在ImageNet等公开数据集上的模型（移除全连接层后）；          适配K-means算法         预期完成时间：2020年08月01日     将scipy中的kmeans算法适配进项目，以用于聚类未做标记的表情包数据集；     备注：无          回复表情包的策略及开发         预期完成时间：2020年08月03日     将初步规划图中的回复策略适配python-wechaty体系，包括前后端体系；     备注：参考ding-dong-bot逻辑编写；          OCR模块包装         已完成     包装chineseocrlite，支持竖排文字，识别准确率尚可；     备注：无          以上所有模块开发完成后，我均会利用unittests模块编写单元测试；  项目链接：@Fighting-Meme-python-wechaty 联系方式：me#mrxiao. net (# -&gt; @) Author: @MrZilinXiao Always dedicated to learn something brand new. Code: @Fighting-Meme-python-wechaty "
    }, {
    "id": 279,
    "url": "https://wechaty.js.org/2020/07/18/python-wechaty-groupchat-assistant-bot/",
    "title": "基于python-wechaty的群聊助手机器人",
    "body": "2020/07/18 - 暑期2020: “开源软件供应链点亮计划-暑期2020”（以下简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html本项目 [基于python-wechaty的群聊助手机器人] 系 暑期2020 支持的开源项目。 [基于python-wechaty的群聊助手机器人]具体计划:  导师：吴京京 学生：孔祥哲 模块列表     群聊消息打标插件   定时消息插件   群成员管理插件   对前几个模块的交互方面进行提升   （选做）rasa chat bot 插件    计划安排：     群聊消息打标插件         7. 1 - 7. 19     该模块为本项目的基本要求，需要实现通过引用消息进行回复对重要的群聊消息进行打标，并存入本地的数据库。在对应问题被提出时机器人能通过搜索存储的打标消息给出相应的回答，如果匹配的答案置信度不高，则提供可能的关键词向用户进行确认。同时支持展示全部或一定时间段内的打标消息，用户可以对其中的消息进行手动删除或定时删除，打标消息本身也可以提供有效期参数，在过了有效期后自动删除。提供帮助系统，用户可随时查看不同功能的帮助信息。     基本功能          定时消息插件         7. 20 - 7. 26     用户指定消息内容和发送时间，由机器人定时发出消息。     扩展功能          群成员管理插件         7. 27 - 8. 2     进行踢人和进群欢迎的管理，踢人要求3位以上群成员对某人表示不满。此插件需要机器人拥有相关的权限。     扩展功能          对前几个模块的交互方面进行提升         8. 3 - 8. 23     对交互方面进行统一优化，提高解析用户命令时的容错性，目前已有的想法是尝试用深度学习方法对问答系统的匹配准确性进行提升（在基础版本中使用 cosine 相似度对问题和答案进行匹配）、在用户命令解析失败但和某些模式很相近时进行确认等。同时该过程中会不断模拟用户场景发现机器人在交互上不够人性化的地方并进行修正。     扩展功能          （选做）rasa chat bot 插件         8. 24 - 8. 31     接入rasa chat bot 的API，此为选做内容，如果在以上内容都完成且仍有较充裕的时间的情况下，可以考虑尝试进行制作。     选做内容           项目链接：https://github. com/kxz18/python-wechaty-groupchat-bot               联系方式：+86 15068701650     e: 15068701650@163. com           Author: @kxz18Code: @kxz18/python-wechaty-groupchat-bot "
    }, {
    "id": 280,
    "url": "https://wechaty.js.org/2020/07/17/wechaty-teamin-assistant/",
    "title": "用 Wechaty 实现微信任务小助手（wechat teamin chat robot）",
    "body": "2020/07/17 -  Wechaty实现微信上的任务小助手: 缘起: iphone自从增加了屏幕时间提醒以后，我惊奇的发现，现在一天有超过一半的时间都在看手机，而这么长的时间里面超过80%的时间在微信。。。可能这是很多人日常生活的一个缩影，慢慢地我们会发现，生活重的各种点滴都开始会和微信关联起来。 知道有Wechaty以后，我萌生了一个想法，是否可以在微信上做一个小助手，让她来帮我管理日常生活中的各种琐事呢？当有什么需要做的事情，就直接告诉小助手，他帮忙记录下来，等到了时间就来提醒我，想想就很爽，比打开一个效率管理的App一字字输入日程安排要简单多了。小助手也可以做的更拟人化一些，让我觉得就好像真的是自己的一个助理。 挑战: 设计思路: 其实结构比较简单，我想了一下，一个最简单的实现结构是这样的 怎么接入Wechat，实现微信消息的收发，这个官方文档已经说的很详细了，这里就不多说了。针对任务助手这块，要实现通过小助手把任务添加进来，对话的意图分析和关键词获取是最核心的两个步骤 意图分析之前曾经对比过百度的UNIT、微软的Luis以及腾讯、讯飞的对话平台，效果最好的感觉还是微软的Luis，因此这里选择用他们的方案来做意图理解。 关键词获取在Luis的意图分析中可以通过Entity顺便挑选出一些想要的词汇，但这些对于添加一条任务来说，还是远远不够和一般我们看到的客服对话不太一样，添加任务的对话场景是开放式的，因此常规的这种关键词获取并不能满足我们的要求比如：  提醒我明天上午去开会 提醒我后台去出差这两句话中，提醒、时间词，这些都很好通过Entity挑选出来，比较难的是，任务的主题：开会、出差任务主题的范围是开放式的，没有办法预料会有什么内容，也没有办法去限制，如果有一天小助手突然对你说，只能跟我说提醒你开会啊，那是一种什么样的心情。。。 为了能够精准获取主题的内容，语法结构就派上用场了，具体怎么分析，不属于这篇Blog的范畴，就不详细说啦。大致的思路是通过语法结构分析，找出用户表达内容的部分，去掉一些无用的词汇，就可以形成主题了，说起来很简单，做起来嘛，嘿嘿。。。 嗯，大致的思路有了，开始搞一把。基本逻辑是：  我发送语音、文字给微信 小助手通过Wechay接口获取我的信息，如果是语音，转成文字 将文字传送给Luis进行意图分析，同时获取一些简单的关键词：时间、地点、人物等 将句子进行句法分析，再抽取出任务的主题 形成业务逻辑，往数据库中记录任务 同时会有一个定时任务，定期检查任务是否到期，如果到期，通过Wechaty给我发送消息效果尝试: 由于任务主题的提取是一个非常难得事情，很难做到尽善尽美，不过常用的提醒任务都是没问题的，效果还是挺好的。我们来看些例子： 在这里，向小助手提的要求是：提醒我后天上午10点去三楼开会在这句话中，我、后天上午10点，这两个关键词都可以在意图分析的时候，直接返回出来按照前面说的，通过句法结构分析，我们发现，我、后天上午10点去三楼开会，都是提醒的宾语，通过这个可以抽取出主题：去三楼开会看起来是不是也不太难，嘿嘿。 那咱们来个复杂的： 这次的话术是：明天上午10点与客户开会，提醒一下小明下午3点之前把会议资料准备好 这个结构就复杂了，在这里，小明是这件事情的负责人，同时这里有两个时间：明天上午10点，下午3点之前这句话的难点是：  判断小明是负责人 两个时间，上午10点是开会的正题，下午3点之前是需要准备资料的时间 得出主题：与客户开会，把会议资料准备好，不能有多余的无用的词具体怎么做，有兴趣的小伙伴可以自己研究研究，还是挺有意思的。 写在最后: 微信现在已经演变成了一个人和人之间的连接工具，对话慢慢会变成以后应用的主流，Wechaty的出现让我们进行类似这样的尝试有了新的机会，还是非常感谢Wechaty的作者们的辛勤努力的。可以畅想，未来一定会出现一个更加智能的对话小助手，它可以帮你解决身边各种复杂的问题，希望这一天能够早点到来，：） 大家也可以加我们的小助手为好友，体验一下对话任务协作的功能，多多给我们提建议哦。  作者: darkli "
    }, {
    "id": 281,
    "url": "https://wechaty.js.org/2020/07/15/wechaty-forwarder-bot/",
    "title": "微信转发机器人(wechaty-forwardbot)",
    "body": "2020/07/15 - 运营群需要有价值的内容，才能把用户留住。但是自己又懒得搞这些内容所以最好就是,直接把别人群有价值的内容转发到自己群既能偷懒，还能留住用户，岂不美哉？ 功能: 判断n个群里面是否存在xxx关键词是则转发至自己的n个群 逻辑:  监听配置好指定的群消息 判断是否存在某个关键词 存在则转发到配置好的群依赖:  wechaty：wechaty核心库 wechaty-puppet-padplus：wechaty iPad协议 qrcode-terminal: 终端输出二维码运行: 克隆项目 git clone https://github. com/22528850/wechaty-forwardbotcd wechaty-forwardbot安装依赖 npm install启动项目 node index. js开发: . on('message', v =&gt; { let from = v. from(), room = v. room() if(!room) return if(v. type() == 0) return if(v. type() != 7) return toRoom() // 文本消息逻辑处理 // 是否为监听群 if(config. group. indexOf(room. payload. topic) &lt; 0) return // 是否存在关键字 for (let k in config. keyWord) if(v. text(). indexOf(config. keyWord[k]) &gt;= 0) return toRoom() // 循环发送转发群 function toRoom() {  for (let k in config. toGroup)  ((k)=&gt;{   setTimeout(async i =&gt; {    let Room = await bot. Room. find({topic: config. toGroup[k]})    if(Room) v. forward(Room)   },(Number(k)+1)*config. sstg)  })(k) }})致谢: 感谢wechaty团队提供微信机器人SDK感谢句子互动提供的iPad协议版token  Author: xiaokCode: Github "
    }, {
    "id": 282,
    "url": "https://wechaty.js.org/2020/07/12/wechat-roommessage-bot/",
    "title": "群消息同步机器人",
    "body": "2020/07/12 -  背景: 前几个月出差，公司租用的公寓房东提出了一个想法1 租户大概有几百户2 租户有散户，也有公司长期出差统一租赁（例如我）3 很多微信群管理起来很麻烦 于是有了这个需求的模型：1 机器人存在于多个群组中 ，例如 散户1群 ，囧东出差群，渣浪出差群，企鹅出差群，。。。。（排名不分先后）2 有个管理群组，只有房东及工作人员在其中3 租户在自己的群中@机器人，提出自己的问题， 机器人会将内容转发至 管理群4 房东接受问题，或将问题处理完后，可以回复相应信息，机器人会在对应的群众转发房东的回复并@租户5 房东可以在管理群中发送公告 ，同步至所有的机器人所在的群 功能:    咨询 ：@机器人 【咨询】你要咨询的内容     回复 ：@机器人 msgId:xxxxoooo【回复】你要回复的内容     公告：@机器人 【公告】公告内容  实现逻辑:  监听群消息，分析消息文本，使用 【】作为关键次标识，然后进行相应的消息发送依赖: wechaty：wechaty核心库wechaty-puppet-padplus：wechaty的ipad协议实现 实现过程: 具体代码可以上github参看 Github 本地运行:  克隆项目git clone https://github. com/sidny/wxbot. git 安装依赖npm install 启动项目npm run serve效果图:    咨询     回复     公告  致谢: 非常感谢 Wechaty 团队提供微信机器人SDK，让开发者可以专注于业务代码。感谢 句子互动 提供的pad协议版token。 wechaty：https://wechaty. github. io/句子互动：https://www. juzibot. com/  作者: sidnyCode: Github "
    }, {
    "id": 283,
    "url": "https://wechaty.js.org/2020/07/11/wechaty-daily-report/",
    "title": "用 Wechaty 实现工作日报管理系统",
    "body": "2020/07/11 -  背景: 我们日常每天都需要写日报,用来汇报今日工作内容和明日工作计划。日报内容维护在 wiki 里面。团队 TL 每天会去 wiki 上收集工作内容；在发送到公司大群。但是每天会有小伙伴会忘记写。 导致 TL 没办法收集今日内容。很是苦恼。还有每次编写都需要去 wiki 挨个复制每个人的。 工作效率很低； 思考: 之前也了解过 wechaty，就想着是否可以做一个每天快下班提醒团队小伙伴，维护下工作日报。以及团队 TL 便捷获取团队所有日报的系统。不需要一个个复制； 项目地址: github:https://github. com/zzhoouxin/wechaty-bot 基础依赖:  wechaty –微信操作 node-schedule –定时任务 superagent –接口请求 cheerio – 抓取数据 qrcode-terminal –终端显示二维码功能:  定时提醒组内小伙伴填写工作日报以及发送工作日报到工作群 根据关键字自动发送日报内容 后续功能…(等待和小组人员讨论)项目成果:  日常提醒  定时发送日报  根据关键字发送日报内容 1. 项目结构:  bot 存放 wechaty 每个状态的回调函数 schecdule 定时任务-获取日报并发送 config 基本配置-链接、群号等 tool 封装基础请求、公共方法 index. js 启动入口1. index. js – wechaty 启动入口: import {Wechaty} from 'wechaty'import {PuppetPadplus} from 'wechaty-puppet-padplus';import config from '. /config'import onScan from '. /bot/onScan'import onLogin from '. /bot/onLogin'import onMessage from '. /bot/onMessage'import onLogout from '. /bot/onLogout'const bot = new Wechaty({  puppet: new PuppetPadplus({    token: config. TOKEN  }),  name:  小艾 });bot  . on('scan', onScan)  . on('login', onLogin(bot))  . on('logout', onLogout)  . on('message', onMessage(bot))  . start()  . then(() =&gt; console. log('开始登陆微信'))  . catch(e =&gt; console. error(e))这边使用的是wechaty-puppet-padplus基于 ipad 协议进行开发的；scan login logout message这些是 Wechaty 的基础回调事件。 2. config 基础文件配置这里面都是自己基于自己业务的参数-如果您也是用confluence wiki 那可以参考下: // 配置文件module. exports = { // 每个人对应页面的ID ALL_USER_LIST: [  { id: 27169291, name: '小人头'}, ], WITHDRAWA_DATE: '00 50 17 * * *', //定时任务事件 COLLOECT_DATE:'10 30 09 * * *', // 定时任务事件 WIKI_URL: 'http://wiki. xxxxx. com/pages/viewpage. action?pageId=', //wiki内容地址 TOKEN: 'puppet_padplus_xxxxx',//token ROOM: '22186778457@chatroom',//需要发送的群号 KEYWORDs:['本组','全部']}; 里面的 wiki_url 是我们自己平常填写日报的 wiki 地址。如果您使用其他方式-那就具体情况具体分析 3. 定时任务提醒:  在登录后启动定时任务这边我们就使用到了- node-schedule 这个 node 库 当然可以配置他的启动时间。可以查看官网详细说明。 3. 1 首页我们在 wechaty 的 onlogin 事件里面加入定时任务: import dailyRemind from '. . /schedule/dailyRemind'import collectContent from '. . /schedule/collectContent'/** * 扫码登录 * @param qrcode * @param status */module. exports = bot =&gt; {  return async function onLogin() {    await dailyRemind(bot);//日常提醒    await collectContent(bot);//所有汇总  }}3. 2 创建一个定时提醒的任务:  通过 bot. Room. find(id) 找到需要提醒的群 在使用 announce 创建群公告 @所有人 即可做到提醒import schedule from '. /index';import config from '. . /config';import utils from '. . /tool/utils'module. exports =async function dailyRemind(bot) {  schedule. setSchedule(config. WITHDRAWA_DATE, async () =&gt; {    if(!utils. judgeIsJob()){ //周末的话，不做提醒      return false;    }    try {      //提醒组内人发送日报      const searchRoom = await bot. Room. find({ id: config. ROOM});      await searchRoom. announce( 快下班了~大佬们可以更新一下日报啦~/:@) )    } catch (e) {      console. log( error: ,e. message);    }  });}#4. 根据关键字。发送日报内容:    上图中 机器人会自动提示，需要回复什么关键字。当然这一步是我们自己配置的。在 config. js 里面有关键字配置属性。直接看代码     机器人自动回复-就需要在message事件里面处理啦-message 的官方文档  // 监听对话import { Message } from 'wechaty';import config from '. . /config';module. exports = (bot) =&gt; { return async function onMessage(msg) {  const contact = msg. from(); // 发消息人  const content = msg. text(); //消息内容  const room = msg. room(); //是否是群消息  if (msg. self()) {   return;  }  //如果是文本消息  if (msg. type() == Message. Type. Text) {   // await textJ(bot);   if (room) {    console. log('room===&gt;', room);    // 如果是群消息    const topic = await room. topic();    console. log(     `群名: ${topic} 发消息人: ${contact. name()} 内容: ${content}`    );   } else {    let info = `日报查询仅支持2种，回复【】内文字即可查询~\n`;    config. KEYWORDs. map((v) =&gt; {     info += '【' + v + '】' + '\n';    });    msg. say(info);   }  } };};5. 获取自己需要的信息:  上文中提交到我们有日报填写的地址 以及 superagent 和 cheerio2个依赖库-主要用到请求我们日报地址 并且获取所需要的内容 这个是我们 wiki 文档的项目结构-我们首先需求通过 superagent 请求访问该页面-并且通过 cheero 获取内容。当然这 2 个依赖库使用。建议先熟悉一下官方文档。下文代码做了一些兼容– async function collectUserContent() { let str = ''; for (let user of config. ALL_USER_LIST) {  const url = `${config. WIKI_URL}${user. id}`;  const res = await fetch(url);  let $ = cheerio. load(res. text);  // const data = $('. wiki-content . p1'). text();  str += `\n ${user. name} \n`;  $('. wiki-content p'). each(function (i, e) {   let text = $(e). text();   if (text !== '\xa0') {    str += ` ${text} \n`;   }  });  $('. wiki-content . p1pkss0x'). each(function (i, e) {   let html = $(e). children();   if (html. length === 0) {    let text = $(e). text();    if (text !== '\xa0') {     str += ` ${text} \n`;    }   }  });  $('. wiki-content . pd7nslm'). each(function (i, e) {   let html = $(e). children();   if (html. length === 1) {    let text = $(e). text();    if (text !== '\xa0') {     str += ` ${text} \n`;    }   }  }); } return str;}获取到自己需要的内容，依旧可以通过room. say发送出去; 至此我们一个简单的日报收集的系统机器人简单的实现了。 总结: 相信很多公司都有发送日报的要求,以上代码实现也是依赖了自己所需业务场景进行实现。通过 wechaty 改变了我们传统的工作流程。大大的提高了工作效率。避免很多重复行为。当然还有更多好玩有趣的功能区可以加入。希望自己可以和团队进行沟通，提高我们流程。大家可以参考以上流程。  作者: zzhoouxinCode: Github "
    }, {
    "id": 284,
    "url": "https://wechaty.js.org/2020/07/09/wechat-music-daycard/",
    "title": "每日微信音乐卡片分享机器人（wechat-daycard）",
    "body": "2020/07/09 -  背景: 公司app有一个呢喃打卡的活动，现有的方式是在app分享图片和H5的二维码。现利用wechaty，基于每日数据接口，获取到当日的歌曲和图片，利用现有的听歌小程序结合微信个人头像和昵称，做一个在群里面就能实现打卡分享每日歌曲图片的这么一个机器人。 功能:  群里回复打卡，合成歌曲分享图片（分享图+微信头像+微信昵称+小程序歌曲码）实现逻辑:  监听群消息，获取打卡人的头像和昵称，这一块wechaty已经做的差不多了，我只需要简单的几行代码搞定； 请求每日数据接口，拉取到当日的歌曲id和对应的分享封面图； 保存拉取到的图片网络连接到本地 根据歌曲id生成对应的小程序码，这一步需要小程序服务端的相关功能 合成图片，这一块利用gm来实现 发送图片消息给用户依赖: wechaty：wechaty核心库wechaty-puppet-padplus：wechaty的ipad协议实现gm: 图片合成axios: 发请求 实现过程: 具体代码可以上github参看 Github 本地运行:  克隆项目git clone g https://github. com/leijiahang/wechat-daycardcd wechat-daycard 安装依赖npm install 启动项目node app. js效果图: 致谢: 非常感谢Wechaty团队提供微信机器人SDK，让开发者可以专注于业务代码。感谢句子互动提供的pad协议版token。  作者: leijiahangCode: Github "
    }, {
    "id": 285,
    "url": "https://wechaty.js.org/2020/07/07/wechat-poem-robot/",
    "title": "用 Wechaty 实现微信诗歌搜索机器人（wechat poem robot）",
    "body": "2020/07/07 -  微信机器人: 微信机器人是很常见的运营工具，不仅能够给微信群带来活跃度，还能针对各种社群开发不同的玩法。 我想要做的是一个诗歌机器人，当群内有人@机器人或者用搜索词触发时，机器人从已有的诗歌数据库中查询一首相关的诗歌，以文字形式回复在群内。 有了这个目标以后，我开始了漫长的折腾。 之所以说是折腾，是因为这一路真是障碍重重。 首先，微信官方并没有相关的 API。可能要考虑考虑企业微信？结果发现企业微信有群机器人，但只支持发送信息，不支持接收。还是得找微信个人号 API。 然后我看了看基于 Web 版微信的各种开源方案，最近一次更新基本是几年前的，issue 列表里常常看见登录不了 Web 版微信的问题。我试了试自己开发用的微信小号，登不了 Web 版微信，放弃。 再然后我试用了基于 PC 版微信的 Mocha-L/WechatPCAPI。虽然能用，但是有不少问题。比如获取不了昵称带 emoji 的用户的消息，每次修改完代码必须手动重新启动微信。我相信这些都是可以解决的，但是开发者并没有完全开源核心代码，无从下手。项目主页上写的是有免费版和收费版，我只成功运行了收费版，十几天后，提示试用到期了。这个基于非常规的 HOOK 的方案只能用指定版本的 PC 版微信，需要 Windows 运行环境。考虑到我需要的是一个较长期稳定运行的 API，且能在 Linux 服务器上使用，而且收发信息相对安全，我只能继续寻找更好的方案。 折腾到这里，我已经对各类方案有了基本了解：主要有 Web 网页端、Xpsoed 技术、PC Hook、iPad 协议、模拟机、MAC 协议这六类方案，从稳定性和安全性上比较，iPad 协议和 Mac 协议的方案是比较好的，商业上的应用也比较多。 此时我找到了 beclass 的博文 《基于Nodejs+Wechaty开发微信机器人管理平台》。发现了 Wechaty 这个项目，支持 iPad 协议，虽然需要付费获取 token，但是可以申请参与开源激励计划来获取免费甚至长期有效的 token。 具体实现: 基本构架: 由于前期尝试各种个人号 API 的方案，已经把搜索诗歌的部分独立出来作为一个服务。这个搜素服务接受查询字符串，返回一个包含结果的 json 字符串。 至于跟微信相关的部分，就全部交给 Wechaty 了，包括接收微信消息，查询到诗歌内容以后发送微信消息。 诗歌搜索服务: 此部分用 PHP+MySQL 实现。诗歌数据库是从某诗歌博客数据库导入，并且用爬虫抓取相关微信公众号文章信息（机器人可以发送公众号文章链接）。 此部分的难点在于博客数据库的诗歌并没有区分标题、内容、诗作者等字段，需要用正则表达式匹配出各个字段内容。虽然大部分的诗歌是有固定格式的，可以通过特定的 html 标签确定标题、诗作者在整个字符串的位置，但不同时期添加进数据库的诗歌格式有细微的区别。 一开始，我试图用一个正则表达式描述尽可能多的格式类型，并且在其中描述所有字段的位置。在折腾了一阵以后我放弃了。 由于对正则表达式具体运行机制不熟悉，它在我眼里就是那种一看就懂，一写就错的外星语言。我需要一个工具来展现正则表达式如何一步步匹配目标字符串，加速我的正则调试过程。 Windows 平台下，我用过 RegexBuddy。我发现了一个更好的 Web 平台正则调试工具 regex101。它不仅能清楚标注匹配结果，还能展现正则一步步匹配的过程，这对于调试来说至关重要。  除了用正则提取诗歌各字段，还需要匹配各种可能句式中的关键词。测试用例如下： public function testGetKeywordStartWithSearch() {  $this-&gt;assertEquals('', getKeyword('搜索'));  $this-&gt;assertEquals('诗', getKeyword('搜诗'));  $this-&gt;assertEquals('小黄诗', getKeyword('搜小黄诗'));  $this-&gt;assertEquals('一下', getKeyword('搜索 一下'));  $this-&gt;assertEquals('一下', getKeyword('搜 一下'));  $this-&gt;assertEquals('大人', getKeyword('搜大人'));  $this-&gt;assertEquals('你大爷', getKeyword('搜你大爷'));  $this-&gt;assertEquals('大人', getKeyword('搜一下大人的诗？'));  $this-&gt;assertEquals('李白', getKeyword('搜一搜李白的诗歌'));  $this-&gt;assertEquals('李白', getKeyword('搜一搜李白的诗. '));  $this-&gt;assertEquals('李白', getKeyword('搜一搜李白的诗。'));  $this-&gt;assertEquals('李白', getKeyword('搜一首李白的诗。'));  $this-&gt;assertEquals('李白', getKeyword('搜一首李白。'));  $this-&gt;assertEquals('李白', getKeyword('搜一搜李白的现代诗。'));  $this-&gt;assertEquals('唐', getKeyword('搜唐诗。'));  $this-&gt;assertEquals('宋', getKeyword('搜 宋词。'));  $this-&gt;assertEquals('搜索', getKeyword('搜索一下搜索'));  $this-&gt;assertEquals('dd索', getKeyword('搜索一下dd索'));  $this-&gt;assertEquals('搜索', getKeyword('搜搜索'));  $this-&gt;assertEquals('搜索', getKeyword('搜 搜索'));  $this-&gt;assertEquals('搜索', getKeyword('搜索 搜索'));  $this-&gt;assertEquals('你大姐', getKeyword('搜索：你大姐'));  $this-&gt;assertEquals('你大姐', getKeyword('搜索:你大姐'));  $this-&gt;assertEquals('text', getKeyword('search text'));}public function testGetKeywordStartWithOther() {  $this-&gt;assertEquals('', getKeyword('帮我找'));  $this-&gt;assertEquals('辛弃疾拍栏杆', getKeyword('我想要辛弃疾拍栏杆的诗'));  $this-&gt;assertEquals(['辛弃疾', '拍', '栏杆'], getKeyword('我想要辛弃疾拍栏杆的诗', true));  $this-&gt;assertEquals('一下', getKeyword('来一首 一下的诗'));  $this-&gt;assertEquals('杜牧', getKeyword('给我来一个杜牧的诗'));  $this-&gt;assertEquals('李商隐', getKeyword('给我来一个 李商隐的诗'));  $this-&gt;assertEquals('杜甫', getKeyword('给我一个杜甫的诗'));  $this-&gt;assertEquals('杜牧', getKeyword('告诉我一首杜牧的诗'));  $this-&gt;assertEquals('海子写德令哈', getKeyword('我想要那个海子写德令哈的诗'));  $this-&gt;assertEquals('海子写半截', getKeyword('我想要哪个海子写半截的诗'));  $this-&gt;assertEquals('写诗', getKeyword('帮我找跟写诗有关的诗'));  $this-&gt;assertEquals('写诗', getKeyword('帮我找一首写诗的诗'));  $this-&gt;assertEquals('李白', getKeyword('有没有李白的诗歌'));  $this-&gt;assertEquals('李白', getKeyword('有没有李白的古诗'));  $this-&gt;assertEquals('杜甫', getKeyword('来一首杜甫的诗'));  $this-&gt;assertEquals('海子', getKeyword('有没有海子的现代诗'));  $this-&gt;assertEquals(['李白的', '现代'], getKeyword('有没有李白的 现代 诗'));  $this-&gt;assertEquals('天空', getKeyword('来一个带天空的诗'));  $this-&gt;assertEquals('天空', getKeyword('来一个带有天空的诗'));  $this-&gt;assertEquals('天空', getKeyword('来一个含 天空 的诗'));  $this-&gt;assertEquals('天空', getKeyword('来一个包含天空的诗'));  $this-&gt;assertEquals('天空', getKeyword('来一个含有天空的诗'));  $this-&gt;assertEquals('莎士比亚', getKeyword('有没有莎士比亚的十四行诗'));  $this-&gt;assertEquals('天空', getKeyword('有没有跟天空相关的诗'));  $this-&gt;assertEquals('天空', getKeyword('有没有和天空有关的诗'));  $this-&gt;assertEquals('唐', getKeyword('来一首唐诗'));  $this-&gt;assertEquals('宋', getKeyword('给我来一个宋词'));  $this-&gt;assertEquals('宋', getKeyword('给我来个宋词'));  $this-&gt;assertEquals('天空', getKeyword('有没有跟天空相关的诗歌'));  $this-&gt;assertEquals('', getKeyword('一首没有人的诗'));  $this-&gt;assertEquals('', getKeyword('那个写火车的诗'));  $this-&gt;assertEquals('', getKeyword('帮我找'));  $this-&gt;assertEquals('', getKeyword('有没人'));  $this-&gt;assertEquals('', getKeyword('有没有人'));  $this-&gt;assertEquals('', getKeyword('有没有谁能告诉我'));}这个部分也花了不少时间，最终写出来的获取关键词的方法如下： /** * @param string $str * @param boolean $divide * @return string[]|string */function getKeyword($str, $divide = false) {  $str = trim(preg_replace('@[[:punct:]\n\r～｜　\s]+@u', ' ', $str));  $keyword = '';  $matches = [];  preg_match('@^(搜索??|search)(一下|一搜|一首|一个)??\s*?(?&lt;keyword&gt;. *)(的?((古|现代)?诗歌?|词))?$@Uu', $str, $matches);  if(isset($matches['keyword'])) {    $keyword = trim($matches['keyword']);  } else {    $matches = [];    preg_match('@^(有没有??|告诉我|帮我找|我想要|(给我来|给我|来)|搜索?)(一首|(一|那|哪)?个|一下)??((和|跟|带|包?含)有??)??\s*?(?&lt;keyword&gt;. *)((有关|相关)?的?((十四行|十六行|古|现代)?诗歌?|词))$@Uu', $str, $matches);    $keyword = isset($matches['keyword']) ? trim($matches['keyword']) : '';  }  // 部分情况下，可能需要返回分词结果  if($divide) {    return Jieba::cut($keyword);  }  return strstr($keyword, ' ')    ? explode(' ', $keyword)    : $keyword;}中文分词的部分使用了 jieba-php，效率不是很高，内存占用比较大，但是可以接受。 使用 Wechaty 收发消息: 在 Wechaty 中，不同的 Puppet 对应不同的协议。Wechaty 还有不同语言的 SDK，以及 demo template repository，对开发者非常友好，开发者参与度也很高。 感谢 beclass 已经开源了一个成功的案例，我不必从头开始，而是在 beclass/wxbot 的基础上改动少量代码。 beclass 的文章 已经介绍了 wxbot 项目，下面不再详细解析 wxbot 的代码，只抽取关键部分。 首先需要初始化一个 bot： // create a Wechaty instance as botlet bot = new Wechaty({ puppet: new PuppetPadplus({  token: puppet_padplus_token }), name: 'poem'})由于申请的是 iPad 协议的 token，这里用到的是 PuppetPadplus。接着对 bot 绑定各种事件的处理函数，其中 message 事件是接收到消息时触发的事件。 bot. on('scan', (qrcode) =&gt; { // show the qrcode}). on('login', onLogin) . on('message', onMessage(bot)) . on('friendship', onFriendShip) . on('room-join', onRoomJoin) . on('room-leave', onRoomLeave) . on('error', error =&gt; {  logger. error('机器故障，error：' + error) }) . on('logout', onLogout)onMessage 是写在 server/roobt/message 里的 async function onMessage(msg) { // 忽略来自自己的消息 if (msg. self()) return // 目前只处理来自群聊的文本消息 if (msg. type() == Message. Type. Text) {  const room = msg. room()  const text = msg. text()  // 消息来自群聊  if (room) {   if (await msg. mentionSelf()) { //@了机器人    let self = await msg. to()    self =  @  + self. name()    let receivedText = text. replace(self,   ). trim()    let content = await getPoemReply(receivedText, room. id)    // 返回消息，并@来自人    if(content. poem) {     let poem =  \n\n  + content. poem     room. say(poem, msg. from())     if(!content. data. wxPost) {      return;     }     const linkPayload = new UrlLink({      description : '点击查看读睡荐诗',      thumbnailUrl: content. data. wxPost. cover_src,      title    : content. data. wxPost. title,      url     : content. data. wxPost. link,     })     room. say(linkPayload)    }    return   } else { // 没有@机器人    const receivedText = text. trim()    // 只处理包含关键词的消息    if(!isSearchString(receivedText)) {     return;    }    const content = await getPoemReply(receivedText, room. id)    if(content) room. say(content. poem)    return   }  }  return }}function isSearchString(text) { return /^搜/. test(text) || /的诗歌?$/. test(text)}/** * @description 回复内容 * @param {String} info 收到消息 * @return {Promise} 响应内容 */async function getPoemReply(word, chatRoomId) { let url = POEMAPI_HOST + '/bot_search. php' const pkg = {  method: 'get',  headers: {   'Content-Type': 'application/json'  },  data: {   keyword: word,   chatroom: chatRoomId  },  encoding: null,  timeout: 5000, } let { status, data } = await urllib. request(url, pkg) if (status !== 200) return '不好意思，我出故障了. ' data = JSON. parse(data. toString()) return data}上线！: 在 production 环境运行，建议使用 PM2 。 使用起来也很简单，新增一个配置文件 pm2. config. js module. exports = { apps: [{  name:  wx-robot ,  script:  . /server/index. js ,  env: {   NODE_ENV:  production ,  } }]}然后命令行执行 pm2 start pm2. config. js。搭配其监控面板服务 PM2+，不仅可以在浏览器中控制任务运行状态，还能查看实时日志： 目标达成： 结论（以及广告）: 开发阶段我认为比较重要的部分，匹配各种搜索句式中的关键词，花费了很多时间，甚至还想过用 NL2SQL（自然语言转换为SQL） 技术来做。其实在上线以后很少有人用到，大部分人还是习惯于用 搜+关键词 的方式触发机器人搜索。虽然做的过程很开心，但是没有人用还是挺心酸的。 还可以改进或拓展的地方：  用 ElasticSearch 代替 MySQL 的搜索，对诗歌内容进行分词（对于诗歌内容，分词结果做到正确很难），让搜索结果更准确。 对不同的群，分别设置机器人的功能开关。 每次的搜索结果应该尽可能不一样。 名句对答模式：如果有消息被判定为名句，机器人接下一句。 飞花令模式：诗句接龙。 被拍一拍时反拍一下。微信机器人这样常见的需求就应该有简单的做法。在排除各种不靠谱方案以后，我选择了 Wechaty。Wechaty 简洁的 API 可以帮助开发者快速地搭建一个微信个人号机器人。没有时间折腾的开发者，就不用花时间尝试其它方案了。 One More Thing: 在此文写作过程中，我一直在想，什么样的技术博文才是好的？讲述各种细节固然是对其它开发者有用的。但软件是一直在变化的，这些有用的细节过不了多久可能就不适用了，反而成为开发者搜索过程中的信息噪音。 Redis 开发者 Salvatore Sanfilippo 在这篇文章中说  Sometimes I believe that software, while great, will never be huge like writing a book that will survive for centuries. Note because it is not as great per-se, but because as a side effect it is also useful… and will be replaced when something more useful is around. 在我看来，好的技术博文不应只有细节，还要有对细节的思考，对开发过程本身的观察，试图提炼出让开发过程更顺畅的经验。这些经验，甚至可以拓展到其它日常事务的处理过程中去。 互联网每天产生和复制那么多技术博文，能有多少是可以在多年之后仍然给人启发的呢？  作者: ray7551 "
    }, {
    "id": 286,
    "url": "https://wechaty.js.org/2020/07/06/wechat-calculator-bot/",
    "title": "微信计算器机器人（wechat robot calculator）",
    "body": "2020/07/06 -  背景: 很早开始就在关注微信机器人，自己是做前端开发的，对nodejs有不错的了解。想自己做一个微信机器人的计算器，因为每次需要用计算器就很不方便，手机里的app我都放在很深的目录，不好找，放在首页又太浪费了。所以就想到用wechaty来实现个人号微信计算器机器人，实现常规的加减乘除功能； 功能: 加、减、乘、除 实现逻辑: 逻辑可以说是很简单；利用wechaty接收用户消息，对消息过滤，用户输入：1+1，然后直接eval 计算结果返回给用户； 依赖:  wechaty：wechaty核心库 wechaty-puppet-padplus：wechaty的ipad协议实现实现过程: function calculator(intxt, callback) { return new Promise(function (resolve, reject) {  var a = intxt;  try {   intxt = intxt. replace(/=|等|等于|\?/, '');   intxt = intxt. replace(/加/g, '+'). replace(/减/g, '-'). replace(/乘/g, '*'). replace(/除/g, '/');   a = eval(intxt);  } catch(e){   // console. log('========error', e);  }   resolve(a);  });}async function onMessage (msg) { const contact = msg. from() let text = msg. text() const room = msg. room(); if (room) return; if(msg. self()){ // 自己发消息  return; } if (text) {  text = text. replace(/[。，、,. ]$/gi, ''). replace(/\s*/gi,   ); } if (msg. type() === bot. Message. Type. Text &amp;&amp; /^\d+. {1}\d+/gi. test(text)) { // 文本消息  let result = await CalcFunc. calculator(text);  await msg. say(result+''); }}本地运行:  克隆项目git clone g https://github. com/leiroc/wechat-calculator. gitcd wechat-calculator 安装依赖npm install 启动项目node app. js效果图: 致谢: 感谢Wechaty团队提供微信机器人SDK，让开发者可以专注于业务代码。感谢句子互动提供的pad协议版token，看到很多基于dll的实现，太费时就没有研究了  作者: RayCode: Github "
    }, {
    "id": 287,
    "url": "https://wechaty.js.org/2020/07/05/multilanguage-meeting-notes/",
    "title": "Multi-language Wechaty Meeting: Mocking & Code Quality",
    "body": "2020/07/05 - 漫长的会议: 昨晚（7. 5）的会议开了接近三个小时，即使如此，大家热情依然饱满，几乎忘却了时间，全身心投入到技术主题讨论中。满载而归的我必须要发一篇博客来分享一下昨晚的成果。 昨晚会议围绕 Mock &amp; Test &amp; Restful Api 这三个主题展开，并进行了深入的讨论，详细的会议议程大家可转到google doc上面查看。 接下来我将一一介绍各位参与者分享的内容，如果想要观看整个会议的过程，可转移到油管观看。 Mock Is required for wechaty: 分享者：wj-Mcat 吴京京 Mocker在多语言wechaty中占据着非常重要的地位，是Wechaty和单元测试的桥梁，能够创建一个测试虚拟环境，动态创建用户，房间，模拟登录注销等事件，并同时将一系列的数据流传抛至wechaty，能够在一定程度上实现自动化测试的工作。 mock-server是一个*-wechaty-puppet-service连接的对象，可以看作是puppet-server，我们可以在不改变任何代码的情况下完成测试的流程，并且这整个流程是非常完整的：language-wechaty + language-wechaty-puppet-service。也就是每次测试是同时测试了language-wechaty和language-wechaty-puppet-service 这两个模块。  将wechaty中所有的事件和消息发送和获取都转化成api 根据restful api，可创建web-bot web-bot依然可使用指定插件 还可存在插件商店这个概念Introducing the wechaty-puppet-mock &amp; the new Mocker: 分享者：Huan 李卓桓  能够模拟登录注销等微信操作事件 模拟指定登录用户 随机创建用户和群组 模拟消息发送  可以用来测试wechaty框架，同时大面积覆盖功能函数 可以作为一个新的puppet实现类的模板Python Wechaty Web: 分享者：fish-ball 黄文超 文超分享了关于web-bot的概念和设计，通过将wechaty中不同的操作转化成restful api从而创建web-bot。 以上就是创建示例一个python-wechaty + restful api最小可行性代码。  How to use ts-wechaty plugin in multi-language-wechaty: 分享者：Huan 李卓桓 为了让多语言wechaty使用typescript-wechaty里面的插件，可以将Plugin移至puppet-server端，那这样Language-wechaty只需要添加指定的配置参数即可调用插件。 How to improve stability of puppet implementation: 分享者：Gao Yuan 高原 句子互动的CTO，给我们分享了很多有价值的实践经验，多方面多角度讲述了如何提升wechaty稳定性方面的方法。 以上为此次分享的大纲。   Some think about the plugin: 分享者：dingdayu 丁大雨 合照: 这次会议讨论的主题虽然不多，可针对于具体的解决方案有非常深入的讨论，也让加深了对wechaty生态的理解。 欢迎大家参与wechaty社区相关的活动以及成为Contributor，感谢大家的参与，我们下次再见。  作者: wj-Mcat "
    }, {
    "id": 288,
    "url": "https://wechaty.js.org/2020/07/03/a-room-punch-bot/",
    "title": "微信群打卡统计机器人",
    "body": "2020/07/03 - 一个可以OCR 打卡并生成统计方块图的机器人。 项目背景: 由于疫情的影响，大家都减少了不必要的外出，互联网行业也有很多公司在家办公。带来的一个问题就是，大家外出和运动的时间减少了，几乎都宅在家里，很多人体重开始飙升。于是朋友建了一个健身打卡群，每天大家在家运动健身，然后在群里进行打卡。非常好的一件事情，唯一的缺点就是，打卡行为只能靠自觉约束，并且不能很好的记录到底打卡多少天了？是否连续打卡？也不能准确的知道打卡最积极的人并给予一些奖励。 这个时候想到微信机器人，其实很多年前我就搞过微信机器人，后来由于web 版本的掉线太频繁，就放弃了一段时间。这次借此契机，又上github 搜索了一下wechaty,看到ipad 协议的机器人支持度很好，于是决定重操旧业，开发一个打开机器人。 项目需求:  支持关键字打卡，例如：发送“打卡”即可打卡成功 记录打卡人的详细信息，包括昵称、备注、头像、打卡时间等 打卡成功后，生成精美的图片卡片，并包含打卡日期统计图 针对分享在群里的图片（keep截图等），进行ocr识别，提前关键字自动打卡 支持机器人聊天，活跃群气氛项目实现: 感谢wechaty提供的框架，项目目前以上功能均已实现，并且还增加了一些外的小功能。在此分享几个实现过程中的功能点。 开发框架: 首先，我们在代码编码之前，应该设计一些代码的目录结构和基本框架，好的框架能让开发得心应手，提高效率。 |-tiny-bot |-Dockerfile |-README. md |-package. json |-src | |-api | | |-constellation. js | | |-turing. js | | |-unsplash. js | |-config. js | |-lib | | |-adDetect. js | | |-admin. js | | |-common. js | | |-file. js | | |-forward. js | | |-logger. js | | |-room. js | | |-utils. js | |-listeners | | |-on-filehelper-message. js | | |-on-friend-message. js | | |-on-friend. js | | |-on-login. js | | |-on-logout. js | | |-on-message. js | | |-on-room-admin-message. js | | |-on-room-invite. js | | |-on-room-join. js | | |-on-room-leave. js | | |-on-room-mention. js | | |-on-room-message. js | | |-on-room-topic. js | | |-on-scan. js | | |-on-superadmin-message. js | |-robot. js | |-tpl | | |-punch. html | |-util | | |-callerFileName. js其中listeners 目录对消息类型进行了分类，这样，需要添加特定消息的业务逻辑时，就可以很清晰的添加。config. js 中提供了项目中的所有动态配置项，tpl/ 目录里，存放了代码的打卡模板，可以点击查看效果（手机版） 打卡模板实现: 打卡模板，是一个纯html 文件，逻辑非常简单，就是从url 上读取用户昵称、头像、数据，进行页面渲染，其中打卡方块图的绘制，用到了可视化库F2。 图片生成: 图片生成是在服务端实现的，主要是用到了无头浏览器puppeteer的截图功能。相当于浏览器访问tpl. html地址，将生成的页面进行截图，再通过File-box 返回给用户，即实现了打卡生成图片的功能。 OCR打卡: 手动输入打卡关键字打卡，对于有的比较懒的同学，还是比较麻烦的。OCR 技术能实现无感知打卡，当用户将keep 运动的截图发送到群聊的时候，就可以通过OCR 技术识别关键字，进行打卡。这里主要调用的接口是腾讯的AI 开放平台的通用识图技术。  功能增强: 至此，你已经能实现一个很好的打卡机器人了。但其实我们还能做更多，这些我也正在开发中，敬请期待，例如：  OCR 识别运动时长，生成更细的打卡记录 采用定时任务，对长期未打卡人进行主动@提醒 智能转发优质运动公众号文章到群聊 支持keep 小程序打卡 …体验: 目前代码开源，大家可以clone 下来体验一下，项目地址：https://github. com/secreter/tiny-bot，博客地址：https://www. redream. cn/ 也欢迎大家添加我的机器人张三进行体验。  Author: @secreter 公众号redreamCode: @tiny-bot "
    }, {
    "id": 289,
    "url": "https://wechaty.js.org/2020/07/03/910taobot-for-better-life/",
    "title": "910taoBot-为了美好的生活",
    "body": "2020/07/03 -  由于现在工作生活加了好多的微信群,并且这些群里的消息不一定每条都是你想看的，所以为了防止过多的消息提醒,所以会把群消息给屏蔽掉。但是这样有可能会错过一些@自己 或者需要自己回复的一些消息。因此想要弄一个微信机器人，潜伏在这些微信群。遇到有@设定人之后 把消息转发给自己。以达到提醒自己的目的。以防错过一些重要消息。 同时还可以让机器人成为生活助手，定时发送天气预报、智能聊天、查快递……项目结构: . ├── LICENSE├── README. md├── config│   └── config. template. js├── img│   └── xxx. jpeg├── package. json└── src  ├── bot. js  ├── handler  │   ├── onMessage. js  │   └── onScan. js  └── tool    ├── replyToAMessage. js    ├── 更多功能待实现src:  项目核心代码放在 src 中，其中 bot. js 为入口文件，作为程序的启动与入口。 handler 文件夹中存放处理 wechaty 相应事件的函数。 tool 文件夹中存放单个功能点，可供随时调用。img: 该文件夹用于存储项目所使用到的图片与其他相应资源。 config: 该文件夹中存放相应的配置文件，用于统一管理。 代码介绍: 入口文件: // 初始化const bot = new Wechaty({ puppet: new PuppetPadplus({  token: config. token, }), name: config. name,});bot . on( scan , onScan) // 机器人需要扫描二维码时监听 . on( login , (user) =&gt; console. log(`User ${user} logined`)) . on( message , onMessage(bot)) // 消息监听 . start();该段代码作为启动文件，我们先建立了使用 padplus 的 wechaty；并在后续监听三个事件，并每个事件有对应的处理函数。 onMessage: async function onMessage(msg) { // 判断消息来自自己或三分钟前的消息，直接return if (msg. self() || msg. age() &gt; 180) return; logMSG(msg);}对于消息的处理，有时候要预防自己和自己对话导致的死循环，与消息时间过期的问题。 运行项目: 前期准备工作:  申请 Wechaty Puppet Token，本项目使用的是 padplus，详情可参考 Everything about Wechaty 找到自己想要用的 七彩API(免费)上述申请完毕后，请将对应的 Token 填写到 config/config. template. js 文件中，并将 config. template. js 修改为 config. js 文件 运行:  npm install npm run 扫码登陆微信 开启bot之旅吧~致谢:  感谢Wechaty团队提供这么好的一个工具，让我们开发者可以持续增强我们的国民级应用。希望能够有更多的人参与进来，来继续扩大wechaty的生态圈。 感谢句子互动提供的api-token 作者: chengaopan源码: Github "
    }, {
    "id": 290,
    "url": "https://wechaty.js.org/2020/07/02/wechat-bot-in-ten-minutes/",
    "title": "十分钟实现一个智能问答微信聊天机器人",
    "body": "2020/07/02 -  最近开始写自己的公众号《前端布朗熊》了，注意到有的的公众号有微信机器人可以实现拉人进群、踢人等自动化操作，也想给自己的公众号开发一个机器人来帮我处理一些自动化的重复任务。因此就对微信机器人技术进行了调研，发现了以下几个情况：  微信禁止了新用户和一部分老用户的网页微信登录权限 市面上现有的微信机器人sdk大部分是基于网页微信的http协议实现的 wechaty是一个可以支持非http协议的Chat Bot SDK，并且是一个使用Typescript 构建的Node. js 应用，可以使用iPad协议实现手机和服务端同时登录微信，并且最重要的即使是新注册的微信号，也可以使用iPad协议登录微信我本人手头上的常用微信号需要登录Mac微信工作使用，因此不能拿来做机器人，而另一个微信小号也没有登录网页微信的权限，因此wechaty就成了我的首选 准备工作:  获取token：wechaty使用iPad协议时需要token，这个token可以购买也可以通过成为项目贡献者来得到一个长期可用的token。对于第一次接触wechaty的开发者，可以申请一个为期15天的token来试用，然后15天之内向官方提交你的wechaty成果，待官方审核通过之后就可以获得一个长期token 注册天行API（购买一个月的基础套餐）：我们要让机器人能够实现执行一些简单的交互，就必须需要数据的支持。比如，想让机器人帮我们查询天气，那么就需要有天气数据供我们使用；那么这个数据可以使用公开的免费API、自己写爬虫抓取等方式获得，我这边提供的方法是使用现成的天行API；价格不贵而且除了天气还有笑话、故事等等API的使用权限。写代码:  登录 接收好友请求 接收文字消息并调用天行机器人接口回复 代码中用到的puppetPadplusToken和tianxinApiKey分别是wechaty的token和天行接口的api key需要自己申请，然后按照项目中的src/config-sample. ts的格式创建src/config. ts并填写wechaty的token和天行接口的api key import { Contact, Message, Wechaty } from  wechaty ;import { ScanStatus } from  wechaty-puppet ;import { PuppetPadplus } from  wechaty-puppet-padplus ;import QrcodeTerminal from  qrcode-terminal ;import { puppetPadplusToken, tianxinApiKey } from  . /config ;import { TXRobot } from  . /cmds/tianxin ;import { error_text, hello_text } from  . /common/constant ;import querystring from  querystring ;import axios from  axios ;const puppet = new PuppetPadplus({  token: puppetPadplusToken,});const name =  BrownWeChatBot ;const bot = new Wechaty({  puppet,  name, // generate xxxx. memory-card. json and save login data for the next login});bot. on( scan , (qrcode, status) =&gt; {  // 扫码  if (status === ScanStatus. Waiting) {    QrcodeTerminal. generate(qrcode, {      small: true,    });  }})  . on( login , (user: Contact) =&gt; {    // 登录成功    console. log(`login success, user: ${user}`);  })  . on( friendship , async (friendship) =&gt; {    // 接收到好友请求时，直接同意并说一句配置好的欢迎语    try {      switch (friendship. type()) {        // 1. New Friend Request        case bot. Friendship. Type. Receive:          await friendship. accept();          friendship. contact(). say(hello_text);          break;        // 2. Friend Ship Confirmed        case bot. Friendship. Type. Confirm:          break;      }    } catch (e) {      console. error(e);    }  })  . on( message , (msg: Message) =&gt; {    // 接收到文字消息时转给天行机器人，调用天行机器人接口并回复结果    switch (msg. type()) {      case Message. Type. Text: {        TXRobot(msg. text(), msg. from()?. id)          . then((replay) =&gt; {            msg. from()?. say(replay);          })          . catch((e) =&gt; {            console. log( catch err , e);            msg. from()?. say(error_text);          });      }    }  })  . on( logout , (user: Contact, reason?: string) =&gt; {    console. log(`logout user: ${user}, reason : ${reason}`);  })  . start()  . catch((e) =&gt; {    console. log(e);  });/** * 天行机器人 * @param {string} question 提问 * @param {number} [restype=0] 输入类型，文本0[默认]、语音1、人脸2、其他3 * @param {number} [datatype=0] 返回类型，文本0[默认]、语音1 * @returns */const TXRobot = (  question: string,  userid?: string,  restype?: number,  datatype?: number): Promise&lt;string&gt; =&gt; {  // 使用axios请求天行机器人的接口就可以  return axios({    method:  post ,    url:  http://api. tianapi. com/txapi/robot/index ,    headers: {       content-type :  application/x-www-form-urlencoded ,    },    data: querystring. stringify({      key: tianxinApiKey,      question,      userid: restype ??   ,      restype: restype ?? 0,      datatype: datatype ?? 0,      voc: 3,    }),  }). then((res: any) =&gt; {    if (res?. data?. code === 200) {      switch (res. data. datatype) {        case  text : {          return res. data. newslist?. [0]?. reply ?? error_text;        }      }    } else {      return Promise. reject(res?. data?. msg ?? error_text);    }  });}; 项目源码  完整代码我已经提交到github上了，大家只需要准备好wechaty的token和天行的api key，然后再代码目录下执行yarn &amp;&amp; yarn start就可以运行了。对了，需要提前安装好node环境和yarn 实现效果: 后续: 以上只是一个mvp的机器人，后期我会完善自己的机器人，实现一些可以帮我提高效率的功能，后面的代码我都会把代码同步到这个仓库，保证所有的代码开源。 "
    }, {
    "id": 291,
    "url": "https://wechaty.js.org/2020/07/01/a-guide-to-official-account-bot/",
    "title": "使用wechaty助力公众号主维护社群",
    "body": "2020/07/01 - 作为公众号的号主，有粉丝加微信想要进群是一件很开心的事情，但是久了以后会发现通过好友、改备注、拉群这些事情耗费太多精力了。还好有幸发现了 wechaty 这个项目。昨天试了一下，真的大大解放了我的双手，这篇博客就以公众号号主的角度，来看看怎么用 wechaty 来开发一个机器人小助手的。 其实挺早之前就看见过 wechaty 网页 web 版微信机器人的支持，但是目前支持 web 登录的微信号应该是越来越少了，我的微信号自然也是不能登录。本来都快放弃希望了，但是最近朋友推荐说 wechaty 其实可以绕过 web 这个限制，改用 ipad 协议登录，本文就来一探究竟。 功能如下：  自动通过好友 关键字回复进群 自动改备注token: 使用 ipad 协议登录需要先从官方申请一个 token，你可以参与开源激励计划获取 15 天的试用 token，也可以直接购买，具体看这里： https://github. com/juzibot/Welcome/wiki/Everything-about-Wechaty#21%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0 安装:  首先确认你的 node 版本在 10 以上。node --version Windows 系统需要先安装 python 环境npm install -g windows-build-toolsnpm install -g node-gyp 创建项目mkdir my-padplus-bot &amp;&amp; cd my-padplus-botnpm init -ynpm install ts-node typescript -gtsc --init --target ES6touch bot. ts // copy the example code to it注意，这里的 tsc 指令要求你全局安装 typescript npm i typescript -g 安装 wechaty 依赖npm install wechaty@latest -Snpm install wechaty-puppet-padplus@latest -S // ipad 登录协议用npm install qrcode-terminal // 终端生成二维码用 编写 bot. ts根据官方给的最小示例，先复制进去。 // bot. tsimport { Contact, Message, Wechaty } from  wechaty ;import { ScanStatus } from  wechaty-puppet ;import { PuppetPadplus } from  wechaty-puppet-padplus ;import QrcodeTerminal from  qrcode-terminal ;const token =  your-token ;const puppet = new PuppetPadplus({ token,});const name =  your-bot-name ;const bot = new Wechaty({ puppet, name, // generate xxxx. memory-card. json and save login data for the next login});bot . on( scan , (qrcode, status) =&gt; {  if (status === ScanStatus. Waiting) {   QrcodeTerminal. generate(qrcode, {    small: true,   });  } }) . on( login , (user: Contact) =&gt; {  console. log(`login success, user: ${user}`); }) . on( message , (msg: Message) =&gt; {  console. log(`msg : ${msg}`); }) . start();token 那边填写你申请获得的即可。 开发: 接下来就可以开始我们的业务开发了： 自动通过好友: 通过公众号等方式引导粉丝加你为好友以后，机器人这边会监听到一个事件 friendship，我们只需要通过好友，然后改备注，自动给他发送一段引导消息，等待他回复 「加群」 两个字以后拉他入群。 bot. on( friendship , async (friendship) =&gt; { // 如果是添加好友请求 if (friendship. type() === Friendship. Type. Receive) {  // 通过好友请求  await friendship. accept();  // 获取联系人信息  const contact = friendship. contact();  greeting(contact);  addAlias(contact); }});/** * 对新增好友打招呼，提示加群消息 */async function greeting(contact: Contact) { try {  await contact. say(`Hi，终于等到你！回复「加群」，即可加入进阶交流群哦。`);  console. log(`greeting to ${contact. name()} successfully!`); } catch (e) {  console. log(`failed to greeting to ${contact. name()}`); }}/** * 为好友添加别名 「前端 + 名字」 */async function addAlias(contact: Contact) { const name = contact. name(); const newAlias = `前端 ${name}`; try {  await contact. alias(newAlias);  console. log(`change ${contact. name()}'s alias ${newAlias} successfully!`); } catch (e) {  console. log(`failed to change ${contact. name()} alias!`); }}自动加群: 如果粉丝有意愿加群，那么他看到这个消息后就会回复你，这时候我们可以监听 messsage 事件，根据关键字来判断是否要拉他入群。 bot. on('message', async (msg: Message) =&gt; { if (msg. type() === Message. Type. Text) {  if (!msg. room()) {   console. log(`msg : ${msg}`)   const text = msg. text()   if (text === '加群') {    addContactToRoom(msg. from()!)   }  } }}) /** * 添加联系人入群 */async function addContactToRoom(contact: Contact) { // 这里直接填写你的群名称即可 const room = await bot. Room. find({ topic: '前端进阶交流群' }) if (room) {  try {   await room. add(contact)  } catch (e) {   console. error(e)  } }}启动: 先确保你安装了 ts-node，然后直接 ts-node bot. ts，你的机器人就开始工作了，让你的好友回复关键字测试一下吧。 总结: 有了这个机器人以后，可以把更多的时间用来写优质的文章回馈社区了，真的太棒了！希望这篇文章能对正在做公众号的你有所帮助哦。  Author: @your_github_username front-end developerCode: @wechaty-bot "
    }, {
    "id": 292,
    "url": "https://wechaty.js.org/2020/06/30/wechat-robot-seller/",
    "title": "带货机器人（wechat robot seller）",
    "body": "2020/06/30 -  背景: 疫情期间基于淘宝客的接口写了一个网站烙馍省钱https://tb-m. luomor. com/ ，而推广对于程序员来说很难实施，现在有很多基于社区的推广微信群，因此想做一个带货机器人，之前接触过wechaty，只是之前基于web协议，昨天试了一下微信不让在web页面登录了 通过一番学习之后，看到了新的ipad协议，有C#版本的但是很久没有人维护了，看到wechaty的puppet-padplus，基于RPC实现的版本，将ipad协议封装到了server端，还是很方便的 功能:  商品搜索通过监听用户输入的关键字，回复此关键字的检索地址 实现逻辑: wechaty具体有如下模块：  FriendShip：主要处理好友请求 Message：处理消息模块 Contact：好友管理 当wechaty实例监听到某一事件触发时，会去执行对应的消息监听逻辑。 这样看来，其实主要的操作逻辑在于消息模块，也就是message事件触发时，处理消息内容，根据用户消息内容，返回关键字检索URL地址。依赖:  wechaty：wechaty核心库 wechaty-puppet-padplus：wechaty的ipad协议实现实现过程: if(msgText. trim() !==   ) {  var room;  var url =  https://tb-m. luomor. com/#/searchlist/  + msgText;  //https://docs. chatie. io/api/message  const urlLink = new UrlLink({    description: '烙馍省钱[' + msgText + ']',    thumbnailUrl: 'https://img. alicdn. com/imgextra/i4/790237325/O1CN01hY4aU523ytm2F4HxA_!!790237325. jpg?t=1586059949000',    title: '烙馍省钱',    url: url,  });  for(let roomId of CouponRooms) {    room = await bot. Room. load(roomId);    room. say(urlLink);  }}&lt;a name= OFtbO &gt;&lt;/a&gt;本地运行:  克隆项目git clone ghttps://github. com/zhangchunsheng/wechat-robot-seller. gitcd wechat-robot-seller/v1 安装依赖npm install 启动项目node bot. js效果图: 致谢:  感谢Wechaty团队提供微信机器人SDK，让开发者可以专注于业务代码。 感谢句子互动提供的pad协议版token，看到很多基于dll的实现，太费时就没有研究了 作者: PeterZhangCode: Github "
    }, {
    "id": 293,
    "url": "https://wechaty.js.org/2020/06/29/go-wechaty-beta-released/",
    "title": "Go Wechaty Beta Released!",
    "body": "2020/06/29 - go-wechaty 是 wechaty 多语言版本中的 golang 语言实现,目的是方便 go 语言开发者更容易的去使用 wechaty。 目前状态: 有人在群里问 go-wechaty 可以使用吗？其实 go-wechaty 已经可以用了，大家可以关注这两个仓库 @go-wechaty 和 @go-wechaty-getting-started. 如何快速运行 go-wechaty example: git clone https://github. com/wechaty/go-wechaty-getting-started. gitWECHATY_PUPPET_SERVICE_TOKEN=your_token_at_here make bot开发过程中遇到的一些问题及解决方案: 循环依赖问题: 参照 ts 的目录架构，在 go 这边会有循环依赖的问题，参照 “计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”，所以我们加了一层 interface，让他们都去依赖 interface。 ├── wechaty│   ├── accessory. go│   ├── config│   ├── event. go│   ├── factory│   ├── interface // 接口文件夹│   ├── option. go│   ├── user│   ├── wechaty. go│   └── wechaty_test. go解决获取、搜索联系人、群成员慢的问题: 搜索操作其实遍历所有联系人，通过 goroutine+channel 实现了一个并发处理的功能 async := helper. NewAsync(helper. DefaultWorkerNum) for _, id := range contactIds {  id := id  async. AddTask(func() (interface{}, error) {   contact := c. Load(id)   return contact, contact. Ready(false)  }) } var contacts []_interface. IContact  for _, v := range async. Result() {   if v. Err != nil {    continue  }  contacts = append(contacts, v. Value. (_interface. IContact)) }go 没有静态方法怎么办？: 看 ts wecahty 里静态方法其实就是创建当前类的实例的，所以在 go 里是创建了对应实例的工厂类用来对标静态方法。 type ContactFactory struct { _interface. IAccessory pool *sync. Map}// NewContactFactory . . . func NewContactFactory(accessory _interface. IAccessory) *ContactFactory { return &amp;ContactFactory{  IAccessory: accessory,  pool:    &amp;sync. Map{}, }}// Load query param is stringfunc (c *ContactFactory) Load(id string) _interface. IContact { load, ok := c. pool. Load(id) if !ok {  contact := user. NewContact(id, c. IAccessory)  c. pool. Store(id, contact)  return contact } switch load. (type) { case *user. ContactSelf:  return load. (*user. ContactSelf). Contact default:  return load. (*user. Contact) }}使用 go-wechaty 写的一个机器人: 为了验证 go-wechaty 是否可用，在端午节最后一天的下午我写了一个机器人, 功能就是每天定时提醒群里人打卡, 如果不想收到提醒，回复 #打卡, 机器人就认为你今天已经打卡了。 项目地址: https://github. com/dchaofei/wechat-remind-bot 代码很粗糙(\捂脸️)，好在能用~~~ 支持命令如下:- #以后不要提醒我- #关闭打卡- #帮助- #开启打卡- #提醒我- #打卡最后: 期待更多的小伙伴加入 go-wechaty，一起优化 go-wechaty。  Author: @dchaofei The author of go-wechatyCode: @go-wechaty "
    }, {
    "id": 294,
    "url": "https://wechaty.js.org/2020/06/28/tom-chat-fun/",
    "title": "TomChat-为生活增趣味",
    "body": "2020/06/28 - 在规律平凡的生活中，希望可以有一个小管家来帮自己完成日常的任务，比如天气汇报、消息记录、随叫随到的聊天打发时间，因此 TomChat 应运而生。它可以为你提供天气查询，给予穿衣意见、运动建议；也可以为你述说历史上的今天，可做今日与同事好友的聊天话题；也可以在不愿打扰别人的时候，和它聊天，博君一笑。 项目结构: . ├── LICENSE├── README. md├── config│   └── config. template. js├── img│   └── xxx. jpeg├── package. json└── src  ├── bot. js  ├── handler  │   ├── onMessage. js  │   └── onScan. js  └── tool    ├── autoChat. js    ├── historyToday. js    ├── log. js    ├── nasa. js    ├── tomato. js    └── weather. jssrc:  项目核心代码放在 src 中，其中 bot. js 为入口文件，作为程序的启动与入口。 handler 文件夹中存放处理 wechaty 相应事件的函数。 tool 文件夹中存放单个功能点，可供随时调用。img: 该文件夹用于存储项目所使用到的图片与其他相应资源。 config: 该文件夹中存放相应的配置文件，用于统一管理。 代码介绍: 入口文件: // 初始化const bot = new Wechaty({ puppet: new PuppetPadplus({  token: config. token, }), name: config. name,});bot . on( scan , onScan) // 机器人需要扫描二维码时监听 . on( login , (user) =&gt; console. log(`User ${user} logined`)) . on( message , onMessage(bot)) // 消息监听 . start();该段代码作为启动文件，我们先建立了使用 padplus 的 wechaty；并在后续监听三个事件，并每个事件有对应的处理函数。 onMessage: async function onMessage(msg) { // 判断消息来自自己或三分钟前的消息，直接return if (msg. self() || msg. age() &gt; 180) return; logMSG(msg); // 对 msg 的处理 /// //// /////}对于消息的处理，有时候要预防自己和自己对话导致的死循环，与消息时间过期的问题。 运行项目: 前期准备工作:  申请 Wechaty Puppet Token，本项目使用的是 padplus，详情可参考 Everything about Wechaty 申请和风天气天气 api 权限 申请小思机器人对话机器人权限 申请阿凡达数据提供商中的历史上的今天接口权限上述申请完毕后，请将对应的 Token 填写到 config/config. template. js 文件中，并将 config. template. js 修改为 config. js 文件 运行:  npm install npm run 扫码登陆微信 enjoy！ 作者: Zophyr源码: Github "
    }, {
    "id": 295,
    "url": "https://wechaty.js.org/2020/06/28/build-divination-yibot/",
    "title": "使用wechaty自助算卦",
    "body": "2020/06/28 - 写这个小东西，本就是想玩耍一下，发现很有意思！ 面临人生重大抉择犹豫不定，头脑乱成浆糊的时候，鄙人会问卦，根据卦象客观分析当前的局势。但是从来不问命，只是借用卦象来让自己以一种不含感情的分析方式重新认识当前面临的形势。朋友中有一两个有类似爱好的，对易经有些兴趣，我们几个谈论的时候，其他人就会要求我们给他们解卦。 易经本来就是一个工具书，只需要理解并会正当使用就行了，并不难。我就想写个机器人，可以让他们自己去操作，然后也慢慢学会掌握这种东西。 注意：非常不推荐占卜！ 个人目前只推崇易理！ wechaty实现: 实现其实很简单了。就是使用0、1分别表示阴、阳两种爻。 然后用户输入自己求得的六爻，获得对应的卦象词条。 // 简单列一下示意var ddict = [  坤为地000000=0 ,  山地剥000001=1 ,  水地比000010=2 ,  风地观000011=3 ,  雷地豫000100=4 ,  火地晋000101=5 ,  泽地萃000110=6 ,  天地否000111=7 ,  地山谦001000=8 ,  艮为山001001=9 , ]async function onMessage (msg) { // log. info('StarterBot', msg. toString()) room = msg. room() let text = msg. text() if(text ==  求卦 ) {  await msg. say(GUA_HELP) } if(text. indexOf( 求卦- ) &gt; -1) {   let code = text. split( 求卦- )[1]   try {    ddict. forEach((item,index,array)=&gt;{     if (item. indexOf(code) &gt; -1 ) {      let o_name = item. split(code)[0]      let names = o_name. split( 为 )      if (names. length &gt; 1) {       o_name = names[0]      }      if (o_name. length &gt; 2) {       o_name = o_name. slice(2)      }      throw new Error(o_name +  卦 )     }    })   } catch (error) {    log. info( 找到了  + error. message)    let resp =  https://baike. baidu. com/item/  + error. message    const linkPayload = new UrlLink({ description : (  === 友情提示  + msg. from(). name() +   === \n看易理，命运自己掌握，我们只需要看清时局！ ),       thumbnailUrl: 'https://ss0. bdstatic. com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3740483648,506813176&amp;fm=26&amp;gp=0. jpg',       title : error. message,       url : resp})    log. info(resp)    await msg. say(linkPayload)   } }}截图: 其他: 过程中看了wechaty的其他的很多博客，发现大家贡献了很多有意思且实用的工具。比我弄得这个实用多了。计划后面选择性地丰富一下功能，添加一些生活元素，丢到群里，给朋友们玩耍。 最后再提示一下：善易者不卜！ 我是不善的，但是也不占卜。 虽然是传说，但是我觉得很多时候浑沌一些挺好的，有助于个人思考，也算是个人活过，真实的体验。什么都靠占卜，命系于天不由自己无说，不知道会不会遭天谴~~ 哈哈 思之~ 慎之~ token的问题: 本人是Java程序员出身，工作一直在大数据领域，对python、scala都比较熟悉。但是对前端js的知识就有些贫瘠了。 Wechaty社区对技术人员是蛮开放与支持的。社区当前也正在对多语言做支持。但是当前人们拿到的大多是padplus版本的。 文档中对于token的介绍个人觉得不太详细，因为很多人都在群内提到了相同的问题：为啥我拿到我的token在java/python中运行不了？ 同学，如果你的padplus版本的token，只能使用js/ts进行编码测试。不要一看是一种新的语言，以前没玩儿过就直接放弃了。写好很难，但是逐渐玩儿起来并不难。加油！ 致谢: 感谢Wechaty团队。  Author: @runningdata "
    }, {
    "id": 296,
    "url": "https://wechaty.js.org/2020/06/23/hitchhiker-info-subtotal/",
    "title": "北京周边跨城顺风车消息汇总",
    "body": "2020/06/23 - 北京的房价涨幅对于北漂的工资涨幅来说永远都是高不可攀的；有很多人到了成家立业的年纪，又不想回到老家，所以距离北京近，房价可以接受的北京周边就是就是一个不错的选择，但是在环京买了房，工作还是在北京，由此衍生出了一批跨城上下班的圈子。由于北京车牌限制，限行策略，堵车等问题，所以导致很多人不能愉快的自驾上下班，坐公共交通工具又不是特别方便，所以大家会选择和邻居或是朋友拼车上下班，既方便了大家通勤，也节省了路上的开销成本。但是由于拼车群人多，各种和拼车消息无关的夹杂在其中不能让有需要的人快速找到适合自己路线的顺路车。 项目说明: 在两年前，我已经基于web协议的wechaty做过一个版本，有微信公众号和微信小程序两个客户端供大家使用，微信公众号输入车寻人，或是人寻车等关键字后会返回当天发布的消息分类汇总，微信小程序也达到1000+pv，但是由于web协议的不稳定性，导致我的微信账号被封登录不了了，所以后期就不维护了现在了解到李佳芮为了支持大家会提供长期的token供大家使用，所以想重新吧这个项目做一下，维护起来，通过wechaty帮大家筛选拼车相关信息，让大家快速查到自己所需要的信息 核心逻辑: 我的微信号上有十几个拼车微信群，里边每天会有很多拼车的相关信息，但是大家都会按照一个规则来发： @车寻人，时间，出发地点，顺路地点，终点，联系方式@人寻车，时间，出发地点，终点，联系方式@车满信息收集规则： 根据大家发送的信息，我做了一些简单的关键字匹配，分类为车寻人，或是人寻车，车满的消息会冲掉之前发送的车寻人消息，收集到的数据会写到mysql数据库里，小程序和公众号从库里边查数据附上部分逻辑代码说明。 import api1 from '. . /. . /server/api'const one = ['车寻人', '车找人', '找人', '寻人', '满人', '满车', '车满', '人满'];const two = ['人寻车', '人找车', '找车', '寻车', '找个车']class dealMsg {  async collectMsg(m) {    const contact = m. from() //发送人    const content = m. text() //内容    const room = m. room() //群 room. topic()    const tels = content. match(/((((13[0-9])|(15[^4])|(18[0,1,2,3,5-9])|(17[0-8])|(147))\d{8})|((\d3,4|\d{3,4}-|\s)?\d{7,14}))?/g)    const tel = tels. filter((x) =&gt; {      if (x) {        return x      }    })    let sex =  无     if (room) {      var contet = null;      one. forEach(item =&gt; {        if (content. indexOf(item) &gt; -1) {          contet = {            type: 1,            author: contact. name(),            wxid: contact. id,            msg: content. replace(/(&lt;img. *?)&gt;/gi, ''),            tel: tel[0],            gender: sex,            headimg: ''          }        }      })      two. forEach(item =&gt; {        if (content. indexOf(item) &gt; -1) {          contet = {            type: 2,            author: contact. name(),            wxid: contact. id,            msg: content. replace(/(&lt;img. *?)&gt;/gi, ''),            tel: tel[0],            gender: sex,            headimg: ''          }        }      })      if (contet) {        api1. insertInfo(contet)      }    } else {      if (contact. name() !=  Sking ) { }    }  }}module. exports = dealMsg项目使用: 目录结构:  server数据库配置和前端使用的接口 routes路由 public存放机器人初始化后一系列事件处理(分模块)     controller 原来web的wechaty的时候用到的，现在不用了   padchat_robot 基于padchaty协议   wechat_robot 基于web协议   wechat_padplus padplus协议   wxgzh 微信公众号的业务处理   如何使用:  修改config配置打开server/index. js 文件，将里面的配置改为自己的。然后就可以运行了npm installnpm start 作者: skingCode: Github "
    }, {
    "id": 297,
    "url": "https://wechaty.js.org/2020/06/20/wonderful-wechaty-devops-tools/",
    "title": "Wonderful Wechaty devops toolset",
    "body": "2020/06/20 - Wechaty 的代码质量，是大家公认的比较高的水准。而在整个项目的搭建和发展的过程中，DevOps 工具是 Wechaty 代码质量的重要保证，这里，就和大家一起聊聊关于 Wechaty DevOps Toolset。 Wechaty DevOps family: 这里主要给大家介绍以下几个重要的 Wechaty DevOps 工具：  @chatie/semver NPM 版本检查工具 @chatie/git-scripts Git 脚本合集 @chatie/tsconfig 中心化 tsconfig 配置 @chatie/eslint-config 中心化 eslint 配置@chatie/semver: @chatie/semver 是一个很简单的 NPM 包，主要负责帮助检查当前包的版本是属于开发版，还是稳定版，并且提供了 typescript 和 shell CLI 两种使用方式。这个包通常是作为辅助包，供其他的脚本来调用的。 Wechaty 的版本控制遵循了 Linux Kernel Version Numbering，如上图所示，Wechaty 使用 minor version 的奇偶来区分当前版本是开发版还是稳定版。  奇数版 -&gt; 开发版 -&gt; @next 偶数版 -&gt; 稳定版 -&gt; @latestExample: package-publish-config-tag. sh in @chatie/git-scripts #!/usr/bin/env bashset -eVERSION=$(npx pkg-jq -r . version)if npx --package @chatie/semver semver-is-prod  $VERSION ; then npx pkg-jq -i '. publishConfig. tag= latest ' echo  production release: publicConfig. tag set to latest.  else npx pkg-jq -i '. publishConfig. tag= next ' echo 'development release: publicConfig. tag set to next. 'fi可以看到，上面的 shell 脚本通过调用 @chatie/semver 来判断当前的版本，然后根据返回结果给开发版打上 @next 的 tag，给稳定版打上 @latest 的 tag。 更多请参考 @chatie/semver repo @chatie/git-scripts: @chatie/git-scripts 是一些 git 脚本的集合，里面主要包括下面几个非常常用的脚本：  npm-pack-testing. sh NPM 打包测试脚本 package-publish-config-tag. sh NPM 自动 tag 脚本 pre-push. sh Git push 自动检查/升版脚本npm-pack-testing. sh: 这个脚本主要做了以下几件事情：    将代码打包成npm包格式  创建临时文件夹  以npm install的方式安装刚才的包  执行smoke-test来验证打包正确性 通过这样四步，可以完整的模拟一个 NPM 包在打包后，依次经历安装，引用，运行的过程，并且在 NPM 发包前保证这个包被发出去了之后，不会出现无法安装，安装后无法运行的情况，而且通过自动化的脚本，也省去了开发过程中对打包情况的测试，大大提升了开发效率，还保证了 NPM 包的健壮性。 package-publish-config-tag. sh: 这个包就是上面已经给出的例子，主要通过执行脚本，调用 @chatie/semver 来针对开发版和稳定版打上不同的 tag，在此不赘述。 pre-push. sh: 这个包主要做了以下三件事情：    执行 npm lint 检查代码格式  如果格式无误，则升级npm版本  执行push 但是接触过这个脚本的同学，可能曾经看到过类似这样的画面： 这个情况看起来就非常诡异 上面是一个大大的 Success Push，但是下面却有一行 error？ 为了研究明白为什么会发生这个事情，我研究了一下这个脚本主要用到的功能 Git Hooks 到底是怎么回事。 Git Hooks: Git Hooks 的主要作用是，在 push 操作前，给用户一个 hook，可以自由执行自己觉得有用的检查，来保证 push 的代码是好的。所以 Git Hooks 会根据用户指定的那个脚本的返回值来判断用户是否希望 git 把这个代码 push 上去。如果返回的结果是 0，则说明验证通过，如果是非 0 的返回，则会被认为是脚本执行失败了，然后 git 会终止后面的 push 操作。 另外，Git Hooks 在设计之初，应该是为了防止用户在做代码检查的时候，修改一些 git 相关的内容，比如 commit 信息，具体 push 的代码等等，所以 Git Hooks 会在执行用户指定的脚本前，锁定当前需要被 push 的所有内容，等待用户的检查结束后，直接将之前锁定的内容推到远程，这样可以保证用户无论做什么检查，都不影响 push 的正确执行。也正是这个原因，导致了我们上面看到的那个奇怪的现象，具体如下图： 可以看到，在当前的 pre-push. sh 脚本中会升级当前包的版本，版本被升级到了 v1. 0. 1，但是这个变化其实对于 git 来说，是不可见的。所以如果想要保留这个版本的变更，就只能在运行的脚本内直接执行 git push 来把当前的新版本推到远端。那如果这样做了之后，就不能再以 code 0 作为脚本的退出了，否则 git 会自动再次执行之前一直在等待着的 git push 并且尝试把 v1. 0. 0 推到远端，然后得到一个 conflict 的报错。所以在这里，pre-push. sh 脚本就以 code 127 退出，终止后续 git 自带的 push 操作。 禁用: 有时候，可能我们就需要推一些无法通过 linting 的代码到远端分支，比如说我们写了一半的代码，想换一台电脑来调试，需要通过 Github 作为代码中转，把代码搞到另外的环境里。那么其实 pre-push. sh 脚本是提供了一个方式来禁用它的，如下： NO_HOOK=1 git push以这样的方式执行就可以跳过 pre-push. sh 脚本里面的所有检查，直接执行 git push 操作。 限制: 也正是因为上面所述的原因，使用这个 pre-push. sh 脚本是有一些限制的，最明显的一个限制就是无法使用稍微复杂的 git push 指令，例如： git push -u origin very-sexy-code-change所以，如果需要执行类似的复杂指令，只能采取一些 workaround。比如说用上面提到的 NO_HOOK=1 的方式先推送一次，把远程的分支创建出来，然后后续再使用 git push 来推代码。 @chatie/tsconfig: 这个包是为了集中管理所有 Wechaty 项目的 tsconfig. json 文件而创建的。这个包会提供一个基础的 tsconfig 配置，方便引入。并且，这个包还包含了一个安装程序，如果安装这个包的时候，项目目录里面还没有 tsconfig. json 文件，@chatie/tsconfig 会自动创建一个 tsconfig. json 文件在根目录下，并且自动引用 @chatie/tsconfig 的配置。 @chatie/eslint-config: 这个包是负责管理所有 Wechaty 项目的 eslintrc. js 文件。因为 tslint 项目已经 deprecated，所以 Wechaty 所有项目都使用 eslint 管理。 这个包主要提供了一个统一的 eslint 配置，并且以良好的 TDD 思想来搭建项目。 总结: Wechaty 的 devops 工具是由很多小的组件组成，每个组件都只负责一小部分功能，但是每个小组件都经过了反复的迭代更新，为 Wechaty 的所有项目的代码质量保驾护航。希望大家能通过这篇博客了解到以上几项工具的作用和使用。 Wechaty 的 devops 还有另外的一个重要组成部分，那就是 Github Actions，这篇博客由于时间原因，没有时间准备完整的内容，后续会持续更新更多关于 Wechaty DevOps 相关的内容，也欢迎大家一起来了解学习 Wechaty DevOps。  Author: @windmemory Wechaty contributor, author of wechaty-puppet-padchat, wechaty-puppet-padpro, wechaty-puppet-padplus. CTO of Juzi. BotCode: @chatie/semver, @chatie/git-scripts, @chatie/tsconfig, @chatie/eslint-config "
    }, {
    "id": 298,
    "url": "https://wechaty.js.org/2020/06/19/python-wechaty-cps-bot/",
    "title": "基于python-wechaty的CPS BOT",
    "body": "2020/06/19 - 无非就是想撸羊毛，自己又懒的一个一个找，一个一个发。已知目前的返佣app非常的多，比如：好省，蜜源，粉象，芬香等等等等。归根到底无非是利用淘宝、京东、拼多多、苏宁的开放平台做的。所以想到是否可以利用已有的开放平台来做一个属于自己的撸羊毛项目。 需求描述: 定时获取优惠信息，发送到指定微信群聊 最终效果图: 快速上手: 安装: 安装 python-wechaty pip install wechaty笔者使用的版本是：0. 5. dev1 编码: bot. py: 创建定时任务 async def jd_job():  scheduler = AsyncIOScheduler()    # 每小时55分45秒时任务启动，抖动时间30秒  scheduler. add_job(jingdongfenxiang, trigger='cron', minute='55', second=45, jitter=30, id='fenxiang')    scheduler. start()向群内发送消息 async def jingdongfenxiang():    # 由于 python 的 wechaty-puppet（0. 0. 8）并没有实现 find 方法，    # 所以这里只能从 _pool 中获取群聊id  room = bot. Room. load( 19679596974@chatroom )  # room = bot. Room. load(bot. Room. find( 京东内部优惠券-爆品区① ))  await room. ready()  conversation: Union[Room, Contact] = room  await conversation. ready()  infos = jingfen_query() # 由于并没有使用京东自有的SDK，源码请访问项目  for info in infos:    for image in info[1]:      file_box = FileBox. from_url(f'''{image}''', name='jing-dong. jpg') # 发送图片      time. sleep(random. randint(5,10))      await conversation. say(file_box)    time. sleep(random. randint(5,10))    await conversation. say(info[0]) # 发送优惠信息启动 async def main():  t1 = asyncio. create_task(dingdong())  # ding-dong任务，详见 python-wechaty-get-start  t2 = asyncio. create_task(jd_job())  await asyncio. gather(t1, t2) #并发运行任务asyncio. run(main())运行: 运行 python bot. py心得: 申请的token属于donut-token ，底层其实是Windows Hook原理，所以微信发送消息的规则需要满足Windows上的操作，不然你会让腾讯关注到哦。 致谢: 感谢Wechaty团队。感谢juzibot提供的donut-token 项目链接 https://github. com/why2lyj/youxiang-wechaty  Author: @why2lyj "
    }, {
    "id": 299,
    "url": "https://wechaty.js.org/2020/06/19/multi-language-wechaty-beta-release/",
    "title": "Multi Language Wechaty Beta Release Announcement!",
    "body": "2020/06/19 - Multi-language Wechaty Beta Released! We have Python, Go, Java, and Scala released on June 19, 2020!  TypeScript Wechaty Getting Started Python Wechaty Getting Started Go Wechaty Getting Started Java Wechaty Getting Started Scala Wechaty Getting Started Agenda:       Time   Topic   Speaker         19:00 - 19:05   Introduction &amp; Warm up   李佳芮, @rui       19:05 - 19:20   Multi-language Wechaty Roadmap   李佳芮, @rui       19:20 - 19:35   Introduction for python Wechaty   吴京京, @wj-Mcat       19:35 - 19:50   漫谈Java Wechaty   刁政欣, @diaozxin007       19:50 - 20:00   puppet manager 的实现   任筱雅, @redmaple1           Tea Break           20:00 - 20:15   聊一下go Wechaty   丁超飞, @dchaofei       20:15 - 20:30   Scala with Wechaty   蔡君, @jcai       20:30 - 20:45   Wonderful Wechaty DevOps Tool set   高原, @windmemory       20:45 - 21:00   How to getting started with Multi-language Wechaty   李卓桓, @huan           Q/A &amp; Free Talk       Self-introduction of Speakers: Before the meeting, every speaker introduced themselves!  Talk 1: Multi-language Wechaty Roadmap, Rui (李佳芮), (@lijiarui): Rui (李佳芮) is the co-author of Wechaty, founder &amp; CEO of Juzi. BOT. She introduced the community organization of Wechaty, which is following the Apache Way from the Apache Foundation  The Apache Way“If it didn’t happen on list, it didn’t happen. ” - Craig, Chairman of Apache Software Foundation.   The Wechaty Way“If it didn’t happen on GitHub, it didn’t happen. ” - Rui, co-author of Wechaty Contributors.  At the last, Rui showed our gifts for our Wechaty Community Contributors, it’s so beautiful and memorable! Talk 1: Video (@lijiarui):  Python Wechaty:  Committers:  Jingjing WU (吴京京) https://github. com/wj-Mcat Chunhong HUANG (黄纯洪) https://github. com/huangaszaqContributors: Talk 2: Introduction for python Wechaty，吴京京 (@wj-Mcat):   Talk 2: Video &amp; Slides &amp; Blog (@wj-Mcat):  Slides Blog Post simple bot : python-wechaty Java Wechaty:  Committers:  Zhengxin DIAO (刁政欣) https://github. com/diaozxin007 Xiaoya REN (任筱雅) https://github. com/redmaple1Contributors: Talk 3: 漫谈Java Wechaty，刁政欣 (@diaozxin007):     Happy Birthday to @diaozxin007:  Talk 3: Video &amp; Blog (@diaozxin007): Blog Post: 终于有一个 Java 可以用的微信机器人了  Talk 4: puppet manager 的实现，任筱雅, (@redmaple1):   Talk 4: Video &amp; Blog (@redmaple1): Blog Post: 简单聊聊java版Puppet Manager的实现  Go Wechaty:  Committers:  Xiaoyu DING (丁小雨) https://github. com/dingdayu Chaofei DING (丁超飞) https://github. com/dchaofei Bojie LI (李博杰) https://github. com/SilkageNetContributors: Talk 5: 聊一下go Wechaty，丁超飞, (@dchaofei):    Talk 5: Video &amp; Blog (@dchaofei): Blog Post: go 语言可用的 wechaty 框架  Scala Wechaty:  Committers:  Jun CAI (蔡君) https://github. com/jcaiContributors: Talk 6: Scala with Wechaty，蔡君, (@jcai):  Scala Wechaty SlidesScala Wechaty - Jun CAI (蔡君) Slides   Talk 6: Video (@jcai):  Talk 7: Wonderful Wechaty DevOps Toolset，高原, (@windmemory):       Talk 7: Video &amp; Blog (@windmemory): Blog Post: Wonderful Wechaty devops toolset  Talk 8: How to getting started with Multi-language Wechaty，李卓桓, (@huan):  GitHub Issues about Multi-language Wechaty:  Wechaty is All You Need: Python, Go, and Java Translation Project #1927 How to create your own Wechaty Hostie Token with the Web Protocol #1986 Using your Puppet PadPlus token with Python, Java, and Go Wechaty #1985Wechaty Getting Started in Multiple Languages:  TypeScript Wechaty Getting Started Python Wechaty Getting Started Go Wechaty Getting Started Java Wechaty Getting Started Scala Wechaty Getting StartedTalk 8: Video (@huan):  Group Photo: To review our first multiple language Wechaty meeting  Meeting Minutes: BOT5 Club: Multi-language Wechaty at April 17, 2020: Meeting Notes:       Time   Topic   Speaker         8:00 - 8:15   Introduction &amp; Warm up   李卓桓，@huan       8:15 - 8:30   Just 0. 1% of the Python Wechaty   吴京京，@wj-Mcat       8:30 - 8:45   Go Wechaty 开发分享   丁超飞 @dchaofei       8:45 - 9:00   从 Go 的角度理解 Wechaty   丁小雨，@dingdayu       9:00 - 9:15   从 Java 开发者的角度谈 Wechaty   刁政欣，@diaozxin007       9:15 - 9:30   Golang里的EventEmitter   李博杰，@SilkageNet       9:30 - 9:45   Discussion: Prize for DingDongBot   李卓桓，@huan       9:45 - 10:00   Q/A &amp; Free Talk        Related Issue Wechaty is All You Need: Python, Go, and Java Translation Project #1927 "
    }, {
    "id": 300,
    "url": "https://wechaty.js.org/2020/06/19/archyshuo-anki-assistant/",
    "title": "Archy.sh: a WeChat Assistant That Generates Anki Flashcards for Chinese Learners 吖奇说：一个帮助外国人与海归学习中文的微信助理，可生成Anki卡片",
    "body": "2020/06/19 - It’s been almost a year since I moved back to China. And currently I’m still struggling with Chinese. 回国几乎一年了，目前我还在苦读中文。 Unlike English there are no spaces in Chinese. Figuring out the proper segmentation for Chinese words in a sentence can often be a mind-numbing task for Chinese learners, especially when the sentence contains Chinese words and characters that one is not familiar with. 不像英文，中文并没有空格。对于还在学习汉字的人来说，很多时候分词是一件令人费解的事，尤其当句中含有学习者不熟悉的词与字。 It has occured to me that many Chinese learners including myself would be able to perform word segmentation more efficiently if we can preview beforehand what are the difficult words in each paragraph (i. e. Chinese words we are likely not familiar with) and have each word annotated with its pinyin and some rough definition. This would also improve the whole reading experience. 在阅读一篇文章前，如果我能事先预览段落中有哪些难词（也就是很大机率我不熟悉的词语），以及这些词语的拼音与大致意思，我相信我（包括很多中文的学习者）将能更高效率地进行分词。这也会让整个阅读体验变得更棒。 And it would be even nicer if there is a simple procedure that would enter everything we need to remember (i. e. the words we are not familiar with, together with their pinyin and definitions) into a system like Anki[1] where we can later perform active recall[2] and spaced repetition[3] to develop long-term memory for these words in an efficient manner. 然后更棒的是如果能有一个极其方便的流程来为学习者把文章中不熟悉的词语，连带拼音与意思，输入进一个类似Anki[1]的学习系统里，有助接下来进行「活性回忆」[2]与「间隔重复」[3]的练习，来提高词语进入长期记忆的效率。  [1]: Anki - Powerful, intelligent flash cards  [2]: Retrieval-Based Learning: Active Retrieval Promotes Meaningful Learning (2012)  [3]: Making long-term memories in minutes: a spaced learning pattern from memory research in education ( 2013) ● ● ● After many burnouts and failures (which included screwing up my MiraclePlus interview) and realising the video editor project that I was working on was not going anywhere, I decided I wanted to work on a chatbot assistant that can help me to be more productive learning Chinese. And maybe others will find it to be useful as well =) 经历了多次倦怠与失败（其中包括亲手把我的奇绩创坛面试搞砸），并意识到我正在做的视频编辑器项目也走不了多远，我决定我想做一个chatbot助理，来帮助我更高效率地学习中文。或许其他学习者也会发现它有用 =） And Archy the Anki Bot 0. 0. 1 was born. 就这样吖奇说Anki助理0. 0. 1出世了。 The Use Cases 用例: 1: Extract difficult Chinese words from WeChat articles. 一、从微信公众号文章中提取难词。 2: Annotate Chinese words with pinyin and rough definitions (expressed in English). 二、给词语标上拼音与英文大意。 3: Generate a deck of Anki notes from Chinese words. 三、从一组词语生成一组Anki卡片。 Design &amp; Implementation &amp; Demo 设计与履行与演示: Basically we would have an ArticleAnalysor, a TextAnalysor, a Lexicographer, and an AnkiDeckGenerator. And we would integrate everything in main. ts where we handle Wechaty callbacks. 基本来说，我们会有一个ArticleAnalysor、 TextAnalysor、 Lexicographer、 AnkiDeckGenerator。 然后，我们会在处理Wechaty回调的main. ts中合并所有东西。 For the current use cases, we would use the ArticleAnalysor to extract text from the WeChat Article (using request &amp; cheerio), the TextAnalysor to tokenise the text into words (using jieba with a pretrained model in paddle), the Lexicographer to assign a difficulty score to each word (using an ad hoc formula with Chih-Hao’s Chinese characters meta-data), as well as to give English definitions and pinyin to selected words (using CC-CEDICT). And lastly AnkiDeckGenerator is for generating a deck of Anki notes (using genanki). 实现当前用例，我们将使用ArticleAnalysor来从微信文章获取文本（request + cheerio）、 TextAnalysor来对文本进行分词（jieba+paddle中一个训练好的模型）、 Lexicographer为每个词语分配一个难度分数（一个随意的公式+Chih-Hao的汉字元数据），以及为词语提供英语定义和拼音（CC-CEDICT）。 最后，AnkiDeckGenerator将用来生成一组Anki卡片（genanki）。 Gluing everything together functionally and this is what we get: 函数式地把所有东西粘起来，即可得出：   What’s Next? 接下来呢？: still in the midst of planning but here are some rough ideas:    Refinements 功能改良          As we can see the ad hoc word difficulty scoring formula isn’t performing super great at the moment. That is something I need to experiment and perhaps do some text scraping and use a combination of BERT with a self-trained model, etc to achieve a more accurate scoring system.           The pretrained paddle model in jieba works well in general but it may still give unsatisfying results (e. g. at times when a sentence contains a person’s name). Trying out different models aside, my plan is to engineer around the problem (i. e. to have results that always make sense to the users) using tools like StandfordNLP’s stanza or approach the problem differently, etc.           I’m also thinking about extending the Lexicographer to contain definitions from different dictionaries as well as online search results that is useful to the language learners, etc.          MiniApp &amp; Premium Version &amp; The Future 小程序与会员版与未来打算          Anki is an amazing and very powerful tool but I feel like it is too exam-orientated in the sense that it is best utilised by people (e. g. medical students) with the aim of doing well in an upcoming exam, etc. And from a UI/UX perspective it has a steep learning curve. I’m currently working on a WeChat and TikTok MiniApp inspired by Anki but with a more laid-back take on it. The end product will a nichely designed tool for people who want to improve their Chinese with the intention to read and speak better rather than scoring well in exams. In the premium version it would come with a chatbot assistant like Archy the Anki bot.           Archy the Anki bot will always remain free and open-source on Github. I will continue to improve it as I work on the commercial aspect of the project described above so that I can continue doing this full-time and maybe it can become ramen profitable. 🍜 🍜 🍜           If things go well I would like to scale it up to cover different language learning (e. g. English, Japanese, German), as well as going beyond language learning to become a full-fledge note-taking productivity tool for autodidacts. It will be like Notion but more for remembering stuff and visualising knowledge representation. And at the core of it would be a cross-platform chatbot assistant* =) At the moment I’m reading up on how to train a model to do handwritten diagram recognition (e. g. mind map, UML, flow chart, etc) as well as looking into visual languages like Chalktalk. ⚗️ ⚗️ ⚗️        *: in general from a product perspective I believe chatbot is a great I/O into the world, especially as social media apps become the new browsers. Lastly 最后: Huge thanks to    contributors of the jieba library for making jieba such an amazing tool!     the CC-CEDICT community for doing such an great job and licensing it under CC BY-SA 3. 0!     contributors of the genanki library for writing such an easy-to-use tool!     the Wechaty community and everyone involved in making Wechaty such a wonderful lib! And the Juzi. bot team for opening up their padplus protocol ecosystem for outsiders like me!  If you are interested in the development of this project feel free to follow Archy. sh on WeChat and TikTok or join our mailing list =) Also please feel free to fork my repo, deploy your own bot, or just do anything with the code, or open issues if there are any! Thanks! p. s. 写中文写到中间有些累与懒🥴「吖奇说记忆卡片」小程序上线后更多关于未来的去向（中+英）会在公众号有的看～ 感兴趣的朋友可以关注我的公众号与抖音@吖奇说～  作者: Archy Will He 何魏奇，on and off创了八年都没有发，目前在全职做吖奇说(Archy. sh)这个项目。  Github Repo: Archy the Anki bot (吖奇说Anki助理)  "
    }, {
    "id": 301,
    "url": "https://wechaty.js.org/2020/06/17/wechaty-academic-yanbot/",
    "title": "学术场景应用：YanBot",
    "body": "2020/06/17 - 备注: 本人是中国科学院心理研究所研究员，博士生导师，心理所抑郁症大数据国际研究中心主任，心理所磁共振成像研究中心副主任，入选爱思唯尔 2019年中国高被引学者（神经科学）。本人对静息态功能磁共振成像（R-fMRI）的计算方法进行了规范化，建立了被引2000余次的脑成像流水线式计算平台DPARSF，并建立了脑成像分析与共享平台DPABI和基于大脑皮层的脑成像数据分析软件DPABISurf。 DPABI/DPABISurf/DPARSF系列软件拥有众多用户，因此需要构建一个机器人助理来回答用户的相关问题。另外，机器人助理要辅助管理相关的多个微信讨论群The R-fMRI Journal Club，并对用户对领域内文献的讨论和相关脑影像技术问题进行桥接。本项目是wechaty在学术场景应用的一个示范。 YanBot is an academic chatbot application to help Dr. Chao-Gan Yan for answering DPABI/DPABISurf/DPARSF questions and managing The R-fMRI Journal Club wechat groups.    YanBot could answer questions including DPABI软件下载、DPARSF软件下载、DPABI软件安装、DPARSF软件安装、DPABISurf软件安装、DPABI编译版软件安装、Demo演示数据、在线网络课程、数据处理报错、常问问题、抑郁症大数据联盟数据下载、加入抑郁症大数据联盟。     YanBot is also a manager for The R-fMRI Journal Club groups, where people are discussing R-fMRI related papers and DPABI/DPABISurf/DPARSF questions. YanBot will invite new friend to The R-fMRI Journal Club groups automatically.     YanBot also bridges The R-fMRI Journal Club 1 and The R-fMRI Journal Club 2 groups, he will also bring the nickname of a user in a specific wechat group to another group. In such a way, users could talk with each other even without in the same wechat group.  If you want to build some chatbot for your own purpose, then YanBot would be a good example! Tips to be shared: YanBot is an academic chatbot application based on wechaty. As YanBot needs to bridge the the R-fMRI Journal Club wechat groups, it also uses the RoomConnectors from wechaty-plugin-contrib. Problem: However, the code example map: async message =&gt; message. from()?. name() + '(many to many): ' + message. text(),has a limitation: People always set nickname (RoomAlias) in a wechat group (chatroom), but the code example will not bring the GroupAlias to another room, thus people in another chatroom doesn’t know who the speaker is. Solution: My modification map: async message =&gt; await message. room()?. alias(message. from()??bot. userSelf()) + '(另群): ' + message. text(),will forward the nickname (RoomAlias) from one chatroom to another chatroom, thus people can talk across rooms more conveniently. Hope this tips helps for others!  Author: Chaogan-Yan Professor, Institute of Psychology, Chinese Academy of SciencesCode: Github "
    }, {
    "id": 302,
    "url": "https://wechaty.js.org/2020/06/17/python-wechaty-beta-released/",
    "title": "Python Wechaty Beta Released: A Simple Bot",
    "body": "2020/06/17 - Python-wechaty能够使用少量代码即可完成一个机器人，使用起来非常简单，基于OOP的设计思路能够很好监听和处理微信内部大量的事件，比如：自动回复消息，定时发送消息，拉人入群，好友申请同意等等。此外，目前的插件系统里面有很多拿来即用的工具，比如拉人入群等。当然开发一个自己的插件也是非常简单，无需很高深的概念，只需要你能够理解事件和OOP即可。 python-wechaty项目源于wechaty，甚至说很大程度上代码是直接从其翻译过来的，然后加上一些python的特性，让其更加pythonic。作为一个IM的入口工具，未来我们也将添加更多的Chatbot元素进去，让其能够成为一个真正的聊天机器人。 在介绍python-wechaty之前，还是简要介绍一下wechaty。 wechaty: 或许有很多人会把wechaty和wechat联系起来，毕竟在名称上面只是一字之差。这个得从wechaty的起源开始说起，起初，此项目只是作为微信的一个工具库，能够进行一些简单的自动化操作过程，比如：定时发送消息，入群消息发送，好友申请接受等。 可随着项目的逐步更新，wechaty已支持主流的IM软件，比如：微信，钉钉，Telegram。 这个项目从2016年开始，到现在已经获取8k star，是一个非常稳定且用户量非常庞大的项目。官方对其给出的介绍是：  A Conversational AI RPA SDK for Chatbot 所以wechaty作为IM ChatBot的入口工具，是很多聊天机器人的基础架构组件，也将会逐步支持主流聊天机器人的功能。 python-wchaty的诞生: 与Wechaty的结缘是在2019年底的一次技术沙龙会上，认识到了原来6行代码就能够开发出一款足够灵活的机器人，当时给我一个很大的震撼。微信作为我们日常聊天工具之一，如果能够对其做一些自动化的过程，能够很大程度上减少繁琐过程的工作量，比如说：办活动时的拉人入群，定时提醒用户打卡，提醒女朋友姨妈快来了等等。而wechaty能够很好的支持以上所有功能，只需要简单的几行代码即可完成。回去之后就立马着手相关资料的查阅，然后逐步进入wechaty的社区。 一个很巧的机会群里面说可以开发一款go-wechaty的开发，当时我就在想，为什么不能够有一款python-wechaty呢，然后就毛遂自荐，成为了python-wechaty的联合作者之一。由于对开源软件和DevOps不是很熟悉，起步阶段遇到了很多的问题，不过经过社区大佬的耐心指导，目前已能够完成对issue和feature的开发和管理。亲身经历，建议大家有机会一定要参加开源项目，能够让你学习到很多知识点。 最简单的Bot: 使用python-wechaty能够很简单的开发一款Bot，特别是使用了一个插件系统之后，如下所示： 以上代码中实现了两个主要的功能：  当Bot接受到一个#ding信号，就立马回复一个dong消息，这就是一个基本的ding-dong-bot。 当接受到查阅天气的文本语句时，则返回对应的天气查询结果，比如：今天天气如何？以上两个插件是系统内置的，后续也会增加更多的拿来即用的实用插件，当然用户也可创建自己的插件，方式很简单。 如何开发插件系统: 在了解如何开发插件系统之前，可先移驾Plug-in`，插件系统支持对插件的安装，卸载，自定义配置等内容 ，至于具体的实现形式我相信也是需要面对具体的应用场景。而在Wechaty这个面相事件型且交互逻辑非常简单的场景下，插件的设计与开发就非常简单。 我们现在直接来看看，系统内置的叮咚插件是如何实现的。    basic ding-dong bot for the wechaty plugin   from typing import Unionfrom wechaty import Message, Contact, Room, FileBoxfrom wechaty. plugin import WechatyPluginclass DingDongPlugin(WechatyPlugin):     basic ding-dong plugin     @property  def name(self):       name of the plugin       return 'ding-dong'  async def on_message(self, msg: Message):       listen message event       from_contact = msg. talker()    text = msg. text()    room = msg. room()    if text == '#ding':      conversation: Union[        Room, Contact] = from_contact if room is None else room      await conversation. ready()      await conversation. say('dong')代码很简单，不过也是需要氛围一下几个层面来介绍。  WechatyPlugin on_[event_name] init_pluginWechatyPlugin: 此类为一个抽象类，所有的插件必须要继承此基类，并重写其中的函数。    name 属性函数   为抽象函数，必须重写。主要是为了标识插件的名称，作为插件唯一性身份认证。     init_plugin 初始化函数   能够支持插件的初始化过程，比如初始化定时器对象，数据库延迟连接对象等。     on_[event_name]   此类函数主要是为了监听系统中的不同事件，比如：on_message, on_login, on_friendship等事件的监听都只需要重写一下函数即可完成。不同插件之间以及不同事件之间都是独立的，能够很好的专注于不同业务场景下的开发。  event_name: python-wechaty很大程度上是由事件驱动，毕竟很多操作都是基于消息接受触发，由此事件的监听是其基础特性，可能第一感觉就是实用EventEmitter这种模式来监听事件，这样每个事件我都可以注册不同的函数来监听，每个函数中会有不同的逻辑处理。这也是传统的事件监听方法，可这至少会给开发上带来一些不方便：函数的参数需要查阅文档才能够获知，标准的函数式编程。  我不是说函数式编程不好，只是在这种场景下对系统性能并不能提升多少，且python-wechaty 也并不能太注重性能。 由此将其扩展了OOP的方式，用户可继承Wechaty或WechatyPlugin来监听不同的事件，且在常规的代码编辑器里面重写函数时就可以自动填充函数参数，从而减少查阅事件函数参数的问题。 监听事件的类型有：error, friendship, heartbeat, login, logout, message, ready, room_invite, room_join, room_leave, room_topic, scan。 在上面已经展示了WechatyPlugin如何开发，需要注意的地方，那接下来我将给大家详细介绍一下最基础的每日一说的机器人如何开发。 每日一说机器人: 每日一说，顾名思义每天每个固定时间段发送一个祝福或提醒，具体内容可自定义。这其中需要注意几点：  机器人内部有一个调度器，用于调度时间事件的触发。 机器人可给制定的人和群发送对应的内容。以上的功能我封装成一个插件，然后注入到python-wechaty中即可。    daily word plugin   from datetime import datetimefrom apscheduler. schedulers. asyncio import AsyncIOSchedulerfrom wechaty import Wechatyfrom wechaty. plugin import WechatyPluginclass DailyPlugin(WechatyPlugin):       say something everyday, like `Daily Words`       @property  def name(self) -&gt; str:       get the name of the plugin       return 'dayily'  async def tick(self):       time tick for the plugin scheduler       room_id = get_room_id()    room = self. bot. Room. load(room_id)    await room. ready()    await room. say(f'i love you -&gt; {datetime. now()}')  async def init_plugin(self, wechaty: Wechaty):       init plugin       await super(). init_plugin(wechaty)    scheduler = AsyncIOScheduler()    scheduler. add_job(self. tick, 'cron', hour=6, minute=16)    scheduler. start()插件就开发完了，然后将其注入到Wechaty中即可跑起来。 async def main():  bot = Wechaty(). use(DailyPlugin())  await bot. start()asyncio. run(main())是不是超级简单，插件系统帮你隔离所有的业务场景，让代码非常易于开发和维护。 python-wechaty还可以做更多: 现在python-wechaty只完成了基本的Chatbot入口工具，离真正的聊天机器人还距离很远，所以未来还有很多工作量可以做，也欢迎更多的研究chatbot，nlp的小伙伴联系我，共同开发让大家都喜欢用的开源软件。 微信号：pure-_--love  Author: wj-McatCode: python-wechaty "
    }, {
    "id": 303,
    "url": "https://wechaty.js.org/2020/06/16/java-puppet-manager/",
    "title": "简单聊聊java版Puppet Manager的实现",
    "body": "2020/06/16 - 我们来简单聊一聊java-wechaty中Puppet Manager的实现。 前言:     首先，这里借用java-wechaty的maintainer犀利豆的博客介绍一下wechaty是什么，以及java版本的前世今生。  犀利豆终于有一个Java可以用的微信机器人了 背景:     参与开发java-wechaty有一个多月的时间，在开发的过程中，不免要进行自测。在前期没有token调试不便的情况下，就想借助单测对所写代码进行验证，但是我发现想要进行单测也不是一件容易的事情。与以往 java web 开发不同，没有Spring封装好的带有上下文的test。于是，我借鉴ts版本wechaty的mock模块，实现了java-wechaty的mock puppet，专门用于测试wechaty上层代码逻辑。开心地实现完成mock puppet之后，又发现了新的问题。那就是现有java版本的wechaty在初始化puppet的时候，在代码中写死了hostie puppet，也就是图中的GrpcPuppet。     这样的话，我就无法初始化mock puppet了，所以我就思考能不能有一个manager来管理puppet的具体实现。有了这个想法，那么如何进行优雅的实现呢？接下来我们简单来聊聊。 实现思路:  PuppetManager来管理具体的puppet实现类 在wechaty中通过调用PuppetManager的实例化方法，初始化出需要的puppet实现 可使用反射机制处理puppet和具体实现类    使用上述思路的改造，wechaty初始化的流程就变成了下图的样子。     可以看到，在wechaty的initPuppet()方法中，不再是直接初始化GrpcPuppet，而是使用了PuppetManager的resolveInstance()方法拿到了初始化过的puppet实现。    那么PuppetManager具体是怎么实现的呢？其实很简单，直接看代码。 const val REFLECTION_BASE_PACKAGE =  io. github. wechaty class PuppetManager {  companion object {    private val log = LoggerFactory. getLogger(PuppetManager::class. java)    @JvmStatic    fun resolveInstance(wechatyOptions: WechatyOptions): Future&lt;Puppet&gt; {      log. info( PuppetManager resolveInstance(${JsonUtils. write(wechatyOptions)}) )      val reflections = Reflections(ConfigurationBuilder(). setUrls(ClasspathHelper. forPackage(REFLECTION_BASE_PACKAGE, Thread. currentThread(). contextClassLoader)))      val subTypes: Set&lt;*&gt; = reflections. getSubTypesOf(Puppet::class. java)      if (subTypes. isEmpty()) {        throw java. lang. RuntimeException( expect one puppet,but can not found any one.  )      }      if (subTypes. size &gt; 1) {        throw RuntimeException( expect one puppet,but found ${subTypes. size} )      }      val clazz = subTypes. first() as Class&lt;*&gt;      val declaredConstructor = clazz. getDeclaredConstructor(PuppetOptions::class. java)      return CompletableFuture. completedFuture(declaredConstructor. newInstance(wechatyOptions. puppetOptions!!) as Puppet)    }  }}    首先定义了一个基础的包路径，在该路径下使用reflections库，扫描所有实现了Puppet的类。因为我们必须需要一个puppet具体实现类，所以当我们扫描不到任何puppet的实现时，会抛出异常，告知开发者期望有一个puppet实现类，但是在classpath下并没有找到。     其次，当前我们只支持单次实例化一种puppet实现，所以当在路径下扫描到多于1个puppet实现类时，同样会抛出异常，提示开发者classpath中存在一个以上的puppet实现。     上面两种情况均未抛出异常的，说明manager已经找到了需要实例化的puppet实现，接下来就使用java反射，直接实例化即可。     以上就是manager实例化puppet的简单实现。 展望:     首次引入manager的版本中，我们把之前引入到wechaty sdk中的hostie puppet实现拿了出来，在sdk中仅引入puppet定义层。这样，使用者需要哪种puppet实现，自己引入即可，作为sdk就不再关心了。    但是这样又增添了使用者的使用门坎，不如之前仅引入sdk包就能使用方便，所以在接下来的版本中，我们还是打算在sdk中使用hostie puppet作为puppet的默认实现，如果使用者有使用其他puppet实现类的诉求，需要手动在pom中exclude掉hostie puppet的默认实现，然后引入需要的puppet实现即可。     后续可能会支持多个puppet，那么manager就需要适当的改造去适配多个puppet实现。这里有一个简单的设计思路，在puppet定义层，我们可以定义一个mapping()方法，该方法的意思是作为一个puppet，我需要如何的映射才能初始化。那么具体怎么映射就交给子类，也就是具体的puppet实现类自己去实现。在manager中，我们只需要使用puppet定义层的mapping()方法就可以实现对子类的映射处理，作为manager，并不用关心当前到底是谁在初始化。下图是大体的结构。     有了PuppetManager，我们的java-wechaty实现得更加优雅了一些，而且实现了mock puppet，后续就可以通过单测提高代码的质量，提升稳定性，相信我们的java-wechaty会越来越完善。    如果你对wechaty感兴趣，恰巧又是java developer，对java-wechaty有自己的想法或对目前的代码实现有任何好的建议，期待你的加入，为java-wechaty贡献代码~  redmaple1’s blog简单聊聊Puppet Manager的实现作者: redmaple1Code: Github "
    }, {
    "id": 304,
    "url": "https://wechaty.js.org/2020/06/15/java-wechaty-beta-release/",
    "title": "Java Wechaty Beta Released: 终于有了 Java 可以用的微信机器人",
    "body": "2020/06/15 - 终于有一个 Java 版的微信机器人了。 公众号很久没有更新了。主要两个原因，换了工作之后，第一，要花更多的时间去了解和学习新的业务。第二，我最近把几乎所有的业余时间都来写这个 Java 版的微信机器人了。 Wechaty 是什么: 官网的描述是：  A Conversational AI RPA SDK for Chatbot其实就是一个能够快速构建聊天机器人的开源 SDK。最早的时候，Wechaty 只是一个基于服务于微信工具库，现在逐渐的发展到可以对接世面上的主流聊天软件包括不限于：微信，企业微信，钉钉，Line 等。 编程语言也由原来的单一语言（TypeScript） 发展到，Java，Scala，Python，Go 等多语言实现的工具库了，同时社区生态还在不断的壮大。 Github 地址：https://github. com/wechaty/wechaty 目前已经有 7. 9k 的 star 了。 与 Wechaty 结缘: 之前的工作，老板有一个要求，是就每天下班后，发一封邮件日报简单描述一下今天工作进展。如果忘记发日报，第二天就负责整理 全组人的日报。作为一个健忘的人，忘记发日报简直就是家常便饭。 于是就考虑需要一个机制：  每天提醒我发日报 动作尽可能简单，且自动化。当时就想能不能在微信上有一个机器人，每天定时提醒我发日报，而且只要回复这个机器人，他就能够把我回复的消息，按照固定模板生成日报并发送给老板。这样既不会忘记，也能简单自动化的完成这个工作。 一顿 Google 还真找到了 Wechaty 这个工具。尝试写了一个日报机器人满足了我的需求。于是再接再厉，又写了一个提醒女朋友吃饭的工具，但是因为不熟悉 TypeScript。写出的机器人没法停止，变成了一个信息轰炸机，差点被拉黑。居然有人能忘记吃饭？写个微信机器人提醒他 就是因为这篇文章，还结识了 Wechaty 的作者李佳芮。现在她的公司已经估值很多个 0 了。 由于我的主要工作语言是 Java ，对 TypeScript 还是了解不多，就暂时放下了。 Java 版的 Wechaty: 在 Wechaty 的某个版本后，开始支持 GRPC 作为传输协议。这个时候我觉得多语言开发的环境就比较成熟了。于是我就开始尝试写一个 Java 版的 wechaty。 Java vs Kotlin: Wechaty 使用 TypeScripe 开发，在移植的过程中，发现要实现 TS 版对应的功能，Java 所需要的模板代码就太多了，开发起来效率不够快。于是就考虑可不可以使用 Kotlin 来构建 Java-wechaty sdk。 Kotlin 有以下特性感觉比较适合 Wechaty 的开发：  Java 和 Kotlin 之间可以无障碍的互相操作 在 Kotlin 中，函数也是第一公民，可以脱离类的存在，这一点在移植 TS 代码的时候优势就比较明显了。 空指针安全，之前写 Java 的时候，受够了一步一检查。Kotlin 在语言层面就解决了空指针安全的问题。写起来有效的减少心智负担。 Kotlin 是务实的，更有表现力的语言。语法更加接近 TS 和 GO，相对 Java 来说更加简洁。事件驱动: TS 版的 Wechaty 是基于 Nodejs 开发的，一个典型的事件驱动的架构。在开发初期我就自然想到了使用 Vertx 框架来开发。但是开发一段时间后发现，其实 Vertx 是一个事件驱动的网络框架。主要解决的还是网络相关的问题，放到 Java-wechaty 中还是太重了。 于是移除了代码中的 Vertx 框架，自己参考 Nodejs 中的 EventEmitter 实现了 Kotlin 版的事件驱动组件。 整体架构:  +--------------------------+ +--------------------------+ |             | |             | |  Wechaty (TypeScript)  | |   Wechaty (Java)    | |             | |             | +--------------------------+ +--------------------------+ +-------------------------------------------------------+ |         Wechaty Puppet Service        | |                            | |        (wechaty-puppet-service)        | +-------------------------------------------------------++--------------------- @chatie/grpc ----------------------+ +-------------------------------------------------------+ |        Wechaty Puppet Abstract        | |                            | |          (wechaty-puppet)          | +-------------------------------------------------------+ +--------------------------+ +--------------------------+ |   Pad Protocol    | |   Web Protocol    | |             | |             | | wechaty-puppet-padplus  | |(wechaty-puppet-puppeteer)| +--------------------------+ +--------------------------+ +--------------------------+ +--------------------------+ |  Windows Protocol   | |    Mac Protocol    | |             | |             | | (wechaty-puppet-windows) | | (wechaty-puppet-macpro) | +--------------------------+ +--------------------------+通过这个图可看到，Wechaty 的结构设计还比清晰。利用 Puppet 的架构，将真正的通信协议和具体的 IM 软件进行了隔离。基于这一点不同的语言基于 Puppet 的协议就可以进行多语言开发。 好用么: 感谢 Wechaty 前期良好的 API 设计几行代码就可以开发自己聊天机器人： Demo 1： class Bot{ public static void main(String args[]){  Wechaty bot = Wechaty. instance()   . onScan((qrcode, statusScanStatus, data) -&gt; System. out. println(QrcodeUtils. getQr(qrcode)))   . onLogin(user -&gt; System. out. println( User logined :  + user))   . onMessage(message -&gt; System. out. println( Message:  + message))   . start(true); }}这个 Demo 6 行代码，就实现了机器人的扫码登录，接受消息的功能。同时现在 Java-wechaty 还支持可插拔的插件。利用插件，可以更简单的构建机器人。 Demo 2： class Bot{ public static void main(String args[]){  Wechaty bot = Wechaty. instance()      . use(        WechatyPlugins. ScanPlugin(),        WechatyPlugins. DingDongPlugin(null)      )      . start(true); }}随着插件的原来越丰富，可能以后，用户只需要组合各种插件，就能达成自己的需求，尽量的做到低代码开发。 现在达到什么程度了？: 目前 Java-wechaty 已经完成了 TS 版的功能的移植。 实现了基础的的聊天，好友管理，群管理功能。接下来的开发就会集中在 API 的打磨，稳定性的提升。同时也期待你的加入为 Java-wechaty 贡献代码。 从 Java-wechaty 中能得到什么？:  真正的参与开源代码的贡献。 在 Maven 中央库，发布了自己的 Jar 包。 认识了各种各样小伙伴，包括写了 25 年程序的天使投资人 @Huan。 在写 Java-wechaty 的时候，不断的参考伙伴们的 TypeScript，Go，Python 代码，从实际的角度去审视各种编程语言的特性。探寻语言各个特性设计的初衷。期待你的加入: Wechtay 社区加入了由 中科院软件所 与 openEuler 社区 共同举办的一项面向高校学生的暑期活动《开源软件供应链点亮计划-暑期2020》。 详情见： https://github. com/wechaty/summer-of-code Wechaty 给学生们提供了很多有意思的题目，比如：  利用 AI 技术，开发一个 AI 斗图机器人 利用 Wechaty 的插件技术，开发一个“每日一句”插件，替你向妹子嘘寒问暖的”撩妹“机器人 还有偏向工程的，代码移植工作，让学生真正的参与到开源项目其中开发语言涉及，TypeScript，Go，Java，Kotlin，Python 甚至还有 Scala，总有一个适合你。 希望看到这里的你，可以把篇文章，转发给学习计算机，或者对编程感兴趣的学生朋友，期待他们加入。 后记: Java-wechaty 项目地址。 加入我们你也可以六行代码写一个微信机器人。  Author: @diaozxin007 The author of Java-wechatyCode: @Java-wechaty "
    }, {
    "id": 305,
    "url": "https://wechaty.js.org/2020/06/15/daily-push-bot/",
    "title": "资讯自动推送机器人（Daily push wechat robot）",
    "body": "2020/06/15 -  前言: 工作后慢慢发现，学习的成本越来越低，真正困难的是没有“空闲时间”学习，如何利用这有限的时间创造更大的价值变得尤为重要。 以 AI 领域的微信公众号为例，每天都在产出最前沿的资讯，以及对经典问题的沉淀，文章篇幅也都不会太长，方便读者阅读，但是假设用户关注了100个这样类型的公众号，每次想看文章都要从100个公众号下逐个审查，这也是一个耗时的过程，那是否可以定时或指令性的自动筛选和推送文章给到用户呢？ 没错，这就是这个机器人要解决的问题。 项目说明: 根据需求，项目可分为两大模块，即 信息爬取模块 和 消息发送模块：    信息爬取模块—-低端的静态爬虫   概述：每天定时从固定微信公众号同名的微博账号主页爬取文章标题及其链接   实现：Python     消息发送模块—-Wechaty   概述：推送等聊天功能   实现：JavaScript  具备功能: 0. 静态网页爬取: 0. 1 每天定时从”微博”相关公众号主页爬取当日资讯 1. 关键词触发功能: 1. 1 关键词”介绍一下自己”、 “自我介绍一下”、 “你是谁”触发自我介绍 1. 2 关键词“推送”触发咨询推送，内容为前一日资讯 1. 3 地名+天气 触发天气查询 2. 群外聊天（好友私聊）: 2. 1 功能1全部具备 2. 2 自动回复文本消息 2. 3 图片、视频、表情包、链接、撤回等非文本消息随机回复颜文字 3. 群内聊天（机器人一对多）: 3. 1 白名单群 功能如同 1、2， 群内成员皆有聊天权限，可 “@bot” 触发，也可直接对话， 不会回复 @其他群成员 的消息 3. 2 灰名单群 功能如 3. 1，但权限有别，仅由指定管理人触发，且必须通过 “@bot” 3. 3 入群欢迎词 目录结构: │ ││ │   README. md            # 本文件│ ││ ├─pull_message│ │   pull_data_from_weibo. py     # 静态抓取资讯│ ││ ├─message_warehouse│ │   push_me_2020-06-11. txt     # 抓取资讯样例 日期为前一天日期│ ││ │─my_robot│ │   bot. js            # 机器人主程序│ │   config. js           # 配置文件 补充自己的信息│ │   onMessage. js         # 主要对话逻辑│ │   onRoomJoin. js         # 进群欢迎程序│ │   onScan. js           # 扫码登录程序│ │快速运行: 按照 github 中 repo 的 README. md 操作即可，另有几点需要说明  信息爬取模块推荐部署成定时任务 打开config. js 文件，配置自己的信息 onMessage. js 中的闲聊接口为小思机器人，需要单独申请完善方向:  加入 NLP 技术，bot 通过识别指令推送相应资讯，比如： 张三：@Bot 推送 知识图谱 Bot：@张三 最新的 知识图谱 资讯如下. . . . . .    加入 NLP 技术，过滤爬取数据中的广告文章     加入定时推送功能，筛选出假节日和工作日，仅在工作日推送     提醒/备忘 功能监听     ……  部分功能展示:   作者: IvanEvanCode: Github "
    }, {
    "id": 306,
    "url": "https://wechaty.js.org/2020/06/15/b-bot-for-fun/",
    "title": "发段子 舔狗 毒鸡汤 美图bot",
    "body": "2020/06/15 -  背景: 个人比较喜欢看看段子,毒鸡汤，舔狗日记，电影，美图，还有虎扑步行街，所以就收集了很多数据放在网站上，同时有一些群需要管理，我希望活跃气氛，就希望做了个这样的bot，通过一番学习之后，之前的itchat vbot都是web协议 都用不了了 然后了解到wechaty，是可以提供ipad协议，具体添加 botorange_yeah 微信 然后就有15天试用，然后你可以通过review 而且写一遍博客关于wechaty就可以 for free Any developers can add JuziBOT Inc’s staff ( Wechat number : botorange_yeah ) as a Wechat friend. You will receive a review form after adding. If you pass the review and willing to write a blog in Wechaty , you can use our iPad protocol for free！链接：https://github. com/juzibot/Welcome/wiki/Support-Developers 功能:  段子 毒鸡汤 舔狗日志 美图准备开发功能:  定时发送 给对象 我们在一起xx日了 爱你每一天 监听虎扑xx基地发帖 一发帖就通过微信通知 发送每天互联网的大事实现逻辑: wechaty具体有如下模块：  FriendShip：主要处理好友请求 Message：处理消息模块 Contact：好友管理 当wechaty实例监听到某一事件触发时，会去执行对应的消息监听逻辑。 这样看来，其实主要的操作逻辑在于消息模块，也就是message事件触发时，依赖:  axios：网络请求库 wechaty：wechaty核心库 wechaty-puppet-padplus：wechaty的ipad协议实现实现过程: import { Contact, Message, Wechaty } from 'wechaty';import { ScanStatus } from 'wechaty-puppet';import { PuppetPadplus } from 'wechaty-puppet-padplus';import QrcodeTerminal from 'qrcode-terminal';import '. /service/';import onFriendship from '. /handler/friendship';import onMessage from '. /handler/message';async function bootstrap() { // 这里使用获取到的ipad token 填写你申请的token 具体查看. /handler/message. ts const token = process. env. WECHATY_TOKEN; // 创建puppet实例 const puppet = new PuppetPadplus({  token, }); const name = 'wechat-bot'; // 传入pupoet，创建wechaty实例 const bot = new Wechaty({  puppet,  name, }); // 链式调用，将事件监听函数传入，并且启动wechaty bot  . on('scan', (qrcode, status) =&gt; {   if (status === ScanStatus. Waiting) {    QrcodeTerminal. generate(qrcode, {     small: true,    });   }  })  . on('login', (user: Contact) =&gt; {   console. log(`login success, user: ${user}`);  })  . on('logout', (user: Contact, reason: string) =&gt; {   console. log(`logout user: ${user}, reason : ${reason}`);  })  . on('message', (msg) =&gt; onMessage(bot, msg))  . on('friendship', (friendship) =&gt; onFriendship(bot, friendship))  . start();}bootstrap();本地运行:  克隆项目git clone https://github. com/generalbao/paipiange-wechat-bot也可以参考 这位仁兄的代码 我也是参考他的 git clone https://github. com/H3lloTom/wechat-bot/ 安装依赖yarn 启动项目yarn start效果图: 致谢:  感谢Wechaty团队提供这么好的一个工具，让我们开发者可以持续增强我们的国民级应用。希望能够有更多的人参与进来，来继续扩大wechaty的生态圈。 感谢juzibot提供的api-token 作者: generalbaoCode: Github "
    }, {
    "id": 307,
    "url": "https://wechaty.js.org/2020/06/13/cps-chat-bot/",
    "title": "CPS chat bot",
    "body": "2020/06/13 - tips: 使用微信群，推广电商商品及优惠券，机器人使用 wechaty-puppet-padplus. 简介: 推广营销机器人是一个微信助手，可以帮助推广者在自己的微信群，查询优惠商品及优惠券并转发到自己所在的微信群 需求描述: 1. 推广者启动机器人，查询商品  当推广者，发送指令查询商品类目后， 微信助手通过接口查询到商品列表。2. 查询到的商品信息，发送到微信群  例如, 发送【京东】君乐宝 涨芝士啦酸奶芝芝多莓口味 180g*12袋京东价：¥ 59. 9-------------------商品入口 https://union-click. jd. com/jdc?e=&amp;p=AyIGZRhYFQARAlYeWxMyFQVcGF8dAxoCUx9rUV1KWQorAlBHU0VeBUVNR0ZbSkAOClBMW0scWRwBFg9UE14TBg1eEEcGJQdmAg9dP2tScQdSHjJIR1lmM3s9cUQeC2UeWhQDEgFdHVMXMhIGVBhSFgMSBlUraxUHIkY7HVIXBBIAZRlaFAEXD1MbXhUyEgNdG1IUAhMFUx1dFDISD1ErAEBsZ3UOTRpXVkdCPkgPJTIiBGUraxUyETcLdVpGAUFTABwLe1hBDwwSBkwEfAVWGF0cBSIFVBpZFw%3D%3DQuick Start: 新建项目: mkdir bot &amp; cd . /botnpm init -y安装项目依赖 npm install --save wechatynpm install --save wechaty-puppet-padplusnpm install --save qrcode-terminal开始编码: 项目目录如下 - src - my-chat-bot. js- config - config. tsconfig. js: 配置信息 module. exports = { // puppet_padplus Token token:  puppet_padplus_. . .  }my-chat-bot. js: /** * wechaty-puppet-padplus index */import { Wechaty } from 'wechaty'import { PuppetPadplus } from 'wechaty-puppet-padplus'import config from '. . /config/config'// initconst bot = new Wechaty({ puppet: new PuppetPadplus({  token: config. token }), name: config. name})bot. on('scan',  onScan)bot. on('login',  onLogin)bot. on('logout', onLogout)bot. on('message', onMessage)bot. start() . then(() =&gt; log. info('StarterBot', 'Starter Bot Started. ')) . catch(e =&gt; log. error('StarterBot', e))收商品指令: 收到查询商品指令 /** * onMessage */async function onMessage (msg: Message) { // log. info('StarterBot', msg. toString()) if (msg. type() === bot. Message. Type. Text) {  if (msg. text(). includes('#查询商品：')) {    queryJingFenGoodsAndSendMsg(msg);  } else if (msg. text(). includes('ready stop')) {   console. log('ready stop');  } }}查询商品: const eliteIds: Array&lt;Number&gt; =[ 1, //好券商品, 22, //热销爆品, 2, //超级大卖场, 10, //9. 9专区, 23, //为你推荐];var eliteIdIndex = 0;/** * QueryJFGoodsAndSendMsg */function queryJingFenGoodsAndSendMsg(msg: Message) { var eliteId: Number = 1; // 查询商品 queryJingFenGoods(eliteId). then(res =&gt; {  var index = 0  if (eliteIdsIndex &lt; eliteIds. length) {   eliteId = eliteIds[eliteIdsIndex];   eliteIdsIndex ++;  } else {    eliteIdsIndex = 0;  }  if (index &lt; res. length) {  var goods: JFGoodsInfo = res[index];  index ++;  // 领链  getCpsUrl(goods). then(res =&gt; {    var cpsInfo: CpsInfo = res;    // 发消息    sendPromotionMsg(msg, goods, cpsInfo)  });  } }, rej =&gt; {  console. log('rej = ', rej); });/** * 根据类目查询商品 */async function queryJingFenGoods(eliteId: Number) { return new Promise((resolve: (value: Array&lt;JFGoodsInfo&gt;) =&gt; void, reject) =&gt; {  var uParam = {   goodsReq: {    pageIndex: 1,    pageSize: pageSize,    eliteId: eliteId   },  };  requestAPI('https://router. jd. com/api', JSON. stringify(uParam))  . then(res =&gt; {   if (res. code === '0') {     var dataArr = res. data;     var list = [];     for (let d of dataArr) {      var goods = new JFGoodsInfo(d)      list. push(goods);     }     resolve(list)   }  }, rej =&gt; {    reject('Server error');  }); });}/** * 领链 */async function getCpsUrl(goodsInfo: JFGoodsInfo) { return new Promise((resolve: (value: CpsInfo) =&gt; void) =&gt; {  var materialId: string = goodsInfo. materialUrl;  // console. log('indexof http = ', materialId. indexOf('http'))  if (materialId. indexOf('http') !== 0) {   materialId = 'https://' + materialId;  }  const appId = 000000; // your app id  var promotionCodeReq = {   materialId: materialId,   siteId: appId,   positionId: 000000, // your positionId   couponUrl: ''  }  var coupon = goodsInfo. coupon;  if (coupon &amp;&amp; coupon. link) {   promotionCodeReq. couponUrl = encodeURIComponent(coupon. link);  }  var uParam = {   promotionCodeReq  }  requestAPI('https://router. jd. com/api', JSON. stringify(uParam))  . then(res =&gt; {   if (res. code === '0') {    var cpsInfo: CpsInfo = res. data;    // 发品    resolve(cpsInfo);   }  }); });}/** * */function sendPromotionMsg(msg: Message, goods:JFGoodsInfo, cpsInfo: CpsInfo) { (async () =&gt; {  // 发商品图  var urlInfo: UrlInfo = goods. imageInfo. imageList[0];  if (urlInfo. url) {   const fileBox = FileBox. fromUrl(urlInfo. url)   await msg. say(fileBox);  }  // 发送商品信息  var jd;  if (goods. owner === 'g') {   jd = '京东自营';  } else {   jd = '京东';  }  var text = '【'+ jd +'】' + goods. skuName + '\n\r'  + '----------------' + '\n'  + '京东价：¥ ' + goods. priceInfo. price + '\n'  + '券后价：¥ ' + goods. priceInfo. lowestCouponPrice + '\n\r'  + '商品入口：' + cpsInfo. clickURL  await msg. say(text); })();}试运行: 启动脚本 ‘package. json’ { . . .   scripts : {   start :  cross-env WECHATY_LOG=verbose nodemon my-chat-bot. ts  }, . . . }运行 npm run start效果图: 致谢:  感谢Wechaty团队。 感谢句子互动提供的api-token项目链接 https://github. com/wss793062366/my-padplus-bot  Author: @wss793062366 your one-line bio at hereCode: @my-padplus-bot "
    }, {
    "id": 308,
    "url": "https://wechaty.js.org/2020/06/08/wechaty-summer-of-code-2020-talk/",
    "title": "Wechaty Summer of Code 2020 Talk",
    "body": "2020/06/08 -  作者: juzibot 关于暑期2020: “开源软件供应链点亮计划-暑期2020”（简称 暑期2020）是由中科院软件所与 openEuler 社区共同举办的一项面向高校学生的暑期活动。旨在鼓励在校学生积极参与开源软件的开发维护，促进国内优秀开源软件社区的蓬勃发展。根据项目的难易程度和完成情况，参与者还可获取“开源软件供应链点亮计划-暑期2020”活动奖金和奖杯。 官网：https://isrc. iscas. ac. cn/summer2020 官方新闻：http://www. iscas. ac. cn/xshd2016/xshy2016/202004/t20200426_5563484. html Wechaty 与暑期2020: Wechaty 作为中国最大的聊天机器人开源项目，与其他数十个中国顶级开源项目一起参与“暑期2020”。Wechaty合计发布了11个项目，共收到来自清华大学、北京大学、中国科学院大学、南开大学、四川大学等高校的数十份申请，并由Wechaty社区的资深Contributor作为导师，选出了11位同学进行项目开发。此次 Wechaty 发布的11个项目涉及多语言、多平台、多功能三个核心主题，来自Wechaty社区的导师将和来自高校的学生开发者们一起，在三个月的时间里完成对应的开源项目。 Wechaty 暑期2020宣讲会: 你可以在Bilibili上查看暑期2020宣讲会视频 你也可以在Google Docs上查看暑期2020宣讲会Slide 开源的微信聊天机器人框架SDK: 我们的链接是&lt;www. github. com/wechaty/wechaty&gt;，我们目前所有的repo加起来也有8000star，我们想要做的事情就是，用最简单的方式用代码模拟微信的登陆，然后用机器去控制微信的收发消息和群管理等功能    我们怎样实现这样的功能？很简单，当我们的微信去自由接入的时候，可以自由选择接入哪一个puppet,不同的puppet对应不同的底层代码，底层代码完全不会暴露在大家面前，只用关心怎么调用应用层的代码，去实现智能对话的能力就可以，对用户来说，用户是无感知的，对他来说就是一个微信上的真人在跟他聊天，不知道这个机器人接入的哪一种底层，不管是模拟登陆mac，ipad，还是windows，对用户来说就是在跟真人对话，wechaty是做这件事做的最好的，     我们可以想这样一个问题，是不是本质上，微信的接入来说，首先要接入底层协议，基于协议写一些应用层代码，然后直接去跟用户交互，既然能够把微信这件事情做好，那么我们来思考问题：是不是可以让更多的IM接入，只要切换环境变量，就可以切换到不同的IM系统，实现同一套代码应用于不同的平台     所以我们想要做的是下面4件事情：让所有的IM平台都封装同一套IM代码，但是底层代码不同，只需要切换环境变量，就可以把原来在微信上的聊天机器人切换到飞书上，还可以在不同语言，不同插件，不同行业都应用到，去解决很多问题     我们认为wechaty期待同为智能的基础设施，所有行业，所有语言的开发者，都可以使用这个框架去接入微信以及更多的IM通讯平台，我们希望做三大件事情：   首先介绍一下我们团队的导师：wechaty团队实际上是站在技术和商业的十字路口，选择了一个现代的场景，通过聊天机器人，让技术为商业更好的服务，我们很欢迎大家可以和我们一起去共建智能对话的基础设施，从六行代码接入微信开始，能够快速的实现机器人的接入。  我们想要做的事情，11个任务，对应不同的场景 多平台:  首先说说多平台，我们认为做智能对话这件事，最核心的就是要接入，如果说不能让代码很快的接入微信，很快的去操作，后面就成了空谈，wechaty花了4年时间做好了这件事，我们希望用同一套应用层代码去接入剩下的5个平台，飞书叮叮企业微信快手抖音，只要把这些事情都做好了，开发者只要用一套应用层代码和不多余10行的代码就可以去完成不同平台的建立。 我们着重介绍一下企业微信，企业微信会是未来一个非常大的机会，实际上和微信不同，企业微信提供了大量的开放接口，基于开放接口去封装成wechaty对应的应用层代码，会实现一个安全符合规定的机器人，创造出极大的商业价值，非常期待大家在这样的框架上和我们一起努力。多平台：基于开放 API 封装 Wechaty 接口下的企业微信聊天机器人 https://github. com/wechaty/summer-of-code/issues/2:  导师：高原，句子互动CTO、前亚马逊工程师（gaoyuan@juzi. bot）；李佳芮，句子互动CEO、专注微信生态近10年（rui@juzi. bot） 学生开发者：谢昱清，清华大学本科生（1205402283@qq. com） 多平台：基于开放 API 封装 Wechaty 接口下的钉钉聊天机器人 https://github. com/wechaty/summer-of-code/issues/11:  导师：高原，句子互动CTO、前亚马逊工程师（gaoyuan@juzi. bot）；李佳芮，句子互动CEO、专注微信生态近10年（rui@juzi. bot） 学生开发者：杨明哲，福州大学本科生（yutinice@foxmail. com） 多平台：基于开放 API 封装 Wechaty 接口下的飞书聊天机器人 https://github. com/wechaty/summer-of-code/issues/12:  导师：高原，句子互动CTO、前亚马逊工程师（gaoyuan@juzi. bot）；李佳芮，句子互动CEO、专注微信生态近10年（rui@juzi. bot） 学生开发者：范蕊，南开大学本科生（953299708@qq. com） 多平台：基于 RPA 封装 Wechaty 接口下的抖音聊天机器人 https://github. com/wechaty/summer-of-code/issues/13:  导师：尹伯昊，连续创业者，句子互动CMO（yinbohao@juzi. bot） 学生开发者：王俊伟，长春工业大学本科生（863445607@qq. com） 多平台：基于 RPA 封装 Wechaty 接口下的快手聊天机器人 https://github. com/wechaty/summer-of-code/issues/14:  导师：尹伯昊，连续创业者，句子互动CMO（yinbohao@juzi. bot） 学生开发者：毕凯乔，长春工业大学本科生（358461417@qq. com） 多语言: 多语言：Wechaty Java 移植组件开发 https://github. com/wechaty/summer-of-code/issues/4:  导师：刁政欣 阿里开发工程师 Author of Java-wechaty （diaozxin@gmail. com） 学生开发者：陈炀，福州大学本科生（1184016190@qq. com） 多语言：Go-wechaty Github Action optimization https://github. com/wechaty/summer-of-code/issues/8:  导师：丁小雨（ 614422099@qq. com），丁超飞（dchaofei@163. com），李博杰（silkage@silkage. net） 学生开发者：唐光彬，华南农业大学本科生（Tang. Packet@outlook. com） 多语言：为 go-wechaty 设计实现 插件体系 https://github. com/wechaty/summer-of-code/issues/9:  导师：丁小雨（ 614422099@qq. com），丁超飞（dchaofei@163. com），李博杰（silkage@silkage. net） 学生开发者：林昊翰，西安电子科技大学本科生（finctive@foxmail. com） 多功能: 多功能想做的事情，原来写一个功能可能需要大家一起来写，可能每个功能需要几十行或者是几百行代码， 基于python-wechaty的群聊助手机器人 https://github. com/wechaty/summer-of-code/issues/6:  导师：吴京京：Wechaty Committer，Python Wechaty Author1435130236@qq. com 学生开发者：孔祥哲，清华大学本科生15068701650@163. com 编写一个“每日一句”插件 https://github. com/wechaty/summer-of-code/issues/10:  导师：Gcaufy，20000+Star小程序框架Wepy作者、Wechaty Plugin系统设计师,gcaufy@gmail. com 学生开发者：江姗姗，北京大学二学位本科生univerone@outlook. com 基于Python-wechaty建立一个斗图机器人 https://github. com/wechaty/summer-of-code/issues/7:  导师：黄纯洪，python-wechaty contributorhuangaszaq@gmail. com 学生开发者：肖子霖，四川大学本科生me@mrxiao. net 欢迎正在阅读的你参与其中:  社区官网链接：https://wechaty. js. org 社区运营微信： FridayBot"
    }, {
    "id": 309,
    "url": "https://wechaty.js.org/2020/06/06/wechaty-game-bot/",
    "title": "聚会娱乐机器人",
    "body": "2020/06/06 - 几年前大家开始通过微信拜年，基于vbot折腾过机器人，想要给所有alias不为空的好友发送定制问候，在发送不到10人消息之后，自己微信的WEB端口被封。无奈尝下没有技术和被墙的泪水。 作为码农，能自动化处理的事情，为什么一定得人工？ 项目说明: 几天前无意中浏览到Wechaty，于是再次萌发了做个机器人的想法。这次做一个娱乐向的机器人~ 游戏特色: 本次开发了谁是卧底小游戏，房主无法设置游戏角色及人数，要求至少4人参加。每轮游戏结束后会重新分配各角色人数，增加随机趣味性。[扫最下方的二维码，发送ding自动加好友体验~] 假定总人数为ALL平民人数[P]：默认 总人数一半 + 1 向下取整卧底人数[W]：默认 随机 1 到 总人数 - 平民人数白板人数[B]：ALL - P - W额外分配：若W大于3则会再次分配，随机减少 0 或 W - 2人数，减少的人数加到P头上因此一般的人数规律是：3/1/0,3/1/1,3/2/0,4/1/1,4/2/0. . . . 游戏规则： 游戏结束：存活人数/游戏人数 &lt;= 1/2时，即 2/4,2/5,3/6,3/7,4/8胜利条件：1. 平民淘汰所有卧底和白板 平民胜2. 卧底存活至游戏结束 卧底胜3. 所有卧底出局后白板仍然存活 白板胜附上部分逻辑代码说明。 /** * 定义当前轮次游戏角色数目 * @param {Number} playLength [游戏总人数] * @return {Array}       [平民、卧底、白板每种角色的具体人数] */Word. defRoleNum = function (playLength) {  let Civilian, Undercover = 0  Civilian = parseInt(playLength / 2) + 1 // 一半 + 1  Undercover = randomNum(1, playLength - Civilian) // 随机卧底数目  if (Undercover &gt; 3) { // 如果卧底大于3个    const rand = randomNum(0, Undercover - 2)    Civilian += rand // 最少保留1个卧底 其它归到平民    Undercover -= rand  }  const Blank = playLength - Civilian - Undercover // 白板人数  return [Civilian, Undercover, Blank];}// 定义当前轮次每玩家对应角色Word. defTurn = function (playsList) {  const playLength = playsList. length  if (playLength &lt; 4) {    return  }  const roles = this. defRoleNum(playLength)  const roleList = deepClone(roles)  const randomWord = randomNum(1) ? this. randomWord() : this. randomWord(). reverse()  // 难得再转化 直接汉字  let role = '平民';  let word = '';  let newPlaysList = []  for (var i = 0; i &lt; playLength; i++) {    var index = randomNum(playsList. length - 1); //随机下标    if (roles[2]) {      role = '白板';      word = '';      roles[2]--;    } else if (roles[1]) {      role = '卧底';      word = randomWord[1];      roles[1]--;    } else {      role = '平民';      word = randomWord[0];    }    playsList[index]. role = role    playsList[index]. word = word    // 顺便按顺序排号    newPlaysList. push(playsList[index])    playsList. splice(index, 1); //  将随机出的元素在arr中删除    // console. log(roles)  }  // 排序  newPlaysList. sort((a, b) =&gt; {    return a. self_id - b. self_id  })  const first = randomNum(1, newPlaysList. length)  return { roleList, playsList: newPlaysList, first }}项目使用: 目录结构:  config文件夹存放公共配置文件以及flyio请求相关配置 imgs存放相关图片 listeners存放机器人初始化后一系列事件处理(分模块)     games 游戏模块         iswho. js 谁是卧底核心模块          on-friendship. js 处理好友请求   on-login. js 处理登录   on-message. js 处理用户消息、群消息   on-scan. js 处理登录二维码   on-work. js 做一些额外任务    schedule 对定时任务node-schedule库进行了封装 migrations 数据库迁移文件 api 存放所有的数据请求、接口封装都在此 utils 公用方法的封装 app. js 入口文件 db. js 数据库入口文件 knexfile. js 数据库配置文件如何使用:  修改config配置打开config/index. js 文件，将里面的配置改为自己的。token 和 name 必填 appToken. tianxin 也必填 修改天行接口配置天行 api 官网 ：https://tianapi. com/ 注册成功后，申请以下接口：     每日英语一句话   神回复    依赖sqlite3 和 redis, redis应需要单独安装然后就可以运行了 npm installnpm run initdbnpm start已实现功能:  发送加群关键字，自动拉人进群。 场景模式     谁是卧底    神回复 英语一句话 天气查询 发送关键字，踢人列几个有趣的功能，后续慢慢完善：  随机匿名好友聊天 生活向文字冒险游戏谁是卧底小游戏:  作者: osindexCode: Github "
    }, {
    "id": 310,
    "url": "https://wechaty.js.org/2020/06/04/group-wechat-bot/",
    "title": "使用Wechaty开发微信群管理小助手",
    "body": "2020/06/04 - 我们设计了一个租房平台的微信小程序，为了方便推广，针对每个地区开设了一个或多个微信群，每天会在群里发文字和小程序的二维码来推广小程序和阐述群规定。因为所开的群太多，如果是人工发送这些东西，会很浪费时间。因为发的东西都是固定的，所以考虑使用微信机器人。 具体实现:  代码repositorygit clone git@github. com:isnl/wechat-robot. git 代码结构 bot. js: 项目入口文件，实现了扫码微信，登录登出功能。 daily-job. js: 群发逻辑的实现函数，可以自定义每天发送的文字以及发送时间。安装依赖:  npm install wechaty@latest npm install wechaty-puppet@latest npm install wechaty-puppet-padplus@latest npm install qrcode-terminal npm install node-schedule sudo npm install ts-node typescript -g代码实现: 扫描二维码登录: 这个功能主要依赖qrcode-terminal，代码实现如下： function onScan(qrcode, status) { if (status === ScanStatus. Waiting || status === ScanStatus. Timeout) {  require('qrcode-terminal'). generate(qrcode, {   small: true  }) // show qrcode on console  const qrcodeImageUrl = [   'https://api. qrserver. com/v1/create-qr-code/?data=',   encodeURIComponent(qrcode),  ]. join('')  log. info('StarterBot', 'onScan: %s(%s) - %s', ScanStatus[status], status, qrcodeImageUrl) } else {  log. info('StarterBot', 'onScan: %s(%s)', ScanStatus[status], status) }}定时发送消息的功能: 主要是依赖node-schedule，通过修改schedule的format可以指定在每天的什么时候发送消息。 // *  *  *  *  *  *// ┬  ┬  ┬  ┬  ┬  ┬// │  │  │  │  │  │// │  │  │  │  │  └ day of week (0 - 7) (0 or 7 is Sun)// │  │  │  │  └───── month (1 - 12)// │  │  │  └────────── day of month (1 - 31)// │  │  └─────────────── hour (0 - 23)// │  └──────────────────── minute (0 - 59)// └───────────────────────── second (0 - 59, OPTIONAL)运行代码: node bot. js测试效果:  作者: SamCode: Github "
    }, {
    "id": 311,
    "url": "https://wechaty.js.org/2020/06/03/wechaty-mqbot-video-downloader/",
    "title": "无水印下载短视频机器人",
    "body": "2020/06/03 - 20年初开始接触到Tiktok(国际版抖音)，一直尝试做到今天，收获很多。同时也维护起了自己的一个圈子，圈子内很多人吐槽“短视频去水印工具”，这个比较常用的就是微信小程序，但是大多数都是一堆堆的广告，反应速度大多被作者故意设置了延时（这样可以多看几秒广告） 于是就想着是不是可以自己做一个这样的工具，同时也可以通过这种方式进行引流。 首先想到的就是微信机器人，因为这个用起来太方便了，不论是监控群还是对个人，然后再朋友的推荐之下就接触到了wechaty，上手及用，真的是太简单了。 现在机器人已经上线，并支持国内各大短视频平台的视频无水印下载，只需要发送给机器人视频链接即可。 项目使用: 1. 目录介绍: . ├── README. md   介绍├── config. js   配置文件，有token、机器人名称等├── dtbot. js   机器人核心逻辑代码├── node_modules 所需的模块├── package. json ├── source    需要的资源 如图片└── utils     工具类2. 安装 nodejs 并确保版本在10以上: # macos 直接使用brew install node3. 克隆项目: git@github. com:remainsu/qmrobot. git4. 修改config. js 中的token: const basic = {  TOKEN: '你的token',  NAME: '你的机器人名称',}5. 运行: node dtot. js效果如图，扫码后即可完成登录 主要功能: 机器人当前支持国内各大短视频平台的视频无水印下载，只需要发送给我的机器人视频链接即可。 备注：因为去水印的接口是需要收费的，所以项目源码中隐藏掉了，有需要的朋友可以加我的机器人，我推荐给你 使用方式如下，拿快手举例 1. 发送复制链接: 2. 发送给机器人，会得到及时的返回结果，复制到浏览器即可下载: 最后: 感谢Wechaty开源项目 及 句子互动公司提供的token，为开发者带来极大便利！ 还有很多可以完善的功能，例如如何快速的下载转换会后的视频，目前正在研究中。 欢迎扫码加我的机器人，验证填写 “tiktok”，也欢迎将我推荐给需要的朋友，无水印下载就是这么简单。  作者: remainsuCode: Github "
    }, {
    "id": 312,
    "url": "https://wechaty.js.org/2020/06/02/coupon-wechat-bot/",
    "title": "优惠券搜索机器人（Coupon wechat bot）",
    "body": "2020/06/02 -  背景: 由于疫情的影响，家里人一直窝在家里面，每天除了数窗外的鸟叫声，也就只能在家里疯狂购物剁手了。时间一长，我发现他们需要到很多地方去找商品的优惠信息，非常麻烦。作为一个程序员，怎么能忍受这么低效率的工作呢，所以就写了个爬虫，去定期爬取某网站优惠券信息。再借助wechaty的微信bot功能，在微信里“足不出户”，即可享受到最新的商品优惠信息。 通过一番学习之后，大致了解了一下wechaty的架构信息，wechaty提供了对外的API封装，wechaty-puppet将内部的实现逻辑进行了封装，再由各个平台具体的protocal去实现数据的获取。 功能:  商品搜索 优惠券搜索 账单查询实现逻辑: wechaty具体有如下模块：  FriendShip：主要处理好友请求 Message：处理消息模块 Contact：好友管理 当wechaty实例监听到某一事件触发时，会去执行对应的消息监听逻辑。 这样看来，其实主要的操作逻辑在于消息模块，也就是message事件触发时，处理消息内容，返回优惠券下单地址，一般发送的是网址或是口令信息，则认定为是优惠券搜索。依赖:  axios：网络请求库 wechaty：wechaty核心库 wechaty-puppet-padplus：wechaty的ipad协议实现实现过程: import { Contact, Message, Wechaty } from 'wechaty';import { ScanStatus } from 'wechaty-puppet';import { PuppetPadplus } from 'wechaty-puppet-padplus';import QrcodeTerminal from 'qrcode-terminal';import '. /service/';import onFriendship from '. /handler/friendship';import onMessage from '. /handler/message';async function bootstrap() { // 这里使用获取到的ipad token const token = process. env. WECHATY_TOKEN; // 创建puppet实例 const puppet = new PuppetPadplus({  token, }); const name = 'wechat-bot'; // 传入pupoet，创建wechaty实例 const bot = new Wechaty({  puppet,  name, }); // 链式调用，将事件监听函数传入，并且启动wechaty bot  . on('scan', (qrcode, status) =&gt; {   if (status === ScanStatus. Waiting) {    QrcodeTerminal. generate(qrcode, {     small: true,    });   }  })  . on('login', (user: Contact) =&gt; {   console. log(`login success, user: ${user}`);  })  . on('logout', (user: Contact, reason: string) =&gt; {   console. log(`logout user: ${user}, reason : ${reason}`);  })  . on('message', (msg) =&gt; onMessage(bot, msg))  . on('friendship', (friendship) =&gt; onFriendship(bot, friendship))  . start();}bootstrap();&lt;a name= OFtbO &gt;&lt;/a&gt;本地运行:  克隆项目git clone git@github. com:H3lloTom/wechat-bot. git 安装依赖yarn 启动项目yarn start效果图: 致谢:  感谢Wechaty团队提供这么好的一个工具，让我们开发者可以持续增强我们的国民级应用。希望能够有更多的人参与进来，来继续扩大wechaty的生态圈。 感谢句子互动提供的api-token 作者: h3llotomCode: Github "
    }, {
    "id": 313,
    "url": "https://wechaty.js.org/2020/05/31/your-wechat-bot/",
    "title": "你的微信小助手",
    "body": "2020/05/31 - 我有一个三百多人的前端开发群，每天都有很多个好友请求，让我添加他们进前端开发群。 每天都得重复这个流程： 同意好友请求 -&gt; 手动拉进交流群。 能用机器代劳的事情为何要用手动？时间都是挤出来的，省出来这点时间给自己充电学习不好吗？ github 上找到了 wechaty ，看到了希望。 克隆代码: git clone git@github. com:isnl/wechat-robot. git目录结构:  config存放公共配置以及superagent请求相关配置 imgs存放相关图片 listeners存放机器人初始化后一系列 callback     on-friendship. js 处理好友请求   on-login. js 处理登录   on-message. js 处理用户消息、群消息   on-scan. js 处理登录二维码    schedule 对node-schedule进行了封装 superagent 存放所有的数据请求、接口封装都在此 utils 公用方法的封装 app. js 入口文件主要依赖:  wechaty 个人微信账号的微信机器人 SDK superagent 数据请求 cheerio nodejs 版 jQuery，用于抓取页面内容 node-schedule 一个在 nodejs 中设置定时任务的库 qrcode-terminal 在控制台打印二维码安装依赖: 依赖中需要安装chromium，使用 npm 会下载失败或者很慢，国内嘛你懂得 强烈推荐 使用cnpm安装依赖 cnpm install //npm install实在不想用 cnpm 可以将 npm 源切换成淘宝源 npm config set registry https://registry. npm. taobao. orgnpm config set disturl https://npm. taobao. org/distnpm config set puppeteer_download_host https://npm. taobao. org/mirrors修改config配置: 打开config/index. js 文件，将里面的配置改为自己的。 修改天行接口配置: 天行 api 官网 ：https://tianapi. com/注册成功后，申请以下接口：  每日英语一句话 神回复注册后请打开superagent/index. js，将顶部APIKEY改为自己天行 api 的key即可 其他免费接口可随意申请，自行扩展~ 运行测试: cnpm start //npm start已实现的功能：:  热更新，修改代码后免重启，便于在线调试。 新增全国肺炎、各省市肺炎数据，按关键字回复即可。 添加转大小写、颜色的 rgb 与 base64 互转等开发者常用小工具。 每日毒鸡汤、神回复、英语一句话、实时天气查询。 自动同意好友请求 发送加群指令自动邀请好友进群。 底层 api 基于 wechaty 更多微信消息、群消息、好友、对话等相关 api 可查阅官方文档 wechaty 官方文档  作者: peanutCode: Github "
    }, {
    "id": 314,
    "url": "https://wechaty.js.org/2020/05/31/wxbot-management-platform/",
    "title": "基于Nodejs+Wechaty开发微信机器人管理平台",
    "body": "2020/05/31 - 前言: 曾几何时，我加了一个微信，给它发送”加群”，然后就自动进到开发群了，随之在群聊里问问题，接着那个微信就会@我，引用我的问题并附上解答和参考链接。每天上下班的时候，它还会来一句温馨提示，出于对这种技术的强烈兴趣，开始了微信机器人研究之旅。 开始找了几个第三方平台，试用了几天，但总觉得不够自由，既然是程序猿，何不通过技术手段实现？于是开始在GitHub找到以下三个开源作品  itchat     itchat是一个开源的微信个人号接口，使用python调用微信   使用不到三十行的代码，你就可以完成一个能够处理所有信息的微信机器人    wechaty     wechaty是适用于微信个人的Bot SDK ，可以使用6行 js 创建一个机器人   具有包括linux，Windows，MacOS和 Docker 在内的跨平台支持，基于Node. js    vbot     vbot是基于微信web版的接口，使用http协议以及轮询方式实现   亮点在于通过匿名函数，能够实现多种有趣的玩法   通过 API，更方便的打造属于自己的网页版微信，基于PHP   初识wechaty: 因为对js相对比较熟悉，直接选择了wechaty 它是使用Typescript进行编写的Node项目，是一个专门为个人微信号搭建的bot框架。基本的实现原是通过Chrome实时监听微信网页版的各类信息，然后将抓取的信息封装成接口，供开发者使用。 先看一下官方文档 wechaty-github     wechaty中文文档 6行js创建一个机器人，实在简洁 import { Wechaty } from 'wechaty'const bot = new Wechaty()bot. on('scan',  (qrcode, status) =&gt; console. log(['https://api. qrserver. com/v1/create-qr-code/?data=',encodeURIComponent(qrcode),'&amp;size=220x220&amp;margin=20',]. join('')))bot. on('login',  user =&gt; console. log(`User ${user} logined`))bot. on('message', message =&gt; console. log(`Message: ${message}`))bot. start()文档里可以看到一个示例代码 wechaty-getting-started 下载完之后先 npm i 安装模块，然后运行就有了登录二维码很遗憾，失败了。 网页版微信登录失败: 原来2017年之后注册的微信号都无法登录网页版微信，而2017年之前注册得微信账号也有很大几率登录不上，找朋友试了也都不行。 检验你的微信号是否支持网页微信登录： http://wx. qq. com 点击链接链接，PC端进入然后手机扫码登录，若是可以登上，即可以使用上述示例 然后又去看了vbot 和 itchat，但发现也都是是基于网页协议实现的 从网上查资料，大概有一下几种实现方式：  Web网页端：2017年后不再支持新号登录，仅支持老号，并且掉线严重，功能缺失严重 Xposed技术：在2019年6月份，微信官方在行业重点打击Xposed，自此行业内一片哀嚎遍野，陆续向iPad/MAC协议转型。具体案例请点击 PC Hook：代码注入型，也就是逆向开发。封号情况偏多，使用容易出现追封，公司大规模封号等情况，且目前在营销行业使用率较少，比较偏小团队使用 模拟机：延迟高、消息实时到达率低、模拟人为操作效率慢、功能偏少，承担不了商业化功能 ipad协议：安全性较好，功能满足，行业占有率高，但具有能力研发人员偏少，基本两三个团队研发，且目前已有团队解散，部分微信号段登录失败、且通过grpc,mmtls研发，被检测几率存在 MAC协议：安全性相比iPad协议更好，功能性相比ipad协议少些，行业内具有研发能力更少，安全性、稳定性比较优秀，不会出现追封、批量封的情况 混合通道：微信内部通道，最高权限，基于MAC与Ipad协议，非grpc,mmtls，功能合适，微信正版通道，不会出现技术封号问题看了看，内部通道是不可能的，只有ipad协议个mac协议目前最好了 wechaty-puppet-padplus: 正当准备放弃的时候，看到wechaty就有一套基于ipad协议的包wechaty-puppet-padplus 微信机器人平台—wxbot: 项目介绍:  控制台     绑定机器人   登录   自动通过好友验证关键词设置，当有人添加机器人时，关键词匹配后直接通过   好友验证通过自动回复   退出    自动回复     普通消息         针对好友/某个群聊/所有群聊 设置关键词自动回复          加群邀请         机器人回复群聊列表，好友可以选择性进群          踢人指令         机器人识别指令，自动把成员移出群聊           我的好友     单独对某个好友送消息    我的群聊     群聊列表，管理所有群聊   设置群聊名称，发布公告，发送群消息   设置群聊基本信息，入群欢迎语，成员违规次数上限，是否受机器人控制    定时任务     针对好友/某个群聊/所有群聊设置定时任务，机器人在指定时间会触发消息推送    智能聊天     低智商对话   成语接龙，查天气，查酒店，歇后语…    技术构成:  服务端 Node. js SSR框架 NuxtJS 前端框架 Vue UI组件 Ant Design of Vue 持久化 MongoDB ipad协议 wechaty-puppet-padplus这里就直接介绍下机器人模块 |-- server/|———- /lib|------ FriendShip. js  # 友谊关系，好友添加监听|------ Login. js    # 机器人登录退出|------ Message. js   # 消息监听处理|------ Room. js     # 加群，退出群聊|------ Task      # 机器人定时任务|———- index. js     # 入口文件在线实例: wxbot (用户名/密码：guest/111111) 快速开始: 准备条件:  安装 Node. js (v10 以上版本)、MongoDB。 推荐安装 cnpm安装依赖: cnpm i启动服务:  开发模式npm run dev 生产模式先编译项目 npm run build再启动服务 npm start打开浏览器，访问 http://localhost:3000/ 系统配置: 根据实际情况修改 config. js 配置文件，修改后需要重启服务才能生效。参数说明： hostString 类型，主机名，配置为 0. 0. 0. 0 表示监听任意主机。 portNumber 类型，端口号。 mongoUrlString 类型，MongoDB 链接。 secretString 类型，JWT 秘钥。 tianApiKeyString 天行数据秘钥 线上部署: 使用PM2: 推荐使用 pm2 进行 Node. js 的进程管理和持久运行。 安装cnpm i -g pm2启动pm2 start pm2. config. js最后: 感谢 Wechaty开源项目及句子互动公司提供的 token，为开发者带来极大便利！ 还有很多可以完善的功能，代码上也有些不妥之处，正在慢慢升级中。欢迎大家多给意见，共同学习，让平台更完善。 欢迎扫码加我的小助手，验证消息写 机器人 即可直接通过啦，加群一起交流也是可以的。也可以把机器人加到你的群聊中来玩耍哦，登陆上面的在线实例，设置关键字就能体验啦。  作者: lwpCode: Github "
    }, {
    "id": 315,
    "url": "https://wechaty.js.org/2020/05/31/wechaty-web-panel-plugin/",
    "title": "wechaty Web Panel的plugin诞生",
    "body": "2020/05/31 - 背景介绍: 对，又是那个写《微信每日说》的家伙来搞事情了。周末在参加了《Wechaty插件系统发布分享会》后，看到大家在群里讨有说到要是有一个可视化的面板插件就好了，看到这里，我就开始萌生了一个想法。其实可视化面板我已经做出来了，何不把这块逻辑直接抽成一个插件来提供web面板服务。既然如此，说干就干，凌晨3点钟，此插件终于发布成功 插件地址：Wechaty-web-panel 面板主要功能:  微信每日说,定时给女朋友发送每日天气提醒，以及每日一句定时提醒:  当天定时提醒 例：”提醒 我 18:00 下班了，记得带好随身物品” 每天定时提醒 例：”提醒 我 每天 18:00 下班了，记得带好随身物品” 指定日期提醒 例：”提醒 我 2019-05-10 8:00 还有7天是女朋友生日了，准备一下”智能机器人:  天行机器人 图灵机器人 更多群定时任务:  群新闻定时发送 群消息定时发送 更多功能等你来pr关键词:  关键词加好友 关键词加群 关键词回复 关键词事件     天气查询 例：”上海天气”   垃圾分类 例：”?香蕉皮”   名人名言 例： “名人名言”   老黄历查询 例： “黄历2019-6-13”   姓氏起源 例： “姓陈”   星座运势 例： “*双子座”   神回复 例： “神回复”   获取表情包 例： “表情包你好坏”   获取美女图 例： “美女图”   更多待你发现    进群自动欢迎 加好友自动回复好友及群管理:  好友列表 群列表 聊天记录 数据分析自动更新配置文件，无需重启:  默认给机器人发送 ‘更新’ 触发拉取新配置文件操作，可在面板小助手配置-&gt;关键词回复-&gt;关键词事件进行修改关键词更多详情介绍：传送门 插件使用: 提前准备: 注册智能微秘书管理账号    注册：智能微秘书     初始化配置文件小助手配置-&gt;基础配置，修改后保存     个人中心获取APIKEY和APISECRET，后续配置用到  开始: Step 1: 安装: npm install wechaty-web-panel --saveStep 2: 创建配置文件: 项目根目录创建env. json,填入之前准备的apiKey和apiSecret $ vim env. json{  apiKey :   ,  apiSecret :   }再创建一个wechat-config. json，内容为一个空对象即可，后续会自动写入配置文件 $ vim wechat-config. json{}Step 3: 创建机器人: $ vim mybot. jsimport { Wechaty } from 'wechaty';import WechatyWebPanelPlugin from 'wechaty-web-panel';const bot = Wechaty. instance({ profile:  WECHATY_PROFILE  });bot . use(WechatyPanelPlugin()) . start() . catch((e) =&gt; console. error(e));Step 4: 运行: ode mybot. jsStep 5: 扫码进入: 进入面板小助手配置-&gt;登录状态扫码登录，或直接扫码控制台二维码登录。成功登陆后，即可使用面板中所有的功能 面板预览: 功能预览: 个人定时与群定时任务 功能一览 后续: 后续会继续完善插件的功能，也欢迎大家来提交Pr。如果想要了解插件最新进展或者进行交流，欢迎添加我的小秘书，回复插件拉你进群 致谢: 感谢Wechaty团队提供这么好的一个工具，同时还开发出这么赞的插件系统。希望能够有更多的人参与进来，来继续扩大wechaty插件的生态圈  作者: Leo_chen，高级前端工程师，喜欢使用node做各种项目 "
    }, {
    "id": 316,
    "url": "https://wechaty.js.org/2020/05/31/wechaty-docker-assistant/",
    "title": "wechaty Web Panel的构思与实现",
    "body": "2020/05/31 - 平台构思:  独立账号登录管理 所有配置工作都转移到前端可视化页面 远程重启项目 实时显示登陆状态 拥有一个素材库 无缝对接智能对话平台 平台端以创建应用的模式对接客户端 客户端无需关心代码逻辑，只需填入APIKEY和APISECRET即可 客户端不关心用户使用的平台（docker化部署） 平台后续可以扩展更多功能平台地址：《智能微秘书》 功能:  微信每日说,定时给女朋友发送每日天气提醒，以及每日一句定时提醒:  当天定时提醒 例：”提醒 我 18:00 下班了，记得带好随身物品” 每天定时提醒 例：”提醒 我 每天 18:00 下班了，记得带好随身物品” 指定日期提醒 例：”提醒 我 2019-05-10 8:00 还有7天是女朋友生日了，准备一下”智能机器人:  天行机器人 图灵机器人 更多群定时任务:  群新闻定时发送 群消息定时发送 更多功能等你来pr关键词:  关键词加好友 关键词加群 关键词回复 关键词事件     天气查询 例：”上海天气”   垃圾分类 例：”?香蕉皮”   名人名言 例： “名人名言”   老黄历查询 例： “黄历2019-6-13”   姓氏起源 例： “姓陈”   星座运势 例： “*双子座”   神回复 例： “神回复”   获取表情包 例： “表情包你好坏”   获取美女图 例： “美女图”   更多待你发现    进群自动欢迎 加好友自动回复好友及群管理:  好友列表 群列表 聊天记录 数据分析自动更新配置文件，无需重启:  默认给机器人发送 ‘更新’ 触发拉取新配置文件操作，可在面板小助手配置-&gt;关键词回复-&gt;关键词事件进行修改关键词技术选择: 后端: 为了达到想要的效果，一个完整的后端平台是必不可少的，由于自己是前端开发，所以能想到的熟悉语言就是js了，而js可以拿来写后端的就是nodejs了，那是选择自己从0搭建一套完整的解决方案还是选择一个现成的框架去做，我也纠结了很久，最后还是确定下来使用egg来实现自己的后端功能。不得不说egg是真的很强大，它的插件和中间件功能让人眼前一亮，而且集成的很多功能可以让我专注于业务逻辑开发，而不需要考虑过多的配置。 前端: 前端首先选的就是vue和element的搭配了，毕竟日常工作用的最多，开发起来上手也快。 客户端: 客户端当然还是wechaty作为核心，由于这次是做一个可视化配置平台，所以在客户端需要很多的重构，因此就把以前《微信小秘书》的项目重新推翻重做，重新梳理了事件过滤器与消息过滤器的功能，同时增加群咨询定时任务和群定时任务功能，必不可少的微信每日说功能当然也不能少。 项目地址：https://github. com/gengchen528/wechat-assistant-pro（如果觉得还可以，请随手来个star，你的star将会是我不断迭代的动力） 具体实现: 独立账号实现: 这个比较简单，起初考虑注册一个账号可以配置多个应用，但是考虑到尽快出一版体验，所以暂时就只支持一个注册账号适配一个客户端的配置，后续可能会支持一个账号支持多个客户端的配置。目前仅支持邮箱注册，后期会增加第三方登录功能 配置可视化: 这一块实现起来也很容易，所有的配置信息都写入到数据库中，每次客户端启动的时候去服务器拉取一下最新的配置信息即可，对于每次改动，需要用户使用另一个微信发送重启命令来拉取最新的配置文件。包含基础信息配置，每日说定时任务配置，群咨询，群消息定时任务，以及关键词自动回复，关键字事件等配置   远程重启项目: 这一块起初是使用了node的auto-reload库来加载最新的配置信息，但是定时任务是在每次启动的时候设置的，所以这个库只能满足我一部分的需求。最后使用了pm2的文件监控功能，每次发送重启命令的时候，修改监控文件的内容来实现远程重启功能。 pm2配置 {  apps : [  {    name :  wechaty-pro ,    cwd :  . / ,    script :  . /index. js ,    log_date_format :  YYYY-MM-DD HH:mm Z ,    error_file :  . /logs/app-err. log ,    out_file :  . /logs/app-out. log ,    pid_file :  . /logs/node. pid ,    autorestart : true,    instances : 1,    min_uptime :  60s ,    max_restarts : 100,    watch : [ reload ], // 监控此文件来达到自动重启目的    watch_delay : 1000,    ignore_watch : [ node_modules ,  logs ,  wechat. config. js ],    watch_options : {     followSymlinks : false   }  } ]}登录状态实时更新: wechaty有一个heartbeat事件，可以推送当前客户端登录的状态，所以实现起来也是很方便的 import {sendHeartBeat} from '. . /proxy/aibotk'async function onHeartBeat(str) {  if (!str) {    sendHeartBeat('dead')  }  if (str. type === 'scan') {    sendHeartBeat('scan')  }}module. exports = onHeartBeat 平台与客户端的对接: 这里参考了开放api接口平台的模式，使用apikey和apisecret来确保通信的安全（把所有的请求参数排序后和apisecretkey做hash生成一个签名sign参数，服务器后台只需要按照规则做一次签名计算，然后和请求的签名做比较，如果相等验证通过，不相等就不通过）key与secret在注册的时候自动生成，在个人中心查看 素材库: 素材库的作用是统一管理所有的文字与文件，方便不同场景下的复用。文件支持常用的图片，office等。目前是直接上传到七牛云之中 客户端多平台通用(docker): 由于前期微信每日说和微信小秘书项目中，很多开发者反应每次在不同平台中下载puppet存在各种问题，而且经常出现下载不了的情况，所以这次客户端建议采用docker化部署。只要有docker环境，就可以使用。 刚开始是准备使用官方提供的docker来进行构建，但是后来发现，官方提供的docker部署方式并不能达到我想要的效果，我的想法是用户直接拉取我生成的docker镜像后，直接简单配置后就可以直接对接《智能微秘书》平台。因此就开始自己编写属于自己项目的Dockerfile,不写不知道，一写吓一跳，遇到的问题还是蛮多的，首先采用的是node:alpine版本，因为这个版本构建体积最小，但是无奈这个环境无法正常安装puppet所需要的字体依赖等文件，没办法还是直接采用了node:10这个镜像。但是并没有结束，不能每次build镜像都重新下载依赖，所以参考了《Node. js 基于 Docker 使用的最佳经验》这篇文章的建议对Dockerfile文件进行了优化。最终配置文件如下： FROM node:10LABEL maintainer= Leo_chen &lt;chengeng@aibotk. com&gt; WORKDIR /home/appCOPY package. json . /RUN npm config set registry https://registry. npm. taobao. org \  &amp;&amp; npm config set disturl https://npm. taobao. org/dist \  &amp;&amp; npm config set puppeteer_download_host https://npm. taobao. org/mirrorsRUN npm install \   &amp;&amp; npm run puppet-installFROM node:10ENV APT_SOURCE_HOST= mirrors. aliyun. com ## 清华镜像源（备选）# ENV APT_SOURCE_HOST=mirrors. tuna. tsinghua. edu. cn## 中科大源（备选）# ENV APT_SOURCE_HOST=mirrors. ustc. edu. cnRUN echo  0. 设置 apt 使用镜像源，然后 update  \  &amp;&amp; sed -i  s@\(deb\|security\). debian. org@${APT_SOURCE_HOST}@g  /etc/apt/sources. list \  &amp;&amp; cat /etc/apt/sources. list \  &amp;&amp; apt-get update --fix-missing \  # 安装 https 协议需要的依赖  &amp;&amp; apt-get install -y --no-install-recommends \    ca-certificates apt-transport-https \  &amp;&amp; sed -i  s@http://@https://@g  /etc/apt/sources. list \  &amp;&amp; echo  1. 安装需要的依赖  \  &amp;&amp; apt-get install -yq gconf-service libasound2 libatk1. 0-0 libc6 libcairo2 libcups2 libdbus-1-3 \  libexpat1 libfontconfig1 libgcc1 libgconf-2-4 libgdk-pixbuf2. 0-0 libglib2. 0-0 libgtk-3-0 libnspr4 \  libpango-1. 0-0 libpangocairo-1. 0-0 libstdc++6 libx11-6 libx11-xcb1 libxcb1 libxcomposite1 \  libxcursor1 libxdamage1 libxext6 libxfixes3 libxi6 libxrandr2 libxrender1 libxss1 libxtst6 \  ca-certificates fonts-liberation libappindicator1 libnss3 lsb-release xdg-utils wgetWORKDIR /home/appCOPY --from=0 /home/app . COPY . . CMD [  node ,  index. js  ]LABEL \ org. label-schema. license= MIT License  \ org. label-schema. build-date= $(date -u +'%Y-%m-%dT%H:%M:%SZ')  \ org. label-schema. version= $DOCKER_TAG  \ org. label-schema. name= wechatAssistant  \ org. label-schema. description= wechatAssistant: 智能微秘书  \ org. label-schema. url= https://www. xkboke. com/web-inn/secretary/client. html  \ org. label-schema. vcs-url= https://github. com/gengchen528/wechat-assistant-pro 如果你的wechaty项目也想运行在docker环境中，那么这个配置文件也是适合你的。现在这个Docker镜像已经发布在Docker hub平台，如果想体验，直接docker pull aibotk/wechat-assistant即可。 部署体验: 首先需要注册一个账号： https://wechat. aibotk. com/ 本地部署: 克隆本项目，并进入项目根目录 第一步 env. js 文件中填入《智能微秘书》的apiKey 和 apiSecret 第二步 npm install 第三步 npm run pm2(如果报错pm2找不到，请执行npm install pm2 -g 后重新执行此步骤) 第四部 登录《智能微秘书》平台扫码登录即可 高级功能(无法登录微信网页端朋友的福音): 如果你拥有了wechaty发放的ipad token，那么也可以直接使用本项目 （ipad token 申请地址） 提前安装依赖: npm i -g node-gyp如果是win平台，还需进行 npm i -g windows-build-tools配置ipad token: 在env. js里填入你的ipadtoken即可 docekr部署（推荐）: 镜像地址：https://hub. docker. com/repository/docker/aibotk/wechat-assistant 一、创建一个env. js，并在env. js中填入相关的配置参数如下 module. exports = {  apiKey: '', //智能微秘书平台APIKEY （必填）  apiSecret: '',//智能微秘书平台APISECRET （必填）  ipadToken: '', // 如果有wechaty的ipad token可以填到此处，没有的话就不用填写 （非必填）}二、拉取镜像 docker pull aibotk/wechat-assistant三、运行镜像 docker run -v 绝对路径/env. js:/home/app/env. js -d aibotk/wechat-assistant四、登录智能微助手平台扫码登录即可 登录地址：https://wechat. aibotk. com/ 体验: 添加我的小助手来体验智能化的小秘书服务  作者: Leo_chen，高级前端工程师，喜欢使用node做各种项目 "
    }, {
    "id": 317,
    "url": "https://wechaty.js.org/2020/05/30/wechaty-plugin-system-launch/",
    "title": "Wechaty Plugin 插件系统发布会：5月30日等你来",
    "body": "2020/05/30 - 如果你不了解Wechaty，一句话快速了解:  Wechaty 是一个开源聊天机器人框架SDK，在Github上已有8000 Star的高度封装、高可用、多语言的聊天机器人框架。现在，再看三句话，了解我们的新进展:  Wechaty 正式上线完整的插件系统，开发者可用一行代码调用已经封装好的插件能力。 Wechaty 将在5月30日（周六）下午举行分享会，介绍如何使用和开发Wechaty插件（文末扫码报名）。 Wechaty 将在接下来的一个月中，举行插件开源月系列活动，并发放价值数十万的Wechaty 服务Token（文末扫码进群）。回溯漫长的过去，软件系统的发展史就是逐层封装的进化史。从汇编语言到高级语言、从命令行到图形界面……毫无疑问，“封装” 让用户视角的计算机变得极其可用。同样的故事在小的落点中同样成立：在已经封装好的项目中，针对常见操作的代码段进行更深度的“封装”，用一行代码就能实现一个完整功能，将是效率的新的指数级提升。 Wechaty 的故事开始于用RPA的方式模拟登录微信，在过去的几年里，服务了数万名开发者，收获了 Github 的 8000 Star。https://github. com/wechaty/wechaty 我们将过去对于绝大多数人难以想象的工作量，通过数万行代码封装成了最短六行代码就可以模拟登录微信的npm包。 import { Wechaty } from 'wechaty' // import { Wechaty } from 'wechaty'Wechaty. instance() // Global Instance. on('scan', (qrcode, status) =&gt; console. log(`Scan QR Code to login: ${status}\nhttps://api. qrserver. com/v1/create-qr-code/?data=${encodeURIComponent(qrcode)}`)). on('login',      user =&gt; console. log(`User ${user} logined`)). on('message',    message =&gt; console. log(`Message: ${message}`)). start()但是，对于真正的可用的微信聊天机器人，不可避免地需要用大量的逻辑来处理不同条件下的收发消息、群管理甚至和外部系统的耦合。这也就意味着，即使收消息、发消息、添加好友等操作都只需要一行代码，对于一个复杂任务仍需数十行代码才能完成。带着对于即插即用的期待，我们上线了完整的插件系统。https://github. com/wechaty/wechaty-plugin-contrib对于传统意义上复杂的、需要数十行代码完成的功能，基于已经封装完成npm包，只需按照文档、用短至一行代码即可调用。如果你感兴趣，请立刻点击上文链接，快速用上开发者们已经写好的插件！ 如果你感兴趣，先扫码！我们将在群里发布此次活动链接、对应开源插件Github链接，并长期举行 Wechaty 插件相关开源活动的新情况。 在活动中，我们将邀请 Wechaty 作者李卓桓、Wechaty Plugin设计师Gcaufy、Wechaty Puppet Donut/Padplus作者高原、Wechaty Plugin 开发者王墨炱分别就 Wechaty 开发生态、插件开发完整指南、插件的商业化可能等领域进行深度分享，议程如下：5月30日（周六）下午14:00 - 14:05 Wechaty 社区团队 「插件开源月」活动开幕及议程介绍 14:05 - 14:25 Wechaty 作者 李卓桓 Wechaty项目和社区生态介绍 14:25 - 14:55 Wechaty Plugin 设计师，腾讯微信小程序框架开源项目Wepy 作者 Gcaufy 插件系统开发历程及应用 14:55 - 15:00 休息 15:00 - 15:30 Wechaty Puppet Donut/Padplus 作者 高原 Wechaty 插件的商业化落地展望 15:30 - 16:00 Wechaty Plugin开发者 王墨炱 基于插件的Wechaty开发 "
    }, {
    "id": 318,
    "url": "https://wechaty.js.org/2020/05/20/wechaty-team-robot/",
    "title": "团队小助手",
    "body": "2020/05/20 - 之前跟一个律师的朋友聊天了解到，他们很多保全的业务，如果忘记保全，标的大的话损失就严重了，非常需要一个提醒的功能，而这个提醒可以通知团队里的多个同事。如果能以微信的方式通知是最好不过，通过微信和小程序模版消息来做通知的话，无法通知到每一个团队成员。用微信机器人来实现的话是再好不过了。于是在Github找了很多开源的产品，经多方面了解，wechaty是目前市场上最好的机器人–Wechaty是适用于微信个人的Bot SDK ，可以使用6行 js 创建一个机器人–具有包括linux，Windows，MacOS和 Docker 在内的跨平台支持，基于Node. js–让天下没有难开发的机器人–说干就干，开始了我的微信机器人之旅 项目: wechaty-team-robot 结构: |-- src/|---- api/|------ api. js       #请求的接口|------ request. js     #request请求|---- constant/|------ config. js      #参数配置文件|---- event/|------ friendship. js    # 好友添加监听回调|------ message. js     # 消息监听回调|------ room. js       # 进入房间监听回调|------ roomInvitation. js  # 群邀请监听回调|-- index. js        # 入口文件|- package. json实现:  方案：     使用 Node. js 开发，使用wechaty/wechaty-puppet-padplus等功能库；   团队成员按格式发送消息，调用接口分析消息，存入数据库，接口返回消息处理结果   定时轮询接口，获取待发送的消息   机器人登录扫码，退出登录，消息处理，好友添加，加入群聊，入群邀请，各种事件回调: bot . on('scan', (qrcode, status) =&gt; { //扫码登录  if (status === ScanStatus. Waiting) {   QrcodeTerminal. generate(qrcode, {    small: true   })  } }) . on('login', (user) =&gt;{  isLogin = true  console. log( 机器人登录成功 ,user) }) . on('logout', (user) =&gt;{  isLogin = false  clearInterval(sendTimeMsg)  console. log( 机器人退出登录 ,user) }) . on('message', onMessage(bot)) //消息处理 . on( friendship , friendship) // 好友添加 . on( room-join , room) // 加入群聊 . on( room-invite , roomInvitation) // 入群邀请 . start()接收消息并交给接口处理: // 消息处理exports. onMessage = bot =&gt;{  return async function onMessage(msg){    console. log( 收到消息 ,msg)    const contact = msg. from() //发送消息的联系人    const text = msg. text() //消息内容    const room = msg. room() //群消息，null则不是    // 判断消息来自自己，直接return    if (msg. self()) return;    // 判断此消息类型是否为文本    if (msg. type() == Message. Type. Text) {      if(room==null){        //调用接口处理消息        var ret = await api. handle({msg: text,wxId: contact. payload. id,wxName: contact. payload. name,type: 1})//type=1私聊，2群聊        //回复消息        await msg. say(ret. data)      }else{        //群消息        //调用接口处理消息        var ret = await api. handle({msg: text,wxId: room. id,wxName: contact. payload. name,type: 2})        if(ret. data){          //回复消息          await room. say(ret. data)        }      }    }else{      console. log( 非文本消息不做处理 )    }  }}接口列表: module. exports ={ handle : params =&gt; { //消息处理  return get({   api:  /taskMsg/handle ,   data: params  }) }, setSend : params =&gt; { //将消息置为已发送  return get({ api:  /taskMsg/setSend , data: params  }) }, list : params =&gt; { //未发送消息列表  return get({ api:  /taskMsg/list , data: params  }) }}轮询获取待发送的消息，发送给联系人或者群里@联系人: //先用轮询，查询是否有要发的消息const sendTimeMsg = setInterval(() =&gt; { if(isLogin){  taskSendMessage(bot) }}, 60000);//查询待发送的任务消息exports. taskSendMessage = async function(bot){  var ret = await api. list()  var list = ret. data  if(list &amp;&amp; list. length&gt;0){    for (let i = 0; i &lt; list. length; i++) {      const vo = list[i];      if(vo. type === 1){ //type=1私聊，2群聊        const contact = await bot. Contact. find({id: vo. wxId})        if(contact!=null){          await contact. say(vo. msg)          await api. setSend({id: vo. id,status: 1}) //设置该任务已发送,status=1为已执行        }else{          api. setSend({id: vo. id,status: 3})         }      }else if(vo. type === 2){        const room = await bot. Room. find({id: vo. wxId})        if(room!=null){          //获取@的成员          var names = vo. wxName. split( , )          var atList = []          for(var y=0; y&lt;names. length; y++){            let roomContact = await room. member({name: names[y]})            if(roomContact!=null){              atList. push(roomContact)            }else{              //群内昵称查询              roomContact = await room. member({roomAlias: names[y]})              if(roomContact!=null){                atList. push(roomContact)              }            }          }          await room. say(vo. msg, . . . atList)          await api. setSend({id: vo. id,status: 1}) //设置该任务已发送        }else{          api. setSend({id: vo. id,status: 3})         }      }    }  }}已实现的功能:  自动通过好友验证 私聊群聊自动回复     回复 帮助 查看功能介绍   回复 小助手 开启自动回复   回复 安静点 关闭自动回复    自动聊天     群聊私聊中开启自动回复后，可以和机器人聊天    定时获取并发送的待办提醒（私聊或者群聊@多人） 中英文互译 成语词典 每日一句 数字计算 天气预报 空气质量效果图: 待实现需求:  日报收集，定时统计日报，定时@未提交日报的成员。 每天早上爬取热点新闻发送 等等团队需要的功能待挖掘实现wechaty-team-robot 还是一个正在开发中的项目, 欢迎留言交流你对它的看法，以及你需要的功能 感谢: Wechaty开源项目及JuziBot公司提供的接口和token，为开发者带来极大便利！  作者: suruozhongCode: Github "
    }, {
    "id": 319,
    "url": "https://wechaty.js.org/2020/05/19/qnamaker-juzi-bot-for-investors-rui/",
    "title": "如何用 QnAMaker.ai 构建一个投融资聊天机器人 - Azure Show",
    "body": "2020/05/19 - 欢迎来到 Azure Show 的从零开始，第一期的嘉宾 Rui Li，李佳芮句子互动创始人，连续创业者，微软人工智能最有价值专家（AI MVP），GitHub 7000+ Stars开源项目Wechaty作者，创建并管理了覆盖全球的微信聊天机器人开发者社区，《Chatbot从0到1：对话式交互设计指南》作者。句子互动围绕微信生态为客户提供智能营销和销售服务，帮助企业引流并实现转化，客户覆盖教育、保险、大健康等多个领域。曾入选百度AI加速器，获得PreAngel、Plug and Play，Y Combination, TSVC和阿尔法公社多家中美机构投资。 Azure Show: Azure Show 是由微软最有价值专家、微软技术社区区域总监卢建晖和微软开发者关系PM朱兴亮共同发起的一个关于微软Azure、开源技术、还有技术社区相关的线上节目。每期节目由MVP面对面、开源故事、从零开始以及Azure101组成，邀请微软技术社区的代表人物以及行业中的技术大牛，与大家分享Azure与开源技术的相关内容，每两周一期，会通过公众号、哔哩哔哩以及油管同步上线，欢迎大家关注。 Open-source Wechaty: Wechaty 联合作者李佳芮，用 20 分钟教会你如何用 Azure Cognitive Service QnAMaker. ai 来构建一个能够自动回答投资人问题的 Chatbot !   Bilibili: https://www. bilibili. com/video/BV1az411q79AMVP:  本期是我们Azure Show的首秀，谢谢各位小伙伴的关注，非常感谢本期嘉宾Kris，卓桓、佳芮以及我的搭档兴亮的大力支持，还有帮忙进行视频处理的小董。想在最后跟大家聊聊为什么要开设这个线上节目。自2012年成为微软最有价值专家（MVP）以来，开始在各个社区与同行们讨论技术，分享代码，在这个过程中，既是一种分享，也是一种收获。通过社区，不仅解决了自己碰到的一些技术难题也认识到很多好朋友。MVP这个社区，汇聚了来自各个行业，各个国家的IT同行，他们乐于分享，乐于互助，我期待通过这个节目，邀请到更多的行业大牛与大家分享，分享 Azure 的知识，分享他们的开源项目，分享技术社区中的点点滴滴，希望能给大家带来点干货！从第二期开始，我们将正式启动Azure 101活动，帮助大家从0开始认识Azure的知识。第一期节目，也是一次探索，后续我们会不断改进，也欢迎大家留言或者在公众号后台留下你们的建议与意见， Source: Azure Show 第一期 开播啦！嘉宾梁迪&amp;李卓桓&amp;李佳芮 "
    }, {
    "id": 320,
    "url": "https://wechaty.js.org/2020/05/19/open-source-wechaty-huan-2020/",
    "title": "Wechaty 2016 - 2020：开源这四年 - Huan",
    "body": "2020/05/19 - 欢迎来到AzureShow的开源故事，第一期的嘉宾 Huan Li，中文首本 Conversational User Interface 畅销书《Chatbot从0到1》联合作者，GitHub 8k Stars 开源 Chatbot 项目 Wechaty 作者，长期从事 Chatbot 领域的 Conversational AI 算法研究与行业应用落地相关方向。现为 PreAngel 合伙人，关注种子阶段的技术类创业项目。清华大学本科，中欧国际商学院 EMBA。 Azure Show: Azure Show 是由微软最有价值专家、微软技术社区区域总监卢建晖和微软开发者关系PM朱兴亮共同发起的一个关于微软Azure、开源技术、还有技术社区相关的线上节目。每期节目由MVP面对面、开源故事、从零开始以及Azure101组成，邀请微软技术社区的代表人物以及行业中的技术大牛，与大家分享Azure与开源技术的相关内容，每两周一期，会通过公众号、哔哩哔哩以及油管同步上线，欢迎大家关注。 Open-source Wechaty: 在下面 20 分钟的这个视频中，由 Microsoft Regional Director, AI MVP, Wechaty 作者李卓桓，为大家系统性的对 Wechaty 开源项目进行了介绍。希望大家可以通过这 20 分钟了解 Wechaty ，并在未来有机会参与 Wechaty 开源社区建设！   Bilibili: https://www. bilibili. com/video/BV1vQ4y1A7W2MVP:  本期是我们Azure Show的首秀，谢谢各位小伙伴的关注，非常感谢本期嘉宾Kris，卓桓、佳芮以及我的搭档兴亮的大力支持，还有帮忙进行视频处理的小董。想在最后跟大家聊聊为什么要开设这个线上节目。自2012年成为微软最有价值专家（MVP）以来，开始在各个社区与同行们讨论技术，分享代码，在这个过程中，既是一种分享，也是一种收获。通过社区，不仅解决了自己碰到的一些技术难题也认识到很多好朋友。MVP这个社区，汇聚了来自各个行业，各个国家的IT同行，他们乐于分享，乐于互助，我期待通过这个节目，邀请到更多的行业大牛与大家分享，分享 Azure 的知识，分享他们的开源项目，分享技术社区中的点点滴滴，希望能给大家带来点干货！从第二期开始，我们将正式启动Azure 101活动，帮助大家从0开始认识Azure的知识。第一期节目，也是一次探索，后续我们会不断改进，也欢迎大家留言或者在公众号后台留下你们的建议与意见， Source: Azure Show 第一期 开播啦！嘉宾梁迪&amp;李卓桓&amp;李佳芮 "
    }, {
    "id": 321,
    "url": "https://wechaty.js.org/2020/05/17/use-wechaty-manage-ur-customers/",
    "title": "使用Wechaty管理你的顾客",
    "body": "2020/05/17 - 作为一个店面开了十多年个体工商户，积攒了很多的客户。希望能够减少人为的操作，去解决一些常见的问题，比如：  群人数超过一定限额，群二维码失效，需要手动拉人 最新的活动通知Wechaty 和 Puppet: Wechaty 提供了群组管理、收发消息等接口，能够方便地满足计划需求。 由于 Wechaty 本身只是一个控制器，因此其对微信功能的执行需要依赖于微信客户端协议与服务器进行通信。puppet 就是这些协议的具体承载者，现在有基于 Web / iPad / Mac 等协议的多种实现。经过测试，首先排除了 Web 协议：由于腾讯的限制，近年新注册的微信账号都无法使用网页协议，而老账号又实在过于珍贵。所以，使用了PuppetPadplus。 架构:  目标：用最简单的方式实现向特定的若干微信群转发消息 功能：     账号登录   好友申请自动通过并回复消息功能菜单   根据指令消息做出对应的操作，比如： 拉群，提供最新活动等    方案：     使用 Node. js + eggjs + mysql 开发；   在没有大量交互需求的情况下暂时可以接受 Node. js 单主线程的局限性。若将来有需要，也可以使用多 worker / 进程合作解决问题；   前端提供后台服务，提供”最新活动”等配置   特别鸣谢:  作者: Kylin93CNCode: Github "
    }, {
    "id": 322,
    "url": "https://wechaty.js.org/2020/05/16/group-repe-assistant/",
    "title": "repe-assistant 社群活动助手",
    "body": "2020/05/16 - repe社群助手主要是为了提高社群活跃度以及群活动管理而设计。管理员使用后台web发起一系列活动并设置动态的参与口令，群成员只需要发送对应口令即可参与活动，并且能够结合积分系统做一些约束和奖励。 架构设计: 机器人: bot基于nodejs平台开发，借助wechaty框架实现微信消息监听与发送 职责:  定时从后台service拉取待发送信息，并发送给对应的contact。 监听微信消息，上报给后台service。 同步contact列表 同步room列表依赖API: const uri= http://127. 0. 0. 1:89/bot // 获取待发送的消息axios. get(uri+ /task )// 上报微信消息axios. post(uri+ /cmd ,message)// 全量同步联系人axios. post(uri+ /sync/user ,contacts)// 全量同步群聊axios. post(uri+ /sync/room ,rooms)// 同步单个联系人axios. post(uri+ /user ,{id:id,name:name})// 同步单个群聊axios. post(uri+ /room ,{id:id,name:name})bot get-started:  修改/bot/examples/apis. js文件中的配置const uri= http://127. 0. 0. 1:89/bot ; // service api urlconst token=  ; // wechaty padplus token 终端输入命令 npm start后台服务: 后台服务使用golang开发，负责解析、调度微信消息，并且为管理员后台提供web api。  tips：wechaty golang依赖包成熟后会将bot迁移到golang上来，目前是使用web api方式交互。 功能:  机器人web api 管理员后台web api 微信口令解析服务 command service 任务调度服务 bot task service 活动管理服务 activity manage serviceBOT API: 对应的bot依赖的api接口，默认监听89端口。基于安全考虑，建议不开放外网端口，只提供bot访问。 engine. GET( /task , t. getTask)engine. POST( /cmd , t. postCommand)engine. POST( /user , t. postUser)engine. POST( /room , t. postRoom)engine. POST( /sync/room , t. syncRooms)engine. POST( /sync/user , t. syncUsers)WEB API: 对应管理员后台的api接口，默认监听80端口。 user manageengine. GET( / , t. getList)engine. GET( /:id , t. get)engine. PUT( /:id , t. update)room manageengine. GET( / , t. getList)engine. GET( /:id , t. get)engine. PUT( /:id , t. update)activity manageengine. GET( / , t. getList)engine. GET( /:id , t. get)engine. GET( /:id/log , t. getLogList)engine. POST( / , t. add)engine. PUT( /:id/done , t. setDone)bot task manage: engine. GET( / , t. getList)engine. GET( /:id , t. get)engine. POST( / , t. add)engine. PUT( /:id , t. update)engine. PUT( /:id/done , t. doneTask)engine. DELETE( /:id , t. delete)后台服务 get-started:  后台启动依赖/backend/main/tmpl和repe. yaml，因此最简单的启动命令如下：cd . /backend/maingo build. /maintest web: 后台提供两个测试web页面，以监听80和89端口为例 ## 微信机器人模拟器http://localhost:89/example/1## 活动管理页面http://localhost/example/1/actvGitHub: https://github. com/xiaogan18/repe-wechat-assistant 致谢: repe bot机器人基于wechaty框架实现，十分感谢wechaty团队提供的技术让repe需求得以实现，wechaty对开源社区的贡献让人致敬。  Author: @xiaogan18 Full stack developer,specialized golang and blockchain. Code: @Github "
    }, {
    "id": 323,
    "url": "https://wechaty.js.org/2020/05/12/weilai-nio-bot/",
    "title": "Nio bot蔚来车主群服务机器人",
    "body": "2020/05/12 - 需求: 一个车主群成员过多, 为有效识别成员, 需要成员以固定格式修改群昵称. 若每个人都需要管理员依次进行提醒并检查, 将会产生大量的重复性工作. 因此, 需要一个群成员管理机器人来替代人工. 在成员进群时发出欢迎词, 提示修改昵称, 并每天定时检查是否仍存在不符合格式的昵称. 后期, 会针对经常提出的问题, 使用自动问答机器人进行自动回答. Wechaty / wxpy / itchat: 作者在调研微信机器人方案是, 最先看到的是wxpy及itchat. 在做出beta版本后, 尝试使用新注册账号登录却屡屡失败. 后来才知道原来Web微信已经不对新注册账号开放. 而且, web微信功能受限, 例如:不能@群成员. 再次调研后, 发现了wechaty &amp; wechaty-puppet-padplus. 此方法基于ipad协议, 突破了web微信的限制, 且wechaty提供了更加丰富的功能接口, 大大简化了开发者的开发流程. 架构:  目标：     新成员进群欢迎辞   每日10:00定时校验群成员昵称, 并@成员进行修改    方案：     使用wechaty/wechaty-puppet-padplus等功能库；   使用node-schedule进行定时任务规划   实现: 接收消息并交给处理: // 进入房间监听回调 room-群聊 inviteeList-受邀者名单 inviter-邀请者module. exports = async function onRoomJoin(room, inviteeList, inviter) { // 判断配置项群组id数组中是否存在该群聊id if (config. roomList. indexOf(room. id) &gt;= 0) {  inviteeList. map(c =&gt; {   // 发送消息并@   room. say(generateWelcome(c. name()), c)  }) }}function generateWelcome (username) {  // 加入房间回复  return '欢迎加入京蔚軍大家庭!\n\n' +      '①请复制并修改群昵称:\n\n' +      username + '-ES6-京ADXXXXX\n\n' +      '(无牌请先使用\ 京ADXXXXX\ )\n\n' +      '②和大家打个招呼\n' +      '③正式成为京蔚軍的一员'}调用接口处理获取数据: module. exports = async function onLogin(bot) { let roomList = [] // 选择群, 进行群成员名称筛选 for (let room of await bot. Room. findAll()) {  if (config. roomList. indexOf(room. id) &gt;= 0) {   roomList. push(room)  } } // 每天早上10点进行提醒 schedule. scheduleJob('59 9 * * *', function() {  let illegalMembers = []  let illegalNames = []  for (let room of roomList) {   room. memberAll(). then(members=&gt;{    for (let member of members) {     room. alias(member). then((nickname) =&gt; {      if (!nickname || (nickname. search(config. pattern) &lt; 0 &amp;&amp; config. whitelist. indexOf(nickname) &lt; 0)) {        illegalMembers. push(member)       illegalNames. push(nickname ? nickname : member. name())      }     }). catch((err) =&gt; {console. log(err)})    }   })   setTimeout(function() {    room. say(generateAdvice(), . . . illegalMembers)    console. log(illegalNames)   }, 60 * 1000)  } })}function generateAdvice () { // 加入房间回复 return '\n您的昵称不符合规范, 请参考:\n\n' +     '蔚来APP昵称-ES6-京ADXXXXX\n\n' +     '(未上牌牌请先使用\ 京ADXXXXX\ )\n'}实际效果:  作者: Leons828 web developerCode: Github "
    }, {
    "id": 324,
    "url": "https://wechaty.js.org/2020/05/11/wechaty-subscription-bot/",
    "title": "用Wecahty制作订阅机器人(B站)",
    "body": "2020/05/11 - 项目背景: 我是一个主 Python 的全栈工程师，偶然发现了 Wechaty 这个如此惊艳的项目，顿时爱了，然后毫不犹豫申请了开发者号。 要加入这个项目的大家庭，我需要一个投名状，当时我瞬间脑海中闪现了无数的想法，不过最终选定了这一个比较轻量又比较实用的动手干起来了。 平时在 Telegram 上有很多各种平台的订阅机器人，只要订阅了指定的频道，就可以在该频道一有更新的时候收到机器人的通知，非常方便抢沙发。既然是机器人，为什么我不自己做一个呢？那么我就想用 Wechaty 这个平台，创建一个国内各平台的订阅机器人，就先从 B 站开始吧！ 基础思路: 然后我简单看了一下 DEMO，虽然 Node 和 ts 我都只会点基础语法，但是框架实在是设计得太好了，我用起来简直就像一个认识了十年的故友一样，写下来的代码句句投机~~ 于是先把登录部分撸下来： bot. on('scan', (qrcode, status) =&gt; { if (status === ScanStatus. Waiting) {  console. log(qrcode);  QrcodeTerminal. generate(qrcode, {   small: true,  }); }}). on('message', async msg =&gt; { const text = msg. text(); const sender = msg. from(); console. log(text, sender); // 后面就在这里做文章了}). start();这个很简单就测试过了，然后事实上后面的工作就是如何在 message 事件里面做文章了，下一步的话，我需要实现三个最基础的功能：  订阅频道 推送新内容 控制功能那么下面围绕这些内容展开说一下整个过程。 订阅频道: 首先，既然是机器人，交互都来源于对话，那么最方便的方式就是直接将 UP 主的频道链接发给机器人，然后就知道具体的频道是什么了，所以这里做一个简单的正则就可以判断到发来的订阅请求： // . . . }). on('message', async msg =&gt; { // . . .  const match = /https:\/\/space\. bilibili\. com\/(\d+)/. exec(text); if (!match) return; const channelId = match[1]; // . . . }). start();好了之后，我们现在实际上拿到了 msg. from() 和 channelId，这样的话实际上我们需要把这种关联持久化下来，每一个 msg. from() 对应的用户都应当有一个订阅的频道列表，然后每个订阅频道下面记录一些附加信息。 我们需要用一个持久化的方式，我想：MySQL? Redis? SQLite? 哎都太麻烦，这屁大点事，直接 json 扔进一个静态文件就好了。 所以我们定一个持久化规则，将这些信息扔进 data/&lt;userid&gt;. subs 这个 json 文件里面保存，例如： // file: data/wxid_yjo4lxrava8b22. subs{  subscriptions : {   9458053 : {   lastTimestamp : 1589170983. 101,   name : 李永乐老师官方  } }}这种结构，事实上我们还需要保存一下标题，这个 lastTimestamp 记录下了这个订阅下面最晚推送的内容时间，如果这个内容早于这个时间点，我们就不再推送，这样来控制推送的逻辑。 然后我顺手就将这部分持久化的逻辑封装到一个 UserContext 类中，通过 msg. from() 获得的任意一个 Contact 对象都可以构造一个 UserContext，然后访问里面的这些持久化的数据，后面的处理，往里面塞方法就可以了。 大概是这样子： class UserContext { userId: string; fname: string; data: any = {}; constructor(userId: string) {  this. userId = userId;  this. fname = `data/${userId}. subs`;  fs. mkdirSync(path. dirname(this. fname), {recursive: true, mode: 0o644});  try {   const content = fs. readFileSync(this. fname);   this. data = JSON. parse(content &amp;&amp; content. toString() || '{}');   console. log(this. data);  } catch (err) {   if (err. code !== 'ENOENT') {    throw err;   }  } } async user() {  return bot. Contact. find({id: this. userId}); } async save() {  // 获取  await fs. promises. writeFile(this. fname, JSON. stringify(this. data));  console. log('write ok'); } static getUserIdList() {  try {   const files = fs. readdirSync('data');   return files. filter(f =&gt; /\. subs$/. test(f))    . map(f =&gt; f. replace(/\. subs/, ''));  } catch (err) {   if (err. code !== 'ENOENT') {    throw err;   }   return [];  } }}然后下面这一段把订阅的持久化做完，当然还要反馈一些提示给用户，顺道需要把频道的名称抓下来存在 UserContext 里面。 // . . . }). on('message', async msg =&gt; { // . . .  const channelId = match[1]; ctx. data. subscriptions[channelId] = ctx. data. subscriptions[channelId] || {}; const channel = ctx. data. subscriptions[channelId]; channel. lastTimestamp = Number(new Date()) / 1000; // 加载频道名称 const url = `https://api. bilibili. com/x/space/acc/info?mid=${channelId}&amp;jsonp=jsonp`; const resp = await fetch(url); const channelInfo = JSON. parse(await resp. text()); channel. name = channelInfo. data. name; await sender!. say(`你已成功订阅《${channel. name}》:list - 查看当前订阅:leave &lt;id&gt; - 退订指定频道`); console. log(ctx. data); await ctx. save(); // . . . }). start();实现内容推送: 嗯，这个其实好办，只要启动了之后，轮询一下查一下B站下面这个频道的新内容，如果日期晚于最晚更新的日期，那么就推送给 UserContext 对应的用户即可，把消息撸得好看一些就不错。 我把这个动作的代码封装到了一个 SubscriptionRunner 类里面（此处省略1000字）： // 定时获取订阅的 UP 主的视频，如果发现更新则推送class SubscriptionRunner { static check() {  UserContext. getUserIdList(). forEach(async userId =&gt; {   console. log(userId);   const ctx = new UserContext(userId);   const contact = await ctx. user();   if (!contact) return;   // console. log(ctx. data);   await Promise. all(Object. entries(ctx. data. subscriptions || {}). map(async ([channelId, channelInfo]) =&gt; {    const url = `https://api. bilibili. com/x/space/arc/search?mid=${channelId}&amp;ps=30&amp;tid=0&amp;pn=1&amp;keyword=&amp;order=pubdate&amp;jsonp=jsonp`;    const resp = await fetch(url);    const data = JSON. parse(await resp. text());    // console. log(data);    await Promise. all(data. data. list. vlist. map(async (video: any) =&gt; {     if (video. created &gt; (channelInfo as any). lastTimestamp || 0) {      const linkPayload = new UrlLink({       description: video. description,       thumbnailUrl: video. pic. replace(/^\/\//, 'https://'),       title: video. title,       url: `https://bilibili. com/video/${video. bvid}`,      });      contact. say(linkPayload);      // 为了避免因为时间不一致导致重复更新，使用最新的时间点来更新最近时间      (channelInfo as any). lastTimestamp = video. created;     }    }));   }));   // 保存所有 ctx 的信息（主要是更新 lastTimestamp 时间）   await ctx. save();  }); }}然后，启动轮询的时机应该是在登录之后，一分钟刷一次吧： bot. on('login', async () =&gt; { // 每分钟查一下有没有新片发布 setTimeout(async () =&gt; {  await SubscriptionRunner. check(); }, 60000);});嗯，测试过不错，这样就挺好了。 控制功能: 作为最小化可用产品，我们还需要一些基础的控制功能才能实现一个闭环，起码应该提供一个查询当前订阅的频道清单以及退订的途径。 所以这两块我在 UserContext 类里面加了两个方法实现： class UserContext { // . . .  async getSubscriptionList() {  const content = Object. entries(this. data. subscriptions || {}). map(([channelId, channelInfo]) =&gt; {   return `${channelId} - ${(channelInfo as any). name}`;  }). join('\n');  (await this. user())?. say(content); } async leaveChannel(channelId: string) {  // console. log(this. data. subscriptions);  const channel = this. data. subscriptions &amp;&amp; this. data. subscriptions[channelId];  if (!channel) {   (await this. user())?. say('您没有订阅这个频道，请检查 ID 是否输入正确');  }  delete this. data. subscriptions[channelId];  await this. save();  (await this. user())?. say(`您已成功退订《${channel. name}》`); } // . . . }然后在 on message 那里引入一下： bot. on('message', async msg =&gt; { // . . .  const text = msg. text(); const sender = msg. from(); if (!sender) return; const ctx = new UserContext(sender. id); ctx. data. subscriptions = ctx. data. subscriptions || {}; // 查询指令 if (/^:list$/. test(msg. content())) {  await ctx. getSubscriptionList();  return; } // 退订指令 if (/^:leave \d+$/. test(msg. content())) {  await ctx. leaveChannel(msg. content(). split(' ')[1]);  return; } // . . . });这样就大功告成了！以后可以再优化封装一下，加入多几个平台，也是非常实用的呢！ DEMO: 测试机器人(wx_easecloud)： 联系作者： 微信号: huangwenchao1987email: huangwc@easecloud. cn  作者: 工画师，分母为零的斜杠大龄青年程序员。 项目链接： "
    }, {
    "id": 325,
    "url": "https://wechaty.js.org/2020/05/09/wechaty-multi-language-developers-meetup/",
    "title": "Wechaty Multi-language Developers Meetup",
    "body": "2020/05/09 - 关于Wechaty: Wechaty 帮助开发者实现一个让用户无感知的在IM平台与接入的机器人对话或交互。开发者在 IM 平台扫码接入，自由选择底层并设计应用层，最终实现智能对话。官网：https://wechaty. js. org 只切换一个变量，其他代码不变就能登录新IM 支持常见流行编程语言，API定义跨编程语言保持一致 多加一行代码,就能拥有复杂对话能力 荣誉:  Google Season of Docs支持的30个全球顶级开源项目之一。 被国内顶级开源组织中国开源云联盟评为优秀开源项目 开源项目作者李卓桓入选“中国开源先锋33人” 连续入选2020、2021年度开源软件供应链点亮计划 多次在 Google、Microsoft、百度大会上进行技术布道相关数据: Github Stars: 11,000+Github Fork: [1,500+]Npm install: 1,000,000+Issue/PR: [2,190+] 开发者群体：: 微信群：5,000+被开源项目所使用：800+国际 Contributor：20+Blog/Post: 260+ Wechaty Multi-language Developers Meetup 会议实录: 会议记录Meeting Notes:https://docs. google. com/document/d/1fVCk8qRYc4RKGMf2UY5HOe07hEhPUOpGC34v88GEFJg/edit#  Attendees:  Huan, Tencent TVP of Chatbot, huan@chatie. io, CST Simple, Java Developer, CST Rui，Founder of JuziBot, rui@chatie. io, CST wj-Mcat NLP Researcher, CST ax4, reads update about Wechaty since 2017, CST dchaofei, Go Developer, CST Yuan, Co-founder of JuziBot, CST Xilidou, Java Developer,CST Chunhong HUANG, Python contributor, CSTAgenda:  00:00:05 Huan introducing everyone.  00:17:10 Wujingjing Log/Exception/Interface Design 00:50:10 Xilidou introduce kotlin-wechaty progress 01:22:23 Huan import wechaty-puppet schemas from auto-generated GRPC code for non-TS languages. 欢迎正在阅读的你参与其中: 想要了解更多或者想联系我们：  Gitter Channel:https://gitter. im/wechaty/wechaty Mail list:wechaty@googlegroups. com(web archive) Website:https://wechaty. js. org"
    }, {
    "id": 326,
    "url": "https://wechaty.js.org/2020/05/05/when-bus-come/",
    "title": "Wechaty 实时公交查询",
    "body": "2020/05/05 - 需求: 我们很多时候需要到某个公交站，但是不知道公交什么时候来，导致等来很久才到，浪费来太多的时间，如果可以提前知道车什么时候来，就可以准时出门，不用在车站等这么久的时间，特别这么炎热的天气。当然，已经有很多小程序可以做到这个查询的工作，这里的仓库也是用来广州公交行讯通小程序的接口，或许你觉得多此一举，但是我觉得这个只是其中一个小功能集成在某个机器人的问答交互功能当中，后面扩展起来还是有很多可以做的工作。 Wechaty 和 Puppet: Wechaty 提供了群组管理、收发消息等接口，能够方便地满足计划需求。 由于 Wechaty 本身只是一个控制器，因此其对微信功能的执行需要依赖于微信客户端协议与服务器进行通信。puppet 就是这些协议的具体承载者，现在有基于 Web / iPad / Mac 等协议的多种实现。经过测试，首先排除了 Web 协议：由于腾讯的限制，近年新注册的微信账号都无法使用网页协议，而老账号又实在过于珍贵；接着，就决定使用了wechaty-puppet-padplus。 架构:  目标：问答式交互，输入公交站名，返回对应的将要来的车辆和时间信息 方案：     使用 Node. js 开发，使用wechaty/wechaty-puppet-padplus等功能库；   抓取广州公交行讯通小程序的接口；   跟进接口参数，用户输入车站名后，调用相关接口，返回整理后的数据。   实现: 机器人登录扫码:   bot. on('scan', (qrcode, status) =&gt; {    if (status === ScanStatus. Waiting) {      QrcodeTerminal. generate(qrcode, {        small: true      })    }  })接收消息并交给处理:   bot. on('message', async msg =&gt; {    const contact = msg. from()    const busStation = msg. text(). trim()    try {      const res = await handler(busStation)      botMsger(contact, res)    } catch (eMsg) {      botMsger(contact, eMsg)    }  })  . start()  function botMsger(contact, text) {    contact. say(text)  }调用接口处理获取数据:   const { retCode, retData } = await fetch('getBusStationId', { name: busStation, requesttime: Math. floor(+new Date() / 1000) })  if (retCode !== 0) {    return Promise. reject('服务器异常，请稍后重试')  }  const { bus: { station } } = retData  if (!station. length) {    return Promise. reject(`查询不到公交站：${busStation}`)  }  const busStationId = station[0]. i  let [busAbout, busTime] = await Promise. all([    fetch('getBusAbout', { stationNameId: busStationId }),    fetch('getBusTime', { stationNameId: busStationId }),  ])  if (busAbout. retCode !== 0 || busTime. retCode !== 0) {    return Promise. reject('服务器异常，请稍后重试')  }  let idTime = {}  busTime. retData. forEach(ele =&gt; {    idTime[ele. i] = ele. time  })  let direcBus = {}  busAbout. retData. l. forEach(ele =&gt; {    const { dn, rn, rsi } = ele    let terminal = dn. split('-'). pop()    let ter = direcBus[terminal]    let itemTime = idTime[rsi]    if (~itemTime) {      let addItem = {        busId: rsi,        name: rn,        time: itemTime      }      if (ter) {        ter. push(addItem)      } else {        direcBus[terminal] = [addItem]      }    }  })处理数据返回:   let resText = `公交车站：${busStation}\n`  Object. keys(direcBus). forEach(direct =&gt; {    let busLine = direcBus[direct]    busLine. sort((pre, next) =&gt; pre. time - next. time)    resText += `\n开往：${direct}\n`    busLine. forEach(el =&gt; {      resText += `${el. time}分钟后-&gt;${el. name}\n`    })  })实际效果: 输入北京路，返回如下： 公交车站：北京路 开往：昌岗路总站5分钟后-&gt;10路 开往：汾水小区总站2分钟后-&gt;183路 开往：芳村花园南门总站9分钟后-&gt;1路 开往：黄沙总站2分钟后-&gt;219路 开往：如意坊总站3分钟后-&gt;3路 开往：恒宝广场总站3分钟后-&gt;541路 开往：纸厂总站3分钟后-&gt;544路 开往：泮塘总站10分钟后-&gt;66路 致谢: 感谢 Wechaty 开源项目及 JuziBot 公司提供的 token，为开发者带来极大便利！  作者: ershing Node. js developerCode: Github "
    }, {
    "id": 327,
    "url": "https://wechaty.js.org/2020/04/30/wechaty-chat-room-manager/",
    "title": "微信群管辅助",
    "body": "2020/04/30 - 微信群管辅助:  Wechaty is a Wechat Bot SDK for Personal Account that lets you create software to extend the functionality of the Wechat, writen in Node. js with TypeScript, Support all platforms including Linux, OSX, Win32, and Docker. 功能目的:  大型微信群（员工群）通常需要多位管理员分工管理，有各种信息需要发布。但是目前微信群中不论规模均最多只能设置三位群管理员，这在有三名以上管理人员的场景中显得十分不便。本项目的目的是通过机器人代办解决超过三名管理员的情况，方便大型微信群的管理。     群主可设置机器人管理员   响应机器人管理员指令   根据机器人管理员的指令发布群公告   根据机器人管理员的指令移除群成员    此外对于人员较多且拥有自己的OA系统的公司而言，HR在微信群的维护上也是苦不堪言。人员流动带来的成员变动、人数超过500人限制导致的分群消息同步等问题都为HR带来了巨量的麻烦。本项目的第二步计划通过网络接口的形式提供API供OA系统调用，达到可以自动控制群成员，解放人力的目的。     提供http访问接口供外部程序引用   对http访问接口添加必要的合法性验证   根据外部接口指令对指定群发送群公告   根据外部接口指令对指定群添加成员   根据外部接口指令对指定群移除成员    对于分群，本项目第三步计划是通过命令连接两个甚至多个不同的微信群，达到消息自动转发的目的，从某种意义上实现群成员超过500人上限。     群主可直接开启群联通，直接开启群联通时将生成联通口令   群主可通过联通口令开启群联通，通过口令开启群联通将于口令拥有群导通并开始转发所有消息   群主或机器人管理员可通过指令设置屏蔽指定人员的消息转发   群主或机器人管理员可通过指令设置屏蔽指定格式的消息转发   系统需求:  我是用的是centos7作为开发运行环境，已经提前安装了git  Node. js v16 或以上 基本开发编译环境开始使用: 0. 安装 Node. js (&gt;=10): 如果你没有安装node或已经安装的node版本低于10，请根据下面步骤安装新的nodejs环境  Linux （centos7）wget https://npm. taobao. org/mirrors/node/v16. 2. 0/node-v16. 2. 0-linux-x64. tar. xztar -xvf node-v16. 2. 0-linux-x64. tar. xzmv node-v16. 2. 0-linux-x64 /opt/nodetee /etc/profile &lt;&lt; EOF export NODE_HOME=/opt/node export PATH=$NODE_HOME/bin:$PATHEOFsource /etc/profile随后可验证安装是否成功 node -v 在其他平台安装 Node. js 的方法可参见 https://nodejs. org/en/download/package-manager/ 1. 下载项目: git clone https://github. com/tianyugeng/wechaty_room_manager. gitcd wechaty_room_manager2. 安装依赖包: #因为某些原因,一些依赖包无法直接从官方源下载，故此需要使用淘宝镜像源npm install -g cnpm --registry=https://registry. npm. taobao. orgcnpm install node-pre-gypcnpm install bufferutil@^4. 0. 1cnpm install utf-8-validate@^5. 0. 2cnpm install file-box@^0. 8. 23cnpm install puppeteercnpm install wechaty-puppet-padplus@^0. 6. 1cnpm install expresscnpm rebuild3. 开始运行: WECHATY_PUPPET_PADPLUS_TOKEN=${YOUR_TOKEN} npm start或者直接通过node来启动 # Linux: export WECHATY_LOG=verbose# Win32: set WECHATY_LOG=verbosenode examples/ding-dong-bot. ts至此启动完成，去给机器人发指令吧。 补充: 1. TypeScript: 虽然官网的示例中提供了js和ts两种方式可供选择，但实际使用时发现用js进行开发会发生许多莫名其妙的错误。调试修改到烦之后换到ts发现可以运行启动。估计是我没怎么用过node，有哪个配置项没有找到的缘故吧。所以虽然我没有删除js，但本项目的所有内容均使用ts完成。  作者: tianyugeng 前端开发工程师(自称) "
    }, {
    "id": 328,
    "url": "https://wechaty.js.org/2020/04/30/wechat-promote-tool/",
    "title": "如何用Wechaty打造一个推广机器人",
    "body": "2020/04/30 - 一、项目背景: 与美团饿了么等线上消费平台合作，以商家提供优惠券、我们以平台与用户合作推广的方式帮助这些平台完成销售指标，从中抽取佣金的一种模式。 二、分析需求: 分析平台用户行为后，发现大部分用户的推广方式较为单一，主动性低。即使是有主动性的用户，也是采用的最传统的手动转发方式来推广。 基于此，能否在不对用户行为做太多干扰的情况下提高平台用户的推广能力？ 有几点需要解决：  如何平滑获取平台用户手上的资源？ 如何利用平台用户的资源为客户创造收益？ 如何以最低的用户成本，为平台用户实现最高的价值？带着这些问题，我们找到了一个完美的解决方案：“WECHAT BOT”。接着就是用市面上功能最强、实现起来最快的Wechaty来实现了。 三、Bot如何解决上述需求: 划重点：“分享优惠券，有人使用优惠券就有收益。” 基于这个重点，我们为用户打造了一个群消息助手，专门为用户在群内发送自己的各类优惠券信息。 只需三步，解放双手:  添加机器人好友 绑定平台账户 将机器人拉进群内测试效果:  机器人相关操作  测试发送效果 后续计划:  自动判断群所属用户、无需手动绑定。 客服功能 增加更多推广能力鸣谢: 感谢 Wechaty 开源项目及 句子互动公司提供的 token，为开发者带来极大便利！ 感谢@huan 提供的代码思路以及编码风格。 感谢osschat提供的issue =&gt; wechat持续追踪。  作者: LegendaryJesse，悦享推广联合创始人，半路出家的程序员。Code: promote-bot "
    }, {
    "id": 329,
    "url": "https://wechaty.js.org/2020/04/23/cps-of-wechat-bot-with-wechaty/",
    "title": "Cps demo of wechat bot with wechaty",
    "body": "2020/04/23 - tips: if you try to use wechaty web version, you will be know it can’t work, so this post show you how to use ipad version to make bot work, if you never use wechaty any version, this post also pass the web version, because it’s pointless What is it: cps-bot is a wechat bot that using wechaty to solve a lot of transfer and push work in the cps. Clear demand: Before development, we need to clarify the requirements, that is, what do I need a robot to docps-bot just need to automatically pass friend verification, send and receive messagesso let’s take a look at wechaty document  Automatically pass friend verification When someone adds a robot, pass or directly pass after judging the keyword of the verification message. After verification, automatically reply and introduce the robot function Reply to product link (JD) For example, reply https://item. m. jd. com/product/100008348572. html?wxa_abtest=o&amp;utm_source=iosapp&amp;utm_medium=appshare&amp;utm_campaign=t_335139774&amp;utm_term=CopyURL&amp;ad_od=share&amp;utm_user=plusmemberbefore start: First of all, the wechaty-puppet-padplus version used here will be very slow to install for the first time, because the installation package contains puppeter, I have also tried it successfully two or three times, and the QR code will appear after successIf the scan code returns null (bug), close and run again Quick Start: Create a new project: mkdir bot &amp; cd . /botnpm init -yThen we install the dependency packages needed by the project npm install --save wechatynpm install --save wechaty-puppet-padplusnpm install --save qrcode-terminalThe preparatory work is done Start to code: Write code according to needs，My file structure directory is like this:  src     config. js   index. js   onFriendship. js // Friends add monitoring callback   onMessage. js // Message listening callback   onScan. js // monitor the callback when scanning the QR code   config. js: put our configuration params module. exports = { // puppet_padplus Token token:  puppet_padplus_f387a9c321f178ce , // bot name name:  Zeng ,}index. js: /** * wechaty-puppet-padplus index */import { Wechaty } from 'wechaty'import { PuppetPadplus } from 'wechaty-puppet-padplus'import config from '. /config'import onScan from '. /onScan' // monitor the callback when scanning the QR codeimport onMessage from '. /onMessage' // Message listening callbackimport onFriendShip from '. /onFriendShip' // Friends add monitoring callback// initconst bot = new Wechaty({ puppet: new PuppetPadplus({  token: config. token }), name: config. name})bot . on( scan , onScan) . on( message , onMessage(bot)) . on( friendship , onFriendShip) . start()onFriendship. js: Friends add monitoring callback /** * Friends add monitoring callback */import { Friendship } from 'wechaty'import config from '. /config'// Friends add verification message to automatically agree to keywordsconst addFriendKeyword =  cps  //if need more , use array// Friends add monitoring callbackmodule. exports = async function onFriendShip(friendship) { let logMsg try {  logMsg =  add friend  + friendship. contact(). name()  console. log(logMsg)  switch (friendship. type()) {   /**    * step 1 New friend request    * to use 'request. hello()'' to get verification message    * Accept this request via 'request. accept ()'    */   case Friendship. Type. Receive:    if (addFriendKeyword == friendship. hello()) {     logMsg = `Pass verification automatically`     await friendship. accept()    } else {     logMsg =  Not automatically passed because the verification message is:   + friendship. hello()    }    break   /**    * step 2 confirm    */   case Friendship. Type. Confirm:    logMsg =  friend ship confirmed with   + friendship. contact(). name()    break  }  console. log(logMsg) } catch (e) {  logMsg = e. message }}onMessage. js: /** * Message listening callback */import { Message } from 'wechaty'// node-requestimport request from 'request'import urlencode from 'urlencode'import config from '. /config'// bot nameconst name = config. name// Message listening callbackmodule. exports = bot =&gt; { return async function onMessage(msg) {  // Judging that the message came from yourself, do not care, return  if (msg. self()) return  console. log( ============================= )  console. log(`msg : ${msg}`)  console. log(   `from: ${msg. from() ? msg. from(). name() : null}: ${    msg. from() ? msg. from(). id : null   }`  )  console. log(`to: ${msg. to()}`)  console. log(`text: ${msg. text()}`)  console. log( ============================= )  // Determine if this message type is text  if (msg. type() == Message. Type. Text) {   // request your api   let res = await requestApi(msg. text())   // return content   await msg. say(res)  } else {   console. log( The message is not text! )  } }}/** * Request an interface and return the message to the user * @param {String} info sent content * @return {Promise} Corresponding content */function requestApi(info) { return new Promise((resolve, reject) =&gt; {  let url = `https://cps. linkces. com/jd/universal`  request. post(url, {form:{content:info}},(error, response, body) =&gt; {   let res = JSON. parse(body)   if (!error &amp;&amp; res. code == 0) {    let send = res. data. result    console. log('res', res)    resolve(send)   } else {    resolve( Server is busy )   }  }) }). then(). catch( function(e){  //do some thing })}onScan. js: /** * monitor the callback when scanning the QR code */import Qrterminal from 'qrcode-terminal'module. exports = function onScan(qrcode, status) { Qrterminal. generate(qrcode, { small: true })}try run: set up your startup script in ‘package. json’ { . . .   scripts : {   start :  node . /src/index. js  }, . . . }then run npm run startdone The above code may be updated in the future, the latest code is located at: https://github. com/shuangjie/cps-bot  作者: shuangjie, a noob developerCode: Github "
    }, {
    "id": 330,
    "url": "https://wechaty.js.org/2020/04/21/wechaty-min-forwarder/",
    "title": "Wechaty 服务器的最小化实现",
    "body": "2020/04/21 - 需求: 我们每天需要向数百个微信群批量转发信息，目前使用手动操作，需要耗费大量时间和精力，且很容易遗漏、出错。如果有一可自动化、程序化群发消息的工具，则可大大减轻负担，提高效率。 Wechaty 和 Puppet: Wechaty 提供了群组管理、收发消息等接口，能够方便地满足计划需求。 由于 Wechaty 本身只是一个控制器，因此其对微信功能的执行需要依赖于微信客户端协议与服务器进行通信。puppet 就是这些协议的具体承载者，现在有基于 Web / iPad / Mac 等协议的多种实现。经过测试，首先排除了 Web 协议：由于腾讯的限制，近年新注册的微信账号都无法使用网页协议，而老账号又实在过于珍贵；接着，在调试使用 iPad 协议的 PuppetPadplus 时发现直接调用接口发送小程序会引起错误，需要深入源代码调查修改。由于时间有限，最后决定选择使用 puppet-macpro。 架构:  目标：用最简单的方式实现向特定的若干微信群转发消息 功能：     账号登录   消息查看   群列表查看   将消息转发至微信群    方案：     使用 Node. js 开发；   在没有大量交互需求的情况下暂时可以接受 Node. js 单主线程的局限性。若将来有需要，也可以使用多 worker / 进程合作解决问题；   由于微信的特性，群、消息等数据无法随时全量拉取，因此必须有一长期运行在线的 bot 将这些数据持久化。选择可以无缝接入的 MongoDB 进行数据存储；   Wechaty / Express. js 作为服务端，负责消息收发；客户端通过 http(s) API 与服务端通信进行简单交互控制。   消息采用队列发送，有可调整的间隔。   实现:  登录 客户端发送启动请求，服务端调用 wechaty. start()。如果需要扫描二维码登录，Wechaty 会触发 ‘scan’ 事件并提供一个链接，服务端将其传给客户端生成二维码让用户识别。 接收消息 若发送者、发送者所在群不在数据库中，则需要将这些信息保存下来。由于 Wechaty 提供了 Room. load()、Contact. load() 等接口，实际上只要将它们的唯一 ID 保存下来已经能满足大部分需求了。 发送消息 普通文本消息可以直接调用 say() 方法，其余消息需要作一些处理。遇到的问题:  第一次运行 Wechaty 时 ‘scan’ 事件给出了空的 code，手机微信也没有登录确认提示。使用这个空 code 生成了二维码，傻傻地扫了无数次登录未果。。。 隔了一段时间后忽然恢复正常，原因不明，可能是微信或 macpro 服务器的短暂不稳定； Wechaty 文档中对于小程序卡片的参数说明已经过时，按文档参数生成的卡片是损坏的无法打开； 由于上一个问题的影响，小程序卡片无法直接转发； 还是文档问题。Room. findAll() 接口的功能按文档是 ‘Find all contacts in a room’, 实际效果则应为 ‘列出加入的所有微信群’； load() 函数并不总能成功，对新群、新联系人调用时容易失败； 底层有时会抛出大量连接方面的错误，需要深入 debug。致谢: 感谢 Wechaty 开源项目及 JuziBot 公司提供的 token，为开发者带来极大便利！  作者: hzzzzzz Node. js developerCode: Github "
    }, {
    "id": 331,
    "url": "https://wechaty.js.org/2020/04/20/run-wechaty-on-raspberry-pi/",
    "title": "在树莓派上运行wechaty",
    "body": "2020/04/20 - 一、介绍: 1、wechaty是迄今为止最易于使用的开源微信机器人框架 只要会写JavaScript就可以开发微信机器人，示例只有7行代码： import { Wechaty } from 'wechaty' // import { Wechaty } from 'wechaty'Wechaty. instance() // Global Instance. on('scan', (qrcode, status) =&gt; console. log(`Scan QR Code to login: ${status}\nhttps://api. qrserver. com/v1/create-qr-code/?data=${encodeURIComponent(qrcode)}`)). on('login',      user =&gt; console. log(`User ${user} logined`)). on('message',    message =&gt; console. log(`Message: ${message}`)). start()2、树莓派是一个具备硬件接口的廉价卡片电脑 树莓派能运行完整的linux系统，可通过读写GPIO文件的方式实现与硬件交互。树莓派降低了开发硬件的难度，可使用开发软件的方式开发硬件。 3、树莓派定律：凡是能在PC上运行的软件，必须在树莓派里也能运行 这个定律是我说的，因为我不出名，所以大部分人都不知道。 二、思考：wechaty + 树莓派 = ？: 这个世界一直在重复造轮子。有平行的，有升维的，也有降维的。换了一个环境和应用场景时，常常会对同样的东西实现重新定义。比如直播重新定义了电视购物。而运行在树莓派上的wechaty微信机器人，则重新定义了人与智能设备的交互方式。 三、在树莓派上体验wechaty: 1、安装nvm curl -o- https://raw. githubusercontent. com/creationix/nvm/v0. 33. 11/install. sh | bash2、设置 ~/. profile，内容如下 export NVM_DIR= $HOME/. nvm [ -s  $NVM_DIR/nvm. sh  ] &amp;&amp; \.  $NVM_DIR/nvm. sh 3、安装node nvm install 13nvm use 134、创建一个名为wechatypi的文件夹，进入文件夹并安装wechaty及依赖 cd wechatypinpm initnpm install wechaty@0. 38. 0npm install bufferutil@^4. 0. 1npm install utf-8-validate@^5. 0. 25、创建 bot. js 文件 import { Wechaty } from 'wechaty' // import { Wechaty } from 'wechaty'Wechaty. instance() // Global Instance. on('scan', (qrcode, status) =&gt; console. log(`Scan QR Code to login: ${status}\nhttps://api. qrserver. com/v1/create-qr-code/?data=${encodeURIComponent(qrcode)}`)). on('login',      user =&gt; console. log(`User ${user} logined`)). on('message',    message =&gt; console. log(`Message: ${message}`)). start()6、运行 wechaty-puppet-service用的是windows微信协议，该协议需要使用token。把下面命令中的token替换成你的token。然后执行如下命令，启动机器人。 WECHATY_PUPPET=wechaty-puppet-service WECHATY_PUPPET_SERVICE_TOKEN=token node bot. js 7、终端上会出现一个url，复制粘贴到浏览器上，会出现一个二维码。 使用微信扫码登陆，微信机器人就上线了。 四、最简单的应用：根据消息开灯或关灯: 关键代码: 树莓派操作硬件，只需要引入相应的GPIO库，操作GPIO，只需要对某个针脚执行高电平或低电平： import Gpio from 'onoff'. Gpio;//引入GPIO库设置针脚17为输出针脚，用于连接继电器 const led = new Gpio(17, 'out');//设置针脚17为输出针脚开灯 led. writeSync(1);//高电平开灯关灯 led. writeSync(0);//低电平关灯全部代码: import { Wechaty } from 'wechaty' // import { Wechaty } from 'wechaty'import Gpio from 'onoff'. Gpio;const led = new Gpio(17, 'out');Wechaty. instance() // Global Instance. on('scan', (qrcode, status) =&gt; console. log(`Scan QR Code to login: ${status}\nhttps://api. qrserver. com/v1/create-qr-code/?data=${encodeURIComponent(qrcode)}`)). on('login',      user =&gt; console. log(`User ${user} logined`)). on('message', on_msg). start()function on_msg(message){  var from = message. from()  var text = message. text()  var to = message. to()  if(text== open ){    led. writeSync(1)  }  if(text== close ){    led. writeSync(0)  }  console. log(`Message from: ${from}`)  console. log(`Message text: ${text}`)  console. log(`Message to: ${to}`)}上面的代码以后可能会更新，最新代码位于： https://github. com/wechatypi/gpio 视频演示: https://www. bilibili. com/video/BV1bz411B7XG?seid=14179117841102771483  作者: cr4fun，极客、物联网专家，SDK产品经理。 "
    }, {
    "id": 332,
    "url": "https://wechaty.js.org/2020/04/17/microsoft-tech-forum-rui-interview/",
    "title": "Microsoft Online Tech Forum 微软在线技术峰会 - 李佳芮专访",
    "body": "2020/04/17 - 看点:  最贴心的、完善的程序员成长路径 一款智能对话机器人从0到1的搭建历程 全球人工智能技术的实践落地情况内容: 1. 自我介绍: 大家好，我是李佳芮，句子互动的联合创始人 &amp; CEO，句子互动围绕微信生态为客户提供智能营销和销售服务，帮助企业引流并实现转化，客户覆盖教育、保险、大健康等多个领域。获得PreAngel、Plug and Play，Y Combination, TSVC和阿尔法公社多家中美机构投资，曾入选百度AI加速器，Facebook 大陆首期加速器。 我是一个连续创业者，过去7年一直基于微信生态为企业提供智能营销服务。同时，我也是微软人工智能最有价值专家（AI MVP），也是 GitHub 上超过 7000 Stars 的开源项目 Wechaty 的联合作者，在做 Wechaty 的过程中创建并管理了一个覆盖全球的微信聊天机器人开发者社区，仅仅在 Github 上就有超过500个开源项目是基于 Wechaty 来写的，不乏有很多 超过 1000 Star 的优质项目。可以说在 Github 上，只要是node的开发者，想做微信机器人的，没有不知道 Wechaty 这个项目的。今年随着 Wechaty 的 Contributor 队伍越来越壮大，Wechaty 陆续开始支持 Go，Python 和 Java，也欢迎广大的开发者使用并参与贡献。 除此之外，今年我出版了一本书《Chatbot从0到1：对话式交互设计指南》，刚刚在京东上架，基于我过去服务企业的经验以及和 Chatbot 开发者的交流，讲述如何从0到1搭建一个聊天机器人，其中有一个片段也提到了2018年，我们团队和陆奇博士交流 Chatbot 和小冰相关的内容，他对我们的激励，同时他也为本书做了序。 作为微软的 AI MVP 以及 Wechaty 的社区发起人，创业之初我们就和微软有非常密切的合作，微软给了社区和我们公司非常多的支持，包括在提供非常棒的技术底层服务，云资源的支持，以及市场层面的支持。可以说我们公司的发展和社区的发展离不开微软的支持。 2. 我用的微软相关的技术: Chatbot 的智能程度取决于它能够给理解的意图和实体的数量和复杂度，因此高效开发语义理解模型是智能对话中非常重要的一环。对于创业公司来说，专门去开发语义理解模块是性价比非常低的事情，因为搭建这样的系统需要长年累月的累计和海量数据的积累，有这种能力的工程师非常少而且非常贵，而海量数据对于创业公司来说，又几乎是不可能的。微软的认知服务，比如 QnaMaker 和 Luis 非常好的解决了这个问题，他是专门帮助非自然语言处理专业的开发者解决自然语言理解这一开发瓶颈的，开发者可以轻松地创建和维护高质量的自然语言理解模型，并能无缝的对接到相关的智能应用中，这一切都是基于云的 API 服务完成的。 开发的过程中，你只要持续对系统训练，也就是喂这个系统相关的语料就够了。 而 Azure 的 Machine Learning 是微软在公有云 Azure 上推出的基于 Web 使用的一个机器学习服务，可以帮助企业快速的构建和部署机器学习模型。这样开发者就不需要掌握特别多的算法基础，也不需要读海量的论文，就可以直接享受微软算法工程师的结果。甚至使用官方支持的无代码设计器，帮助企业快速搭建机器学习模型，极大的提高了企业的开发效率。 最近新冠疫情席卷全球，微软为美国疾病和预防控制中心，也就是CDC，构建了一个 Chatbot，就是用到了上面的技术。这个 Chatbot 可以指导用户进行自我评估，通过自然的对方方式引导客户，初步判断自己是否感染了新冠病毒，并在需要的时候联系其他医疗资源和相关专业人士。除此之外，微软还向客户提供了多个 COVID-19 模板，开发者可以对这些模板进行修改，帮助企业和开发者快速自建各类新冠相关的 Chatbot。这样除了 CDC 之外，任何企业和开发者都可以通过微软的云服务，快速使用医疗 Chatbot 了。 3. 我和 wechaty 与 Chatbot 的渊源: 做 wechaty 社区已经做 wechaty 的开源项目，有一个非常有意思的背景。做开源项目是因为我喜欢跳舞。。。 2016年的时候，我和几个一起跳舞的小伙伴做了一个舞蹈社区，叫做舞哩，并在线录制200多期舞蹈教学视频，在b站、优酷、美拍、腾讯视频、youtube等等都有我们的舞蹈专辑，全网播放2000多万，我在视频上留了微信公众号的二维码，然后在公众号上放了一个我的舞蹈小号的微信号二维码。当我有了非常多的粉丝的时候，我面临一个问题，如何更好的管理我的粉丝。我仔细研究了下，发现我核心要解决三个问题：如何能自动化的把他们邀请到我的舞蹈微信群粉丝经常会问相似的问题，比如某只舞蹈的教学视频在哪里。虽然我明明已经在公众号写的非常清楚，并且还搭建了一个网页帮助用户搜索视频，但他们还是不厌其烦的问我的微信小号，这些问题应该能被自动化的回复的。我想找到社区最活跃的用户，让他做我们大区管理员和群管理员。我判别这个用户活跃的标准就也非常简单，就是他在群里发言的多少。显然，我不可能手动的去统计每个人说话的数量。 基于上面3个核心的需求，我参与到了 wechaty 非常早期的开源项目中，并成为 wechaty 的联合作者，这样我就可以花费非常少的精力运营我的社群，大部分的操作都能自动化做了，比如自动通过好友请求，自动拉好友入群，自动找群内最活跃的人，并且用几条常用的问答训练了一个舞蹈问答的机器人，可以快速的回答舞蹈的问题。 结合我自己多年基于微信生态为企业做运营的经验，我忽然意识到：随着用户越来越习惯通过微信交流，他们更习惯于在聊天对话中直接获取服务。这是一个交互方式演进的变化，也是随着技术升级，信息服务下一阶段的必经之路。我认为 wechaty 不应该只解决我自己社区的问题，还应该为更多的企业赋能，帮助他们更好的管理他们的用户，帮助更多企业赋能。因为那个时候我有比较多的种子企业用户，所以我用这个产品问了几个之前服务的企业，他们都觉得非常棒并表明了非常强烈的需求，所以这就成为了我这次创业的开端。 后来随着开发者越来越多，我创建了 wechaty 的开发者社群，用我自己写的微信机器人管理这些微信开发者，就像当时我管理我的舞蹈粉丝一样。相关的内容我写过一篇博客，有兴趣的可以去看下：https://wechaty. github. io/2016/12/10/try-to-write-wexinrobot 之所以选择 Chatbot 是因为我认为这里面有一个巨大的机会。回顾技术发展的历史，最大的几次浪潮出现基本都伴随着一个规律：新的技术的出现和整合带来全新的人机交互方式，大量的商业应用在此基础上营运而生。其实人类的需求一直都没有变化，只是交互变得越来越便捷了。人机交互的方式 2000 年之前以鼠标键盘为主，逐步过渡到 2010 年以手指触摸为主的移动 App ，每一次交互的变革，以此引发了互联网的浪潮和移动互联网的浪潮。那么在今天，随着人工智能技术催生的自然语言处理技术和底层硬件的愈发成熟，人机交互的方式会逐渐变为以自然对话为主，比如智能音箱、手机助手等，交互方式的变革一定会带来新一轮的革命。这也是我为什么非常看好 Chatbot 的原因。 实际上，在我每次管理社区过程中，用一个 bot 回答用户的问题；或者说今天我公司提供的智能营销 SaaS 工具，主动提示销售应该怎么和用户沟通并在聊天记录中抽取关键信息，对用户进行自动化标签管理；以些都是在Chatbot爆发的前夕，基本还都是在 B端应用比较多。我认为真正的 Chatbot 带来的革命还没有完全到来，当他能直接为海量 C端用户服务并且能提供符合用户预期的服务的时候，过去的成百上千个App会逐渐演化成未来的成百上千个Chatbot，各大企业的局面会非常不一样，也会非常有意思，我期待着那一天的到来。 4. 介绍如何从0到1搭建 Chatbot: 在这里，我为大家推荐我的新书，《Chatbot从0到1：对话式交互设计实践指南》，这本书的内容共分为五个部分。第1部分从人工智能的发展带动对话式交互引出Chatbot的应用场景及其分类；第2部分和第3部分从需求分析、流程设计、数据处理、对话脚本撰写、系统搭建、对话任务测评、平台渠道集成、运营反馈等方面，对Chatbot的整个生命周期进行了详细分析和介绍；第4部分通过案例分析，对Chatbot进行了实践；第5部分总结了目前对话式交互的局限性，并展望了基于人工智能发展Chatbot的机会。 《Chatbot从0到1：对话式交互设计实践指南》适合希望从事Chatbot行业的读者阅读，尤其是正在考虑将业务切入 Chatbot领域的决策者，即将或正在从事Chatbot专业工作的产品经理和项目经理，以及希望了解Chatbot领域工作流程的开发人员。 其实写这本书的原因之一，就是随着我创建我的公司并持续为企业提供自动化营销，并通过信息增量辅助销售、提高销售转化率和运营留存率的过程中，我在持续的和我服务的企业以及从业者交流的过程中发现，大部分对 Chatbot 有一个很大的误区，他们认为 Chatbot 是一个黑科技，Chatbot 等同于算法和论文，这个是不对的，我在本书主要想推出的理念是，Chatbot是一个产品问题，不是一个算法问题。我前面也介绍了，过去成百上千个 App 会逐渐演化成未来的成百上千个 Chatbot。在今天的视角看，搭建 App 其实是一个产品问题，不是你会 C Sharp 或者会 Java 这么单纯的技术问题。 这本书的第四部分的案例分析，就是通过微软认知服务的LUIS来进行了实操。LUIS的开发流程更像是一个教学过程：开发者是老师，LUIS App是学生。老师通过不停地告知学生正确的文本解析结果来完成教学。一个好的教学过程是一个“训练+实践”的闭环，标注一定量的起始数据；训练得到语义理解模型；对模型进行必要的测试；发布模型并应用到真实用户场景；甄选应用日志中的语句；继续标注并更新模型。这个过程周而复始，通过不停地迭代开发，不停地改善理解模型，使其越来越接近人类的理解能力。总结一下，四步分别是数据标注、模型训练、模型发布和主动学习。 我认为作为开发者，一定要学会站在巨人的肩膀上做事情，而不是自己死磕成为一个巨人。搭建一个 Chatbot 是比较负责的事情，算法非常重要，但依然只是搭建 Chatbot 中八个环节中的一个环节。还有很多其他的环节，比如对话脚本撰写，运营反馈等，这些几乎决定了一个 Chatbot 的成败。 今天因为时间关系，所以我简单的介绍一下 Chatbot 里面比较独特的一环，对话脚本撰写。因为 Chatbot 是没有 UI 的，整个的服务都是通过对话的方式引导用户并推进流程进行的，所以这里的对话脚本撰写其实替代了过去搭建 App 时候的绘制原型交互图。换句话说，在 Chatbot 中，产品功不能像图形式交互那样直接呈现在界面上，而是隐藏在对话中，所以对话脚本撰写其实是非常非常重要的，我的书里总结了十条设计原则，有兴趣的可以去详细看下。 今天我带了几本书，可以作为奖品现场抽奖送给大家。。。 5. 微软收购 Github 的看法: 其实 GitHub 不仅仅是一个编程工具，它已经成为了开源社区的核心，某种程度上是社交网络和项目管理工具之间的交叉点。很多人开玩笑说他是“全球最大的同性交友社区”，其实也可以说他是程序员界的“Facebook”。程序员在上面会大量公开开源代码，互相寻求帮助。发展到现在，GitHub 的作用已经不仅是一个程序员交流地，更成为一个猎头挖人平台，普通程序员甚至可以将自己在 GitHub 上的经验写进简历。 微软的CEO萨提亚说，微软 + Github = 为开发者赋能。所以微软收购 Github 是对社区开发者来说，似乎在围绕着开发的生命周期的各个阶段为开发者赋能：从构思、到协作、再到云部署。从我自身角度说，Github给了我很多，因为我2017年和2018年基本每天都泡在Github上，我认识了很多开发者，并且在技术和商务上都展开了非常多的合作。我们的开源项目也是托管在 Github 上的，我们的开发者社区也是基于 Github的，我和这些开发者的协同工作中，从他们身上也学习到了很多。 所以从我自身的角度看，Github 伴随了我很多年的成长，看到今天微软收购了 Github，感觉也很是开心和激动。 从开源角度来看，我们看到了微软作为全球最大的闭源公司，最讨厌开源的公司，忽然变化了，他开始拥抱开源了。这种转变还是蛮惊讶的，说明微软对开发者更友好了。我们也看到，在收购了 Github 之后，微软成为 Github 上代码贡献量最大的企业。刚刚我在后台也在和韦青老师交流，在收购 Github 之前，微软的很多员工也都在使用 Github，这次收购对微软的员工也带来了非常大的便利。 最后，其实关于开源，我想再分享一下真正的开源精神，其实分享和贡献。这也是刚刚我在后台和韦青老师交流的体会，开源是在其他人的代码上，学习以后，再反哺给开源，大家一起推动一个项目变得更好，开源不是伸手党，而是共同学习，共同进步，推进技术领域的进步。 谢谢大家！ 本次直播内容的部分视频内容，感谢微软MVP的负责人，来自微软的@康康全称截屏~  看 YouTube 有障碍的同学，可以移步到 腾讯视频 彩蛋: 下面是在后台和微软中国 CTO 韦青老师的合影，为我的新书 《Chatbot从0到1：对话式交互设计实践指南》 打call~ 现场很多小伙伴发了额 wechaty 弹幕，开心~~ "
    }, {
    "id": 333,
    "url": "https://wechaty.js.org/2020/04/10/chatbot-on-uniqueway/",
    "title": "Chatbot 在定制旅游行业的应用",
    "body": "2020/04/10 - 一、定制旅游介绍:  按需定制行程，不用自己做旅游攻略 提前预定住宿、交通、景点、活动，不用自己动手 24小时行中保障，不用担心出问题没人管 纯自由行、不跟团、丰俭由己、省时省心二、定制旅游业务流程: 三、Chatbot在定制旅游行业中的运用:  减少导流流失 提高销售签约率 提高售后服务效率 减少客户差评和赔付 提高微信沟通效率减少导流流失:  问题: 客人提交咨询后半天都无人联系，再次联系时客人 已经选择了别家 期望: 所有客人填单后都能够及时联系，减少本阶段流失 思路: 通过 Wechaty 主动添加客人微信，收集意向需求， 计算优先级，分配销售人员 成果: 呼叫中心提效40%(有些渠道拿不到手机号) 提高销售签约率:  问题: 有的销售人员转化率高，有的销售人员转化率低 期望: 不求个个都是销冠，但希望提高平均值水平 思路: 梳理高转化率人员的销售沟通策略，利用 Wechaty 进行消息推送 成果: 销售签约率提高5. 69% 提高售后服务效率:  问题: 客户签约后到出现前有大量体力性工作，如:收集 签证材料、货币兑换，目的地介绍等、特定地点注意事 项、气候天气温度提醒等 期望: 售后人员应该做更有价值的事，重复的工作给机器 做 思路: 整理这些重复工作，结合客户数据和行程数据将通 过 Wechaty 做消息推送和收集 成果: 售后服务效率提升15. 6% 减少客户差评和赔付:  问题: 差评多，赔付率高 期望: 降低差评、降低赔付率 思路: 在客户爆炸前发现并解决，基于百度AI做实时聊天内容的情感分析，及时发现并 告知管理人员跟进了解情况，避免客户爆炸 成果: 公开渠道差评下降45% 提高微信沟通效率:  现状: 业务人员大量时间花在微信沟通上，每天要无数次切换微信和内部系统 期望: 提高沟通效率，减少来回切换 思路: 打通PC端微信和内部系统 成果: 智能推荐回复话术(基于百度UNIT和预设规则)、实现自动关联微信对话和工单、根据聊天内容分析成交意向  作者: 李恺，无二之旅研发总监、资深后端工程师。 "
    }, {
    "id": 334,
    "url": "https://wechaty.js.org/2020/04/06/iot-based-on-juzibot/",
    "title": "使用句子秒回控制家里的台灯",
    "body": "2020/04/06 - 多年前，我曾基于XMPP协议设计了一套物联网系统，每个设备对应一个XMPP账号。后台可以方便地看到各种设备的在线状态，而无需开发心跳API。还可以通过群发消息，批量对设备进行远程操作。 但XMPP协议也有不足之处，比如很多算力受限设备无法使用XMPP协议，以及操作时需要XMPP协议的客户端。安装XMPP协议的客户端在推广时也是一个巨大的门槛。 根据去年的资料显示，微信有11亿个人用户。如使用微信去控制，则没有安装门槛。同时，用户用一个微信向自己的另一个微信发送消息去控制设备更能产生信任感。消息没有经过别人的APP，也没有经过别人的公众号。 如何控制硬件设备？: 硬件设备控制是一个很专业的领域，这里不做过多介绍。简单说一下，微控芯片有很多条腿，它们叫做GPIO针脚。这些针脚可以产生不同的电平，连接针脚的设备可以根据电平呈现不同的状态。比如高电平继电器，一旦输入的电平是高电平，则它就的常断电路会闭合，电流导通，电灯就可以亮。 如何让针脚产生电平？可以通过编程语言实现。比如在arduino中，对针脚 0 执行高电平： digitalWrite(0, HIGH);对针脚 0 执行低电平： digitalWrite(0, LOW);如何远程控制硬件设备？: 只要让设备通过网络，获得相应的指令即可。当采用推送方式时，可使用MQTT协议，指令端去发布一个主题，设备端去订阅该主题。当采用轮询方式时，设备端每隔一定时间间隔，去GET一下云端的资源地址，获得相关的指令，再根据指令，去更改GPIO的电平。 为了安全，需要把传输的指令进行加密，并添加签名。当设备获得指令时，需要解密，同时也需要去验签。 但为了演示如何使用微信控制设备，这里采用明文传输，不加密，不加签，不验签。 如何用微信远程控制设备？: 如上图所示，使用微信远程控制设备的关键，就是在设备上面跑一个微信客户端，并对消息进行判断，处理成高低电平。 以前有命令行的微信，可以直接通过命令方式调用。但是现在这种方法已经失去作用了。目前，wechaty是一个很优秀的微信机器人框架。只要在on message方法里写代码对消息进行处理，操作GPIO，就可以实现用微信去远程控制家里的设备。 然而，我在树莓派里跑wechaty并没有成功，原因是wechaty会启动一个chrome，但那个chrome是x86的，不支持arm。而把arm的chrome替换掉x86的chrome后，依然不能启动。我猜测是arm的chrome和x86的chrom可能不仅仅是指令集不一样，里面的接口也不一样。因此，需要有一个平台，能直接获得微信消息。句子秒回就是这样一个平台。 在句子秒回中，可以设置API回调接口。https://wechat. botorange. com/ 因此可以构建一个回调API，根据获得的消息去操作硬件设备。因此，目前有2种方案可选，一种是在回调地址中，把获得的消息转成MQTT，即发布一个主题。 如上图所示，使用廉价的arduino，订阅主题，当微信发送消息时，句子秒回会把消息推到回调API。在回调API中，把获得的消息发布到一个MQTT主题。但这也需要额外配置一个MQTT broker服务器。 另一种方案是在回调API中，把消息存起来。通过另一个API可让设备轮询获得该消息。因轮询有时间间隔，因此它的速度没有MQTT快。 具体代码: 为了便于演示，不做太复杂。传输直接用明文，不加密了。获得的消息也不存在数据库里，直接保存为文本文件，让arduino能调用就行了。 指令设置: open为开灯命令，close为关灯命令。 作为 webAPI 的 PHP 代码: 本例子使用flight微框架和用于POST数据的workerman库来实现。 因此composer. json中设置了这两个库。 {   require : {     mikecao/flight :  ^1. 3 ,     workerman/workerman :  ^4. 0   }}具体代码 &lt;?phprequire __DIR__ . '/. . /vendor/autoload. php';use flight\Engine;use GuzzleHttp\Client;use Workerman\Worker;$app = new Engine();$app-&gt;route('GET /text/@id', function($id){  echo file_get_contents( $id. txt );});$app-&gt;route('POST /message', function(){  $data=file_get_contents( php://input );  $json_data = json_decode($data, TRUE);  $user = $json_data[ data ][ contactName ];  $contactId = $json_data[ data ][ contactId ];  $text = $json_data[ data ][ payload ][ text ];  $token = $json_data[ data ][ token ];  $chatId = $json_data[ data ][ chatId ];  $myfile = fopen( $contactId. txt ,  w ) or die( Unable to open file! );  fwrite($myfile, $text);  $client = new Client();  $r = $client-&gt;request('POST', 'https://ex-api. botorange. com/message/send', [    'json' =&gt; [      'chatId' =&gt; $chatId,      'token'=&gt; $token,      'messageType' =&gt; 0,      'payload' =&gt; [        'text'=&gt;  $text too ,        'mention'=&gt;[]      ]    ]  ]);  echo $r-&gt;getBody();});$app-&gt;start();?&gt;上面的例子中，获得消息和发消息，可以参考句子秒回的API文档：https://github. com/juzibot/xiaoju/wiki/API-Doc arduino代码: 本例子中，采用廉价的ESP8266作为设备微控器，在GPIO0针脚上面连接继电器。 需要把yourdomain替换成你的网址，wxid替换成发指令消息的微信id。该id可以从获得消息中的json字段中获得。即PHP代码中的 $contactId 。 #include &lt;ESP8266WiFi. h&gt;#include &lt;WiFiClient. h&gt;#include &lt;ESP8266HTTPClient. h&gt;void setup() { // put your setup code here, to run once: pinMode(0, OUTPUT); Serial. begin(9600); WiFi. begin( wifiname ,  wifipasswd );  //WiFi connection while (WiFi. status() != WL_CONNECTED) { //Wait for the WiFI connection completion  delay(500);  Serial. println( Waiting for connection ); }}void loop() { HTTPClient http; http. begin( http://yourdomain/text/wxid ); // http. addHeader( Content-Type ,  application/json ); int httpCode = http. GET(); if (httpCode) {  if (httpCode == 200) {   String payload = http. getString();   if (payload ==  open ) {    digitalWrite(0, HIGH);   } else {    digitalWrite(0, LOW);   }   Serial. println(payload);  } } http. end(); delay(500);}视频演示: https://b23. tv/BV1Gt4y127Qz 除了点灯还能干点别的不？: 开门禁、开空调、开电视，总之一切智能家居，都可以通过微信遥控。  作者: cr4fun，极客、物联网专家，SDK产品经理。 "
    }, {
    "id": 335,
    "url": "https://wechaty.js.org/2020/04/05/wechaty-check-in-robot/",
    "title": "微信打卡机器人",
    "body": "2020/04/05 - 1. 开发背景: 女朋友(逃)建了一个学习打卡的微信群，邀请了一些同学进群进行每日打卡学习，三天没有打卡就会被踢出群聊。于是需要记录每个用户的打卡时间，并进行相关的结算。之前看到过开发微信机器人，于是就想到可以做一个机器人代替手动记录以节省时间。本项目用的是 wechaty 的 wechaty-puppet-padplus 协议进行开发。 2. 打卡说明:  用户需要每天将打卡及学习内容或者学习图片发送到群聊中 每日凌晨 00:00:00 结算今天未打卡人数     未打卡的人机器人会在群聊中 @ TA，提醒今日未打卡    每日凌晨 00:00:00 结算三天内都没打卡的人数     会发送三天内未打卡的人到管理员的微信上，管理员再进行移除         这里可以做成自动移除该用户           用户可以进行请假 请假之后当天可以不打卡 白名单内的用户不会计入结算内3. 功能:  群聊功能     记录用户打卡   进群发送欢迎语   用户可以进行请假   每日早上 8:00 推送一条历史上的今天   用户补卡   打卡排行榜    管理员功能     查看当天未签到用户 (当天0点前)   查看三天未签到用户   更新群聊用户信息 (用户可能改名，避免 @ 时名字错误，可以做成定时更新)   获取历史上的今天   修正某个用户的打卡时间   设置管理员 - 目前手动在数据库中设置   设置白名单 - 目前手动在数据库中设置   4. 技术栈:  TypeScript TypeOrm (MySQL) 原生 NodeJS (主要用了发布订阅模式) wechaty (机器人)5. 运行项目: #1. 下载项目git clone https://github. com/yeojongki/wechaty-check-in-robot. git#2. 安装依赖yarn config set registry https://registry. npm. taobao. orgyarn config set disturl https://npm. taobao. org/distyarn config set puppeteer_download_host https://npm. taobao. org/mirrorsyarn install#3. 复制 . env. sample 为. env文件 并设置相关环境#4. 配置 mysql 环境#5. 运行yarn dev#6. 打包 会在根目录生成 dist 文件夹yarn build# 注意：配置好管理员和白名单 目前只能在数据库中设置 字段为 is_admin, isWhiteList (突然发现没有把数据库中的字段设为下划线风格. . . )6. 部署: 6. 1 你可以自行将 dist 文件夹复制到你的服务器中运行: 6. 2 可以参考本项目进行部署 (PM2 + webhook): 注意：首次需要先在服务器 clone 好项目，并运行 dist/src/webhook. js 和 dist/src/main. js。  在对应的 github 仓库中配置好 webhook 在 . env 文件中配置以WEBHOOK_ 开头的相关配置 修改 script/depoly. sh. sample 为 depoly. sh 并修改 PROJECT_NAME 为你的项目名 push 上 github 时服务器会发送 webhook 然后服务器会执行 script/deploy 自动拉取项目并构建重载7. 其他:  用到了 Server 酱，突然发现不需要用也行，直接用机器人发信息给管理员就行了… 机器人判定打卡功能很粗糙，有待完善 将业务功能抽离处理 开发更多功能 作者: yeojongki 前端开发工程师 "
    }, {
    "id": 336,
    "url": "https://wechaty.js.org/2020/03/30/financial-marketing-practice/",
    "title": "使用Wechaty助力金融营销实践",
    "body": "2020/03/30 - 首先，先为我拙劣的代码道个歉。临时野生程序员JS为现学，各种不规范请见谅。 作为一个从互联网行业转型的证券从业者营销人员，在传统的行业中作业时，会有一些需求过于人工化。那么我今天将我使用Wechaty助力金融经纪业务的实践记录并分享给大家。 我在做一件自动化营销的事情: 在做经纪业务营销过程中，有一项最基本的工作内容：开户。也就是互联网中常说的获取新用户。我在工作的过程中，考虑过很多拉新的思路，其中有一个叫可转债套利拉新。简而言之就是通过可转债这项金融工具进行套利，得到实打实的利益。有利益可循，客户才有开户的动力。在可转债套利这件事情中，我需要做这么一些事情：  找到有意向的客户，添加好友 与客户介绍可转债套利的玩法 营销开户，核心为开户二维码和开户注意点 可转债打新信息的推送 可转债中签的缴款通知 可转债可卖出的通知每天都要花费不少的时间做这一系列事情，如果能用机器实现自动化，那么我可以节省非常多的时间，并且我可以把营销的主被动关系尽可能转换掉。加上现有的绝大部分客户都落地在微信号中，那么第一个思路就是：如何做一个微信个人号的机器人。经过多方搜索，终于找到了Wechaty这个个人号框架。  为什么用微信个人号呢？用户沉淀，二次营销的发展。 工作事项和自动化的业务调整: 我计划营造一个新的营销环境和场景去驱动这件事，期望将自动化营销的各个节点串联起来，形成小生态。那么与需求对应的事情一件件来：  将寻找客户添加好友转变为被加好友 套利玩法形成清晰的文章和图 适当的推送开户二维码或者开户链接 汇聚有意向的客户到交流群 可转债的打新、缴款、上市卖出以及明日打新统一整合进行播报期望业务链：种子客户-&gt;交流群播报可转债信息-&gt;适当营销文字-&gt;添加bot为好友-&gt;应答添加及对话-&gt;拉群、开户等服务-&gt;群播报 机器人计划实现的功能:  好友添加自动应答 加群自动应答 拉群自动应答 消息响应     被动可转债播报   被动开户应答   被动大宗预留   被动联系我   点对点数据推送订阅    主动推送     可转债播报    群数据储存 系统配置 消息触发的白名单 群管理代码实现的思路: 首先根据example中的样例，我讲bot的事件监听分发到了不同的监听器中。 // mybot. jsbot  . on('scan', '. /listeners/on-scan')  . on('message', '. /listeners/on-message')  . on('onLogin', '. /listeners/on-login')  . on('friendship', '. /listeners/on-friendship')  . on('room-join', '. /listeners/on-room-join')  . on('room-topic', '. /listeners/on-room-topic')  . on('room-invite', '. /listeners/on-room-invite')  . on('room-leave', '. /listeners/on-room-leave')  . on('ready', '. /listeners/on-ready')  . start()其中值得说明的是ready这个事件，借助这个事件，我们可以构造定时任务。那么先看看定时任务是怎么做的。这里借助了cron这个库实现了定时任务。其中推送的目的地有一个json维护者，我可以手动添加。 // . /listeners/on-ready/*BOT启动时，加载定时任务。每天早上主动往管理的群推送打新内容。 */async function onReady(){  try {    import CronJob from 'cron'. CronJob;    import isHoliday from '. . /functions/holiday'    import moment from 'moment';    const bot = this    const job = new CronJob('15 9 * * *', async function() {    // const job = new CronJob('*/1 * * * *', async function() {     // if (isHoliday(moment(). format( YYYY-MM-DD ))){      //  return      // }      import config from '. . /config'      console. log(new Date(). toLocaleDateString()+'Tick Tick Tick');      for (x in config. PushGroups){        const room = await bot. Room. find({topic: config. PushGroups[x]})        console. log( room name is   + config. DebtGroups[x] +  , raw data is   + room)        await room. say(await require('. . /functions/stocks-debt'). debts()) //推送打新资讯        await room. say(config. Message. Tick)//推送打新提醒      }    }, null, true, 'Asia/Shanghai');    await job. start();  }catch (e) {    console. log(e)  }}module. exports = onReadyWechaty的事件监听分离的非常清晰，通过message事件的监听，可以对接收到的消息进行处理，实现我想要实现的被动消息触发。为了尽可能不复杂的做好数据存储，我选择了lowdb这款json适配器，相对容易的存储数据到本地json文件中。 . . .  if (room){    if (await msg. mentionSelf()) {      console. info('this message were mentioned me! [You were mentioned] tip ([有人@我]的提示)')      const topic = await room. topic()      console. info(`Room: ${topic} Contact: ${contact. name()} Text: ${text}`)      switch (text. split(/\s+/)[1]) {        case '可转债':        case '打新':          console. debug( Request from :   + contact. name() +  ; Check Mod Permission result： +config. Mod. indexOf(contact. name())+ ； Check Admin Permission result:  + config. Admin. indexOf(contact. name()))          if (config. Mod. indexOf(contact. name()) || config. Admin. indexOf(contact. name())){            // console. debug(await stockDebt. debts())            /*              await room. say( 今日休息，不开盘。 )              return            }*/            await room. say(await stockDebt. debts())          }          break        case '开户':          await room. say( 请长按识别以下二维码开户 , contact)          const fileBox = FileBox. fromUrl('URL EXAMPLE')          await room. say(fileBox)          break        default:          break      }    }  }}. . . 为了能对将要管理的几个人的人数进行监听，我选择在room-join事件中做用户信息的同步和存储。 //on-room-join. jsasync function onRoomJoin(room, inviteeList, inviter){  try {    const nameList = inviteeList. map(c =&gt; c. name()). join(',')    const topic = await room. topic()    const memberList = await room. memberAll()    console. log(`Room ${topic} got new member ${nameList}, invited by ${inviter}`)    // room. say( T:欢迎小伙伴  +nameList+   加入我们！ )    await require('. . /functions/db-operation'). syncGroupMembers(topic, memberList)  } catch (e) {    console. error(e)  }}module. exports = onRoomJoin//db-operations. jsmodule. exports = {  syncGroupMembers: async function(topic, members) {    try {      import low from 'lowdb'      import FileSync from 'lowdb/adapters/FileSync'      const adapter = new FileSync('. /db/db. json')      const db = low(adapter)      if (db. get('groups')        . find({ name: topic })        . value()){        db. get('servers')          . find({ name: topic })          . assign({ members: members})          . write()      }else{        db. get('groups')          . push({ name: topic, members: members})          . write()      }      return await db. get('groups')        . find({ name: topic })        . value()    }catch (e) {      console. error(e)    }  },  getGroupMember: async function(topic) {    try {      import low from 'lowdb'      import FileSync from 'lowdb/adapters/FileSync'      const adapter = new FileSync('. /db/db. json')      const db = low(adapter)      const data = db. get('groups')        . find({ name: topic })        . value()      console. debug( Member list as follow :  +data+ , Member numbers is :   + data. members. length)      if (data. members. length &lt;=500){        return true      }else{        return false      }    }    catch (e) {      console. error(e)    }  }}通过这几个核心模块的完成，第一版要搭建的核心骨架和功能就完成了，我们来测试看看。 运行效果:       我   机器人         hi               您好，我尚在学习中，可做的事情有限。           那么，还是请跟随我来吧。           - 发送[可转债]了解转债信息。- 发送[可转债群]加入转债交流群- 发送[开户]一键开户，高效。- 发送[大宗交易]勾兑业务。       可转债               🍁可转债小助手给您带来的信息如下： \n 2020-03-30日申购清单如下： \n 无 \n 2020-03-30日中签公布清单如下，请及时检查并缴款： \n 同德转债 128103 \n 计划发行量：1. 44亿 \n 申购代码：072360 \n 配售代码：082360 \n 股票名称：同德化工 \n 股票代码：002360 \n 中签公布日：2020-03-30 \n 转股价格：5. 330 \n 上市日期：未定 \n 2020-03-30日可以卖掉这些债啦，请遵守交易原则进行卖出： \n 无 \n 明日申购清单如下： \n 华体转债 113574 \n 计划发行量：2. 09亿 \n 申购代码：754679 \n 配售代码：753679 \n 股票名称：华体科技 \n 股票代码：603679 \n 中签公布日：2020-04-02 \n 转股价格：47. 720 \n 上市日期：未定 \n   后续计划和致谢: 首先，感谢开源项目Wechaty团队以及其提供的开发者计划，让我有机会能实现自己的想法。其次需要感谢同花顺和东方财富，你们提供的金融数据至关重要。项目代码在这儿 目前的机器人还只能做一些简单的事情，后续会根据业务的需求增加更多的功能上去。目标是让机器人为我打工，以及在传统金融里面实现微创新。 对了，如果您想要体验我的机器人，或者对可转债套利有兴趣。您都可以扫描我的机器人进行体验。  作者: lemonsx(柠檬x)，证券从业者，前平台产品经理 "
    }, {
    "id": 337,
    "url": "https://wechaty.js.org/2020/03/27/kaiyuanshe-interview-huan-slash-youth/",
    "title": "开源社：走进 “ SLASH（斜杠)青年 ” 李卓桓",
    "body": "2020/03/27 - 近年来非常流行“SLASH（斜杠）青年”一词，指的是不再满足“专一职业”的生活方式，而选择拥有多重职业和身份的多元生活的青年。 今天我们将走近这位“SLASH（斜杠）青年”——李卓桓先生，他集创业者/投资者/作者/程序员/顾问/极限运动爱好者等多重身份于一身。将于我们谈谈自己的一些故事，以及和开源的不解之缘。 1 履历：拒绝被单一标签化:  https://blog. zixia. net/2007/06/28/computer-with-huan-preface/LinkedIn：https://www. linkedin. com/in/zixia/ 25 年编程经验，15 年互联网创业经历，投资过百余家移动互联网初创企业，在这个并不算小的圈子里，他靠着自己的不断努力，成为了一个闪耀的人物。 用他的话说，自己就是“一个从小喜欢计算机的小朋友追求过上写程序生活“的例子。 担任过水木清华 BBS 站长、叽歪网创始人、优酷网首席科学家，现在是 PreAngel 合伙人，Plug and Play Venture Partner，Venture SPRINT 联合创始人。 同时他还是明星投资人，作为 LP 投资了中美多支天使基金，还投资了许多人工智能、机器学习的公司。 他在业界也有着多个显赫的 Title ：中关村股权投资协会副会长，中国天使联合会创始理事，清华企业家协会（TEEC）人工智能委员会主任委员，多家创业公司和 VC 机构顾问。 2 创业：其实是一场思维挑战: 在本次采访中，李卓桓回顾了自己过往的创业经历：  大学时最早在 ChinaRen 打工，ChinaRen在 1999 年是国内互联网行业 最亮的新星。我负责所有网站服务器软硬件安装、系统管理和运维；包括整个系统的日志收集、管理统计、分析报告，网站图表系统等等。 大学后期开始注册了自己的公司：阿卡信息技术，完全基于开源软件，提供了一些互联网服务，比如 wMail 邮箱系统，wForum水木清华BBS Web系统，与BBS短信互联互动的手机短信平台 AKA SMSD，和反垃圾邮件网关系统等等。现在我还保留着当时的代码，都顺便存档在 GitHub 上了。（地址： https://github. com/zixia ） 2005年，参与创立优酷网。最初优酷网的初创团队只有不到十个人，我负责从零组建产品技术团队，完成了优酷网第一个版本的网站的设计、开发和上线运维。 2007年，创立了叽歪网。因为我当时特别喜欢 Twitter ，就特别想在国内也做一个。不过在2009年因故失败了。这些创业经历，让他更加理性地看待创业和工作二者之间的关系。 打工思维大多数时候会基于一种”多一事不如少一事”的态度，把身边的需求做60分合格即可。 创业思维不同，创业思维更多的是时候会深度思考，这个需求有没有更好的完成方式？甚至会更进一步思考为什么要做这个需求？有没有其他的方法更能够解决目前面临的问题？ 用软件开发来举例的话，就像一个基于 TDD 开发的流程中，打工思维的开发者就是完成一段代码，能够通过对应的单元测试就足矣。 而创业思维则从单元测试的代码中，去理解系统的设计思路和工作原理，甚至对单元测试的代码提出优化建议。 3 开源：英雄与宝刀的相遇: 一路从创业中走来，他接触了并也践行了多种开源的方式，而在开源领域的贡献中，李卓桓也是身体力行的开路先锋。 在过去的 3 年多里，我在 GitHub 上提交了超过三万行代码，发布了数十个开源 Repository，包括十余个NPM 模块，5 个 PyPI 模块，5个Docker Image，1个 Swift 模块等等； 同时也给大量其他的项目提交了 Pull Request 并且被最终合并，比如 Microsoft 的 BotFramework 和 Google 的 TensorFlow 项目中都我提交的代码补丁。 我发布的开源项目，合计 Stars 数量超过一万，模块被其他代码库引用数量数千，每月模块下载量 3 万余次，Docker Pull 总计百万余次。 同时，我还在 GitHub 上被其他开源组织、作者邀请为 Owner 和 Maintainer 。 比如我现在是维护 LevelDB 的 Level Org 的 Owner 之一，Google项目 pinject 的 maintainer，Node Python Bridge 的 maintainer 等等。 在开源社，我也作为 committer 参与了 Apache 基金会和开源社联合发起的项目 OSSChat 这个项目。 而对开源的热爱，在他口中，只是因为单纯处于个人的业余爱好。 可能是我从小就对代码有兴趣，对代码的洞见能够让我意识到开源本身对软件发展的重要性，以及开源社区的强大力量。 做为一个开发者，最好的学习渠道就是使用成熟的代码，然后基于成熟的代码进行学习了。我推测，在一个闭源的世界里，整个开发者群体的成长速度，会比在开源世界中低上至少一个量级。 1997 年到了清华大学之后，开始接触 Open Source 和 GNU/Linux 精神，当时参与了网上发起的一个推广 GNU/Linux 精神的组织：阿卡信息技术。 网站：http://www. aka. net. cn （2003年版）  1998 年 10 月阿卡组织的杂志第一期：http://www. aka. net. cn/Magazine/Aka1/aka1-cover. html应该是国内最早翻译《大教堂和集市》这篇文章的了 http://www. aka. net. cn/Magazine/Aka1/c&amp;b. html 从那时起，GNU/Linux 就在工作和学习上，给我带来了极大的的帮助，开源的理念也开始我心里生根发芽。 4 洞见：开源是一种解决之道: 长期的开源经历，也让李卓桓有着对开源别样的见解和体会。 在开源领域，最喜欢的名人名言是 GNU 和 Linux 的这两句：  “When we speak of free software, we are referring to freedom, not price. ”― Richard M. Stallman  “Software is like sex: it’s better when it’s free. ”― Linus Torvalds 我认为开源文化的核心就是 Free 。Free 有两层含义：一层是自由，另一层是免费。 合起来，我认为开源文化代表了一群追求自由的 Hacker 。在社群里面免费贡献自己的知识，并将知识以软件为载体进行流动和演进，让我们的生活变得更加美好的一种越来越流行的软件社区发展方向。 这里给出一个我的 Hacker 的定义：Hacker 是那些有能力，同时也有意愿去改变世界，并且愿意不断通过自己的努力钻研，使世界越来越美好的那类人。一般开源社区中的作者和 Contributors ，大多都是 Hacker。 而关于开源对社会的贡献，他则是这么去讲述： 首先，开源让知识流动的壁垒变低了，更能够促进真正有价值的创新出现。这并不是说开源就一定水平很高，事实恰恰相反，最初的 Linux 操作系统就是一个学生的作业水平而已。 但是，随着 GNU/Linux 的盛行，一代又一代拥抱开源的新生程序员，通过GPL许可证的授权，将一次又一次的代码迭代更新到 Linux 代码中。也许起步的时候并不高，迭代的速度并不快，但是指数增长的力量是惊人的。 如果说 Linux 在诞生的时候，只有 1 分（假设Windows是 100 分），但是如果全世界的程序员，每天能够为 Linux 贡献 1% 的提升，第一年下来，Linux 就讲提升到 37. 8 分（算法：(1+0. 01)^365），十年下来，Linux 就讲提升到 5929448572069368 分…… （1+0. 01)^3650 所以我认为，开源的技术意义就是解放知识的流动壁垒和社区的生产力，社会价值就是技术领域生产力的爆发。 而对开源的独特理解，也反过来，成为他在投资领域的一个法宝： 我现在任职合伙人的 PreAngel 是一支专注于技术创业项目的天使基金，以帮助有理想的创业者实现更大的社会价值为使命，核心价值是提供“职业联合创始人”服务。它借助自身在技术和产业领域的深刻认识和资源积累，投资早期创业团队并且帮助他们成长。 PreAngel 的 LP 多为行业中知名天使投资人和成功企业家，比如蔡文胜、雷军、刘晓松等；曾被私募基金联盟评选为“中国天使投资TOP15” ，清科评选为“早期投资机构17强” ，并在全球人工智能人才白皮书中，与YC、真格基金并列AI顶级投资机构。 最初我之所以会从技术型创业者转型为投资人，是因为自己在2010年的一次深度反思。回顾清华工科出身，一直在互联网领域创业的我：从创立清华校园最大的zixia FTP/BBS，到第一轮互联网泡沫时在ChinaRen参与创业；从在担任优酷网首席科学家，到创立第一家中文微博客Twitter类网站叽歪网服务；一直走在互联网技术的前沿。 在这些过程中，我是一个技术推动者和Geek。作为技术领域的Leader，我始终坚信：技术只有应用到社会中，才能带动带动社会发展；然而，只有自己应用技术，推动技术是不足够的。为了最大限度的影响社会，带动社会发展，一定要成立商业组织，才能达到目的。所以，未来能够对技术社会产生影响的人，一定是懂得管理的技术Geek。因为技术已经越来越成为商业社会的原始推动力。 所以，我邀请了李开复老师和雷军导师，为我写了推荐信，申请了中欧国际工商学院EMBA，并与2011年入学。 在开始学习更多的 MBA 知识的同时，我投身于天使投资领域，成为了 PreAngel 合伙人。从 PreAngel 的角度来评估一个技术项目的时候，也会带着我对开源的眼镜，去观察投资领域的早期技术项目。 一般来说，非技术背景的投资人，对开源项目解决的问题的理解、对功能的把握，和对长期价值的评估，都会有一些难度。 在评价纯技术领域的项目时，我和其他投资人最大的不同——就是我很容易的就可以理解到一个开源项目所解决的问题在哪里，技术价值在哪里，以及做得好不好。 5 知人：当伯乐遇到良驹 我有两个关系非常好的 PreAngel 项目CEO，他们都是非常优秀的技术极客创始人。 一位是 Chatopera 创始人&amp;CEO王海良。Chatopera 是一家为企业提供智能客服系统的技术服务公司，愿景是让聊天机器人从事工作中重复、繁琐的部分，把人从这些工作中解放出来，去做更有价值的事情。海良是微软人工智能最具价值专家（AI MVP），问答对话机器学习书籍《智能问答与深度学习》作者，在 Github 上发布了大量的开源项目，并在开发者社区得到了广泛的认可。他同时也是北京 Node. js 社区的组织者。 我和海良就是在全球最大同性交友网站 GitHub. com 上认识的，可以说没有开源社区，就不会有我和海良的合作。当时我刚发布自己的基于Node. js的微信个人号 Wechaty 开源项目，海良是我项目的用户，也是 Contributor 。后来海良邀请我去北京 Node. js 社区做了分享，我们便成了非常好的朋友。再后来，海良决定创立自己的公司，我也非常荣幸的能够通过 PreAngel 和海良开展了更加深度的合作。 另外一位是蒸汽动力的创始人&amp;CEO谢扬。蒸汽动力(authing. cn)是中国版的 Auth0. com ，提供开源的身份认证云服务，为开发者和企业提供用以保证应用程序安全所需的认证模块。谢扬曾任字节跳动 Hacker ，连续创业者，曾经在大学期间创立龙猫科技，提供容器云、可视化编程 IDE、人工智能、知识图谱等服务，并荣获腾讯创业大赛银奖。大学毕业后创立蒸汽动力，研发的 Authing 身份认证云，服务全球七个国家和地区的开发者，托管用户超过一百万。 和谢扬的相识，可以说也是完全基于技术的惺惺相惜。那年腾讯举办校园创业大赛，我作为决赛评委，前往深圳负责评审同学们的项目。那一年谢扬大二，单枪匹马来深圳腾讯公司角逐决赛，并最终获得了银奖的好成绩。在所有的项目中，谢扬的技术实力和潜力是所有参赛同学中的佼佼者，所以我就把我在活动中设立的唯一一个PreAngel特别奖颁发给了谢扬，联合英诺基金的合伙人李小丽女士一起，成为了谢扬的天使投资人。 这是我的优势，我能够更容易的和技术专家型创始人交流和合作的良好基础。  左起：马云、李卓桓、周星驰 6 未来：挑战与机会如影随形 当被问及开源未来将面临的挑战时，他给出了这样的回答： 开源目前整体上一片大好，因为有国际上微软这样的巨头，能够从痛恨开源到完全拥抱开源，支持了 GitHub，各种开源软件项目，收购 NPM 等等。这让整个互联网上的开源社区，得到了极大的资源支持。 但机会和挑战并存，主要的困难在我看来有三个方面： 第一，就是开源项目自身的生命力，是否足够强大到支撑其成为一个真正有价值的开源项目。 开源项目有很多，GitHub上所有的 repository 都可以认为是一个开源项目。但是并不是所有的开源项目都会被开发者认可的。 开源项目被社区所使用的频率，极大部分都是聚焦在头部的。100 个开源项目，可能是只有 1 个明星项目，9 个也许被一些人知道，偶尔用一下，而其余的 90 个都是”尸体“。 如何使自己的开源项目能够向着明星项目的方向前进？这是首要思考的问题。 第二，是开源项目取得了一些成绩之后，如何更好的走下去，也就是持续发展的问题。 很多项目在进展到一定阶段之后，就没有更大的资源投入了。 这一点开源项目和创业项目很像，首先需要找到真正的市场痛点并且做出符合市场需求的产品（在产品市场验证这一步，99% 的项目倒下了）；其次，剩下的 1% 需要找到能够让自己爆发性增长的机会。 第三，就是作者（创始人），或 maintainer （CXO），以及所有的 contributors （VP/Directors）在这个项目持续工作的动力从何而来？ 团队如果散了，项目自然就没有了生命力。在开源社区中，基本上应该大多以非金钱部分的激励为主。那么它如何生效，应该是一个融合心理学和组织行为学的大话题了。 对于开源未来趋势的建议，他则是这么说到： 我的一个直观感受是：All in AI/ML，人工智能将会是接下来 10 年，人类社会中最大生产力的提升机会，将会大大超越之前 20 年里，互联网信息化对社会带来的生产力提升。 AI/ML 领域对开源也进行了最佳实践：从论文完全在 arxiv 上公开开放，到 ML 的框架代码 TensorFlow 等完全开源，再到所有的神经网络模型都走向开源，这个领域越早进入，在未来得到的复利回报就会越高。 7 挑战：拥抱不设限的人生 热爱极限运动也是李卓桓的标签之一，这源于他自己的价值取向——挑战不可能，人生不设限。 我骨子里是喜欢刺激和挑战的。凡是能够让我感觉肾上腺激素上升的事情，我大多都会感兴趣。在工作上，只要是我喜欢的事情，我从来都不惧怕有挑战，去追求征服前进路上的挑战会是我的乐趣。生活中也一样，我会把有难度的事情，看作是游戏通关一样的过程，打boss升级，去感受、去体验。 如果新朋友是这种人，我们就会特别聊得来。因为这样的人无论在工作还是生活中，冲劲和闯劲特别大，抗压能力也会更强。  滑翔中的 Huan LI (李卓桓) 对于工作和生活的关系，他也有着自己的一些观点： 在经历了优酷网创业，并创立了自己的叽歪网项目后，我开始意识到，我的生命几乎被工作所完全充斥—— 优酷网创业初期，我带领技术团队没日没夜的加班，经常是天亮了其他团队的人来上班，我们才下班。 后来，我非常偶然的看了一部叫做《神奇遥控器》 的电影后，产生了极大的共鸣。 我突然意识到，我就像电影里面的那个主角，将生活中很多美好的东西被自己以工作的借口而忽略，比如家人朋友，健康作息、兴趣爱好。 华兹华斯说，“我们穷其一生追求的目标，早就已经在童年得到。我们越追求，离目标就越远。”。 从那时起，我开始平衡自己的工作和生活，这也是一种”双赢“的思维。  “阳光少年” Huan LI (李卓桓) 对于想成为斜杠青年的小伙伴来说，资深过来人李卓桓的肺腑之言是： 成长过程中要不断追求自己喜欢的东西，不必太在乎其他人的看法，能让自己收获源源不断的开心才是最重要的。生活原本沉闷，但跑起来就会有风。 对年轻人的建议，就是 Follow your heart ，不要害怕犯错误。年轻的时候试错成本小，多犯错误便能够多成长，迭代升级，进而真正知道自己想要的是什么。 写在后面：: 十分感谢李先生接受我们的采访，也感谢大家对开源的支持。 在人工智能领域里，李卓桓先生最关注的是聊天机器人方向，即 NLP （自然语言处理），他最近出版了一本专门讨论 Chatbot 行业的书籍——《Chatbot从0到1》和 TensorFlow 2 手册《简明的 TensorFlow 2》，欢迎大家购买阅读！             | 作者：李卓桓 稻子| 编辑：杨紫琳| 设计：刘颖洁  转载于：开源社 "
    }, {
    "id": 338,
    "url": "https://wechaty.js.org/2020/03/26/ncov2019-data-broadcasting/",
    "title": "nCoV2019疫情播报",
    "body": "2020/03/26 - 之前用pywx尝试玩过wxbot，我这种完全属于自嗨，但后来众所周知，web版被限制了，在github上瞎逛发现了wechaty这么个神奇玩意儿，真的太棒了。疫情播报的代码1月就已经在使用了，只可惜是py写的，这次借wechaty，改写成nodejs，也算是一次新语言的挑战。 环境: 看了一下wechaty的文档，推荐通过docker运行。但docker不熟悉啊，用惯了Windows，于是折腾部署win下环境，可惜没整出来，npm的时候出现大量错误，大概意思是需要安装有VS2013及以上的IDE才能编译，本机只有VS2010，算了暂时不折腾了，最终选择了推荐的docker环境，尴尬。 centos安装docker还是挺简单的，一条命令即可：yum install -y docker 启动docker服务(并设置开机自启): systemctl start docker. servicesystemctl enable docker. service查看docker服务状态: systemctl status docker拉取镜像: docker pull registry. docker-cn. com/zixia/wechaty若失败，执行这句试试，网络不好则多试几次： docker pull zixia/wechaty运行例子: 创建一个文件夹如：nCoV2019，copy一个package. json过来或使用npm init创建，创建代码文件如mybot. js或其它名称，自己开心就好。官方6行代码是不行的，因为调用的是网页版wx，我的帐号不行，又尴尬。 项目地址: github 下载完后，cmd进入项目目录，执行：npm install 启动程序: docker run -ti --rm --volume= $(pwd) :/bot zixia/wechaty mybot. js扫码登录，手机确认，登录成功后会显示 “登录成功”昵称，此bot只接受几个命令，如ding/ping/bing/code/疫情,自动消息回复pong，更多功能有待自行扩展。里面加了名片发送、链接等功能，但未使用，需要自行调试。 写在最后: 很简单的一个例子，也没多少代码量，适合初学者，大佬轻喷。对于写代码，我就是一只弱鸡，python略懂，nodejs更是现学现卖。若代码执行有问题，欢迎沟通交流。 有wechaty这个神器，其实可以做很多有趣好玩的事情，如自己关注的股票信息推送等。  Author: @zjacai enjoying ML&amp;Wechaty at BUPT代码: nCoV2019 "
    }, {
    "id": 339,
    "url": "https://wechaty.js.org/2020/03/17/sqlite-wechat-assistant/",
    "title": "使用 SQLite 和 pullword 实现简易的业务助手",
    "body": "2020/03/17 - 需求之初是，希望有一个机器人能够替我们完成各种机械式的操作，来提高我们的工作效率。 业务背景是客户需要一个消息中心系统，对接多种第三方推送平台，内部系统通过我们发送通知，一边是三方平台一边是内部系统，两边的对接需要提供各种文档和脚本，还需要配合QA测试及查询发送状态，有时有3-4个群同时@我们，工作效率严重下降。 所以我们想能否做一个自动化的机器人来替代我们，完成这些机械式的动作，最终我们找到了Wechaty。 好了，废话少说进入正题！ 调研: 最开始我们发现市面上有很多“傻瓜式”微信机器人，只能根据关键字回复固定内容，这显然不符合我们的需求，通过Google我们找到两款基本符合我们需求的产品。  Wechaty是适用于微信个人帐户的Bot SDK ，可以帮助您使用6行javascript创建一个机器人… 微控API是一套商业的的微信个人号接口，它能监测微信中的各种事件，并辅助微信执行各种操作…根据我们的情况我们选择Wechaty，原因：Wechaty提供SDK方便本地调试，微控API需要外网IP不方便内网使用。 基础环境: NodeJS v10. 15+ SQLite 3 PM2 v3. 5. 1+ 配置数据库: 考虑到我们的需求相对简单，所以使用SQLite进行简单的数据存储。 创建数据库： sqlite3 assistant. db创建表： -- 操作表create table action_tb(  id     integer not null primary key autoincrement,  keyword   text  not null unique,  operation  text  not null,  create_date integer not null default (strftime('%s', 'now')),  update_date integer not null default (strftime('%s', 'now')));-- 权限表create table power_tb(  id     integer not null primary key autoincrement,  user_id   text  not null,  action_id  integer not null,  create_date integer not null default (strftime('%s', 'now')),  update_date integer not null default (strftime('%s', 'now')),  foreign key (action_id) references action_tb (id));-- 关键字表 用户提问时附带的关键字（value）可能不统一 统一修改为（name）create table keyword_tb(  id     integer not null primary key autoincrement,  name    text  not null,  value    text  not null unique,  create_date integer not null default (strftime('%s', 'now')),  update_date integer not null default (strftime('%s', 'now')));根据表结构大概可以看出，我们做了简单的权限验证，并根据用户提问的关键字设置了不同的操作。 项目思路: 我们可以将用户的提问的看作route，专门创建一个message. js充当router。 // index. js// 使用ipad协议const puppet = new PuppetPadplus({token: config. wechatyToken});// 创建一个机器人const bot = new Wechaty({name: config. botName, puppet});. . . // 收到消息事件bot. on('message', async (msg) =&gt; { await message. index(bot, msg)});根据我们的需求，我们只需要捕获与机器人交互的信息，并将它们格式化。 // message. js. . . /** * 用于接收消息 并分发 * @param bot * @param message * @return {Promise&lt;void&gt;} */async index(bot, message) { // 当有人在群中@我或者私聊时 再处理 if ((message. room() &amp;&amp; (await message. mentionSelf())) || !message. room()) {  try {   // 打印原始数据   logger. log('info', `from:${message. from(). name()}/room:${message. room() ? await message. room(). topic() : null}/text:${message. text()}`);   // 将消息内容格式化   let msgData = messageUtil. formatMessage(message. text());   // 查询 消息 action   let action = await messageService. queryActionByKeyword(msgData);   // 格式化消息里的字段   msgData = await messageService. unificationMsgData(msgData);   // 如果查到 action 则继续 否则提示错误   if (action) {    // 校验权限    if (await powerService. verifyActionPower(message. from(). id, action. id)) {     // 执行操作     switch (action. operation) {      case 'queryRequest':       await this. queryStatus(bot, message, msgData);       break;     }    } else {     await messageService. sendMessageByMsg(message, '抱歉，你暂时没有这个权限');    }   } else {    await messageService. sendMessageByMsg(message, '你可以这样问我：\n查询状态');   }  } catch (e) {   await messageService. sendMessageByMsg(message, '抱歉短路了，重试一下吧！');  } }},. . . 在判断应该走哪一个操作（action）时，我们考虑到用户的消息可能并不规范，我们选用了Pullword对消息进行分词处理，根据关键词匹配action_tb表里的keyword字段。 接下来，我们就根据不同的action来进行不同的业务查询。 /** * 查询状态 * @param bot * @param message * @param msgData = {phone,?email} * @return {Promise&lt;void&gt;} */async queryStatus(bot, message, msgData) { const {phone, email} = msgData; try {  let returnMsg = '请参照如下格式提问：\n查询状态\n手机号:13000000000\n邮箱(可选):example@xxx. com';  // 如果 phone 不存在 则发送提示语  if (phone) {   // 如果存在 email 则查询详细信息 否则查询统计信息   if (email) {    let result = await requestService. queryStatusDetail(phone, email);    // 这整理错误和成功的发送消息    if (!result. error) {     returnMsg = `手机号为:${phone}，邮箱为:${email}的状态如下：\n` +      `状态:${messageUtil. customMsgStateToZh(result. state)}\n` +      `时间:${result. time}\n`;    } else {     returnMsg = '未查询到该状态，可能是手机号或邮箱错误';    }   } else {    ···   }  }  await messageService. sendMessageByMsg(message, returnMsg); } catch (e) {  logger. log('warn', {text: message. text(), msgData, err: e. message});  await messageService. sendMessageByMsg(message, '我好像有点问题，重问一下试试！'); }}至此我们的小助手基本框架已经搭好。 运行效果: 粗略演示一下 ￣▽￣”       小助手       用户             @小助手 查询消息状态 \n 手机号：1300000000 \n 邮箱：xxx@example. com   &lt;-       -&gt;   手机号为:13000000000，邮箱为:xxx@example. com的状态如下： \n 状态:成功 \n 时间:2020-03-01 12:12:00       感谢: 在最后我们要感谢所有为我们提供工具和服务的团队和个人。特别感谢开源项目Wechaty团队和免费提供服务的Pullword团队。  作者: moderncrazy，个人开发者。首发于博客: 使用 SQLite 和 pullword 实现简易的业务助手 遵循 CC BY-NC-SA 3. 0 CN "
    }, {
    "id": 340,
    "url": "https://wechaty.js.org/2020/03/07/meta-puppet-for-python/",
    "title": "MetaPuppetForPython - 用Python写Wechaty程序",
    "body": "2020/03/07 - 一个支持Wechaty调用的Python框架 特征：  你可以只会python 支持Wechaty全部协议，全部接口 兼容同步/异步编程 可拓展至其他app/社交平台声明：作者是更加支持native的python-wechaty的哈，看好@Huan和@wj-Mcat的工作！不过貌似开发还需要一段时间，有需要的童鞋可以暂时用MetaPuppetForPython。 Talk is cheap, show me the code: 初级：Hello Human:  目标：更改微信签名要点：你可以调用类似a_server. change_self_signature()的函数来主动调用Wechaty的各种接口，从而主动查找联系人，发信息等。你可以在SocketServerCore和SweetSocketServer中找到更多类似的函数。但他们其实都是只语法糖（下文会介绍原理），你也可以继承SweetSocketServer，然后根据自己的需要设计自己的函数。 # -*- coding: utf-8 -*-import timefrom MetaPuppet. core. SweetSocketServer import SweetSocketServerfrom MetaPuppet. core. TestBot import TestBotif __name__ == '__main__':  # init  a_bot = TestBot(name='test')  a_server = SweetSocketServer(    robot=a_bot,    num_async_threads=1,    debug_mode=True  )  a_server. run()  print(    'Please make sure the client is connected '    'before run the following codes'  )  time. sleep(20)  # -------------edit following code for simple tasks-----------------------  a_server. change_self_signature('Hello Human!')初级：a simple bot:  目标：一个简易机器人。自动接受加人邀请，并问好Hello Human!。自动回复，内容为接收到信息的反序。要点：你可以继承RobotBase然后override _process_message() 和_process_friend_invitation()函数。这些函数在收到相关微信信息后会被自动调用，你可以把机器人自动回复的逻辑放在这个类中。通过这种方式，你可以处理所有的被动请求。结合Hello Human!的例子，你可以主动发出请求。到此，你已经可以实现全部的业务逻辑。 # -*- coding: utf-8 -*-import timefrom MetaPuppet. core. SweetSocketServer import SweetSocketServerfrom MetaPuppet. core. RobotBase import RobotBaseclass MyBot(RobotBase):  def __init__(self, **kwargs):    super(). __init__(**kwargs)  async def _process_message(self, message, verbose=False):    # -------------edit following code for simple tasks-----------------------    return_msg = None    if 'payload' in message and 'text' in message['payload']:      return_msg = message['payload']['text'][::-1]    return return_msg  async def _process_friend_invitation(self, message, verbose=False):    return_msg = {      'wx_msg_type': 'TEXT',      'path': 'Hello Human!',    }    return return_msgif __name__ == '__main__':  # init  a_bot = MyBot(name='test')  a_server = SweetSocketServer(    robot=a_bot,    num_async_threads=1,    debug_mode=True  )  a_server. run()  print(    'Please make sure the client is connected '    'before run the following codes'  )  time. sleep(20)  # -------------edit following code for simple tasks-----------------------  # nothing needed here in this example  # however, you can put your other backend code here中级：语法糖:  目标：自定义函数：发送文本给特定联系人/群聊要点：MetaPuppetForPython实际上是用python将ts的代码片段转发给node并编译运行(详见原理部分)，所以若已有的语法糖不能满足需求，你需要定义自己的函数。由于ts的代码和python其实比较相似，并且往往只需要写很少的ts的代码，主要业务代码还是python，所以自定义函数的难度应该不大。你可以继承SweetSocketServer，然后在自定义函数中调用exec_wx_function()或exec_one_wx_function()执行文本格式的ts代码。如果你需要使用第三方的ts库，可以在socket_client/src的相关代码中声明。 同步代码的语法糖： from MetaPuppet. core. SweetSocketServer import SweetSocketServerclass ExtendedSocketServer(SweetSocketServer):  # definition for other functions/variables  . . .   def send_wx_msg_text(self, text, username, chat_type):    ts_code = '''      let say_content = `{}`      const a_contact = bot. {}. load('{}')      await a_contact. say(say_content)    '''. format(text, self. all_chat_type[chat_type. lower()], username)    self. exec_wx_function(      ts_code=ts_code,      need_return=False,    )异步代码的语法糖(只需要在函数的定义前加上async，在调用异步函数前面加上await)： from MetaPuppet. core. SweetSocketServer import SweetSocketServerclass ExtendedSocketServer(SweetSocketServer):  # definition for other functions/variables  . . .   async def async_send_wx_msg_text(self, text, username, chat_type):    ts_code = '''      let say_content = `{}`      const a_contact = bot. {}. load('{}')      await a_contact. say(say_content)    '''. format(text, self. all_chat_type[chat_type. lower()], username)    await self. async_exec_wx_function(      ts_code=ts_code,      need_return=False,    )中级：同步/异步:  目标：通过使用异步编程加速代码要点：同步和异步的区别是在等待响应时前者是真的等待，后者是会缓存当前程序，执行其他异步程序，收到响应时恢复当前程序继续执行。需要等待的情况有：网络通信等待回复，等待其他某个进程结束，人为使用等待/睡眠等函数。所以，对于大多数看到这篇帖子的人而言，异步代码加速的主要是网络通信的部分。如果同步代码本身很慢，将其改为异步并不能减少其执行时间。基于MetaPuppetForPython的原理，对于频繁调用Wechaty的函数，建议使用异步编程，如默认的_process_message()就是异步函数。在_process_message()中，若需要经常调用Wechaty函数，建议使用异步版本的语法糖；若仅是偶尔调用，使用同步版本亦可。当然，为避免所有函数都需要异步定义，建议在设计层面将Wechaty的相关调用放在比较上层的位置，甚至与核心的同步代码相互独立。对于大部分业务代码，只是偶尔调用Wechaty函数，可以直接使用同步风格的语法糖，并不影响效率。 异步： # -*- coding: utf-8 -*-import threadingimport timefrom MetaPuppet. core. SweetSocketServer import SweetSocketServerfrom MetaPuppet. core. RobotBase import RobotBasefrom MetaPuppet. core. time_classes import Timefrom MetaPuppet. core. utils import run_coroutine_in_new_threadclass MyBot(RobotBase):  def __init__(self, **kwargs):    super(). __init__(**kwargs)  async def _process_message(self, message, verbose=False):    # -------------edit following code for simple tasks-----------------------    return_msg = None    if 'payload' in message and 'text' in message['payload']:      return_msg = message['payload']['text'][::-1]    return return_msg  async def _process_friend_invitation(self, message, verbose=False):    return_msg = {      'wx_msg_type': 'TEXT',      'path': 'Hello Human!',    }    return return_msgasync def async_foo(server):  # -------------edit following code for simple tasks-----------------------  rooms = await server. async_exec_one_wx_function(    func_name='bot. Room. findAll',    func_paras=[],    need_return=True,  )  print('Time:', Time())  print('async_foo', threading. currentThread(). getName())  if rooms is not None:    print('async: len(rooms)', len(rooms))    print(rooms[0])  else:    print('async: rooms not found')if __name__ == '__main__':  # init  a_bot = MyBot(name='test')  a_server = SweetSocketServer(    robot=a_bot,    num_async_threads=1,    debug_mode=True  )  a_server. run()  print(    'Please make sure the client is connected '    'before run the following codes'  )  time. sleep(20)  # -------------edit following code for simple tasks-----------------------  # async version  # better to use async version because sync version might block io  run_coroutine_in_new_thread(    async_foo(a_server)  )同步： . . . def bar(server):  contacts = server. exec_one_wx_function(    func_name='bot. Contact. findAll',    func_paras=[],    need_return=True,  )  print('Time:', Time())  print('bar', threading. currentThread(). getName())  if contacts is not None:    print('sync: len(contacts)', len(contacts))    print(contacts[0])  else:    print('sync: contacts not found')if __name__ == '__main__':  . . .   # -------------edit following code for simple tasks-----------------------  # sync version  # sync code is simpler, though not recommended for heavy load  # you can use it if you don't need to use many async functions  # (e. g. async_exec_one_wx_function) at the same time and also  # (1) the task here is short-term and light-load  # or (2) you have a powerful computer  bar(a_server)中级：线程:  目标：通过使用多线程加速代码要点：上文中提到，异步主要是提升io方面的效率。对于需要较长计算时间的代码本身，异步帮助不大。此时可以使用多线程来避免堵塞其他任务。SweetSocketServer会默认开放一个线程进行消息的自动回复，需要的情况下可以设置初始化参数num_async_threads增加线程数。 . . . def bar(server):  contacts = server. exec_one_wx_function(    func_name='bot. Contact. findAll',    func_paras=[],    need_return=True,  )  print('Time:', Time())  print('bar', threading. currentThread(). getName())  if contacts is not None:    print('sync: len(contacts)', len(contacts))    print(contacts[0])  else:    print('sync: contacts not found')if __name__ == '__main__':  . . .   # -------------edit following code for simple tasks-----------------------  # sync version  # sync code is simpler, though not recommended for heavy load  # you can use it if you don't need to use many async functions  # (e. g. async_exec_one_wx_function) at the same time and also  # (1) the task here is short-term and light-load  # or (2) you have a powerful computer  # however, pay attention that you should run the task here in a new thread  # it is not good to run it in the main thread  threading. Thread(    target=bar,    args=(a_server,)  ). start()高级：拓展至其他app/社交平台:  目标：使用MetaPuppetForPython框架与web app通信要点：MetaPuppetForPython将机器人本身作为服务器，将Wechaty作为客户，但其实可以有多个客户同时与机器人进行交互，可以是微博，QQ，或者网页应用等。你可以继承SweetSocketServer并override process_socket_message()和process_custom_message()以处理来自其他app的信息。 服务器： # -*- coding: utf-8 -*-import timefrom MetaPuppet. core. SweetSocketServer import SweetSocketServerfrom MetaPuppet. core. RobotBase import RobotBaseclass ExtendedSocketServer(SweetSocketServer):  def __init__(self, **kwargs):    super(). __init__(**kwargs)    self. webgui_room = 'webgui'  async def process_socket_message(self, sid, message, verbose=False):    sender = message['sender']    if sender. startswith('wx_'):      room_name = self. wx_room    elif sender. startswith('webgui_'):      room_name = self. webgui_room    else:      room_name = sender    text = message. get('text', '')    if text == 'CONNECTED':      print('{}: sender, sid, room_name'. format(text), sender, sid, room_name)      self. sio. enter_room(sid, room_name)      self. add_room(        sender=sender,        room_name=room_name,      )    else:      pass  async def process_custom_message(self, sid, message, verbose=False):    sender = message['sender']    msg_type = message. get('type', '')    if sender. startswith('webgui_'):      if msg_type == 'CHAT_INFO':        print('webgui info received', message)        await self. robot. process_webgui_chat_message(message, verbose=verbose)        passclass MyBot(RobotBase):  def __init__(self, **kwargs):    super(). __init__(**kwargs)  async def _process_message(self, message, verbose=False):    # -------------edit following code for simple tasks-----------------------    return_msg = None    if 'payload' in message and 'text' in message['payload']:      return_msg = message['payload']['text'][::-1]    return return_msg  async def _process_friend_invitation(self, message, verbose=False):    return_msg = {      'wx_msg_type': 'TEXT',      'path': 'Hello Human!',    }    return return_msg  async def process_webgui_chat_message(self, message, verbose=False):    return_msg = await self. _process_webgui_chat_message(message, verbose=verbose)    return return_msg  async def _process_webgui_chat_message(self, message, verbose=False):    print('message', message)    return Noneif __name__ == '__main__':  # init  a_bot = MyBot(name='test')  a_server = ExtendedSocketServer(    robot=a_bot,    num_async_threads=1,    debug_mode=True  )  a_server. run()  print(    'Please make sure the client is connected '    'before run the following codes'  )  time. sleep(20)   # -------------edit following code for simple tasks-----------------------Web app作为客户端(示例中的任务不需要性能，可以直接用同步代码)： import socketioimport jsonimport osclass WebClient(object):  def __init__(self,         config_path):    self. config_path = config_path    self. config = self. read_config(config_path=self. config_path)    self. sio = socketio. Client()    self. create_response_functions()  def read_config(self, config_path):    # get config    with open(config_path, 'r') as fr:      config = json. load(fr)    return config  def run(self):    self. sio. connect('http://{}:{}'. format(        self. config['server']['host'],        self. config['server']['port'],      ))    # use sio. wait if no other process keeping the program living    # self. sio. wait()    . . .   def create_response_functions(self):    @self. sio. on('message')    def process_msg_from_server(message):      . . .     @self. sio. on('connect')    def on_connect():      print('CONNECTED')      msg = {        'type': 'SOCKET_INFO',        'text': 'CONNECTED',      }      self. send_msg_to_server(msg)    @self. sio. on('disconnect')    def on_disconnect():      print('DISCONNECTED')  def send_msg_to_server(self, msg):    msg_to_send = {      'sender': 'webgui_client',      'status': 'NORMAL',    }    if isinstance(msg, str):      msg_to_send['text'] = msg    elif isinstance(msg, dict):      msg_to_send. update(msg)    else:      msg_to_send['status'] = 'ERROR'    self. sio. emit(      'message',      msg_to_send,    )a_webgui = WebClient(  config_path=os. path. join(os. path. dirname(__file__), '. . /config. json'))# run is a dead loop if sio. wait() called, so we should call lastlya_webgui. run()原理: MetaPuppetForPython的核心是通过socket双向通信，实现业务逻辑(server)与第三方业务(client)的交互，包括信息的收发以及接口的调用等。所以，在这个框架下，与Wechaty的架构类比，server是Wechaty的TS代码，client是Wechaty调用的各个puppet。MetaPuppetForPython默认包括完全的server和运行Wechaty的client代码，针对其他app(weibo, qq, web, etc. )的client需要自定义。对于想要一个python版本的Wechaty的童鞋来说，默认的代码已经够用。 针对Wechaty而言，server使用python-socketio，client使用socket. io-client，从而建立起双向异步通信。主要的业务逻辑在server端，使用Python控制。在需要调用Wechaty时，使用Python将文本形式的小段ts代码发送给client，client将其编译运行。client端包含少量的ts代码，用于编译来自server的代码，和响应微信的请求(新消息，好友请求等)，一般不需要更改。 基于此原理，可以使用Python调用Wechaty的任意原生代码，所以理论上可以兼容Wechaty的所有协议和接口函数。已实现async_exec_wx_function()用于运行代码块，和async_exec_one_wx_function()用于运行单个函数。 安装: git clone https://github. com/quantumFlame/MetaPuppetForPython. gitcd MetaPuppetForPythonpip install . cd socket_client# install node. js# https://github. com/nodesource/distributions/blob/master/README. md# Using Ubuntucurl -sL https://deb. nodesource. com/setup_13. x | sudo -E bash -sudo apt-get install -y nodejsnpm install -g ts-nodenpm install -g typescript sudo apt-get install autoconfsudo apt-get install libtoolnpm install# or# rm -rf node_modules package-lock. json# npm install wechaty@latest# npm install wechaty-puppet-padplus@next# npm install qrcode-terminal# npm install socket. io-client# npm install @types/socket. io-client# npm install @types/node# npm install other packages if needed. . . 运行: # start client in one terminalcd socket_client# (before you run, you need a wechaty token and# create the config. json file following# the example config. example. json)ts-node src/wechaty_actions. ts# start server in another terminalpython example/hello_word. pyKeys to remember:    Extend RobotBase and modify _process_message() to reply to various wechat messages.     Compile your management tasks as async_foo() and call with run_coroutine_in_new_thread().     If you don’t like async, you can also run the sync version functions in new thread (see more details in example/hello_world. py).   作者: Tom代码: MetaPuppetForPython首发于博客: 用Python写Wechaty程序文本协议: CC BY-NC-SA 3. 0 CN "
    }, {
    "id": 341,
    "url": "https://wechaty.js.org/2020/03/02/wechaty-north-america-umiuni/",
    "title": "wechaty 在UMIUNI北美校友圈中的应用",
    "body": "2020/03/02 - 内容简介:  UmiUni – 北美留学生自己的校园生活圈子 Wechaty在UmiUni的应用 Wechaty 的 技术实现 Umiuni+Wechaty 的将来发展 UmiUni – 北美留学生自己的校园生活圈子: UmiUni 旨在连接留学生群体, 相互帮助, 解决留学生群体 在海外遇到的生活学习等等问题, 依靠中国留学生在海外的校友圈的无形力量,促进整个留学生群体的进步。 主要提供的服务如下：  留学生校园二手闲置买卖,转租房,二手车信息等功能,帮助留学生解决部分生活问题 校园攻略:周边生活娱乐,社团活动,生活讯息,顺风车等等校内论坛内容目标用户：:  美国大学的中国留学生群体 即将出国留学的国内高中生、大学生 走上工作岗位的毕业生应用场景:  新生入学寻找校内及周边公寓信息 暑假回国空置公寓转租 毕业回国闲置家居,家电等物品低价卖给学弟学妹 走上工作岗位的校友借助自身的能力, 为学弟学妹推荐工作的机会 机场与学校之间的顺风车 社团活动参与信息运营情况: UmiUni平台自2017年3月份开始对用户开放，经过半年多的发展，开发完成网页、微信小程序、手机APP三个端口的应 用。目前完全发展三所大学，部分发展达7所大学，累计用户数 超过1. 8万，其中UIUC市场普及率和占有率均超过95%平均日活超过6000次，数据库保有超过1万条校园官方edu邮箱信息尝试并发现多个盈利方式，并在不断挖掘新的稳定盈利点UmiUni是北美知名的校内网小助手，为各个北美学校的校友提供如下服务 Wechaty在UmiUni的应用: Umiuni 目前主要依托于用户登录小程序或app来发布，搜索自己所需的信息，但是目前该产品提供的服务有如下不足：  用户偏爱在微信群中通过发送图片，文字的信息发布租房信息，要在小程序中发布需要重新写作，效率低下 用户希望在特定微信群中收到特定的消息（如二手车群，二手货群等），在app中搜索效率比较低下 用户希望在多个微信群中同时发布消息，逐个发布效率低下因此我们使用Wechaty 的微信机器人用以提升整体效率 上图为umiuni的新架构设计，具体创新点如下：  利用微信机器人帮助用户加入想加入的群组（如某个学校的二手群，租房群等） 用户发布信息后，通过分析自动将发布的信息转换为app内的post，用户无需再次手动输入 用户发布信息后，通过微信机器人发送消息至kafka，由kafka自动推送至特定的多个群组 用户只需输入搜索的信息，微信机器人将搜索消息，自动从UmiUni后台数据中找到用户想要的信息 商家发布新信息时，可以通过kafka将最新资讯转发至各个餐馆群Wechaty+ Umiuni 的技术实现: 我们将使用padplus协议作为微信机器人的底层通讯协议wechaty-puppet-padplus 主要运用的技术：  Kakfa     消息队列收发，将消息发给对应的人群，手机用户的消息用于数据分析    Node. js （feathers. js)     用于快速构建后端服务    Mysql     用作数据前台，存取产品服务的数据，如二手车，二手货信息等    Hadoop HDFS (在建)     用作数据后台，存取用户数据信息    wechaty     用作构建消息来源   wechaty 代码示例: wechaty 部分由于还在搭建，因此仅展示正在运行的部分 用户加群，为用户寻找合适的群组：    const dingRoom = await this. Room. find({ topic: str })   if (dingRoom) { // Room found    log. info('on-message', 'onMessage: got Room:  %s ', await dingRoom. topic())    if (await dingRoom. has(from)) { // speaker is already in room     const topic = await dingRoom. topic()     log. info('on-message', 'onMessage: sender has already in the Room')     await dingRoom. say(`I found you have joined in room  ${topic} !`, from)     await from. say(`no need to send the name again, because you are already in room:  ${topic} `)    } else { // put speaker into room     log. info('on-message', 'onMessage: add sender( %s ) to Room( %s )', from. name(), dingRoom. topic())     await from. say('ok, I will put you in the room!')     await putInRoom(from, dingRoom)    }   } else {    log. info('There is no related groups')    log. info(text)    log. info(from. name())    await from. say('There is no related groups')   }用户加群操作 async function putInRoom (contact: Contact, room: Room) { log. info('on-message', 'putInRoom( %s ,  %s )', contact. name(), await room. topic()) // check the number of memebers in that room const room_members = await room. memberAll() if (room_members. length &lt;= 100) {  // tslint:disable-next-line:no-console  console. log('test') } try {  await room. add(contact)  setTimeout(   _ =&gt; room. say('Welcome ', contact),   10 * 1000,  ) } catch (e) {  log. error('Bot', 'putInRoom() exception: ' + e. stack) }}wechaty 未来发展: 基础features:  群目录: 以分地区划分，先建立校友群 南京:， 香槟: 硅谷:, Maryland:, 群的分法，【校友群，同城群】，类目找工作，内推，跳槽，二手，租房，身份。 自动通过加好友验证，并且发送群目录。 Make post call到python AI的项目。 advanced做法：apache thrift, google protobuff。简单做法：post call。Security features:  验证系统，学校邮箱验证(可以使用北美校内网的edu验证Api)， 【或用户上传学校证明(发学生卡+自拍）()-&gt;人工review queue，】 【怎么验证同城，科技公司邮箱，或者美国工作证明(payement stub) -&gt;人工review queue】 2. 上传的学校证明。 Implement黑名单，记录广告特征。 自动踢人，踢广告功能。(AI batch processing)高级features:  mysql数据库，记录用户session，wechat id，上传的学校证明。 为之后ai，data science发展铺路。 Implement管理员，可以对机器人发出不同指令，可以剔除广告等。（implementation method，管理员群。） Save广告图片，文字，分析识别特征。(AI) 1）BlackList 广告号wechatID; 2) 文字关键词blacklist nodjs chatbot grpc call python service, send chat message to a python for model processing. Service crash, session logout -&gt; send a notification to 管理员群。 校友问答。校友在群中，或者私聊中提问 (e. g. 有没有二手自行车?），1)先搜索北美校内网数据库找匹配 2)搜索网络；有match后查看score。 工友问答。Package details, Layoff news, etc.  作者: SuperCharlesZhu "
    }, {
    "id": 342,
    "url": "https://wechaty.js.org/2020/03/01/wechaty-data-bau/",
    "title": "wechatfordata数据碎片化响应与BAU常规运维的探索实践",
    "body": "2020/03/01 - 新冠疫情爆发于 2020 年2 月，某大型跨国药企业务数据的响应与维护工作随着疫情爆发迅速提升，一时间数据需求方的响应诉求迅速攀升，找到合适的开源解决方案成为目前乃至长期的救命稻草。 wechatfordata 希望解决的问题:  碎片化数据被动查询（已实现） BAU运维监控信息的主动推送（已实现） 按业务场景进行邀请并一定程度的管理微信群（计划实现） 聊天内容的分析(计划实现)业务分析与技术实现（基于已实现部分）:  代码参见：GitHub 基于 wechaty碎片化数据被动查询: 单一业务场景的数据应急需求，通常以碎片形式体现，或是阶段性有规律的需求，所以总结部分高频率、碎片化、有规律的需求，是此部分实现的前提。  比如：~某会议数据是否已推送？~目前推送活动的类型是什么？ 实现方案：构建此类场景的查询关键词规则，入参查询并回复 BAU运维监控信息的主动推送: 目前需要监控的BAU信息分布于两处：  位于内网的关系型数据库中 位于内网的某些web展现层实现方案：请求数据库监控数据，构建nodejs爬虫，爬取web层数据 开发与生产环境: 目前环境均基于windows X64，对安装、部署等要求比较繁琐，且均处于内网，对代理的要求配置也比较讲究。  Tips：npm环境尽量提前安装windows-build-tools@4. 0. 0，内网环境或代理不满足，可尝试离线安装vsbuild2015/2017 结尾: wechatfordata 依然是一个正在开发中的项目, 欢迎留言交流你对它的看法  Author: @KellyCheng 数据工程师，Java工程师,偶尔写写python、Node. js在医疗,医药行业打杂 "
    }, {
    "id": 343,
    "url": "https://wechaty.js.org/2020/03/01/matrix-wechat-bridge/",
    "title": "使用 [Matrix] 收发微信消息",
    "body": "2020/03/01 - 我周围的人都知道我很讨厌微信————臃肿、慢速、开放性低而且还极其费电，于是呢我当然发挥裁剪流氓软件的能力，直接把微信的后台打了个半残，所以我周围的人一直说我微信经常找不到我，那是当然的，微信连后台都没了，能实时找得到我就怪了。 所以用其他聊天软件代收微信消息就显得很重要了，之前我用过 EH Forwarder Bot 将微信的消息转发到 Telegram，用了一段时间之后我发现它比较麻烦，在登录之后所有消息都是被 Bot 账号发送给你，而且如果你想将一个微信群组单独连接，就得自己创建群组，拉入 Bot，然后再选择连接。而且因为微信这个协议连接的问题，经常会出现突然就收不到消息，或者突然掉线的问题，所以后来我就不再使用 EH Forwarder Bot 了。（当然也是由于我那个时候买了第二台手机. . ） 然后今年因为一些原因，我和朋友分别建立了自己的 Matrix 服务器。然后我发现官网上有一个叫做 Bridge 的功能，具体来说就是可以将其他聊天协议上的用户和群组以虚拟用户和 Portal 群组的方式加入 Matrix 中，就如同他们本来就是 Matrix 用户一样。 作为尝试，我先建立了一个 Telegram Bridge 用来连接我的 Telegram 账号，连接倒是成功了，而且也正常收到消息，也可以回复，但是因为我的 Telegram 消息量太大了，造成了我服务器经常性的响应缓慢，后来不得已关闭了 Telegram Bridge。同时，我看到 Bridge 介绍中有一个 Huan 开发的叫做 Wechaty 的 Bridge，而我的微信消息并没有那么多，所以就想要尝试一下。 安装 NodeJS: 其实安装 NodeJS 搜索一下就能找到怎么安装，所以在此就简略啦。我使用一台国内的 VPS 安装 Debian Stable 作为 Wechaty 的运行服务器。避免因为微信异地登录而被封禁。不过由于 Wechaty 最好使用 NodeJS v10，而且因为使用官方源安装之后 Node 有一部分存储于系统的某些固定目录下，有一些 Node 包会调用重编译之类的命令进而引起权限问题导致失败，所以我建议使用 nvm 来安装 NodeJS。安装 NVM 就十分简单了，直接执行 curl -o- https://raw. githubusercontent. com/nvm-sh/nvm/v0. 35. 2/install. sh | bash等待安装好就可以了。 待 NVM 安装完成后输入 nvm install v10. 18. 0完成 NodeJS v10. 18. 0 的安装和配置。 使用 Yarn: 虽然 matrix-appservice-wechaty 的 README 上写着使用 npm install -g matrix-appservice-wechaty 进行安装，但在我安装的过程中，反复遇到在安装 grpc 时执行 node-pre-gyp 失败的问题，经过多方查找发现，使用 Yarn 管理器就可以快速解决这个问题，所以我们先安装 Yarn。 npm install -g yarn然后通过 yarn 安装 matrix-appservice-wechaty，不过注意因为现在版本是在快速更新修复 bug 的状态，所以建议安装 next 版本 yarn global add matrix-appservice-wechaty@next安装所需的 Puppet: 在 matrix-appservice-wechaty 的程序中，我们需要定义一个 Puppet 来指示这个 AppService 使用什么微信后端来进行通信。现在可以选择的后端有 Puppeteer Padplus Macpro Mock Wechat4u 这几种。其中 Puppeteer 和 Wechat4u 基于 Web 协议，Padplus 基于 iPad 微信协议，Macpro 基于 MacOS 微信协议。选择合适的协议后使用下面的命令来安装。 yarn global add wechaty-puppet-后端名 注：后端名为全小写，如 wechaty-puppet-wechat4u注2：某些后端是收费的，请注意查看各后端的部署信息。 目前已知 next 版本的 appservice 在使用 PadPlus 作为后端时需要 next 版本的 PadPlus。 wechaty-puppet-padplus@next 创建配置文件: 先复制 config. sample. yaml 到 config. yaml ，我建议单独为它创建一个文件夹，方便之后将所有的数据文件都放在这一个文件夹里。 domain: chatie. iohomeserverUrl: https://matrix. chatie. ioregistration: wechaty-registration. yaml将示例中的 aka. cn 替换为你的 Matrix Synapse 服务器地址。将 homeserverUrl 替换为你的 Synapse 服务器终结点地址。然后运行命令创建注册文件。 export APP_SERVICE_ENDPOINT='http://localhost:8788'matrix-appservice-wechaty \ --config config. yaml \ --url    $APP_SERVICE_ENDPOINT  \ --generate-registration注意如果你的 Synapse 服务器和 Wechaty 服务器不是同一个服务器则要将 APP_SERVICE_ENDPOINT 的地址设置为 Wechaty 服务器的地址，同时注意防火墙开放端口。  注：如果你的服务器在国内的 VPS 上，请注意备案问题。如果没有备案，Matrix 服务器连接可能会被你的 VPS 服务商阻挡。 上述命令运行后将会生成一个名为 wechaty-registration. yaml 的文件，将它复制到你的 Synapse 服务器上。编辑 Synapse 的 homeserver. yaml 文件，在其中的 app_service_config_files 项内加入 wechaty-registration. yaml 的路径，保存并重启 Synapse 服务器。  注：每次运行 --generate-registration 后都需要重新复制并重启 Synapse 服务器。 开始运行: 一般来说，直接在有 config. yaml 和 wechaty-registration. yaml 运行下面这个命令就可以了。 export WECHATY_PUPPET=wechaty-puppet-后端名matrix-appservice-wechaty \ --config config. yaml \ --file  wechaty-registration. yaml不过要注意，如果你使用 PadPlus 那些需要付费或者 Token 的 Puppet 后端，那么也需要 export 对应的变量，如 export WECHATY_PUPPET_PADPLUS_TOKEN=xxxxxxxxxxxxxxxxxxxxx不过我创建了一个 start. sh 以方便运行  注意： padplus 版本需要额外安装 qrcode-terminal 否则会出现错误。 #!/bin/bash. /home/user/. nvm/nvm. shexport WECHATY_PUPPET=wechaty-puppet-后端名matrix-appservice-wechaty \ --config config. yaml \ --file  wechaty-registration. yaml 注：将 user 更换为你的用户名 chmod +x /path/to/config/start. sh 同时还可以创建一个 systemd 配置来自动启动（如果你的 Wechaty 和 Synapse 不在同一个服务器则不要加 After 那行） [Unit]Description=Matrix Bridge WechatyAfter=matrix-synapse. service[Service]Type=simpleWorkingDirectory=/path/to/config/ExecStart=/path/to/config/start. shRestart=on-abort[Install]WantedBy=multi-user. target执行 systemctl daemon-reload。 之后就可以使用 systemctl enable 命令和 systemctl start 命令来启动 Wechaty Matrix Bridge 了。仅建议在调试完成，可以成功运行的情况下使用 systemctl 启动。 Let’s Go！: 来到你的 Matrix 客户端上，对 @wechaty:你的服务器 发起 私聊 ，等待 Bot 加入后它应该会提示 This room has been registered as your bridge management/status room. 看到这条提示后输入 !login，首次使用时 Bot 应该会提示 You are not enable matrix-appservice-wechaty yet. 之后会立刻提示 I had enabled it for you. 这时，Wechaty 就正式注册为 AppService 了。 再次发送 !login 后，如果你没有安装你指定的 puppet，PuppetManager 会自动进行安装，稍等即可。如果安装过于缓慢，可以考虑按 Ctrl + C 终止程序，然后自己用 yarn 手动安装后再启动。 当 puppet 成功启动后，Matrix 端会生成一个二维码的链接，打开并扫描二维码就可以完成登录了。 关于登出: 给 wechaty 机器人发送 !logout 就行啦！  注意：截至到目前 latest 版本 (0. 6. 3) 没有这个命令，需要 next 版本 (0. 7. 2) Matrix-AppService-Wechaty: 这个通讯桥目前是一个刚开始开发没有多长时间的状态，只能解决基础的消息互通问题，如果遇到对方发送的是链接消息的情况，Matrix 这边会显示一个超长的 xml 结构，期待之后版本更新能带来更多的功能！ 同时借助 Wechaty-Puppet-PadPlus ，那些无法使用 Web 版微信的用户可以使用 iPad 协议来进行连接。因为我刚刚完成部署，所以稳定性我还不是非常清楚，不过因为这个协议是通过客户端级协议完成的，目测会稳定一些。 非常感谢 huan 开发的 Wechaty，让微信桥接和微信机器人有更多可能！ 同时我也推荐一下他开发的 Docker-Wechat ，用 Docker 解决了使用 Linux 微信比较麻烦的问题。想了想我用 CrossOver 安装微信，然后用起来还有一堆的 bug 就感觉这个真的非常好。  作者: 立音，个人开发者。首发于博客: 使用 Matrix 接收微信消息 遵循 CC BY-NC-SA 3. 0 CN "
    }, {
    "id": 344,
    "url": "https://wechaty.js.org/2020/02/08/wechaty-new-release-version-0.30/",
    "title": "Wechaty New Release Version v0.30: Lots of New Features!",
    "body": "2020/02/08 - Wechaty v0. 30 Released! We have lots of new features added and bugs fixed! Change Log: v0. 30 (2020-02-08): Full Changelog Implemented enhancements:  Support room. sayhi ${contact} ${num++} #1899 Support new event named “message” on Room #1897 Support search new friends by phone number or user name. #1892 {Room,Contact}. qrcode() should return QR Code Value instead of Image #1889 Implmented UrlLink. create(url) with Open Graph support #1887 主动撤回消息 #1885 Implement Label in Wechaty #1856 Would like to have the timestamp on the room/friendship events #1829 Would like to have receiver, serialize and deserialize functions on RoomInvitation #1823 Wechaty v0. 26 iosBird Testing, an iOS hook puppet implementation! #1775 Missing example code #1756 BREAKING CHANGE v0. 25 Room. say(text: string, mention: Contact[]) deprecated #1730 New Puppet: Ioscat (iPhone Wechat App Hook) #1528Fixed bugs:  bot. logonoff()报错【static puppet not found for Wechaty】 #1878 JSDoc publishing problem: missed the Room class #1872 Wechaty can not get room info when the bot has been removed from one room. #1834 bot. Contact. find() error message misleading #1812 机器人会隔一段时间自动退出 #1810Closed issues:  Use docker to run, QR code address prompt “unrecognized QR code” #1905 room. announce()中当参数为空字符串时, 调用获取群公告而不是设置群公告为空 #1902 启动官方学习项目报错 #1898 延期通过好友 #1890 I want wechaty puppet padpro token to create a wechat bot #1882 msg. mentionSelf()方法不对，始终返回false #1877 需要取到Contactid或者微信号 #1873 Function message toContact\(\) should to be implemented. #1855 install error #1853 wechaty-puppet can not install in electron #1851 wechaty-puppet-macpro alpha test #1846 Action required: Greenkeeper could not be activated 🚨 #1781 登陆二维码无法识别 #1753 经常报以下warning #1634 Doesn’t work with UK Android account/device #1556Merged pull requests:  fix: wechaty-puppet-dll temporary unavailable #1908 (kis87988) docs: improve ding-dong-bot example #1904 (rikakomoe) Add reason for logout event #1900 (su-chang) Friend search #1895 (su-chang) Delay friendship #1891 (SilentQianyi) Create url link #1888 (huan) Recall msg #1886 (SilentQianyi) Change Mini Program payload in wechaty #1883 (su-chang) Update README. md #1876 (lijiarui) add kaiyuanshe bot #1875 (lijiarui) chore(package): update @types/node to version 12. 12. 3 #1870 (huan) Implement toContact() method #1868 (su-chang) feat: change say() method response type from void to Message #1866 (su-chang) Implement Label related methods #1864 (su-chang) Update contact. ts #1861 (su-chang) fix opencollective Sponsors style #1859 (lijiarui) fix typo #1854 (LanceZhu) Update wechaty. ts #1833 (su-chang)"
    }, {
    "id": 345,
    "url": "https://wechaty.js.org/2019/12/23/wechaty-north-america-ricepo/",
    "title": "RICEPO北美地道中餐外卖",
    "body": "2019/12/23 - 内容纲要:  RICEPO简介 Wechaty在RICEPO的应用 Wechaty+SQS整体架构 Wechaty使用遇到问题以及解决方案 RICEPO简介: RICEPO​是海外最大的地道中餐订餐平台。2013年于纽约创立，总部位于加州硅谷，现已覆盖全美及欧洲等200多个城市。合作的饭店已多达上千家，服务近10,000,000人次。RICEPO ​​​​还是Apple Pay、银联、微信、支付宝的战略合作伙伴。RICEPO 用心连接地道中餐和喜爱中餐的用户，为创造最佳的用户体验而奋斗。在专注传统中餐的同时，RICEPO 同时也在致力于让世界更加了解中国。 Wechaty在RICEPO的应用: 用户在RICEPO下单后系统需要发送给饭店确认订单。在接入Wechaty前我们一直在寻找最高效、便捷、稳定的方式发送订单。北美饭店主流接受订单的方式都存在各种问题：  传真：速度慢，经常断开链接 Email：饭店查收不及时，耽误订单确认 电话语音：语音播报易出错，效率低 使用饭店端APP：对饭店有学习成本（部分饭店老板不会使用APP） 商米小票机：设备成本高Wechaty可以几乎完美解决以上所有问题，我们以文字+链接形式实时发送订单给餐馆老板，点击链接可以查看订单详情，并一键确认订单。上线wechaty发单后，80%饭店开始转用微信接单。  实时发送订单信息，速度快 几乎所有中餐馆老板都有微信，接受度高，没有下载新app的学习成本 老板查看微信频次高，不容易错过订单 无需打印，无需设备，使用成本低文字+链接发送实时订单 查看订单详情，一键确认 除此之外，Wechaty还可以实现饭店公告的功能。例如APP新功能，节假日营业时间变更，RICEPO都已开始大范围使用Wechaty来通知餐馆。 Wechaty+SQS整体架构: RICEPO的wechaty使用的是wechaty-puppet-padplus 主要运用的技术：  Docker     Docker化部署    mongodb     用于持久化登陆信息，以便Docker重启之后无需再次扫码登陆    SQS     aws的消息队列服务，wechaty从这里获取消息发送给对应的人(群)    slack     用作登陆提醒。   若未登陆，会将登陆二维码发送至对应的channel   若扫码登陆成功，发送一条登陆成功的消息至对应的channel    Wechaty使用遇到问题以及解决方案:  群丢失     发生原因：微信临时群组不保存的话，docker重启之后会丢失这些群组   解决方案：         挂载缓存目录到docker宿主机 -v ~/. wechaty:/root/. wechaty     每天早上给每个bot下面的所有群组发送早安信息（消息间隔时间2S,避免过于频繁的消息发送），最大限度地保证有较多的群组缓存下来          总结与未来发展: 基于Wechaty的自动发单系统，给平台的订单确认效率得到非常大的提升。饭店群公告功能也节省了大量客服与餐馆沟通成本，下一步我们将着手开始实现更多功能，包括自动机器应答，自动事件提醒等，都能再次提高各部门效率。感谢Wechaty给我们带来的变革。期待在未来看到在RICEPO平台更多的应用场景。  作者: RICEPO LLC "
    }, {
    "id": 346,
    "url": "https://wechaty.js.org/2019/12/20/microsoft-ai-global-training-camp-ends-in-beijing/",
    "title": "年末最硬核！微软AI全球训练营北京站落幕",
    "body": "2019/12/20 - Global AI Bootcamp是微软发起的全球AI开发者训练营活动，旨在凝聚全球的开发者共同学习交流，共同推进人工智能行业快速发展。在2019年12月14日同一天内，全球几十个国家，130个城市，上万人共同参与了这场AI人的狂欢盛会。当日18点30分，AI Bootcamp北京站也在宇宙中心五道口PNP创业孵化器内如期开幕，近百名中国AI开发者参与活动，聆听八位业内专家倾囊分享。  Global AI Bootcamp: https://globalai. community/global-ai-bootcamp Global AI Bootcamp Beijing: https://globalai. community/global-ai-bootcamp/china-beijing 本次北京站Microsoft AI Bootcamp是由三位微软AI MVP共同发起与组织，三位分别是:  Microsoft Regional Director, Microsoft AI MVP, Pre-Angel 合伙人李卓桓 Microsoft Data&amp;AI 解决方案架构师, 前 Microsoft MVP 陈堰平 Microsoft AI MVP, 句子互动创始人&amp;CEO 李佳芮。 现场共有八位来自不同AI领域的嘉宾进行了分享，主题内容涵盖了从基础层到应用层的方方面面，因为分享内容过于精彩，多位嘉宾超时分享，小编在文章最后献上了活动全程直播视频回放，足足5小时，没来现场的开发者们可以远程学习了。 活动签到: Wish you were here.  1. 主办方致辞: 微软AI MVP 2. 上半场嘉宾分享:  微软软件架构师 丁煜恒 Chatopera 王海良 兰州大学博士 武强 VMware软件工程师 张一赫 3. 下半场嘉宾分享:  Azure AI资深产品经理 张璐 前小米算法专家 郭成凯 句子互动创始人 李佳芮 微软Data&amp;AI架构师 陈堰平 4. 开发者互动提问: 现场讨论相当热烈，十几位开发者提出了自己的问题，与嘉宾进行互动，并获得了微软礼品。坚持听讲到最后的童鞋还获得了微软Azure Pass。 经过五个小时的分享与讨论，活动在大家高喊“AI MVP”的声音中落下帷幕。 本次活动由Microsoft MVP &amp; DataFun &amp; Plug and Play &amp; Pre-Angel &amp; 句子互动全程落地支持。 微软MVP项目介绍: 微软最有价值专家Microsoft Most Valuable Professional（MVP）是微软公司授予第三方技术专业人士的一个全球奖项。27年来，世界各地的技术社区领导者，因在线上和线下的技术社区中分享专业知识和经验而获得此奖项。 MVP是经过严格挑选的专家团队，他们代表着技术最精湛且最具智慧的人，对社区投入极大的热情并乐于助人的专家。MVP致力于通过讲课、论坛、网站、俱乐部以及自己所创建的网站和博客来帮助他人，并最大程度地帮助微软技术社区用户使用Microsoft技术。MVP申请请联系：ChinaMVP@Microsoft. com。 DataFun介绍: DataFun专注大数据、人工智能技术在工业界落地经验分享，发起于2017. 12，至今已在全国7个数据智能企业和人才集中的城市举办了100多场线下技术分享和两场千人规模的行业峰会，邀请近400位工业界专家和40位知名学者参与分享，近30000人次从业者参与线下交流。合作企业包含BAT等大厂，以及知名互联网公司和数据智能创业公司。其运营的公众号DataFunTalk共生产原创文章300+篇，近百万阅读，4万+精准粉丝。 Plug and Play孵化器介绍: Plug and Play 前身始于1998年，投资和孵化了谷歌等互联网巨头。2006年在硅谷由伊朗家族企业Amidi Group创立，现已发展成为美国TOP 10的企业加速器，专注于对科技类创业企业的孵化投资，在美国硅谷、德国、俄罗斯、新加坡及西班牙等地均设有分支机构。Plug&amp;Play创始人曾经投出过PayPal、Dropbox、LendingClub等现象级公司，谷歌、罗技也曾从他旗下的办公楼走出。 2015 年，PNP 来到中国，目前已经在北京、上海、深圳、苏州、杭州、重庆、西安、郑州等创新腹地设有加速器。PNP 中国已累计投资、孵化超过 300 家中国创业公司，有超过 200 家创业公司进入到“PNP 独角兽加速计划”进行加速，我们与全国各中心城市及双创示范中心城市深度合作构建产业创新加速平台，此外，我们从美国硅谷、德国、俄罗斯以及 Plug and Play 在全球其他国家的加速器引进了超过 100 个科技项目进入中国市场。 作为全球无与伦比的创新生态平台，Plug and Play 中国致力于连接大企业与优质的创新项目，让硅谷的资源惠及全世界各个角落，让创新无处不在。 PreAngel 介绍: PreAngel是一支专注于人工智能技术创业项目的天使基金，核心价值是提供“职业联合创始人”服务，参与创始 300+ 中美初创企业。它借助自身在人工智能产业领域的深刻的认识和资源积累，投资与早期创业团队并且帮助他们成长。PreAngel使命是在人工智能领域帮助有理想的创业者实现更大的社会价值。网址：https://pre-angel. com。 句子互动介绍: 句子互动是国内领先的智能对话服务商，专注于将智能对话落地到微信等社交生态，设计专业的对话系统对接流程，将业务场景梳理、数据收集、对话脚本撰写、系统搭建、评估反馈等进行标准化，帮助企业搭建符合真实业务场景的对话机器人。 句子互动的自研SaaS产品句子秒回，为企业赋能，大幅度增强其获客、用户粘性和销售转化的能力。客户来自教育、保险、旅游等多个领域，包括好未来、中国人寿、皇包车旅行、美团点评等，产品服务客户规模覆盖年销售额 100 万至 10 亿。其中 80% 的客户来自口碑传播，每天提升 100 万人次的销售体验。产品免费体验链接：wechat. botorange. com，扫码联系客服获取更多资料。 彩蛋: 附最后的彩蛋，北京站直播视频回放地址，各位童鞋认真学习起来吧！  附录： 国内用户，B站地址 "
    }, {
    "id": 347,
    "url": "https://wechaty.js.org/2019/10/18/wechaty-pku-lecture/",
    "title": "Wechaty 走进北大开源实验班",
    "body": "2019/10/18 - 内容纲要:  Wechaty整体架构 Wechaty开源社区治理 Wechaty社区生态治理 Wechaty应用案例分享 2019. 10. 18，受北京大学软件与微电子学院张齐勋老师邀请，经华为云庄表伟的介绍，我代表Wechaty开源项目，给来自北大软院实验班的120多位同学，完整系统地介绍了Wechaty项目，并分享了Wechaty应用案例-毛豆课堂小助手。 这一批学生大部分都是95年之后才出生，他们的成长阶段，本身就是Linux开源文化通过互联网传入中国，到萌芽传播再到发展壮大，最后做出我们自己的开源项目的一个历史过程。 下面，我来重点介绍一下在讲座分享中比较有亮点的几张PPT。 Wechaty整体架构: Wechaty是一个典型的三层架构，最上层提供接口，中间层进行抽象，最下层对接各种不同的实现，这和Linux的系统调用层，fs文件系统层，driver层的逻辑和理念很接近，这样对上层的应用可以尽量保持接口一致和稳定性，便于构建各种chatbot实现；对下层可以接入不同的微信通信协议，例如puppeteer对应微信web协议，padpro对应微信pad协议。 Wechaty开源社区治理: Wechaty的开源社区，同样遵循了众多开源社区的组织形式，包括了PMC（社区管理团队），CDG（社区开发者群体），OC（组织者委员会）。其中人数最多的是开发者群体，按照对项目的贡献程度和话语权，从高到低分为了4个等级：维护者Maintainer，代码提交者Commiter，代码贡献者Contributor，社区成员Community Member。大部分参与项目贡献代码的开发者，都是通过fork-pr-merge的流程来对项目作出自己的贡献。 。 Wechaty社区生态治理: 社区不是只有线上的代码提交，还包括每周五的Bot Friday线下活动。每次活动的人数大概在10-20左右，小规模的参会人数确保了大部分的人都能有发言和输出的机会，这也体现了社区管理者更重视质量而不是数量的治理理念。 。 下面是一系列的数字，对Wechaty项目做一个总结！ Wechaty应用案例分享: 毛豆课堂项目是为少儿教育机构和老师提供一个全线上可实时互动的教学平台，借助AI人工智能进行教学辅助和学习反馈，并通过课程智能推荐引擎为家长提供最可信赖和适合孩子的课程。在这个项目中，有一个部分是帮助老师进行创建课程提醒的微信机器人，就是毛豆课堂小助手。 通过自然语言给毛豆课堂小助手发一条消息，就可以自动提取出其中的时间、地点和主题，帮助老师创建课程提醒，并给老师推送相关课程小程序。基本流程如下图所示： 。 这个项目的代码，目前就在 Wechaty Examples 里面，如果对此有兴趣也欢迎和我联系。（加我微信号 limingth） 推荐阅读和这个项目有关的三篇博客：    实现支持微信小程序的聊天机器人     The Bad Part of My Chatbot Experience     如何用 padpro 发送微信小程序  致谢:    lijiarui 的PPT。这次讲座所用的ppt，绝大部分来自于李佳芮的贡献。如果不是那么精美的Slides已经完美总结了项目的方方面面，我很难有勇气走上讲台去做这个lecture。     感谢北大张齐勋老师提供这么好的一个机会，能够让我们给新一代的大学生研究生来介绍来自开源社区的最新进展。会后有100多位同学加入了Wechaty-北大开源技术交流群，这一批新鲜血液相信会让Wechaty项目焕发出新的生机！   作者: limingth 毛豆网 "
    }, {
    "id": 348,
    "url": "https://wechaty.js.org/2019/08/31/wechaty-wwdc-in-silicon-valley/",
    "title": "Frist WWDC in Silicon Valley",
    "body": "2019/08/31 - 第一次的 WWDC in Silicon Valley: 首先，Wechaty對我來說是非常意義重大的一個Open sources Project, 也是我第一個在GitHub做Contributor的Project。 Being a software engineer, it is my pleasure to join this project and event. 做為一個Wechaty Platform的使用者跟貢獻者，Wechaty讓我們的生活更簡單我一開始的目標是希望可以建立一個群幫助Silicon valley的De Anza College學生，但是由於Wechat的100人QR Code限制，導致我需要使用人工的方式拉群，這是非常麻煩的，所以我開始尋找可以輕鬆簡單用非人工的方式，嘗試了很多類似的Project，Wechaty就是唯一最好用最Powerful並且擴展性高的Wechat工具了。我認為Wechaty之所以會這麼Powerful是因為有各路願意貢獻的偉大貢獻者們，才可以做出這麼優秀的Open source project，個人我也希望可以從各位Contributor身上學到更多技能也希望可以互相幫助。 這篇文章因為是由有拖延症的我編寫，導致延遲了接近一年，深感抱歉，現在讓我們來坐坐時光機回去吧 讓我們回到2018年前的11月7日，在Chatie開源創始人的李董人來訪美國時，發生了神奇的事 Guess what! Something happened. 對的！就是 Chatie WWDC in Silicon Valley!! 對於小弟我，第一次參加這種盛大的宴會也是我第一次見到李董本人，我們之前都是網友，我曾經以為他就是個機器人，這種想見面的心情又緊張又期待，當天我連要穿什麼都不知道，到底是要穿西裝打領帶，還是要穿蘇格蘭裙呢？翻翻李董朋友圈的照片穿著，我還是決定效法一波程序猿正常的穿著打扮，就是一個Tshirt配個牛仔褲去參加拉～ 因為有選擇困難症的我們，實在不知道要辦在哪，然而李董貌似又想要在有朝一日進Google當實習生。所以當然要去參觀一下Google大本營，巧合之下，我們有另外一位靠普的周載南小伙伴在Google工作，帶著我們參觀了Google內部及辦公室的美食 對了，忘了介紹了一下參加者名單，讓我們來介紹一下吧！ 裝{}組織名單如下：  李卓桓外號李機器人、李董、Microsoft AI MVP &amp; Regional Director，不需要過多介紹一下，就是我們這次活動的大領導，無人不知無人不曉的Chatie product owner，可能是未來”Google AI interner”。 周載南Google程序猿，我們這次活動的靠普場地提供者，好室友(www. haoshiyou. org)項目的Product owner，這次也Share給我們很多有趣的Business ideas。 任晶磊YC創投參加者之一，正在創立Code Contribution scale system(關於開源社區的福利項目之一)，對於正在創立的System非常有任情也跟我們解說如何做Coding analysis。 林思奇李董的學妹，現在在Silicon valley的某間創投公司工作，非常有能力。 William(威廉)時常幫忙端茶倒水的程序猿，當時無夜遊名，現在是打工仔。我們是一群擁有純樸又愛喝奶茶的心，而聚在一起。當我們聚在一起聊的東西天南地北的，但事實則無題。 在Google聊了很多有關於未來Chatie的應用及發展，還有很多未來的Software開源社區創建以及管理，我們大家也對晶磊正在做的東西非常有興趣，想要知道未來要怎麼量化Code才不會讓開源社區的Contributor的貢獻變成Pointless。當然我們也希望我們的李董及林思奇未來在創業方面可以給我們一盞資金的明燈，讓我們可以沒有後顧之憂的寫代碼，這會是我們非常嚮往的生活。 其間我們還聊到了如何給各大有名的trending open souorces做Contribution，這是一個非常有趣的奇妙思想，如有興趣請參詳李董，他會告訴你他是如何貢獻給Tensowflow repo的，並且載南也實踐過但是不如卓桓哥而裝{}失敗了。 就在我們天花亂墜的跳躍聊天後，當然免不了要來張大合照拉！這時候我們的Googler發生了一件非常可愛的事情，他不知道自己家的手機產品可以語音自動Take Selfie讓我們非常極度懷疑他是個假的Googler，但是鑑於他有個工作牌還是勉強相信了他，有圖有真相！ 這個時光之旅也到了一個段落了，讓我們回到現實吧！ 這次的WWDC之旅，是個非常有趣的體驗。歡迎大家以後多參加Chatie的活動，這樣可以讓這個Repo更好更健壯，並且大家都有交流也有更多的Idea來貢獻給開源社區。 再次謝謝李董給我這個機會給我寫這個拖延已久的Blog、也謝謝載南哥Host我們參觀Google MountainVview office。 讓我們繼續期待未來的下一次聚會，相信會非常非常的快的  Author: @kis87988 William Chen, Software Engineer "
    }, {
    "id": 349,
    "url": "https://wechaty.js.org/2019/08/12/dotnet-club-use-wechaty-to-collect-valuable-wechat-threads/",
    "title": "dotnet club 借助 Wechaty 沉淀深度技术对话",
    "body": "2019/08/12 - 与一个领域里的专家大牛对话，常有醍醐灌顶之感。有的疑问在我们脑子里徘徊良久不能获得解答，有时是一阵子，有时一留就是数年之久。如同武侠世界里的神童，多年来参悟某个秘籍时不得要领，数年没有长进。如果在某个良辰吉日里，你在一处不起眼的街角路遇高手，正好切中要害一语中的地帮你解答疑问，你茅塞顿开、武功大为精进，从此步入武林高手行列，这将是何等幸事？ 幸而在互联网高度发达、信息传播充分高效的今天，通常当我们在技术上遇到问题时，不再需要花费数年之久来参悟。一般来说，现实压力也通常不会允许要花这么久，不然我们连 996 的福报也没有资格享受了。所以，人们通常从搜索引擎上查找已经遇到过类似问题的人所发布的讨论和分享，从开源网站上参考其他人的示例方法，大部分的问题也就能够快速得到解答了。另一方面说，这几乎足以说明不少技术人员的工作内容都是相同、至少是类似的。 如果在搜索引擎上找不到现成的分享，这时就要考虑以某种其他方式来获得解答了。比如，去一些问答网站上发贴求救，或者去一些在线群聊里讨论。一般来说，如果说的不够清楚，就会被管理员一顿批评，大意是“哪里来的菜鸟，问题都不会提！”，或者“扯那么多废话干嘛，先上代码！”如果确实是遇到了群组和社区大佬亲临指点，我们基本上就愉快地忍了，然后速速地按照指点把代码呈上一份、听候进一步的指点。 如果这是一个没有出现过的问题，就会引发大家的围观和讨论，最后问题在讨论中被淹没或者解决。如果这个问题经常出现、太初级，就会被大佬和大家鄙视一番，并被要求回去看书。这时，情况就有点尴尬了。毕竟，我怎么知道该去看哪本书，哪部分？而且，本来这个问题就是在线等的很着急，这会儿我还等着下班呢…… 如果时光能倒流: 如果这时，人群里冒出来一位善良的姑娘，她打破尴尬给你指出，刚好在三天之前群里还讨论过这个问题，或者给你发来一个独家整理的笔记和总结，你是不是恨不能穿过网线去看她？（然而，人家并不想理你） 那么，问题就来了：我怎么知道前两天讨论过…… 所谓大隐隐于市，高手在民间。在日常互联网上，很多即兴对话里蕴含着很多知识，他们当时给围观者带来了帮助，却又很快消失在人们眼中。当不断再度有人谈到时，高手们不再有耐心来解答，低手们也就不再能够获得解答了。他们又绝望地回到了搜索引擎上……无意中有的人却搜到了这个： 情何以堪！ Wechaty 成就 dotnet club 时光机: 这时，聪明的我在想，大佬们分享的时候，大家都爽，可惜就是像上面这种做笔记的好人太少，而对于日以继夜的大佬们来说，这点小事更是不会上心。如果有一种工具能帮我们把微信群里大佬们的精辟对话导出来，放到某个地方供后人瞻仰、查阅，岂不美哉？ 是的，作为关注 . NET Core 的技术社区，dotnet club 就开发了 club-chaty 这样一款工具：它可以将微信群里发生的对话批量导出为 JSON 格式，然后再导入到 dotnet club 网站上，供他人公开查阅这些对话。它的使用步骤是：  用户添加网站的客服号为好友，在网站上完成账号的映射绑定 用户把自己想收藏的对话，“多选”之后合并转发给客服号 待客户号完成对话转换后，由用户选择把已经转换的对话导入到网站上整体流程如下图： 其中最为关键的就是右上角的“Wechaty 自动转换客服” club-chaty 项目，它能将收到的微信“消息记录”类型的消息导出为 JSON 格式，同时解析并下载其中包含的多媒体消息，包括链接、文件和图片视频等。 之所以它能将微信消息提取到微信之外，这得益于微信消息解析 SDK。club-chaty 开发之初，在选用微信 SDK 的时候，发现社区中的微信 SDK 很多，琳琅满目到处都是，一时之间，难分伯仲。然而，club-chaty 要求能够解析“消息记录”类型的消息，这一硬性要求很快便将绝大多数 SDK 排除在外了。只有 Wechaty 才能完美地提供这些功能。 Wechaty 是由句子互动发布的开源微信 SDK，它直接为微信个人账号赋予编程接口，将个人账号变成自动化应答程序。最重要的是，它能以结构化的方式解析“消息记录”类型的消息。除了解析消息本身，Wechaty 还提供相关的 API 可以下载消息中包含的多媒体内容。这些功能都完美地满足了 club-chaty 的需求。 时不我待，club-chaty 很快就开始了基于 Wechaty 的开发，并在 dotnet club 主站中集成了相关的对话导入流程。作为 dotnet club 网站的一部分，club-chaty 并没有独立地提供线上的网站服务。不过它作为一个软件项目，它的代码与 dotnet club 主站的开发是相互独立的，因此可以单独使用这部分代码。 club-chaty 如何防止隐私泄漏: 随着了解 club-chaty 这项功能的人越来越多，逐渐有人关注到它可能带来隐私泄露的风险。比如，张三正跟李四在微信里聊起了他对哪个姑娘刚刚萌生的情愫之后，李四改天就用 club-chaty 这款神器把张三的想法公之于众，页面上还有张三的头像和名字，这还得了。鉴于这种考量，dotnet club 在使用由 club-chaty 导入的数据时，会对对话的内容进行一系列“脱敏”处理。比如，隐去微信对话参与者的原始昵称和头像，换用随机生成的昵称和对话；必须由实名制账号导入对话，并接受原对话参与者的认领和删除等。 在 club-chaty 这种智能导入工具之前，人们如果要留存聊天记录，就需要一张张截图，并利用一些拼图软件将多张图拼到一起作为一个整体进行保存了。相信大家都以这种方式吃过不少大瓜，吃的时候很过瘾，但要么是事后再也找不到了，要么是被吃瓜的当事人信息被泄漏。 而用 club-chaty 导入的聊天记录与截图相比，有诸多好处和优势：  整个过程操作顺畅、便利 导出的结果是文本、链接和单张图片等可以二次整理的素材 导入的结果保存在互联网或笔记软件之后，可以公开查阅和搜索 可以更好地保护和管理对话参与者的隐私写在最后: 作为例子，可以来看看导入后的最终效果：https://dotnetclub. net/topics/61 综合来看，基于 Wechaty 实现的 club-chaty 提供的这项功能十分实用，能对具备收藏价值和传播价值的对话内容进行导出、再发布和持久利用，以便解决文章开头的困惑。另一方面，如果某位大牛的发言广为传播，使很多人受益，那么他难道不应该因此收到应有的肯定和赞赏吗？由于 club-chaty 导出的数据中包含原始的发言人账号信息，因此只要使用单向哈希等方式，便可以在保护隐私的同时还能够保留必要的信息以便支持进一步的互动。  作者: @jijiechen dotnet club 技术社区负责人。  原文地址 "
    }, {
    "id": 350,
    "url": "https://wechaty.js.org/2019/07/26/bot-friday-second/",
    "title": "Bot Friday 第二弹",
    "body": "2019/07/26 - « 本次活动通知: 腾讯+句子互动第二弹，Chatbot Friday « Bot Friday Second - 沙龙第二弹:  时间：2019年7月26日（周五）18:30 - 22:30（4小时） 地点：腾讯公司北京办公室，理想国际大厦17层 赞助方：腾讯公司第二期沙龙参与成员:  分享嘉宾         李明，毛豆网创始人CEO，清华大学计算机硕士。曾于2003年创立嵌入式操作系统培训公司亚嵌科技。毛豆网致力于为内容创业者提供技术支持服务，关注Chatbot和微信小程序的结合与互动，并在微信群中基于NLP技术为用户提供流畅体验。已获清华XLab/DNA基金数百万天使投资。           邝伟鹏，积致科技创始人CEO，巴黎笛卡尔大学硕士。全栈工程师，曾任智能客服Udesk交互架构师，并独立完成类Google doc的实时文档编辑应用以及可视化拖拽开发App应用平台开发宝。积致科技致力于基于微信社交生态，以 Chatbot 的交互方式为用户提供人脸识别应用（FindMyFace及脸盲助手）。已获PreAngel种子投资。        腾讯公司     宋俊，腾讯智能对话平台研发工程师   刘晓倩，腾讯智能对话平台产品经理    Chatbot行业     段清华，金证优智技术总监。曾任文因互联研发工程师，完成项目包括金融搜索，公告摘要抽取项目，银行问答机器人。拥有多年金融NLP经验，带领团队完成问答机器人、投研系统、监管舆情、知识图谱等项目。对金融文档解析、抽取、搜索、量化分析、知识图谱建设、对话系统等领域有深入研究。   雷飏，北京安络技术有限公司，董事长，公司业务主要是AI安防，会涉及到楼宇可视对讲门禁的通讯、交互。   李云军，圈动无界创始人CEO。资深互联网从业者，历任方正、金山安全产品总监、高级技术总监。拥有2个智能排版算法专利。公司曾获英诺天使千万级投资。公司主打团队协作产品Teamin，结合自然语言处理及人工智能，为新型社交协作人群提供更智能的助理服务。   李佳芮，句子互动创始人。句子互动创建了覆盖全球的微信聊天机器人开发者社区，公司围绕微信生态为客户提供智能对话服务。客户覆盖教育、保险等多个领域。曾入选百度AI加速器，并由PreAngel、Plug and Play和Y Combination孵化支持，已获TSVC/Alpha公社联合千万RMB级别天使投资；   高原，句子互动CTO，先后在 Expedia, Amazon 做研发工程师，后回国创立句子互动。   赵俊良，毛豆网客服总监，北京交通大学硕士，曾任北京联合大学信息学院讲师，拥有十余年嵌入式系统研发经历和智能仪器测控领域的创业经历；   李卓桓，Github 6000 Star 的微信个人号SDK开源项目 Wechaty 作者，Conversational AI 布道者。曾任水木清华BBS站长，优酷网首席科学家。清华本科，中欧EMBA，北邮博士在读。   主题分享: 1. Talk 1 - The Bad Part of My Chatbot Experience: 1. 1 分享嘉宾: 李明 @limingth 毛豆网创始人CEO，清华大学计算机硕士。曾与2003年创立嵌入式操作系统培训公司亚嵌科技。毛豆网致力于为内容创业者提供技术支持服务，关注Chatbot和微信小程序的结合与互动，并在微信群中基于NLP技术为用户提供流畅体验。已获清华XLab/DNA基金数百万天使投资； 1. 2 内容大纲: NLP技术到底哪家强？  需求背景     时间，主题，地点识别问题    AI开放平台调研     讯飞   百度   腾讯   阿里    实际使用的库和效果     @microsoft/recognizers   BosonNLP NER   chi-time-nlp    开放问题讨论     有没有NER一站式解决方案？   Wechaty面临的挑战和机会   BotHub之畅想   1. 3 Slides:  2. Talk2 - 脸盲助手-基于微信社交的Chatbot人脸识别应用探索: 2. 1 分享嘉宾: 邝伟鹏 @creatorkuang 积致科技创始人CEO，巴黎笛卡尔大学硕士。全栈工程师，曾任智能客服Udesk交互架构师，并独立完成类Google doc的实时文档编辑应用以及可视化拖拽开发App应用平台开发宝。积致科技致力于基于微信社交生态，以 Chatbot 的交互方式为用户提供人脸识别应用（FindMyFace及脸盲助手）。已获PreAngel种子投资。 2. 2 内容大纲:  用户场景 Chatbot解决方案 未来可能性探索 产品Demo2. 3 Slides:  3. 分享视频回顾:    Your browser does not support the video tag.   感谢毛豆网提供价值4000元的本次活动视频直播赞助！ 吐槽大会:  李卓桓     活动应该守时，时间一到，不等任何人立即开始，优先满足活动现场人的用户体验。    李明     借助直播扩散影响力，能产出高质量对话。    邝伟鹏     每次活动主题应该更加明确。    李云军     协会应该制定系列内容，聚焦主题。    段清华     应该让算法的人接触更多的实际需求。    雷飚     分享应该带有成功案例，而不是探索性的分享。    李佳芮     制定未来的至少4次分享的主题内容。    高原     未来活动更多后，为活动打标签做区分。    刘晓倩     倾向于圆桌会议形式举办活动。    俊良     脑洞了一个“吐槽机器人”。   Bot Friday 决议:  平台主席 Bot Friday 推选了首位平台主席为会员提供巨头 Chatbot 平台的行业指导，平台主席为期1年，恭喜Bot Friday的首位平台主席: 刘晓倩。 俱乐部名称 在活动现场，11个人中10个人赞成每周五举办Chatbot活动，因此俱乐部名称暂定为：Bot Friday Club，简称 BFC。 轮值主席制度     每次活动后按照先自愿 + 主席指定原则，选出下次活动的轮值副主席。   本次活动的轮值副主席自动成为下次活动的轮值主席。    会员制度 Bot Friday 会员制度：只有在沙龙上分享过的人才能成为会员。参加沙龙活动的每一个人，原则上都必须发言。下次活动信息:  下次活动时间：8月2日（周五） 18:30 - 20:30     18:30 - 19:00 (30 MIN): Registration &amp; Social &amp; Pizza   19:00 - 19:10 (10 MIN): Warm Up   19:10 - 19:40 (30 MIN): Talk 1   19:40 - 19:50 (10 MIN): Tea Break   19:50 - 20:20 (30 MIN): Talk 2   20:20 - 20:30 (10 MIN): Reflection &amp; Group Photo    下次活动轮值主席：李卓桓 下次活动轮值副主席：李明 下次活动分享     王天 《Tencent Bot Platform Product Talk》   李云军《Chatbot在团队任务管理中的应用》   未来分享议题: 欢迎大家踊跃报名！  李明/俊良/Simon：Wechaty Mini Program Support 李明/俊良/Simon/云军：What will happen after Chatbot empowered by Mini Program? 俊良：如何用if else 和正则表达式写一个聊天机器人。 邝伟鹏：Chatbot 场景分享：秒印，家校沟通的工具。 李卓桓：Bot Market Place — 可重用能力平台。 肖立鹏：udesk 场景分享 （待定） 刘晓倩：Chatbot 行业应用，智能对话连接数据与商业 高原：企业微信开发实战分享 李佳芮：如何用Chatbot做售前导流 雷飚：AI + AR + Chatbot = ？ 段清华：打造一个超越 rasa 的chatbot平台 —— deepdialog. ai集体合影:  After Party 🍻: 主场活动结束后，六个人前往上次After Party的管氏串吧继续补充能量，大家讨论了创业，社区，技术，招聘等一系列问题，并成功的消灭了3炮鲜啤！ 另外，After Party 上我们从Lua数组下标从1开始，聊到了本次活动的第一场是0还是1，最终投票了第一次活动应该叫做First！ 特别鸣谢:  场地赞助方：腾讯公司 晚餐赞助方：Tencent Bot Platform产品团队 直播赞助方：毛豆教育公司 活动主办方：句子互动公司RSVP:  如果对活动纪要有修订或补充意见，请回复对本次活动纪要留言； 如果参加下次沙龙活动，请回复下次自己愿意分享的主题； 如果计划邀请新朋友参加下次沙龙活动，请让新朋友回复一句话的自我介绍；"
    }, {
    "id": 351,
    "url": "https://wechaty.js.org/2019/07/23/introduce-rasa-product-tech/",
    "title": "Rasa介绍：对话系统、产品与技术",
    "body": "2019/07/23 - « 本次活动通知: 腾讯+句子互动=碰撞思想，点燃科技 « Bot Friday Zero - 沙龙第0场分享: 关于对话系统/产品/技术 2019-07-19 于北京腾讯，QHDuan 对话系统与Rasa: 首先笔者认为：所谓对话系统，是通过对话的方式，实现人机交互的一种方法 就如同键盘鼠标是输入设备，显示器音箱是输出设备，输入输出是什么？是与计算机交互。对话系统也如此而已。 Rasa是一家通过机器学习技术实现对话系统、机器人开发的工具，同时也是一家创业公司。 Rasa最新于2019年初A轮融资$13M。 笔者认为Rasa最大的创新，是开发了整套的基于机器学习的对话工具，而相对的，如wit. ai，dialogflow(原api. ai)，luis. ai等都不够完整。 相对来说国内的unit，yige ai，更完整，但是无论是体验、效果、社区等等都不如rasa。 个人认为：程序员更爱工具，而不是平台。 Rasa的组成: Rasa NLU: 主要实现自然语言理解（即NLU）功能，本质上就是识别句子的意图和实体。 如“买一张去北京的票”，我们可以定义一个意图是“购票”，实体是“北京”和“一张”。 意图识别本质是短文本分类任务（当然在学术界可能称为Intent Detection来和Text Classification分开）。单纯短文本分类任务的SOTA基本上就是BERT了。 抽取本质是信息抽取任务。抽取的SOTA现在一般还是BiLSTM-CRF的各种变型，或BERT之类。 现在学术界的主要研究方向是多种工作结合，例如同一模型同时做意图识别和信息抽取，互相配合增加总体准确率。 Rasa的NLU，主要是当前的社区版，主要还是使用了各种开源技术，并没有追求学术上的SOTA。它使用的工具包括Spacy、sklearn-crfsuite Rasa Core: 笔者认为这是Rasa的核心部分，NLU有各种实现，开源的也有snips nlu等，但是core却独一无二。 Rasa Core主要完成了基于故事的对话管理，包括解析故事并生成对话系统中的对话管理模型（Dialog Management），输出系统决策（System Action/System Policy）。 学术上一般认为这部分会包含两个模型  对话状态跟踪（Dialog State Tracking / Belief Tracking） 对话策略（Dialog Policy / Policy Optimization）对于1. 其实Rasa实现很简单，具体在它的论文 Few-Shot Generalization Across Dialogue Tasks, Vlasov et at. , 2018 中说的比较具体。就是简单的基于策略的槽状态替换。 对于2. Rasa使用基于LSTM的Learn to Rank方法，大体上是将当前轮用户意图、上一轮系统行为、当前槽值状态向量化，然后与所有系统行为做相似度学习，以此决定当前轮次的一个或多个系统行为 Rasa X: Rasa的可视化编辑工具，更方便NLU、NLG数据的管理，故事的编写。 Rasa X可能暂时还不能让所有非开发人员也能快速方便的使用。不过它本质上可以方便开发人员快速开发，快速训练模型验证。 笔者是这么认为的，Rasa X就好像小程序开发也要有个本地开发工具一样，或者像Android Studio那样的工具。本地工具的优点就是方便调试、开发、快速验证、Debug。相对线上的缺点就是速度慢、验证需要等待后台训练、不便于Debug。 可以看出国内外现在很多机器人平台都是完全在线的，例如国外的luis. ai，dialogflow等。这样当然也可以，但是总还是不如有一个可自己训练的终端对开发者更友好。国内的就不说了。 再举个例子，如Elasticsearch、Docker都是非常棒的工具，但是如果官方开始的时候说：你不能自己本地架设，你只能用我的云服务。这样对于很多开发者来说就必然丧失了很大的兴趣。 Rasa 的 Pipeline: Pipeline 的过程是这样的：  用户输入文字，送入解释器，即Rasa NLU NLU给出结果，如图  从Tracker到Policy，Tracker用于跟踪对话状态，Tracker输出的是Embedding     用户意图的Embedding   系统动作（上一步）的Embedding   实体（槽值/Slot）的Embedding    Policy给出系统行为 Tracker记录系统行为，下一次会提供给Policy使用 返回消息给用户Rasa技术详细: Embedding 方法: 用户意图和系统行为会通过bag-of-word的方法分词，然后向量化，很有趣的结果。在官方论文没有仔细探讨为什么，笔者猜测是为了增加不同的意图、行为之间的语义关联。 论文原文： A bag-of-words representations for the user and the system labels are then created using token counts inside each label. 例如: action_search_restaurant = {action, search, restaurant} 实体/槽值（Slot）的向量化就非常简单了，只是走了是否存在的binary向量 The slots are featurized as binary vectors, indicating their presence or absence at each step of the dialogue. Learn to Rank 方法: 很多对话系统的系统决策都采用的是分类（Classification）方法，也就是每次总是在多个系统行为中选择唯一一个。 而Rasa选择了排序方法，即判断当前对话状态和系统行为的相似度，笔者认为这有两个可能的好处（论文没说明）：  可以更容易实现多个系统行为的同时输出。能让一个对话状态输出多个系统行为是Rasa的特色。至于为什么如此，可能有工程上的一些考虑，例如这样更方便，例如两个系统行为，一个是机器人说“请等待”，一个是真的去查询数据。 更方便扩展系统行为。如果是分类模型，增加一个分类，那必须重新训练整个分类器。如果是Ranking模型，如果只是增加或减少分类，可以考虑只训练新增的系统行为相关的和不相关的部分数据集，可能增加总体的训练速度。更方便快速实验、迭代。总结: 优点:  机器学习方法的好处是实际工程上代码量比较少，很多状态不需要写判断（对比专家系统） 可以做到不写逻辑下，快速验证某些场景或对话流。例如一个非开发者甚至可以不需要写一行代码就能搭建某种原型机器人。缺点:  要做好一个比较复杂的机器人，还是需要对机器学习有了解的工程师 针对复杂的机器人，可能需要大量数据"
    }, {
    "id": 352,
    "url": "https://wechaty.js.org/2019/07/19/bot5-seminar-minutes-0/",
    "title": "Chatbot Friday - 碰撞思想，点燃科技",
    "body": "2019/07/19 - « 本次活动通知: 腾讯+句子互动=碰撞思想，点燃科技 « Bot Friday Zero - 沙龙第0场:  时间：2019年7月19日（周五）18:30 - 22:30（4小时） 地点：腾讯公司北京办公室，第三极大厦1113 赞助方：腾讯公司首期沙龙创始会员:  分享嘉宾     段清华，金证优智技术总监。曾任文因互联研发工程师，完成项目包括金融搜索，公告摘要抽取项目，银行问答机器人。拥有多年金融NLP经验，带领团队完成问答机器人、投研系统、监管舆情、知识图谱等项目。对金融文档解析、抽取、搜索、量化分析、知识图谱建设、对话系统等领域有深入研究。    腾讯公司     王天，腾讯智能对话平台产品经理   徐岱，腾讯智能对话平台研发工程师   刘晓倩，腾讯智能对话平台产品经理   邱耀，微信模式识别中心，多轮对话阅读理解算法工程师   程睿，微信模式识别中心，Chatbot任务型对话算法工程师   张金超，微信模式识别中心工程师，功能产品、对话系统算法工程师   朱叶霜，微信模式识别中心，对话系统，语言理解，实体抽取算法工程师   周家伟，微信模式识别中心，对话系统，语义理解，功能任务算法工程师    Chatbot行业     李明，毛豆网创始人CEO，清华大学计算机硕士。曾与2003年创立嵌入式操作系统培训公司亚嵌科技。毛豆网致力于为内容创业者提供技术支持服务，关注Chatbot和微信小程序的结合与互动，并在微信群中基于NLP技术为用户提供流畅体验。已获清华XLab/DNA基金数百万天使投资；   李萌，小理智能创始人CEO，北大计算机博士。专注于利用人工智能、自然语言处理，通过Chatbot“主动”帮用户发掘信息中的价值。已获弘道资本千万RMB级别天使投资；   涂艳平，句子互动公司合伙人。句子互动创建了覆盖全球的微信聊天机器人开发者社区，公司围绕微信生态为客户提供智能对话服务。客户覆盖教育、保险等多个领域。曾入选百度AI加速器，并由PreAngel、Plug and Play和Y Combination孵化支持，已获TSVC/Alpha公社联合千万RMB级别天使投资；   梁皓然，Xanthous Tech 创始人，前亚马逊全栈工程师。2016年回国创业，组建团队在全球范围内为大公司提供Chatbot咨询开发服务，应用RASA对话系统，并基于微信将Chatbot和MiniProgram进行了深度整合;   赵俊良，毛豆网客服总监，北京交通大学硕士，曾任北京联合大学信息学院讲师，拥有十余年嵌入式系统研发经历和智能仪器测控领域的创业经历；   吕纪，国家电网研发经理，架构师。关注NLP技术和智能对话系统如何应用在电网电话中心的客服智能化中；   李卓桓，Github 6000 Star 的微信个人号SDK开源项目 Wechaty 作者，Conversational AI 布道者。曾任水木清华BBS站长，优酷网首席科学家。清华本科，中欧EMBA，北邮博士在读。   活动内容: 1 主题分享：《从Rasa开始谈对话机器人开发》: 段清华 @qhduan 曾任文因互联早期研发工程师，完成项目包括金融搜索，公告摘要抽取项目，银行问答机器人。目前负责基金管理公司的量化分析平台，资产配置平台算法。拥有多年金融NLP经验，带领团队完成问答机器人、投研系统、监管舆情、知识图谱等项目。对金融文档解析、抽取、搜索、量化分析、知识图谱建设、对话系统等领域有深入研究。 在2018年在哈尔滨召开的SMP第二届中文人机对话技术评测中，清华凭借着人机对话领域卓越的技术实力，领导句子互动参赛团队得到了行业专家评委的一致认同和推荐，荣获本次SMP任务型人机对话回复自然度第1名，在线评测第4名的好成绩。 Slides:  Video:    Your browser does not support the video tag.   感谢毛豆网提供价值4000元的本次活动视频直播赞助！ 2 闭门会议: 抛出问题：我们如何才能够将我们的活动，打造成为 Chatbot 时代的长城会（GWC）？  长城会成立于移动互联网发轫之初，见证了整个中国移动互联网的崛起过程。从某种意义上说，长城会可以说是窥视整个中国移动互联网的一个缩影。长城会的成立源起于一次失败的访问。  2008年，包括长城会创始人文厨、时任UC CEO俞永福在内的9个人，相识于微末之时，看到了移动互联网蕴含的机会，准备一起去日本取经。当时的日本在移动互联网领域领先全球，已经出现了像GREE、DeNA和mixi这样的独角兽。而当时，俞永福的UC Web才刚刚拿到了100万美元的融资额。微信在三年之后才正式推出。  当时，文厨、俞永福这些人想着学习经验，结果吃了闭门羹。怎么能让对方接纳自己呢？这群人就想到了成立一个组织，于是长城会就出现了。雷军是这个组织的首任投资人，投资了30万元。  首批的会员有八个，分别是刘斌（时任易查CEO）、俞永福（UC CEO）、林宇（网秦联席CEO）、李晋吉（时任3G泡泡CEO）、肖永泉（当乐网CEO）、居易飞（时任天下网CEO）、文厨（长城会CEO）、张向东（3G门户CEO）。  最初，长城会就是为了给中国的移动互联网圈提供一个交流、学习的平台，只有论坛没有展览。  36Kr, 起底互联网巨头云集的长城会 Our Vision: Became the hottest place for a Friday night out with the chatbots! Top developers, entrepreneurs, and corporate PMs and can’t beat a BOT chippy on your way back to the Holylands! 3 圆桌头脑风暴与意见收集:  王天     腾讯希望更多的人参与进来，听到开发者的声音    刘晓倩     专门有一个环节来说“聊天机器人在什么什么场景下的作用”。    张金超     学术 + 技术 + 产品，都想看demo；手机需求，提前交互    段清华     为每个环节准备倒计时的钟，严格设置时间    徐岱     活动中应该补充足够的水果饮料   建议两周一次    李萌     搜集一下听众的需求，针对性地分享。   从用户层面的人来提需求：应该请一些用户来，才不会拿着锤子看什么都是钉子   +商业角度，纯技术没有很大意义，因为一直都在迭代    梁皓然     找现成的，做案例分析，大家互相分享作品。（没有痛点的不看）   每个人写3点――找出共性最强的客户    李明     节奏上可以快一点   关注工程实际应用场景和效果产出    其他腾讯同事     多demo（没有Demo的不看）、学术增强、时间太长、节奏更快   多一些Demo，定一些指标来量化。   学术层面增强    李卓桓     每个人都要分享，带着问题来、提问、多交流   争取更多的人参加 After Party！   4 活动决议:  下次活动时间：7月26日（周五） 18:30 - 20:30     18:30 - 19:00 (30 MIN): Registration &amp; Social &amp; Pizza   19:00 - 19:10 (10 MIN): Warm Up   19:10 - 19:40 (30 MIN): Talk 1   19:40 - 19:50 (10 MIN): Tea Break   19:50 - 20:20 (30 MIN): Talk 2   20:20 - 20:30 (10 MIN): Reflection &amp; Group Photo    下次活动轮值主席：李佳芮 下次活动分享     李明：The Bad Part of My Chatbot Experience   TBD: TBD    下下次活动分享：     王天：Tencent Bot Platform Product Talk   李萌：TBD    其他可选分享议题（欢迎大家踊跃报名）:     李明/俊良/Simon：Wechaty Mini Program Support   李明/俊良/Simon/云军：What will happen after Chatbot empowered by Mini Program?   云军：Chatbot在团队任务管理中的应用，以及AI底层支持能力的不足与痛点，及hack的解决方案分享   邝伟鹏：FindMyFace - Run Face Application in Wechat and Provide Offline Events Photo Service   5 集体合影: After Party 🍻: Bot Friday Zero 主场活动结束后，意(ji)犹(chang)未(lu)尽(lu)的三个人前往第三极大厦十字路口对面的管氏串吧继续补充能量，大家一起头脑风暴了活动的参加人员、可持续性发展、讨论主题，以及活动名称等，并成功的消灭了4L鲜啤。 经过头脑风暴，大家想出了一些活动名称：  Bot Friday Bot Friday Club Bot Five Club Bot5 Bot5 Club bot5. club Bot Lab Bot Revolution Bot Evolution等等，列在这里等待继续迭代下次头脑风暴。:D 特别鸣谢:  场地赞助方：腾讯公司 晚餐赞助方：Tencent Bot Platform产品团队 直播赞助方：毛豆教育公司 活动承办方：句子互动公司RSVP:  如果对活动纪要有修订或补充意见，请回复对本次活动纪要留言； 如果参加下次沙龙活动，请回复下次自己愿意分享的主题； 如果计划邀请新朋友参加下次沙龙活动，请让新朋友回复一句话的自我介绍；"
    }, {
    "id": 353,
    "url": "https://wechaty.js.org/2019/07/18/send-miniprogram-using-padpro/",
    "title": "如何用PadPro实现发送微信小程序",
    "body": "2019/07/18 - 3个月前，也就是2019. 4. 18，我们公司启动了一个小程序项目 – 毛豆课堂。这个项目是依托毛豆网的音视频互动直播技术，搭建一个专注少儿素质课程的在线教育平台。 目前这个小程序的MVP已经通过微信审核上线，初步实现了家长（例如孩子妈妈）给孩子的课程设定时间提醒，提醒的方式包括小程序消息，短信，电话，邮件等四种常用通知方式。转发这个课程还可以邀请和课程有关的人（例如孩子爸爸，同学家长和课程老师等）也加入这个课程提醒，未来计划还会开发一些类似家长朋友圈的社交功能。有兴趣体验的朋友，可以扫这个毛豆课堂小程序二维码。 1个月前，我们觉得通过这个小程序创建课程提醒的流程还是不够方便，想到了能否在微信里通过聊天方式来创建提醒，例如孩子妈妈发过来一条消息”今天晚上6点晨晨英语课，在商务会馆1101“，收到消息的爸爸就可以转发给一个微信机器人bot，从而为爸爸建好这个课程提醒，爸爸加入后就可以提醒他去送孩子上课。有这个想法的时候，正好有一天带娃路上偶遇了李卓桓，很自然就想到了要用Wechaty这个牛逼闪闪的微信机器人开源项目。 其实知道这个项目已经有好几年了，但登录到github上看到huan的5000多次commits还是把我惊了一跳，心中无数个草泥马翻腾而过，想说zixia还是那个zixia，你大爷居然还在写代码。Orz 钦佩之余，接下来一个多星期我也日夜奋战，虽然只有C语言和ARM汇编的基础，但在学习了xiaoli-news-bot代码框架的基础上，实现了我们的maodou-ketang-bot。有兴趣体验的朋友，可以扫这个毛豆课堂小助手二维码，加好友之后，转给它那条孩子妈妈的消息。 大家看到小助手回复了2条消息，一条是文字，解析了这段文本中的时间、地点和标题；一条是小程序，创建了相应的消息提醒。但当时Wechaty底层是不支持发送小程序的，只能发送文字，图片，名片和链接。 初期测试我们使用的wechaty+puppeteer，发现不能发送图片和小程序，和李卓桓联系沟通后，建议使用puppet-padpro，还把他珍藏的两个token送了一个给我们做开发。这时我们发现wechaty真的很强大，可以挂接不同的puppet，而puppet-padpro就是ipad版本的puppet。 同时，我们了解到Simon大侠已经在puppet-padpro上做了很多这方面的底层改造工作，就差一点即可实现发送小程序，因为时间关系没能继续完成。于是在他的基础上，我们进行了实验和修改，发现只需要在底层xml协议中加上filekey字段就可以了。随后我发了一个相关的#issue Send Mini-Program，接下来我的同事@zhaoic参与完成了后继的开发工作，初步解决了这个问题并提交了代码的PR。 对这次 PR 想仔细了解的可以直接进入下面的3个链接，重要的代码部分我也摘录在本文中，便于给想了解这个工作的人多一些线索。  https://github. com/wechaty/wechaty/pull/1822/files https://github. com/wechaty/wechaty-puppet/pull/55/files https://github. com/botorange/wechaty-puppet-padpro/pull/172/files下面，我就重点介绍一下我们是如何实现发送微信小程序的。 内容纲要:  毛豆课堂项目背景介绍 如何用PadPro实现发送微信小程序 进一步需要完成的工作如何用PadPro实现发送微信小程序: 实现发送小程序改造代码的过程，需要涉及 wechaty，wechaty-puppet和wechaty-puppet-padpro 三个库。关于这三个库的关系，推荐读一下另一位大侠苏畅写的这篇Summary of Learning Wechaty and Padpro，非常清晰的勾画出了从上到下的三个层，即接口层-抽象层-实现层的逻辑关系，这里我就不再赘述，主要说明一下我们所做的代码改动过程。 要想从上到下整个改动，涉及的代码修改量很大，为了尽快跑通小程序的流程，经过分析后，我们发现UrlLink结构，和小程序比较接近。这样我们就不需要动wechaty和wechaty-puppet这两个库，只修改wechaty-puppet-padpro这一个库，大大减轻了工作量。 Simon的wechaty-puppet-padpro库，对小程序大多数功能都已经实现了，在此基础上，我们先改造了 puppet-padpro. ts文件的forwardAttachment函数，该函数调用generateAttachmentXMLMessageFromRaw函数，我们把分析出来的小程序xml替换这个函数的内容后，转发小程序成功了，基本流程跑通了。 接下来，继续改造messageSendUrl函数，仿照generateAttachmentXMLMessageFromRaw，创建了一个generateMiniProgramXMLMessageFromRaw函数，把messageSendUrl底层调用改成这个新的函数 await this. padproManager. GrpcSendApp(id, generateMiniProgramXMLMessageFromRaw(urlLinkPayload))通过urlLinkPayload传递两个参数，小程序的title和url。经过测试后，通过say(urlLink)，可以实现小程序的发送。 经过了可行性的验证，确认了底层能够发送小程序之后，下面我们就开始在三个库里进行具体的代码和文件的修改工作。 wechaty接口层:  新增一个文件 src/user/mini-program. ts ，定义一个新 Classexport class MiniProgram { /**  *  * Create  *  */ public static async create (): Promise&lt;MiniProgram&gt; {  log. verbose('MiniProgram', 'create()')  // TODO: get title/description/thumbnailUrl from url automatically  const payload: MiniProgramPayload = {   appid       : 'todo',   description    : 'todo',   pagepath      : 'todo',   thumbnailurl    : 'todo',   title       : 'todo',   username      : 'todo',  }  return new MiniProgram(payload) } constructor (  public readonly payload: MiniProgramPayload, ) {  log. verbose('MiniProgram', 'constructor()') } public appid (): undefined | string {  return this. payload. appid } public title (): undefined | string {  return this. payload. title } public pagepath (): undefined | string {  return this. payload. pagepath } public username (): undefined | string {  return this. payload. username } public description (): undefined | string {  return this. payload. description } public thumbnailurl (): undefined | string {  return this. payload. thumbnailurl }} 更新三个文件 src/user/contact. ts ，src/user/message. ts ，src/user/room. ts ，加入 say 接口src/user/contact. ts  public async say (textOrContactOrFileOrUrlOrMini: string | Contact | FileBox | UrlLink | MiniProgram): Promise&lt;void&gt; {  log. verbose('Contact', 'say(%s)', textOrContactOrFileOrUrlOrMini)  if (typeof textOrContactOrFileOrUrlOrMini === 'string') {   /**    * 1. Text    */   await this. puppet. messageSendText({    contactId: this. id,   }, textOrContactOrFileOrUrlOrMini)  } else if (textOrContactOrFileOrUrlOrMini instanceof Contact) {   /**    * 2. Contact    */   await this. puppet. messageSendContact({    contactId: this. id,   }, textOrContactOrFileOrUrlOrMini. id)  } else if (textOrContactOrFileOrUrlOrMini instanceof FileBox) {   /**    * 3. File    */   await this. puppet. messageSendFile({    contactId: this. id,   }, textOrContactOrFileOrUrlOrMini)  } else if (textOrContactOrFileOrUrlOrMini instanceof UrlLink) {   /**    * 4. Link Message    */   await this. puppet. messageSendUrl({    contactId : this. id,   }, textOrContactOrFileOrUrlOrMini. payload)  } else if (textOrContactOrFileOrUrlOrMini instanceof MiniProgram) {   /**    * 5. Mini Program    */   await this. puppet. messageSendMiniProgram({    contactId : this. id,   }, textOrContactOrFileOrUrlOrMini. payload)  } else {   throw new Error('unsupported arg: ' + textOrContactOrFileOrUrlOrMini)  } }src/user/message. ts  public async say (  textOrContactOrFileOrUrlOrMini : string | Contact | FileBox | UrlLink | MiniProgram, ): Promise&lt;void&gt; {  log. verbose('Message', 'say(%s)', textOrContactOrFileOrUrlOrMini)  // const user = this. puppet. userSelf()  const from = this. from()  // const to  = this. to()  const room = this. room()  if (typeof textOrContactOrFileOrUrlOrMini === 'string') {   /**    * Text Message    */   await this. puppet. messageSendText({    contactId : (from &amp;&amp; from. id) || undefined,    roomId  : (room &amp;&amp; room. id) || undefined,   }, textOrContactOrFileOrUrlOrMini)  } else if (textOrContactOrFileOrUrlOrMini instanceof Contact) {   /**    * Contact Card    */   await this. puppet. messageSendContact({    contactId : (from &amp;&amp; from. id) || undefined,    roomId  : (room &amp;&amp; room. id) || undefined,   }, textOrContactOrFileOrUrlOrMini. id)  } else if (textOrContactOrFileOrUrlOrMini instanceof FileBox) {   /**    * File Message    */   await this. puppet. messageSendFile({    contactId : (from &amp;&amp; from. id) || undefined,    roomId  : (room &amp;&amp; room. id) || undefined,   }, textOrContactOrFileOrUrlOrMini)  } else if (textOrContactOrFileOrUrlOrMini instanceof UrlLink) {   /**    * Link Message    */   await this. puppet. messageSendUrl({    contactId : (from &amp;&amp; from. id) || undefined,    roomId  : (room &amp;&amp; room. id) || undefined,   }, textOrContactOrFileOrUrlOrMini. payload)  } else if (textOrContactOrFileOrUrlOrMini instanceof MiniProgram) {   /**    * MiniProgram    */   await this. puppet. messageSendMiniProgram({    contactId : (from &amp;&amp; from. id) || undefined,    roomId  : (room &amp;&amp; room. id) || undefined,   }, textOrContactOrFileOrUrlOrMini. payload)  } else {   throw new Error('unknown msg: ' + textOrContactOrFileOrUrlOrMini)  } }src/user/room. ts  public async say (  textOrListOrContactOrFileOrUrl : string | Contact | FileBox | UrlLink | MiniProgram | TemplateStringsArray,  . . . mentionList         : Contact[] ): Promise&lt;void&gt; {  log. verbose('Room', 'say(%s, %s)',   textOrListOrContactOrFileOrUrl,   mentionList. join(', '),  )  let text: string  if (typeof textOrListOrContactOrFileOrUrl === 'string') {   if (mentionList. length &gt; 0) {    const AT_SEPARATOR = FOUR_PER_EM_SPACE    const mentionAlias = await Promise. all(mentionList. map(async contact =&gt;     '@' + (await this. alias(contact) || contact. name())    ))    const mentionText = mentionAlias. join(AT_SEPARATOR)    text = mentionText + ' ' + textOrListOrContactOrFileOrUrl   } else {    text = textOrListOrContactOrFileOrUrl   }   const receiver = {    contactId : (mentionList. length &amp;&amp; mentionList[0]. id) || undefined,    roomId  : this. id,   }   await this. puppet. messageSendText(    receiver,    text,    mentionList. map(c =&gt; c. id),   )  } else if (textOrListOrContactOrFileOrUrl instanceof FileBox) {   /**    * 2. File Message    */   await this. puppet. messageSendFile({    roomId: this. id,   }, textOrListOrContactOrFileOrUrl)  } else if (textOrListOrContactOrFileOrUrl instanceof Contact) {   /**    * 3. Contact Card    */   await this. puppet. messageSendContact({    roomId: this. id,   }, textOrListOrContactOrFileOrUrl. id)  } else if (textOrListOrContactOrFileOrUrl instanceof UrlLink) {   /**    * 4. Link Message    */   await this. puppet. messageSendUrl({    contactId : this. id,   }, textOrListOrContactOrFileOrUrl. payload)  } else if (textOrListOrContactOrFileOrUrl instanceof MiniProgram) {   /**    * 5. Mini Program    */   await this. puppet. messageSendMiniProgram({    contactId : this. id,   }, textOrListOrContactOrFileOrUrl. payload)  } else if (textOrListOrContactOrFileOrUrl instanceof Array) {   await this. sayTemplateStringsArray(    textOrListOrContactOrFileOrUrl,    . . . mentionList,   )  } else {   throw new Error('arg unsupported: ' + textOrListOrContactOrFileOrUrl)  } }wechaty-puppet抽象层:  新增一个文件 src/schemas/mini-program. ts，定义一个 Interfaceexport interface MiniProgramPayload {  appid?     : string,  // optional, appid, get from wechat (mp. weixin. qq. com)  description?  : string,  // optional, mini program title  pagepath?    : string,  // optional, mini program page path  thumbnailurl?  : string,  // optional, default picture, convert to thumbnail  title?     : string,  // optional, mini program title  username?    : string,  // original ID, get from wechat (mp. weixin. qq. com)} 更新 src/puppet. ts ，声明 messageMiniProgram 和 messageSendMiniProgram 抽象接口 public abstract async messageMiniProgram (messageId: string) : Promise&lt;MiniProgramPayload&gt; public abstract async messageSendMiniProgram (receiver: Receiver, miniProgramPayload: MiniProgramPayload)     : Promise&lt;void&gt;wechaty-puppet-padpro实现层:  更新 src/puppet-padpro. ts ，加入 messageMiniProgram，messageSendMiniProgram 的实现 public async messageSendMiniProgram (  receiver: Receiver,  miniProgramPayload: MiniProgramPayload ): Promise&lt;void&gt; {  log. verbose(PRE, `messageSendLink( ${JSON. stringify(receiver)} , ${JSON. stringify(miniProgramPayload)})`)  if (!this. padproManager) {   throw new Error('no padpro manager')  }  // Send to the Room if there's a roomId  const id = receiver. roomId || receiver. contactId  if (!id) {   throw Error('no id')  }  await this. padproManager. GrpcSendApp(id, generateMiniProgramXMLMessage(miniProgramPayload)) } public async messageMiniProgram (messageId: string): Promise&lt;MiniProgramPayload&gt; {  const rawPayload = await this. messageRawPayload(messageId)  const payload = await this. messagePayload(messageId)  if (payload. type !== MessageType. MiniProgram) {   throw new Error('Can not get miniProgram from non miniProgram payload')  } else {   const appPayload = await appMessageParser(rawPayload)   if (appPayload) {    return {    }   } else {    throw new Error('Can not parse miniProgram message payload')   }  } } 更新 src/pure-function-helpers/app-message-generator. ts，增加 generateMiniProgramXMLMessage 的实现export const generateMiniProgramXMLMessage = (payload: MiniProgramPayload): string =&gt; { return ` &lt;appmsg appid=   sdkver= 0 &gt;  &lt;title&gt;${payload. title}&lt;/title&gt;  &lt;des&gt;${payload. description}&lt;/des&gt;  &lt;action/&gt;  &lt;type&gt;33&lt;/type&gt;  &lt;showtype&gt;0&lt;/showtype&gt;  &lt;soundtype&gt;0&lt;/soundtype&gt;  &lt;mediatagname/&gt;  &lt;messageext/&gt;  &lt;messageaction/&gt;  &lt;content/&gt;  &lt;contentattr&gt;0&lt;/contentattr&gt;  &lt;url&gt;https://mp. weixin. qq. com/mp/waerrpage?appid=${payload. appid}&amp;amp;type=upgrade&amp;amp;upgradetype=3#wechat_redirect&lt;/url&gt;  &lt;lowurl/&gt;  &lt;dataurl/&gt;  &lt;lowdataurl/&gt;  &lt;appattach&gt;   &lt;totallen&gt;0&lt;/totallen&gt;   &lt;attachid/&gt;   &lt;emoticonmd5/&gt;   &lt;fileext/&gt;   &lt;cdnthumburl&gt;&lt;/cdnthumburl&gt;   &lt;cdnthumbmd5&gt;&lt;/cdnthumbmd5&gt;   &lt;cdnthumblength&gt;&lt;/cdnthumblength&gt;   &lt;cdnthumbwidth&gt;&lt;/cdnthumbwidth&gt;   &lt;cdnthumbheight&gt;&lt;/cdnthumbheight&gt;   &lt;cdnthumbaeskey&gt;&lt;/cdnthumbaeskey&gt;   &lt;aeskey&gt;&lt;/aeskey&gt;   &lt;encryver&gt;0&lt;/encryver&gt;   &lt;filekey&gt;&lt;/filekey&gt;  &lt;/appattach&gt;  &lt;extinfo/&gt;  &lt;sourceusername&gt;${payload. username}@app&lt;/sourceusername&gt;  &lt;sourcedisplayname&gt;${payload. description}&lt;/sourcedisplayname&gt;  &lt;thumburl/&gt;  &lt;md5/&gt;  &lt;statextstr/&gt;  &lt;weappinfo&gt;   &lt;username&gt;&lt;![CDATA[${payload. username}@app]]&gt;&lt;/username&gt;   &lt;appid&gt;&lt;![CDATA[${payload. appid}]]&gt;&lt;/appid&gt;   &lt;type&gt;2&lt;/type&gt;   &lt;version&gt;&lt;/version&gt;   &lt;weappiconurl&gt;&lt;![CDATA[]]&gt;&lt;/weappiconurl&gt;   &lt;pagepath&gt;&lt;![CDATA[${payload. pagepath}]]&gt;&lt;/pagepath&gt;   &lt;shareId&gt;&lt;![CDATA[0_${payload. appid}_858901320_1563444358_0]]&gt;&lt;/shareId&gt;   &lt;appservicetype&gt;0&lt;/appservicetype&gt;  &lt;/weappinfo&gt; &lt;/appmsg&gt; &lt;fromusername&gt;&lt;/fromusername&gt; &lt;scene&gt;0&lt;/scene&gt; &lt;appinfo&gt;  &lt;version&gt;1&lt;/version&gt;  &lt;appname/&gt; &lt;/appinfo&gt; &lt;commenturl/&gt;`}进一步需要完成的工作: 底层小程序的xml协议分析: padpro中想要发送一个小程序需要先打开调试开关PADPRO_LOG='silly'接收一个小程序，才能获得到诸如以上的信息。这样我们对保存的信息进行序列化操作，摸索规律，找到变量，提取公共模板数据，从而程序化的构造出一个发送小程序的 XML 数据。 大体流程：  根据appid查询小程序信息（需要调研下如何进行） 将获得到的信息进行存储（若查询便利的话应该可以省去该操作） 构造公共模板 将获得到的信息嵌入模板 得到的XML结构作为messageSendMiniProgram的返回数据我们把抓到的底层 xml 协议发到了这里，有兴趣深入研究的朋友可以继续分析这些底层的协议字段。虽然我们猜出了一些关键字段，实现了基本的发送功能，但不知道微信服务器那边会不会监测字段的完整性或者正确性，毕竟通过这样Hack的方法要把bot拉入黑名单也很容易。 thumbnailUrl的CDN上传: 一个发送出来的小程序，其视图和接口传入数据的关系，如下图所示 目前，appid、description、pagepath、title和username都比较容易获得，thumbnailUrl 我们参考了 UrlLink 结构，这块区域的缩略图可以让调用者传入一个图片的 thumbnailUrl ，底层代码里未来还应该做如下2个后继的工作，目前因为时间关系也还未实现。  调用 FileBox. fromUrl 获得这个图片文件 调用微信提供的 CDN 上传文件功能，获得如下的数据结构 thumbnail: {  cdnthumburl:  cdnthumbmd5:  cdnthumblength:  cdnthumbwidth:  cdnthumbheight:  cdnthumbaeskey:  aeskey:  filekey: }目前底层发送的xml协议里面，cdnthumbnailurl, aeskey, filekey等字段，都是从已有小程序中提取出来的，后续这里可能还需要继续完善。 NLP的Help needed: 目前bot采用的NLP Parser是微软提供的@microsoft/recognizers-text-suite，我们用它实现了从一句话中提取出时间变量，也就是 const time = parseTime(msgText) 这样一个简单函数。但微软NLP处理的结果，其实是一个复杂的Json返回值，还需要我们写不少代码来筛选出我们期待的时间结果，这些代码在 getTimeInResults 这个函数里，显得啰嗦又低级，期待谁能告诉我们一个更美好的 parseTime。 除了时间之外，识别出一句话的课程标题和上课地点，也是我们所需要的，但微软NLP还不支持，所以我们又用了另外一个BasonNLP NER，但它的处理结果同样也是一个复杂的Json返回值，还需要借助词性来拼凑出我们期待的结果，这些代码在另外一个函数 parseTitleAndLocation里，显得低级又业余，也同样期待更优雅的ai来拯救一下。 如今NLP在各个大厂提供的智能API套件里面都是标配了，但从腾讯百度阿里到科大讯飞到复旦FudanNLP测了一圈，也没有发现能够很方便很准确地实现识别时间/地点/主题的api。如果谁对这方面比较了解，可以告诉我，欢迎加我微信: limingth 致谢:  Simon Liang 的代码，其实已经做完了大部分的底层工作。如果不是他的开创性成果在前面开路，我们很难有勇气最终完成这个任务。 苏畅 写的本地开发环境搭建的文档，为我们本地跑通开发环境节省了时间，同时在代码修改过程中也提供了热心的帮助，更重要的是人还长得帅。 还要感谢微信PR群里的 @高原ོ 和 @杉木，帮我们确认了CDNManager可以解决未完成工作里的thumbnailUrl，期待以后能够一起再完善这部分的代码。 最后感谢Wechaty团队提供这么好的一个工具，感谢李卓桓，李佳芮前期做了那么多奠基性的工作，也很高兴通过这个项目认识了正在做Teamin群协作的李云军，这么多姓李的，在一起搞事情很开心！:P 作者: limingth，zhaoic 毛豆网 "
    }, {
    "id": 354,
    "url": "https://wechaty.js.org/2019/07/16/wewe-public-wechat-group/",
    "title": "wewe 向全世界公开群消息",
    "body": "2019/07/16 - 几周前, 我在几个论坛分享了 透明创业实验, 并且建了一个微信群方便交流. 没想到有超过 500 人加入, 在群里了也出现了很多有意思的讨论. 很遗憾的是这些讨论停留在了微信里面, 只有加群的那些人可以看到, 新加入的还看不到旧消息, 对于一些重复的问题, 有时候需要回复多遍. 我就一直在想, 可不可以把这些消息公开出来, 让所有人可见, 这样感兴趣的人可以方便的查看聊天记录, 搜索感兴趣的内容. 如果我做这么一个工具, 对其他希望公开消息的群也是有意义的. 正好之前有使用 wechaty 的经验, 说干就干, MVP 整起来! 经过几个礼拜的设计和开发, 我做了 wewe wewe 提供的价值:  在一个地方记录了群聊里的信息, 群外人也可以看到 可以被搜索引擎搜到 话题抽取,便于浏览和搜索 聊天内容的分析(unfinished) 支持各种群聊工具(目前支持微信群和 slack 群, 并且计划支持 telegram/gitter 等主流群聊工具)技术实现: wewe 是一个开源项目, 具体实现细节可见 GitHub 微信部分基于 wechaty, 基本原理是启动一个浏览器, 登录网页微信后, 将收到的消息存入数据库. 如何加入: 要求  告知全体群成员群消息将公开在互联网上 如果是微信群, 需要指定一名愿意收集话题的志愿者(slack 不需要, 自带 threads 功能)加入方式  微信: 加 timbot 为好友, 备注 “join wewe”, 然后将机器人拉入群聊即可, 如果内容适合公开, 我就会开始收集 slack: 加入t9t. io slack 群FAQ:  隐私问题: 最大限度保障群友隐私, 所以消息称默认是匿名的. 但是对于愿意公开身份的群友, 也支持公开昵称, 对自己简单介绍, 放上自己的链接等. e. g. t9t 群里的成员 https://wewe. t9t. io/chat/t9t. io%20community/members 如何收费: wewe 仍在开发阶段, 并且因为网站使用 serverless 方式开发(aws lambda &amp; dynamodb &amp; s3), 维护和服务器成本比较低, 对前 30 个加入的群免费提供服务, 之后的收费模式仍在思考当中wewe 还是一个正在开发中的项目, 欢迎留言交流你对它的看法:  Author: @timqian Building transparent products at t9t. io "
    }, {
    "id": 355,
    "url": "https://wechaty.js.org/2019/07/12/wechaty-business-easy-pay/",
    "title": "Wechaty - 让线上没有难做的生意",
    "body": "2019/07/12 - Wechaty - 让线上没有难做的生意: TLDR: 本文主要面对没有营业执照，想使用微信或支付宝在线收款的中小企业或者个人开发者，日收入在5K以下（菠菜类或者想偷税者请绕道）。 自从使用了Wechaty，资金及时到账，收款后立即通知。即开即用，高并发，超稳定不掉单。 背景: 随处可见微信和支付宝的支付二维码，已经让超市水果店和煎饼果子摊贩没有难做的生意。然而在线支付可就没那么容易了。接口大部分需要企业资质认证，或者需要备案域名以及开通权限，对于中小型商户门槛非常高。大部分人会在收到款后，手动确认订单，经常出现订单延误或者遗漏。然而市面上的解决方案都差强人意。那么这个线上支付的流程如何利用Wechaty优化一下呢？ 技术实现: 整个收款过程分为3步，更多信息可以点击查看：WechatyPay.  用户选择支付金额后，付款页面打开对应的付款码（支付宝可自定义金额），用户扫码付款 确认收款后（onMessage），跟后端发送回调收款金额及收款时间（sendPayment） 后台根据金额以及时间，把对应的订单自动标记下面的例子以第2步为例，如何在后台确认收款，以及跟后端发送回调。 // Wechaty 经典启动const bot = new Wechaty()bot. on('scan',  onScan)bot. on('login',  onLogin)bot. on('message', onMessage)bot. start()// 微信收款的消息提示async function onMessage (msg) { if ( msg. type() !== bot. Message. Type. Attachment &amp;&amp; !msg. self()  || contact. name() !== '微信支付') {  return } const strs = msg. text(). split('元') if (strs. length &gt;= 1) {  const prices = strs[0]. split('微信支付收款')  if (prices. length &gt;= 1) {   const priceStr = prices[1]   sendPayment(parseFloat(priceStr), msg. date(). getTime())  } }}// 收到金额之后，进行确认订单回调function sendPayment (priceAmount, timestamp) { const options = {  method: 'POST',  url: 'https://api. callbackaddress. com/api/admin/callback',  headers: { 'content-type': 'application/json', 'token': 'XXXXXX'},  body: {'amount': priceAmount, 'timestamp': timestamp },  json: true }; request(options, function (error, response, body) {  if (error) throw new Error(error); });}支付宝道理类似，不过目前产品包装没有Wechaty这么优秀的代码库。半自动操作如下：  扫码登录支付宝账号，在Headers中获取Cookie。操作类似于bot. on('scan',  onScan) 轮询获取订单列表，如果有新支付订单，，跟后端发送回调收款金额及收款时间（sendPayment） 由于此处使用了轮询的方式，为了防止频繁访问被支付宝风控，仅当有待支付订单才会高频访问订单接口。效果预览: 终于可以一站式的管理所有微信和支付宝的订单了！每笔订单的时间，金额，还有每天收入统计一览无余。 产品实现: 如果还是觉得步骤有点繁琐？那可以试一下这款基于桔子互动的云端服务哦。  支持微信扫码托管（基于桔子互动服务） 支持支付宝扫码托管 保障安全性，不记录个人账户密码 资金实时到账，不经过第三方 继续交流技术产品探讨可以添加👇微信。本文仅供技术产品交流参考，建议使用官方认证接口。请勿使用此项目做违反微信、支付宝规定或者其他违法事情！  作者: Shawn，全栈创业狗，致力于利用技术提升支付领域效率。 "
    }, {
    "id": 356,
    "url": "https://wechaty.js.org/2019/07/08/summary-of-learning-wechaty-and-padpro/",
    "title": "Summary of Learning Wechaty and Padpro",
    "body": "2019/07/08 -  总结 wechaty 的基础用法； 介绍 wechaty 与 puppet 及 padpro 模块之间的关系、数据流向、事件监听机制等； 详细介绍合作开发的本地环境配置。简介: Wechaty: Wechaty 是一个开源的微信机器人接口，由 Typescript 构建的 Node. js 应用。支持多种微信接入方案，包括网页、ipad、ios、windows, android 等。同时支持Linux, Windows, Darwin(OSX/Mac) 和 Docker 多个平台。 Wechaty能帮我们做什么？:  智能收发消息     发送者，接收者及群组的ID   消息的类型（文本、链接、联系人、表情、图片、文件）   通过简单配置，即可加入智能对话系统，完成指定任务    管理联系人     查找好友   获取联系人详细信息   管理备注信息   获取机器人信息（self）    管理群组     创建群组   自动入群、关键字入群、二维码入群   邀请联系人进群（40人以上链接邀请好友，确认后入群；40人以下直接入群）   将联系人移出群组    处理好友请求     自动处理好友请求   获取发好友请求的联系人信息   快速创建微信机器人: import { Wechaty } from 'wechaty'Wechaty. instance() // Singleton. on('scan', (qrcode, status) =&gt; console. log(`Scan QR Code to login: ${status}\nhttps://api. qrserver. com/v1/create-qr-code/?data=${encodeURIComponent(qrcode)}`)). on('login', user =&gt; console. log(`User ${user} logined`)). on('message', message =&gt; console. log(`Message: ${message}`)). start()以上一段很简短的代码就能创建一个 wechaty 智能机器人。  通过监听scan事件，触发扫码登录的功能 监听login事件，检测到用户登录成功时，提示用户登录信息 监听message事件，用户通过微信所发的消息都会被微信机器人打印显示在控制台基于事件绑定机制，我们可以根据不同场景事件的触发，通过wechaty中的room, contact, message等功能模块完成自己感兴趣的逻辑操作，从而提升工作效率。 为了机器人功能的多样化，wechaty 中还支持对群组操作、好友请求、数据准备，退出登录等事件的监听。下面简单介绍我对这些事件的理解，便于大家能够更好的使用 wechaty。 群组监听事件区别 room-join     无论邀请者是群主还是群成员，被邀请者加入群组后即触发此事件。     room-leave     群主在群组中移出某些用户会触发此事件，群组成员自动退出不会触发此事件。     room-invite     bot 被邀请至群组中，会触发此事件。    其他监听事件 ready     完成数据准备工作，在底层拉取微信端数据进行同步，同步完成后会触发此事件。对数据实时性有较高要求的操作需要监听此事件。     message     bot 收到消息时，会触发此事件。     friendship     bot 收到好友请求时，会触发此事件。     room-topic     bot 所在群组的群名称发生变动时，会触发此事件。     logout     当 bot 退出登录时，会触发此事件。    关于 say() 方法: wechaty 所创建微信机器人做的最频繁的事情就是应答消息，下面我来简答介绍关于机器人应答消息的几种方式。    bot. say()   bot即我们所创建的机器人，其对应的 say() 方法，也就是机器人这个微信号来发送消息。该方法并不常用。     contact. say()   该方法从字面理解起来可能会存在些困惑，它不是指联系人对微信机器人发送消息，而是微信机器人对某个联系人发送消息。结合几种 say() 方法来看，就能理解。     msg. say()   该方法是发送消息最常用的方法，微信机器人只要收到消息就会予以回复，即微信机器人对所接受到的消息进行回复。使用该方法需要慎重，很可能会导致你的微信机器人疯狂的和自己说话。具体解决办法在我们官方的 FAQ 中有明确答案，有兴趣的小伙伴可以飞去查看。     room. say()   该方法是微信机器人在群组中发送消息，类似 contact. say()。  以上简单介绍了 wechaty 的基本功能、事件监听，以及消息的几种发送方式，接着我们就可以创造自己的微信机器人了。为了能够使我们所创建的机器人更加友爱，作为开发者的我们还需要对 wechaty 及其相关模块（puppet, padpro）的源码进行阅读，从而能够更好的理解微信机器人的构造原理。我们先对相关模块进行介绍，在后续章节中会整理一些我在阅读源码过程中所遇到的疑惑点。 Puppet: Puppet 是帮助 Wechaty 操纵微信的工具，即微信接入方案。目前存在根据不同协议实现的版本(wechaty-puppet-padchat, wechaty-puppet-padpro,wechaty-puppet-mock等)。详细了解Puppet抽象类的层级结构，参见 Puppet Provider Interface Documentation。 Puppet常用方法梳理: 对于Wechaty中所提供的接口，部分接口的实现都会依赖于 Puppet 的抽象方法，再根据协议的不同进行实现。例如 wechaty-puppet-padpro 模块，该模块是一种基于 iPad 协议的对 Puppet 抽象方法的具体实现。  Message方法Message--&gt;messageSendText:发送文本信息Message--&gt;messageSendFile:根据FileBox的文件名后缀进行处理Message--&gt;messageFile:根据消息文件类型进行处理Message--&gt;messageSendContact:发送联系人名片Message--&gt;messagePayload:从缓存中获取message信息Message--&gt;messageForward:根据payload的type来判断消息类型处理 Contact方法Contact--&gt;contactRoomList:联系人群组列表Contact--&gt;contactList:联系人ID列表Contact--&gt;contactQrcode:联系人二维码Contact--&gt;contactPayload:从缓存中获取联系人信息Contact--&gt;contactSearch:查找联系人 Room方法Room--&gt;roomCreate:创建群组Room--&gt;roomTopic:群组的名称Room--&gt;roomQrcode:群组二维码Room--&gt;roomAdd:添加成员Room--&gt;roomDel:移出成员Room--&gt;roomList:群组列表Room--&gt;roomMemberList:群组成员列表Room--&gt;roomMemberPayload:加载群组成员Room--&gt;roomMemberSearch:查找群组成员 Friendship方法Friendship--&gt;friendshipAdd:添加好友Friendship--&gt;friendshipAccept:接受好友Friendship--&gt;friendshipPayload:从缓存中获取好友请求信息Puppet-Padpro: Puppet-PadPro 是 Puppet 基于 iPad 协议的一种实现方式，将 Puppet 中的抽象方法进行实现，是一种较成熟的微信接入方案。 padpro入门: 从 git 上下载 wechaty-puppet-padpro源码，从入口文件index开始，我们会发现项目的核心文件 puppet-padpro，一切的学习从这里开始。  引入模块     wechaty-puppet         引入 puppet 基类中的一些数据类型           pure-function-helpers         纯函数助手，用来解析一些数据，大多是对XML的解析           config         日志及基础配置文件           utils         工具类方法           padpro-manager         Padpro逻辑管理工具，主要是调用gRPC接口来实现相应的功能，也是该项目的核心之一           schemas         类型声明，对于业务处理所采用到的数据结构进行约束           以上介绍了 padpro 中所依赖的一些模块，可以看出 puppet-padpro 及 padpro-manager 这两个文件是 padpro 的核心。 进一步了解 padpro 从 puppet-padpro 的 start 方法开始。 GRPC及其优点: Padpro 采用 gRPC 取代 RESTful 作为通信方式。具体使用教程参见 GRPC quick start  谷歌开发的一个远程调用框架，现在已开源 使用了二进制编码，所以它比 JSON / HTTP 更快 明确的接口规范 支持流式传输三者之间的调用关系: 为了便于讨论，本文以 wechaty 中的 room. qrcode() 为例，来阐述三个模块之间的调用关系。 Wechaty API ⇒ room. qrcode   room. qrcode() ⇒ Promise &lt;string&gt;获取群二维码，用户可以通过扫描这个二维码加入群聊。 我们先看一下该 API 所执行的具体逻辑：   /**   * Get QR Code of the Room from the room, which can be used as scan and join the room.    * &gt; Tips:   * This function is depending on the Puppet Implementation, see [puppet-compatible-table](https://github. com/wechaty/wechaty/wiki/Puppet#3-puppet-compatible-table)   * @returns {Promise&lt;string&gt;}   */  public async qrcode (): Promise&lt;string&gt; {    log. verbose('Room', 'qrcode()')    const qrcode = await this. puppet. roomQrcode(this. id)    return qrcode  }该逻辑实现的过程中会依赖于 puppet 的 roomQrcode 方法，在 puppet 中 roomQrcode 方法只是一个抽象方法：   public abstract async roomQrcode (roomId: string) : Promise&lt;string&gt;我们知道 puppet 是 wechaty 微信接入方案的抽象，其具体的实现还需要看使用者所采用的puppet实现模块，例如 wechaty-puppet-padpro。当我们使用 padrpo 模块时，padpro 会继承并实现 puppet 中的所有抽象方法：   export class PuppetPadpro extends Puppet {    . . .   }padpro 对于 roomQrcode 的具体实现如下： public async roomQrcode(roomId: string): Promise&lt;string&gt; {  log. verbose(PRE, 'roomQrcode(%s)', roomId)  const memberIdList = await this. roomMemberList(roomId)  if (!memberIdList. includes(this. selfId())) {   throw new Error(`userSelf not in this room: ${roomId}`)  }  const result = await this. padproManager!. GrpcGetContactQrcode(roomId)  const base64 = result. QrcodeBuf  const roomPayload = await this. roomPayload(roomId)  const roomName  = roomPayload. topic || roomPayload. id  const fileBox   = FileBox. fromBase64(base64, `${roomName}-qrcode. jpg`)  const qrcode = await fileBoxToQrcode(fileBox)  return qrcode}源码阅读部分: 状态管理: 对于一些操作需要添加状态，确保其已经完成。wechaty 中采用 status 的 on 方法和 off 方法来判断启动和结束。这两个方法都会接收一个参数来表示当前该方法的状态，具体如下所示。  status. on()     ‘pending’         表示当前操作正在启动           true         表示当前操作启动成功            status. off()     ‘pending’         表示当前操作正在关闭           true         表示当前操作关闭成功           事件监听机制: 事件监听机制主要由事件源、事件对象、事件监听器三个部分组成。例如 room-join 事件：  事件监听器bot. on('room-join', msg =&gt; {}) 事件源bot. emit('room-join', messagePayload) 事件对象'room-join'padpro 通过 GRPC 接收到微信端推送过来的消息进行处理，根据处理后消息的类别来触发对应事件，并发送对应的数据。puppet 在监听到该事件时，将接收到的数据进行进一步处理，并携带处理后的数据继续向上层发送监听事件（对 puppet 的监听是在 wechaty-manager 中进行的）。使用者就可以通过监听 wechaty 所 监听到的事件，来对返回的数据进行处理。 为了更详细的了解 wechaty 中的数据流，我写了一篇博客来进行详细的介绍。关于 wechaty 中 room-join 事件的数据流。 介绍了这些，相信你结合官方API文档已经能够打造出属于自己的微信机器人了。如果你在开发过程中，有超 nice 的想法，并想为 wechaty 的发展贡献力量。那就让我们一起来合作开发吧！ 合作开发: 有兴趣参与 wechaty 开发的小伙伴们，可以从GitHub上将 wechaty、wechaty-puppet、wechaty-puppet-padpro 源码下载到本地，在开发项目中使用 npm link 将以上模块载入。便于Bug修复、业务拓展等的提交。 技术栈：Typescript Node. js 环境变量配置及使用:  WECHATY_NAME     设置该变量来控制启动的机器人      WECHATY_NAME= your-cute-bot-name  node bot. js    PADPRO_IP     传文件的时候在查询CDN之前需要配置本地公网IP      PADPRO_IP='192. 0. 0. 1' node bot. js    PADPRO_LOG     查看日志      PADPRO_LOG='silly' node bot. js    PADPRO_REPLAY_MESSAGE     bot发送的消息也会触发message监听事件      PADPRO_REPLAY_MESSAGE=true node bot. js    WECHATY_PUPPET_PADPRO_TOKEN     配置padpro的token      WECHATY_PUPPET_PADPRO_TOKEN='your padpro token' node bot. js    STORE_HOME     配置 FlashStore 缓存在磁盘中的位置      STORE_HOME='your store dir' node bot. js   详细日志查看: padpro中有详尽的日志层级系统，可以使用命令PADPRO_LOG='silly'来启动项目，从而查看对应等级的日志。通过日志的反应情况，可以明显的得知某功能所执行的具体逻辑过程，便于快速锁定问题。 npm link 的坑: 简单介绍以上三个模块之间的依赖关系：  wechaty 依赖于 wechaty-puppetwechaty-puppet-padpro 依赖于 wechaty-puppet 引入模块的步骤说明：  Note:以上三个模块都需要执行npm install安装项目依赖包 Step1  在模块 wechaty-puppet 中创建链接，执行以下命令 npm run dist // 编译 . ts 文件npm link // 创建链接Step2  在模块 wechaty 中引入依赖模块并创建链接，执行以下命令 npm link wechaty-puppet // 引入 puppet 模块npm run dist // 编译 . ts 文件npm link // 创建链接Step3  在模块 wechaty-puppet-padpro 中引入依赖模块并创建链接，执行以下命令 npm link wechaty-puppet // 引入 puppet 模块npm run dist // 编译 . ts 文件npm link // 创建链接Step4  在开发项目 my-wechaty-project 中引入链接，执行以下命令 npm link wechaty // 引入 wechaty 模块npm link wechaty-puppet-padpro // 引入 puppet-padpro 模块Step5  运行开发项目 my-wechaty-project，执行以下命令，并查看运行状态。 ts-node index. ts 若出现错误提示，请在模块 wechaty 及 wechaty-puppet-padpro 中重新执行 npm link 操作。作者: Su Chang，Node. js全栈工程师 "
    }, {
    "id": 357,
    "url": "https://wechaty.js.org/2019/07/08/data-stream-about-room-join-from-wechat-to-wechaty/",
    "title": "Data Stream about Room-Join Event from Wechat to Wechaty",
    "body": "2019/07/08 - 介绍wechaty中的room-join事件的产生，及其数据流的变化 问题: 当 Bot 在群组中邀请 Contact 进入群组时，从微信获取到的数据是如何转换为 room-join 事件的？ Step-1 从微信接入数据（msg）: 在用户登录时，padpro-manager 中的 onLogin() 方法会调用initData()方法来获取近期的微信消息（此消息不仅指微信聊天所发送的消息，还包括好友请求、群组操作、通知消息等，甚至当前所打开的聊天对话也会被当做微信消息传递过来），initData中以每500ms的频次，持续获取微信消息，存放在延时队列中并对得到的消息进行处理。 syncMessage()方法也会获取微信信息。这两个方法之所以能够接入微信消息，是由于分别依赖 GrpcNewInit() 和 GrpcSyncMessage()这两个方法想微信端发起消息请求。 请求到的消息 msg 具体格式如下，并对其进行简单解释。 {  MsgId: 1601421499, // 此条消息的唯一ID  FromUserName: '22949941039@chatroom', // 消息的来源，即邀人进群来自22949941039@chatroom群组  ToUserName: 'wxid_x01jgln69ath22', // 发起此操作的用户ID  MsgType: 10002, // 消息类型  // 此条消息的具体内容（xml格式）从消息中的汉字可以看出是一条邀请入群的通知信息  Content:  '22949941039@chatroom:\n&lt;sysmsg type= delchatroommember &gt;\n\t&lt;delchatroommember&gt;\n\t\t&lt;plain&gt;&lt;![CDATA[你邀请 桔小秘 加入了群聊 ]]&gt;&lt;/plain&gt;\n\t\t&lt;text&gt;&lt;![CDATA[你邀请 桔小秘 加入了群聊 ]]&gt;&lt;/text&gt;\n\t\t&lt;link&gt;\n\t\t\t&lt;scene&gt;invite&lt;/scene&gt;\n\t\t\t&lt;text&gt;&lt;![CDATA[ 撤销]]&gt;&lt;/text&gt;\n\t\t\t&lt;memberlist&gt;\n\t\t\t\t&lt;username&gt;&lt;![CDATA[wxid_3xl8j2suau8b22]]&gt;&lt;/username&gt;\n\t\t\t&lt;/memberlist&gt;\n\t\t&lt;/link&gt;\n\t&lt;/delchatroommember&gt;\n&lt;/sysmsg&gt;\n',  Status: 4,  ImgStatus: 1,  ImgBuf: null,  CreateTime: 1561637217, // 当前消息发生的时间  MsgSource: '',  PushContent: '',  NewMsgId: 5899126111507662000 // ？}msg 是从微信接入的信息，为了提取该信息中的内容为 padpro 服务，还需要进一步进行处理。即调用processMessages() 方法对 msg 消息进行加工。 Step-2 转化数据(msg =&gt; rawPayload): 在 processMessages() 方法中的根据 msg 中的消息类型进行处理，由于此条消息的类型为 10002 根据类型判断后，仅需要执行convertMessage() 方法，完成 msg 到 rawPayload 的转换。 当用户离线、未登录，或者掉线，此时 this. userId 不存在，会将此时到来的消息存放到 messageBuffer 中，当机器人上线之后，把之前存放到 messageBuffer 的消息再emit出来。 convertMessage()方法具体如下。 export const convertMessage = (input: GrpcMessagePayload): PadproMessagePayload =&gt; { try {  const convertedMessage = {   content   : input. Content,   data     : input. ImgBuf,   fromUser   : input. FromUserName,   messageId  : input. MsgId. toString(),   messageSource: input. MsgSource,   messageType : input. MsgType,   status    : input. Status,   timestamp  : input. CreateTime,   toUser    : input. ToUserName,  }  return convertedMessage } catch (e) {  log. error(PRE, `Converting message failed, failed message: ${JSON. stringify(input)}`)  throw e }}该方法将 msg 中对 padpro 有价值的信息进行提取，转换得到的 rawPayload 如下所示。 {  content: // 消息的具体内容，和 msg 中的一样  '22949941039@chatroom:\n&lt;sysmsg type= delchatroommember &gt;\n\t&lt;delchatroommember&gt;\n\t\t&lt;plain&gt;&lt;![CDATA[你邀请 桔小秘 加入了群聊 ]]&gt;&lt;/plain&gt;\n\t\t&lt;text&gt;&lt;![CDATA[你邀请 桔小秘 加入了群聊 ]]&gt;&lt;/text&gt;\n\t\t&lt;link&gt;\n\t\t\t&lt;scene&gt;invite&lt;/scene&gt;\n\t\t\t&lt;text&gt;&lt;![CDATA[ 撤销]]&gt;&lt;/text&gt;\n\t\t\t&lt;memberlist&gt;\n\t\t\t\t&lt;username&gt;&lt;![CDATA[wxid_3xl8j2suau8b22]]&gt;&lt;/username&gt;\n\t\t\t&lt;/memberlist&gt;\n\t\t&lt;/link&gt;\n\t&lt;/delchatroommember&gt;\n&lt;/sysmsg&gt;\n',  data: null,  fromUser: '22949941039@chatroom', // 消息的来源，即 `msg` 中的 FromUserName  messageId: '1601421499', // 消息ID，即`msg` 中的 MsgId  messageSource: '',  messageType: 10002, // 消息类型，即 `msg` 中的 MsgType  status: 4, // 消息状态，即 `msg` 中的 Status  timestamp: 1561637217, // 消息发生时的时间戳，即 `msg` 中的 CreateTime  toUser: 'wxid_x01jgln69ath22' // 发起此操作的用户ID，即 `msg` 中的 ToUserName}Step-3 发送转换后的数据: 当数据转换完毕，发送 message 事件，padpro中监听到该事件后，调用onPadproMessage()方法 根据消息类型 10002 判断为 PadproMessageType. Recalled 具体执行以下两件事  处理加入群组事件 onPadproMessageRoomEventJoin 处理消息撤回事件 onPadproMessageRecalled处理代码如下: switch (messageType) { . . .  case PadproMessageType. Recalled:  await Promise. all([   this. onPadproMessageRoomEventJoin(rawPayload),   this. onPadproMessageRecalled(rawPayload),  ])  break . . . }根据消息类型 10000 判断为 PadproMessageType. Sys 具体执行以下方法：  处理好友请求事件 onPadproMessageFriendshipEvent 处理加入群组事件 onPadproMessageRoomEventJoin 处理离开群组事件 onPadproMessageRoomEventLeave 处理变更群组名称事件 onPadproMessageRoomEventTopic处理代码如下: switch (messageType) { . . .  case PadproMessageType. Sys:  await Promise. all([   this. onPadproMessageFriendshipEvent(rawPayload),   this. onPadproMessageRoomEventJoin(rawPayload),   this. onPadproMessageRoomEventLeave(rawPayload),   this. onPadproMessageRoomEventTopic(rawPayload),  ])  break . . . }以上两种消息类型都会执行 onPadproMessageRoomEventJoin 方法，由于本文讨论 room-join 事件，根据接入微信消息的类型10002，所以下面暂时只介绍此条路线的逻辑。  结论：room-join判断的依据是通过消息内容，做正则表达式匹配之后判断的。因为入群消息只可能通过两种消息类型推送，所以对这两种类型做了处理。 Step-4 构造加入群组事件: 由Step-3可知，根据类型判断，我们能将该消息判断为加入群组事件。这里我们主要讨论一下如何从处理后的消息中提取出加入群组所需的信息。先简单介绍一下构造room-join事件的流程。  解析 rawPayload 提取 roomJoinEvent 事件 从 roomJoinEvent 中获取 inviteeNameList，inviterName，roomId信息 提取出 inviteeIdList 和 inviterId 发布room-join事件 --&gt;wechaty对于从 rawPayload 中提取 roomJoinEvent 事件，具体代码如下： if (!isPayload(rawPayload)) {  return null } const roomId = rawPayload. fromUser if (!isRoomId(roomId)) {  return null } let content = rawPayload. content /**  * when the message is a Recalled type, bot can undo the invitation  */ if (rawPayload. messageType === PadproMessageType. Recalled) {  /**   * content:   * ```   * 3453262102@chatroom:   * &lt;sysmsg type= delchatroommember &gt;   *  . . .   * &lt;/sysmsg&gt;   * ```   */  const tryXmlText = content. replace(/^[^\n]+\n/, '')  // 定义 XML 解析格式  interface XmlSchema {   sysmsg: {    $: {     type: 'revokemsg' | 'delchatroommember' | 'multivoip',    },    delchatroommember?: {     plain : string,     text : string,    },    revokemsg?: {     replacemsg : string,     msgid   : string,     newmsgid  : string,     session  : string,    },   }  }  // 解析 content 中的 XML 数据，提取有用信息  const jsonPayload: XmlSchema = await xmlToJson(tryXmlText) // toJson(tryXmlText, { object: true }) as XmlSchema  try {   // 根据解析得到的类型，判断应提取的信息   if (jsonPayload. sysmsg. $. type === 'delchatroommember') { // 本案例所执行的分支    content = jsonPayload. sysmsg. delchatroommember!. plain   } else if (jsonPayload. sysmsg. $. type === 'revokemsg') {    content = jsonPayload. sysmsg. revokemsg!. replacemsg   } else if (jsonPayload. sysmsg. $. type === 'multivoip') {    return null   } else {    throw new Error('unknown jsonPayload sysmsg type: ' + jsonPayload. sysmsg. $. type)   }  } catch (e) {   console. error(e)   console. log('jsonPayload:', jsonPayload)   throw e  }经过此代码块的处理，构造出 content 后，再根据中英文话术进行正则匹配，匹配成功后根据不同的邀请情况，提取所需信息。 加入群组的情景：  Bot Invite Other Other Invite Bot Other Invite Other Other Invite Other Qrcode正则匹配：目前根据以上四种场景，提供中文（ZH）和英文（EN）两种语言的话术匹配。  注意：若微信联系人入群的话术发生变化，或者所使用的系统语言非中文或者英文，则不会匹配成功，也就是不能发布 room-join 事件。 对于场景 Bot Invite Other：  根据系统当前的语言来分割被邀请人，构成 inviteeNameList 由于是 Bot 发起的邀请，因此 inviterName 设定为 YOU 根据前面已知的 roomId 和以上两个信息构建 PuppetRoomJoinEvent事件构造出的PuppetRoomJoinEvent事件方法如下：   // 构造 room-join 事件  const other = matches[1]  let inviteeNameList  if (languageEn) {   inviteeNameList = splitEnglishNameList(other)  } else if (languageZh) {   inviteeNameList = splitChineseNameList(other)  } else {   throw new Error('make typescript happy')  }  const inviterName: string | YOU = YOU  const joinEvent: PuppetRoomJoinEvent = {   inviteeNameList,   inviterName,   roomId,  }  return joinEvent构造出的PuppetRoomJoinEvent事件数据如下： {  inviteeNameList : 桔小秘  inviterName : Symbol(You)  roomId : 22949941039@chatroom}room-join 事件要发送给 wechaty，还需提取 wechaty 监听该事件所需的信息。具体数据如下，即将邀请人和被邀请人的id提取出来，也就是从Name到ID的转化。 此处对于被邀请人列表的处理需要注意，要将 inviteeName 转化为 inviteeID，需要执行操作 this. roomMemberSearch(roomId, inviteeName)  关于roomMemberSearch：由于查找的 inviteeName 存在三种可能roomAlias，name，contactAlias。因此，需要对每种情况进行查询，并将结果汇总到一个数组中，进行去重操作。此处我们得到的 inviteeName 为一个数组。且数组中只有一个元素。 每个 inviteeName 的查询操作互不影响，可以使用Promise. all()方法进行并行处理。由于 roomMemberSearch 方法返回的是一个数组，因此需要将该结果进行 flatten 处理，从而返回一个 inviteeIDList。 若获取 inviteeIDList 出错，则会清除当前群组成员的缓存数据，并抛出异常。 这里引入 promise-retry 模块执行重试操作。retry中定义了重试的次数，最大最小超时时间，以及 factor 来控制速率的增长。  factor: 3 minTimeout: 10 maxTimeout: 20 * 1000 retries: 9增加retry的动机：当入群发生的时候，群成员的数量是发生了变化的，这个变化的同步需要一点时间，有可能在查询进群的人，和邀请的人的时候，群成员数据并没有同步过来，如果没有同步完整，那么就查找不到这个群成员。找不到群成员之后，会把本地这个群的缓存数据删掉，然后重新查找，第二次查找的时候就会因为没有缓存数据而从微信的接口去获取，这样就能更新群数据，从而最后找到这个群成员的信息。 经过以上过程处理，得到的数据如下： {  roomId : 22949941039@chatroom  inviteeIdList: wxid_3xl8j2suau8b22  inviterId: wxid_x01jgln69ath22}在提取以上数据的同时，由于对群组新增了成员，因此需要在缓存中清除该群组的数据（包括群组和群组成员）。 处理好这些之后，就可以向 wechaty 发送 room-join 事件了。以上完成了onPadproMessageRoomEventJoin()方法的调用。 由于room-join事件是可以撤回的，因此，该方法主要通过正则匹配，从 rawPayload 信息中的 content 判断该条消息是否为撤回消息。TODO Step-5 wechaty中监听room-join事件: 在 wechaty 初始化时，对puppet监听了 room-join 事件，加载并将其转发给wechaty。先简单介绍下所执行的流程：  获取room 获取inviteeList，并同步每个联系人的数据 获取inviter 发布事件     发布 room-join 事件--&gt;wechaty   发布 join 事件 --&gt;room   具体代码如下： puppet. on('room-join', async (roomId, inviteeIdList, inviterId) =&gt; {  const room = this. Room. load(roomId)  await room. sync()  const inviteeList = inviteeIdList. map(id =&gt; this. Contact. load(id))  await Promise. all(inviteeList. map(c =&gt; c. ready()))  const inviter = this. Contact. load(inviterId)  await inviter. ready()  this. emit('room-join', room, inviteeList, inviter)  room. emit('join', inviteeList, inviter)})break此时得到的数据如下所示： {  inviteeList: Contact&lt;桔小秘&gt;  inviter: Contact&lt;a壁虎阿八&gt;  room: Room&lt;Room-Join-Test&gt;}Step-6 监听 room-join 事件: Step-6. 1 wechaty 中监听 room-join 事件: wechaty中的监听方法及声明： public on (event: 'room-join', listener: string | ((this: Wechaty, room: Room, inviteeList: Contact[], inviter: Contact) =&gt; void)) : thispublic on (event: WechatyEventName, listener: string | ((. . . args: any[]) =&gt; any)): this关键代码片段： if (typeof listener === 'function') { this. addListenerFunction(event, listener)} else { this. addListenerModuleFile(event, listener)}Step-6. 2 room 中监听 join 事件: room中的监听方法及声明 public on (event: 'join', listener: (this: Room, inviteeList: Contact[], inviter: Contact) =&gt; void) : thispublic on (event: RoomEventName, listener: (. . . args: any[]) =&gt; any): this 作者: Su Chang，Node. js全栈工程师 "
    }, {
    "id": 358,
    "url": "https://wechaty.js.org/2019/06/21/three-step-get-girlfriend/",
    "title": "三步教你用Node做一个微信脱单神器，小白可上手",
    "body": "2019/06/21 - 三步教你用Node做一个微信脱单神器，小白可上手！也可以用来哄女友，哄女(男\基)友我们程序猿(媛)是认真的 前言: 不知道大家最近有没有被python版的《微信每日说》刷屏呢，他可是霸占了github的python热门快两周了。我们前端的小伙伴是不是也看着有点眼馋呢，因为毕竟是不那么熟悉的python语言，学起来和用起来肯定没有那么舒服。想想要是用我们熟悉的js语言做一个属于自己的哄女友神器是不是很开心呢！😆 哄女友我们前端开发人员也是很认真的，自动哄女友(基友)神器我们也可以做！ 项目介绍: 其实《微信每日说》小项目早在三月份都已经做好了，当时也发布了一篇文章《用Node+wechaty写一个爬虫脚本每天定时给女(男)朋友发微信暖心话》，有看过的朋友应该有印象的。由于上次分享的文章比较偏向于技术，被朋友说可能不太适合小白用户使用，在他的建议下呢，我又重新整理了一下现有代码，和制作了教学视频，方便任意人群的使用。 同时呢我也维护了两套项目，一个是本项目《微信每日说》适合入门人群，操作简单，配置方便，上手容易。另一个项目是《微信个人秘书》，功能较多，涵盖自动加群、自动加好友、自动回复、可设置定时提醒等功能。由于涉及到数据库的操作，所以主要面向有编程经验的群体，有兴趣的小伙伴可以参考《使用koa2+wechaty打造个人微信小秘书》。 本文介绍项目是用node和wechaty微信网页接口开发的一款小工具，可以定时给女朋友发每天的天气情况，天气提醒，每日一句。通过配置机器人api后还可以实现微信机器人自动陪女朋友聊天。 项目地址: github: https://github. com/gengchen528/wechatBot 看看前端的小伙伴能不能把这个项目送上热门呢 哈哈 效果预览: 在三步走教学之前，先放上效果看一下  可以看到在指定的时间就会收到发送的消息，包括天气信息，天气提醒，还有你们在一起多少天了。当开启机器人后，女朋友就可以和小助手对话了，不过目前开源机器人的api都不是非常的智能，匹配的语义可能不是那么准确。所以有时候女朋友生气了，千万记得不要开启机器人，不然回答的不对是会被女朋友暴打的😨！ 此项目前期使用的是图灵机器人，但是最近图灵机器人做了限制，没有认证的用户不允许调取API，认证的用户每天也只有100条，这就很鸡肋了，女朋友还没哄过瘾呢就被限制了，这是很可怕的（手动滑稽）！所以现在更换了一个天行机器人的api接口，这个接口没有太多限制，送的调用次数也足够用，在项目中已经开放给大家用了，不过还是建议大家自己申请一个账号比较好，因为这个机器人可以自定义名称之类的，也可以设置自己需要的回复内容。 视频教程:  三步走教程: 一、安装node: node官网：https://nodejs. org/zh-cn/ 选择系统对应版本node下载安装，win建议. msi包安装，只需一直下一步即可，其他系统同理；  windows下安装node步骤详细参考 https://www. cnblogs. com/liuqiyun/p/8133904. htmlMac下安装node详细步骤参考 https://blog. csdn. net/qq_32407233/article/details/83758899Linux下安装node详细步骤参考 https://www. cnblogs. com/liuqi/p/6483317. html 安装完成后，按住键盘的shift+鼠标右键，选择在此处打开命令窗口。在命令行执行node -v出现版本号说明安装成功 二、下载代码并配置: 代码地址：https://github. com/gengchen528/wechatBot  访问此地址，直接下载zip包到本地桌面，然后解压；  进到目录中，找到config目录下的index. js文件  选中index. js文件，右击选择打开方式，没有安装代码编辑器的可以用记事本打开。有代码编辑器的直接用代码编辑器打开,建议非开发人员可以下载一个notepad++，下载链接链接:https://pan. baidu. com/s/1mWdEOaTQ1D6kihQveN1JHw 密码:fn9g，开发人员就各自发挥吧，相信每个人都有自己用的比较舒服的编辑器我就不推荐了  配置文件中需要修改的地方，女朋友的微信备注姓名NAME必须要换一下，不然你发给我就不好了😂，微信昵称NICKNAME最好也写一下，你和女朋友的纪念日MEMORIAL_DAY就不用说了，也要改一下。 如果要发送天气信息，女朋友所在城市CITY肯定也是必须修改的，地区LOCATION不知道怎么拼写的话，我建议可以查一下墨迹的官网https://tianqi. moji. com/weather/china/  在墨迹天气找到对应地区的天气后，查看一下网页地址栏，绿色标记的拼音填入CITY，红色标记的拼音填入LOCATION  每天发送的时间SENDDATE，这里的规则可以参见schedule目录下的index. js文件。这里0 06 8 * * *代表的是每天的早上8点06分0秒，我们通常只需配置前三个就可以了。 如果需要开启机器人聊天的话，需要把AUTOREPLY设置为true，这里我放弃了图灵机器人，原因上面也说了，改用了天行机器人，但是不要抱太大希望，它并不是那么智能😂。目前由于我自己账号的api次数还比较多，就在项目代码中开放给大家使用了，这里就不放出来，下载代码后只要修改一下AUTOREPLY就可以自动回复了。// 配置文件module. exports = {  // 基础定时发送功能配置项（必填项）  NAME: 'Leo_chen', //女朋友备注姓名  NICKNAME: 'Leo_chen', //女朋友昵称  MEMORIAL_DAY: '2015/04/18', //你和女朋友的纪念日  CITY: 'shanghai', //女朋友所在城市  LOCATION:  pudong-new-district , //女朋友所在区（可以访问墨迹天气网站后，查询区的英文拼写）  SENDDATE: '0 06 8 * * *', //定时发送时间 每天8点0分0秒发送，规则见 /schedule/index. js  ONE: 'http://wufazhuce. com/', ////ONE的web版网站  MOJI_HOST: 'https://tianqi. moji. com/weather/china/', //中国墨迹天气url  //高级功能配置项（非必填项）  AUTOREPLY: true, //自动聊天功能 默认关闭  AIBOTAPI: 'http://api. tianapi. com/txapi/robot/', //天行机器人API 注册地址https://www. tianapi. com/signup. html?source=474284281  APIKEY: '天行机器人apikey', //天行机器人apikey}三、开始运行程序: 配置完成好文件别忘记保存了，保存好就回到项目的主目录吧。这时候win系统的话就按住键盘的shift+鼠标右键，选择在此处打开命令窗口。  然后输入npm install。  等待安装完成后输入npm run start，这时会下载一个文件，因为比较大，所以要多等一下，等待出现二维码的时候就可以拿出手机微信扫一扫登录了。接下来就是一顿神对话了😆  如果执行npm run start遇到失败的话，先执行npm install wechaty-puppet-puppeteer@^0. 17. 14 --no-save然后再执行npm run start常见问题处理:  先检查node版本是否大于10 存在package-lock. json文件先删除 删除node_modules后重新执行npm install 也可添加小助手微信后，发送'加群'进入微信每日说技术交流群 我的微信号无法登陆     从2017年6月下旬开始，使用基于web版微信接入方案存在大概率的被限制登陆的可能性。 主要表现为：无法登陆Web 微信，但不影响手机等其他平台。 验证是否被限制登陆： https://wx. qq. com 上扫码查看是否能登陆，不能登录的话，那你可能就无法用这个工具了。 更多内容详见：   Can not login with error message: 当前登录环境异常。为了你的帐号安全，暂时不能登录web微信。   [谣言] 微信将会关闭网页版本   新注册的微信号无法登陆    执行npm run start时无法安装puppet-puppeteer&amp;&amp;Chromium   Centos7下部署出现以下问题 问题原因:https://segmentfault. com/a/1190000011382062 解决方案:   #依赖库 yum install pango. x86_64 libXcomposite. x86_64 libXcursor. x86_64 libXdamage. x86_64 libXext. x86_64 libXi. x86_64 libXtst. x86_64 cups-libs. x86_64 libXScrnSaver. x86_64 libXrandr. x86_64 GConf2. x86_64 alsa-lib. x86_64 atk. x86_64 gtk3. x86_64 -y #字体 yum install ipa-gothic-fonts xorg-x11-fonts-100dpi xorg-x11-fonts-75dpi xorg-x11-utils xorg-x11-fonts-cyrillic xorg-x11-fonts-Type1 xorg-x11-fonts-misc -y    windows下，下载puppeteer失败 执行一下npm install wechaty-puppet-puppeteer@^0. 17. 14 --no-save注意: 本项目属于个人兴趣开发，开源出来是为了技术交流，请勿使用此项目做违反微信规定或者其他违法事情，请勿商用。建议使用小号进行测试，有被微信封禁网页端登录权限的风险（客户端不受影响），请确保自愿使用。因为个人使用不当导致网页端登录权限被封禁，均与作者无关，谢谢理解 最后: 如果有微信号无法登录和有技术问题需要交流，可以加我的微信小助手后发送加群，会自动发送交流群的二维码，同时此小号有更多高级功能等待你的发现。（注：添加好友后会在20s内自动通过） 赶快亲自试一试吧，相信你会挖掘出更多好玩的功能 另外我的公众号已经接入微软小冰，关注后发语音会有小姐姐的声音陪你聊天，也可以和她文字聊天，有兴趣可以试试看，单身的欢迎来撩  作者: Leo_chen，前端工程师，喜欢使用node做各种小项目，就职于大数据公司。本篇文章首发于掘金: 三步教你用Node做一个微信哄女友(基友)神器，小白可上手 "
    }, {
    "id": 359,
    "url": "https://wechaty.js.org/2019/06/13/wechaty-as-a-service-why-and-how/",
    "title": "Wechaty-As-A-Service Why and How",
    "body": "2019/06/13 - 代码 这里作者分享一下为什么要做这个Wechaty-As-A-Service的东东，它如何将Wechaty服务化，在什么场景下应用的。 为什么需要Wechaty: Wechaty是对接微信的工具，这个工具在今天已经很成熟，也有充足的社区的支持。 作者的想法是希望使用一个能方便支持桌面端、移动端的机器人入口平台。目的是开发机器人，接入一个API入口，这个入口如果是放在全球角度有很多合适的方法，但是因为某原因很多服务不能用，国内很少有这样的开放平台，大部分IM的平台都保守且很难接入。 在使用Wechaty之前，作者使用的是接入slack，但是经常在不同网络下延迟很大。 为什么需要Wechaty-As-A-Service（waas）: 首先一个原因是作者的bot是Python的，而Wechaty是基于JavaScript的。那么当然也有另一种选择，就是作者把bot变成一个服务，而用Wechaty作为客户端接入，之所以没有这样做是因为：  Wechaty应该持续服务。它如果能保持稳定运行，那么无论后端如何改变，也不需要重启Wechaty或者重登录了。 Wechaty作为服务之后，作为客户端的机器人就可以任意发挥，使用任何语言或者方法都没问题。如何实现: 按照 @huan 的说法，Wechaty之后会有基于gRPC的服务接口，很可惜现在没有。 这里作者选择了用一个简单的Web Server实现Wechaty的服务化。  优点：简单 缺点：用轮询方法，损耗一定资源首先我们选择了koa作为web服务框架。遇到的第一个问题就是koa是需要持续服务的，Wechaty也需要，也就是说它们相当于各自默认都会阻塞一个线程，而JavaScript默认是单线程的，这样显然不行。 解决方法是Wechaty单独在一个worker线程运行，这里使用NodeJS 10及之后版本支持的worker_threads方法，这个方法要在10版本的NodeJS使用需要增加参数-experimental-worker 首先bot-worker. js的实现代码类似这样： import process from 'process'import { Wechaty } from 'Wechaty'import { parentPort } from 'worker_threads';// bot实例const bot = Wechaty. instance({profile: 'Wechaty-bot'}) // Global Instance// 这里几个函数是分别将Wechaty的几个类序列化（这里并不完全，只取了作者需要的信息）// 序列化Message类（消息）async function serializeMessage(message) {  if (!message) {    return null  }  let obj = {}  obj. id = message. id  obj. from = await serializeContact(message. from())  obj. to = await serializeContact(message. to())  obj. room = await serializeRoom(message. room())  obj. text = message. text()  obj. date = await message. date()  return obj}// 序列化Contact类（联系人）async function serializeContact(contact) {  if (!contact) {    return null  }  let obj = {}  obj. id = contact. id  obj. name = contact. name()  obj. alias = await contact. alias()  obj. isFriend = contact. friend()  obj. gender = contact. gender()  obj. province = contact. province()  obj. city = contact. city()  obj. isSelf = contact. self()  return obj}// 序列化Room类（群）async function serializeRoom(room) {  if (!room) {    return null  }  let obj = {}  obj. id = room. id  obj. topic = await room. topic()  obj. announce = await room. announce()  return obj}// 这里接收来自主线程（koa）的控制信号parentPort. on('message', async message =&gt; {  const {event, data} = message  if (event === 'message') { // 只有一个，就是发送信息，暂时没实现别的    const {topic, name, text} = data    if (!text) {      return    }    let contact = null    let room = null    if (name) {      contact = await bot. Contact. find({name})    }    if (topic) {      room = await bot. Room. find({topic})    }    if (room &amp;&amp; contact &amp;&amp; await room. has(contact)) {      room. say(`@${contact. name()} ${text}`)    } else if (room) {      room. say(text)    } else if (contact) {      contact. say(text)    }  }})bot. on('scan', (qrcode, status) =&gt; {  qrurl = `https://api. qrserver. com/v1/create-qr-code/?data=${encodeURIComponent(qrcode)}`  console. log(`Scan QR Code to login: ${status}\n${qrurl}`)  // 当需要扫码时，发一个消息给主线程，这样client也能从koa中获取到这个二维码链接  parentPort. postMessage({    event: 'scan',    data: qrurl  })}). on('login', user =&gt; {  console. log(`User ${user} logined`)  // 当登录成功时告诉主线程，这样client也能知道登录成功了  parentPort. postMessage({    event: 'login',    data: user  })}). on('logout', (user) =&gt; {  // Logout Event will emit when bot detected log out.   console. log(`user ${user} logout`)  // 告诉主线程清除登录信息  parentPort. postMessage({    event: 'logout',    data: user  })}). on('message', async (message) =&gt; {  if (message. age() &gt; 60 * 1000) {    console. log('Message discarded because its TOO OLD(than 1 minute)')    console. log(message)    return  }  if (message. self()) {    console. log('Message discarded because its mysel')    return  }  console. log(`Message: ${message}`)  // 把消息发送给主线程，client就可以通过不断轮询来获取  parentPort. postMessage({    event: 'message',    data: await serializeMessage(message)  })}). start()主线程代码 import process from 'process'import Koa from 'koa'import Router from 'koa-trie-router'import bodyParser from 'koa-bodyparser'import { Worker } from 'worker_threads'import lodash from 'lodash'// 保存bot状态，以便被client轮询const botStatus = {  qrurl: null,  login: null,  messages: []}// 启动Wechaty线程const worker = new Worker('. /bot-worker. js')worker. on('message', message =&gt; {  const {event, data} = message  // 收到不同的Wechaty信息的时候，改变不同的bot状态，这样客户端也可以读取到状态的变化了  switch(event) {    case 'scan':      botStatus. qrurl = data      break    case 'login':      botStatus. login = data      break    case 'logout':      botStatus. login = null      botStatus. qrurl = null      botStatus. messages = []    case 'message':      botStatus. messages. push(data)      break    case 'error':      process. exit(1)      break  }})// 这里再往下主要是koa的接口了，也就似乎跟client对接的let app = new Koa()let router = new Router()app. use(bodyParser());router. get('/', async ctx =&gt; {  ctx. body = 'Why you here?'}). get('/api/scan', async ctx =&gt; {  /**   * 获取二维码接口   * curl localhost:3010/api/scan | jq .   */  if (botStatus. qrurl) {    ctx. body = {      ok: true,      qrurl: botStatus. qrurl,    }  } else {    ctx. body = {      ok: false,      error: 'Not initialized',    }  }}). get('/api/status', async ctx =&gt; {  /**   * 状态查询接口   * curl localhost:3010/api/status | jq .   */  if (botStatus. login) {    ctx. body = {      ok: true,      login: botStatus. login    }  } else {    ctx. body = {      ok: false,      error: 'Not login',    }  }}). get('/api/message', async ctx =&gt; {  /**   * 获取消息接口   * curl localhost:3010/api/message | jq .   */  if (botStatus. login) {    ctx. body = {      ok: true,      // 每次只发送最后的5条不超过5分钟的信息      messages: botStatus. messages. slice(        Math. max(botStatus. messages. length - 5, 0)      ). filter(msg =&gt; {        const now = new Date()        if (now - msg. date &gt; 5 * 60 * 1000) {          return false        }        return true      })    }  } else {    ctx. body = {      ok: false,      error: 'Not login',    }  }}). post('/api/message', async ctx =&gt; {  /**   * 发送消息接口   * curl -H 'Content-Type: application/json' -XPOST localhost:3010/api/message -d '{ name :  superman ,  text :  hello }' | jq .   */  if (!ctx. request. body) {    ctx. body = {      ok: false,      error: 'Invalid post body, not a JSON'    }    return  }  if (!lodash. isString(ctx. request. body. name) &amp;&amp; !lodash. isString(ctx. request. body. topic)) {    ctx. body = {      ok: false,      error: 'Invalid name or topic, must have one of them'    }    return  }  if (!lodash. isString(ctx. request. body. text)) {    ctx. body = {      ok: false,      error: 'Invalid text'    }    return  }  worker. postMessage({    event: 'message',    data: ctx. request. body,  })  ctx. body = {    ok: true,  }})app. use(router. middleware())app. listen(3010, '0. 0. 0. 0', () =&gt; {  console. log('SERVER GREEN')})如何使用: 客户端的实现代码 import timeimport jsonimport requestsBOT_API = 'http://localhost:3010/api/'class WAAS(object):  # 初始化bot，保存机器人服务api的地址  def __init__(self, api=BOT_API):    if not api. endswith('/'):      api = api + '/'    self. api = api    self. qrurl = None    print(f'Running on api {api}')  # 获取状态，如果登录之后会返回True，否则是False  def status(self):    r = requests. get(self. api + 'status', timeout=10)    r = json. loads(r. text)    if r. get('ok'):      return True    return False  # 当需要扫码时，打印二维码地址，让用户可以点击-扫码-登录  # 如果服务端还没获取到二维码会不断的停在这重复测试  def scan(self):    while True:      r = requests. get(self. api + 'scan', timeout=10)      r = json. loads(r. text)      if r. get('ok'):        self. qrurl = r. get('qrurl')        return      print(r. get('error', 'Unknown error'))      time. sleep(5)  # 不断测试登录状态，成功后返回  def login(self):    while True:      r = requests. get(self. api + 'status', timeout=10)      r = json. loads(r. text)      if r. get('ok'):        return      print(r. get('error', 'Unknown error'))      time. sleep(5)  # 获取消息  # 注意这个函数是一个generate函数，因为返回的是yield  def message(self):    exists_messages = {}    while True:      r = requests. get(self. api + 'message', timeout=10)      r = json. loads(r. text)      if r. get('ok'):        for msg in r. get('messages', []):          # 判断id是否重复          if msg. get('id') not in exists_messages:            exists_messages[msg. get('id')] = msg            yield msg      time. sleep(0. 2)  # 给远程koa发送消息  # koa会再给Wechaty发送消息  # 最终发送给用户  def send_message(self, text, name=None, topic=None):    body = {      'name': name,      'topic': topic,      'text': text    }    r = requests. post(self. api + 'message', timeout=10, json=body)    r = json. loads(r. text)    if not r. get('ok'):      print(r. get('error', 'Unknown error'))  # 这个是一个启动流程，相当与Wechaty的start、flask的run，nodejs的listen  def start(self, on_message):    # 如果是未登录状态就去寻求获取二维码    # 保证如果waas一直运行并且在登录，bot客户端任意重启也不会导致重复登录    if not self. status():      self. scan() # wait qrurl generate      print(f'Please scan {self. qrurl}')      self. login() # wait login    print('logined')    # 不断的轮询信息，如果有新信息会交给 on_message的回调函数    for msg in self. message():      print(msg)      on_message(self, msg)实际使用bot的代码： from waas_client import WAAS# 消息回调函数def on_message(bot, msg):  text = msg. get('text') # 文本消息  # 发来的用户，可能是空的，例如是群消息  from_name = msg. get('from', {}). get('name')  # 发来的群，如果是私信就是空的  room_topic = msg. get('room', {}). get('topic')  if text:    # 发送信息    bot. send_message(text, name=from_name, topic=room_topic)if __name__ == '__main__':         这里构造一个WAAS实力并把回调函数给到bot. start，就可以一直在监守了    当然这里也可以自己调用类似bot. start里面的类似方法，手动运行，例如：    if not bot. status():      bot. scan() # wait qrurl generate      print(f'Please scan {bot. qrurl}')      bot. login() # wait login    print('logined')    # 不断的轮询信息，如果有新信息会交给 on_message的回调函数    for msg in bot. message():      print(msg)      on_message(bot, msg)       bot = WAAS('http://localhost:3010/api/')  bot. start(on_message)缺陷与未来: 缺陷：  轮询效率低 没有安全性 没有做容错 实现功能少 很多Wechaty的功能都需要一个一个实现这些主要是因为基本功能已经足够满足作者需求，所以暂时开发到这里。这些功能理论上都可以通过其他方法修改，例如把轮询换成一个长链接协议，例如websocket，例如gRPC。容错需要考虑错误的传播路径，好做但是比较繁琐。 未来还是期待Wechaty推出gRPC功能，真正实现Wechaty-As-A-Service  Author: qhduan, A Deamer. "
    }, {
    "id": 360,
    "url": "https://wechaty.js.org/2019/06/12/chatie-devops-toolset/",
    "title": "New DevOps Toolset for @Chatie Organization",
    "body": "2019/06/12 - The powerful and easy to use Chatie DevOps Toolset:  @chatie/tsconfig: Enables other module to inheritance tsconfig. json via Node. js packages @chatie/eslint-config: ESLint Sharable Rules in TypeScript Standard Style @chatie/semver: The Enhanced Semantic Versioner for NPM @chatie/git-scripts: Git Hooks Integration for Chatie Projects tstest: A pytest in TypeScript pkg-jq: Find the nearest package. json then deal with jq syntax on it. (in-line edit supported!)DevOps is king. Chatie dependents DevOps for years and it works great. We have dozens of projects with repositories hosted on GitHub, and publish them to NPM right after a commit &amp; push, through the DevOps pipeline, which mainly under the control of Travis CI. We had build lots of helper scripts to do those tasks automatically, and today, we had published most of them to NPM modules, so that we will no longer need to copy them everywhere, and we can use NPM version to manage them very well. So, I’d like to introduce them to the community, and also it’s a quick sheet to check. 1. @chatie/tsconfig: This module enables other module to inheritance tsconfig. json via Node. js packages. All you need is to: npm install @chatie/tsconfigThen it will create a very nice tsconfig. json at the root of project for you, and you will also get the latest TypeScript &amp; ts-node binarys installed. {  extends :  @chatie/tsconfig ,  compilerOptions : {   outDir :  dist , },  exclude : [   node_modules/ ,   dist/ ,   tests/fixtures/ , ],  include : [   app/**/*. ts ,   bin/*. ts ,   bot/**/*. ts ,   examples/**/*. ts ,   scripts/**/*. ts ,   src/**/*. ts ,   tests/**/*. spec. ts , ],}After extends from @chatie/tsconfig from your tsconfig. json, you will have the chatie version of the TypeScript Configuration, it aim the following goals:  Support the latest esnext ECMAScript Targeting for ES6 Strict for everything Aiming for Convenience, including the esModuleInterop and resolveJsonModule etc. 2. @chatie/eslint-config: ESLint Sharable Rules in TypeScript Standard Style. npm install --save-dev @chatie/eslint-configThen it will create a very nice . eslintrc. js for you automatically (if there’s no such file before). It will contains the following content: module. exports = { extends: '@chatie',}Then you are all set. . /node_modules/. bin/eslint will work and follow the @chatie rules. 3. @chatie/git-scripts: Git Hooks Integration for Chatie Projects. This module is a wrapper of the NPM module git-scripts, it provide following additional features:  pre-push hook had been set to run npm run lint and then npm verion patch for better code quality and version management. By adding the following json entrance to package. json:   git : {   scripts : {    pre-push :  npx git-scripts-pre-push   } }4. @chatie/semver: The Enhanced Semantic Versioner for NPM. This module is a wrapper of the NPM module semver, it provide cli utility for identifying whether the VERSION is for production(stable). $ semver-is-prod 1. 0. 0YES: 1. 0. 0 is production release$ echo $?0$ semver-is-prod 1. 1. 0NO: 1. 1. 0 is development release$ echo $?1Background: Copy from Linux Kernel Version Numbering - http://www. linfo. org/kernel_version_numbering. html:  The second number denotes the major revision of the kernel version. It was formerly the case that even numbers indicated a stable release, that is, one that was deemed fit for production use (i. e. , use in a non-experimental environment), such as 1. 2, 2. 4 or 2. 6. Likewise, odd numbers, such as 1. 1 or 2. 5, have historically represented development releases. They were for testing new features and device drivers until they became sufficiently stable to be included in a stable release. However, this has changed starting with the Linux 2. 6. x series, and new feature development now takes place in the same revision number. Following the Semantic Versioning 2. 0 http://semver. org/, and we will be able to use the MINOR version to indicated the release is STABLE or NOT. Numbering rule:  even numbers, such as 0. 8, 0. 12 indicated a stable release, which is fit for production use.  odd numbers, such as 0. 11 or 0. 13, represented as development releases. See also: https://github. com/wechaty/wechaty/issues/905 5. tstest: A pytest in TypeScript This module is planed to be a TypeScript version of pytest However, currently, it’s only a wrapper of blue-tape and @types/blue-tape 6. pkg-jq: Find the nearest package. json then deal with jq syntax on it. (in-line edit supported!) Features:  Search package. json in current and all parent directories by default, powered by pkg-up.  Use jq syntax to deal with the json file, powered by node-jq.  In-place edit support by specify a -i or --in-place argument. Example: 1. generate-version. sh: This helper script will automatically generate a src/version. ts with the version number from the package. json file of the current project. #!/usr/bin/env bashset -eSRC_VERSION_TS_FILE='src/version. ts'[ -f ${SRC_VERSION_TS_FILE} ] || { echo ${SRC_VERSION_TS_FILE}  not found  exit 1}VERSION=$(npx pkg-jq -r . version)cat &lt;&lt;_SRC_ &gt; ${SRC_VERSION_TS_FILE}/** * This file was auto generated from scripts/generate-version. sh */export const VERSION: string = '${VERSION}'_SRC_2. package-publish-config-tag. sh: This helper script will set the NPM module version to @next if the semver is not production, and set to @latest if the semver is production. #!/usr/bin/env bashset -eVERSION=$(npx pkg-jq -r . version)if npx --package @chatie/semver semver-is-prod $VERSION; then npx pkg-jq -i '. publishConfig. tag= latest ' echo  production release: publicConfig. tag set to latest.  else npx pkg-jq -i '. publishConfig. tag= next ' echo 'development release: publicConfig. tag set to next. 'fi3. Scripts for Installing Chatie DevOps Toolsets for Existing Project: # package. json jq modification utilnpm install --save-dev pkg-jq## @chatie/tsconfig## @chatie/tsconfig will re-generate it automaticallyrm -f tsconfig. jsonnpm uninstall \ @types/node \ ts-node \ typescript \npm install --save-dev @chatie/tsconfig## @chatie/eslint-config## @chatie/eslint-config will re-generate it automaticallyrm -f . eslintrc. *npm uninstall \ @wwwouter/tslint-contrib \ eslint \ markdownlint-cli \ tslint \ tslint-config-standard \ tslint-eslint-rules \ tslint-jsdoc-rules \npm install --save-dev @chatie/eslint-confignpx pkg-jq -i  . scripts. \ lint:es\ =\ eslint --ignore-pattern tests/fixtures/ '{bin,examples,scripts,src,tests}/**/*. ts'\  ## @chatie/git-scripts#npm uninstall git-scriptsnpx pkg-jq -i 'del(. git)'npm install --save-dev @chatie/git-scripts## @chatie/semver#npm uninstall \ @types/semver \ semver \npm install --save-dev @chatie/semver## tstest#npm uninstall \ @types/blue-tape \ @types/sinon \ blue-tape \ sinon \ sinon-test \npm install --save-dev \ tstest \## Other Settings## Set default npm publish tag to @next instead of @latestnpx pkg-jq -i '. publishConfig. tag= next ' Author: huan, A DevOps fan. "
    }, {
    "id": 361,
    "url": "https://wechaty.js.org/2019/05/11/remind-eat-bot/",
    "title": "居然有人能忘记吃饭？写个微信机器人提醒他",
    "body": "2019/05/11 - 居然有人忘记吃饭？？？ 为了解决这个问题，我写了一个微信机器人到点就提醒他吃饭。 Github 地址 使用方法: git clone https://github. com/diaozxin007/remindEat修改 config/default. json 里面的 ‘toName’ 为要提醒人的备注名称。 cd remindEatnpm installwechaty 使用了无头浏览器，安装的过程中会到 google 下载 chromium。如果遇到下载不成功的错误。可以尝试 export PUPPETEER_DOWNLOAD_HOST=https://storage. googleapis. com. cnpmjs. orgnpm install编译完成后： node remindEat. js如果在 ubuntu 上启动报错缺少包，可以参考 puppeteer/docs/troubleshooting. md 到时候对方应该不会忘记吃饭了。 实现原理：: 这个机器人主要使用两个库：  wechaty 一个 node 实现的微信机器人。 node-schedule 一个定时任务触发器。其实核心的原理，就在 wechaty 登录以后，注册了一个定时任务。这个定时任务，用于在饭点的时候，注册另外一个 schedule ，同时这个 schedule 是为了实现每分钟一次的提示。 当对方按照指定的话术服务短信的时候，我们只需要调用每分钟提醒一次的 schedule cancel() 方法。 希望每一个人都能按时吃饭，谢谢大家。  Author: 犀利豆 北邮本科，University of Leicester EE 研究生，Java后端开发，目前就职知乎。  原文地址 "
    }, {
    "id": 362,
    "url": "https://wechaty.js.org/2019/04/02/node-wechaty-spider/",
    "title": "用Node+wechaty写一个爬虫脚本每天定时给女(男)朋友发微信暖心话",
    "body": "2019/04/02 - 微信每日说，每日自动发送微信消息给你心爱的人。 项目介绍: 灵感来源: 在掘金看到了一篇《用Node + EJS写一个爬虫脚本每天定时女朋友发一封暖心邮件》后，在评论区偶然看到一位读者说可不可以用微信实现一下。然后最近刚好在做微信机器人的小项目，那就把这个定时任务放到微信上去做吧，说干就干，撸了一下午终于撸出来了。 项目地址: github:https://github. com/gengchen528/wechatBot 使用库:  wechaty - 微信操作 node-schedule - 定时任务 superagent - 爬取页面信息 cheerio - 抓取页面 qrcode-terminal - 终端显示二维码功能:  定时给朋友发送每日天气提醒以及每日一句 根据关键词自动加好友和自动拉群功能 引入图灵机器人 后续继续扩展吧…(你有好的想法也可以提pr)数据来源:  每日一句和上面的大佬一样也是来自one 天气信息来自墨迹天气定时任务: node-schedule非你莫属了，可以定时每个月、每个礼拜、每天具体什么时候执行什么任务 实现效果: 由于是微信定时发送消息，较邮件来说，微信无法把图片和文字放在同一消息框中，所以美观度来说可能没有邮件好，不过文字进行排版后还是可以的，由于时间仓促，所以文字比较少，后续会继续增加内容；  代码说明: 目录结构:  config: 存放公共变量和superagent的配置 schedule: 任务调度的配置 superagent: 获取每日一句和天气信息 untils: 抽取的共用方法核心代码: index. js 关于微信的登录，定时任务的创建，发送信息的获取都在这个文件里   /**   * WechatBot   * - https://github. com/gengchen528/wechatBot   */  import {Wechaty,Friendship} from 'wechaty'  import schedule from '. /schedule/index'  import config from '. /config/index'  import untils from '. /untils/index'  import superagent from '. /superagent/index'  import {FileBox} from 'file-box' //文件读取模块  // 二维码生成  function onScan (qrcode, status) {   require('qrcode-terminal'). generate(qrcode) // 在console端显示二维码   const qrcodeImageUrl = [   'https://api. qrserver. com/v1/create-qr-code/?data=',   encodeURIComponent(qrcode),   ]. join('')   console. log(qrcodeImageUrl)  }  // 登录  async function onLogin (user) {   console. log(`贴心小助理${user}登录了`)   // 登陆后创建定时任务   schedule. setSchedule(config. SENDDATE,()=&gt;{   console. log('你的贴心小助理开始工作啦！')    main()   })  }  //登出  function onLogout(user) {   console. log(`${user} 登出`)  }  // 监听对话 根据关键词自动加群  async function onMessage (msg) {   const contact = msg. from() // 发消息人   const content = msg. text() //消息内容   const room = msg. room() //是否是群消息   const roomCodeUrl = FileBox. fromUrl(config. ROOMCODEURL) //来自url的文件   const roomCodeLocal = FileBox. fromFile(config. ROOMLOCALPATH) //添加本地文件   if (msg. self()) {   return   }   if(room){ // 如果是群消息   const topic = await room. topic()    console. log(`群名: ${topic} 发消息人: ${contact. name()} 内容: ${content}`)   }else { // 如果非群消息   console. log(`发消息人: ${contact. name()} 消息内容: ${content}`)   let addRoomReg = eval(config. ADDROOMWORD)   let roomReg = eval(config. ROOMNAME)   if(addRoomReg. test(content)&amp;&amp;!room){    let keyRoom = await this. Room. find({topic: roomReg})    if(keyRoom){     try{      await contact. say(roomCodeLocal||roomCodeUrl)      await keyRoom. say('微信每日说：欢迎新朋友', contact)     }catch (e) {      console. error(e)     }    }   }else {    await contact. say('你好，不要轻易调戏我，我只会发群二维码，不会聊天的！')    await contact. say('请回复暗号：加群 获取群二维码图片')   }   }  }  // 自动加好友功能  async function onFriendShip(friendship) {   let logMsg   try {   logMsg = '添加好友' + friendship. contact(). name()   console. log(logMsg)   switch (friendship. type()) {    /**     *     * 1. New Friend Request     *     * when request is set, we can get verify message from `request. hello`,     * and accept this request by `request. accept()`     */    case Friendship. Type. Receive:     let addFriendReg = eval(config. ADDFRIENDWORD)    if (addFriendReg. test(friendship. hello())) {     logMsg = '自动添加好友，因为验证信息中带关键字‘每日说’'     await friendship. accept()    } else {     logMsg = '没有通过验证 ' + friendship. hello()    }    break    /**     *     * 2. Friend Ship Confirmed     *     */    case Friendship. Type. Confirm:    logMsg = 'friend ship confirmed with ' + friendship. contact(). name()    break   }   } catch (e) {   logMsg = e. message   }   console. log(logMsg)  }  // 自动发消息功能  async function main() {   let contact = await bot. Contact. find({name:config. NICKNAME}) || await bot. Contact. find({alias:config. NAME}) // 获取你要发送的联系人   let one = await superagent. getOne() //获取每日一句   let weather = await superagent. getWeather() //获取天气信息   let today = await untils. formatDate(new Date())//获取今天的日期   let memorialDay = untils. getDay(config. MEMORIAL_DAY)//获取纪念日天数   let str = today + '&lt;br&gt;' + '今天是我们在一起的第' + memorialDay + '天'    + '&lt;br&gt;&lt;br&gt;今日天气早知道&lt;br&gt;&lt;br&gt;' + weather. weatherTips +'&lt;br&gt;&lt;br&gt;' +weather. todayWeather+ '每日一句:&lt;br&gt;&lt;br&gt;'+one+'&lt;br&gt;&lt;br&gt;'+'------来自最爱你的我'   await contact. say(str)//发送消息  }  const bot = new Wechaty()  bot. on('scan',  onScan)  bot. on('login',  onLogin)  bot. on('logout', onLogout)  bot. on('message', onMessage)  bot. on('friendship', onFriendShip)  bot. start()   . then(() =&gt; console. log('开始登陆微信'))   . catch(e =&gt; console. error(e))superagent/index. js   import superagent from '. . /config/superagent'  import config from '. . /config/index'  import cheerio from 'cheerio'  async function getOne() { // 获取每日一句   let res = await superagent. req(config. ONE,'GET')   let $ = cheerio. load(res. text)   let todayOneList = $('#carousel-one . carousel-inner . item')   let todayOne = $(todayOneList[0]). find('. fp-one-cita'). text(). replace(/(^\s*)|(\s*$)/g,   )   return todayOne;  }  async function getWeather() { //获取墨迹天气   let url = config. MOJI_HOST+config. CITY+'/'+config. LOCATION   let res = await superagent. req(url,'GET')   let $ = cheerio. load(res. text)   let weatherTips = $('. wea_tips em'). text()   const today = $('. forecast . days'). first(). find('li');   let todayInfo = {    Day:$(today[0]). text(). replace(/(^\s*)|(\s*$)/g,   ),    WeatherText:$(today[1]). text(). replace(/(^\s*)|(\s*$)/g,   ),    Temp:$(today[2]). text(). replace(/(^\s*)|(\s*$)/g,   ),    Wind:$(today[3]). find('em'). text(). replace(/(^\s*)|(\s*$)/g,   ),    WindLevel:$(today[3]). find('b'). text(). replace(/(^\s*)|(\s*$)/g,   ),    PollutionLevel:$(today[4]). find('strong'). text(). replace(/(^\s*)|(\s*$)/g,   )   }   let obj = {   weatherTips:weatherTips,   todayWeather:todayInfo. Day + ':' + todayInfo. WeatherText + '&lt;br&gt;' + '温度:' + todayInfo. Temp + '&lt;br&gt;'    + todayInfo. Wind + todayInfo. WindLevel + '&lt;br&gt;' + '空气:' + todayInfo. PollutionLevel + '&lt;br&gt;'   }   return obj  }  module. exports ={   getOne,getWeather  }项目运行: 由于需要安装chromium, 所以要先配置一下镜像，注意由于wechaty的限制，最好使用node10以上版本 npm npm config set registry https://registry. npm. taobao. orgnpm config set disturl https://npm. taobao. org/distnpm config set puppeteer_download_host https://npm. taobao. org/mirrorsyarn yarn config set registry https://registry. npm. taobao. orgyarn config set disturl https://npm. taobao. org/distyarn config set puppeteer_download_host https://npm. taobao. org/mirrors然后进行项目安装 git clone git@github. com:gengchen528/wechatBot. gitcd wechatBotnpm install 或 cnpm install参数配置 wechatBot/config/index. js 项目相关配置: config/index. js   // 配置文件  module. exports ={   // 基础定时发送功能配置项（必填项）   NAME:'A兔子',//备注姓名   NICKNAME:'嗯哼', //昵称   MEMORIAL_DAY:'2015/04/18', //你和收信者的纪念日   CITY:'shanghai',//收信者所在城市   LOCATION:'pudong-new-district',//收信者所在区 （可以访问墨迹天气网站后，查询区的英文拼写）   SENDDATE:'0 0 8 * * *',//定时发送时间 每天8点0分0秒发送，规则见 /schedule/index. js   ONE:'http://wufazhuce. com/',////ONE的web版网站   MOJI_HOST:'https://tianqi. moji. com/weather/china/', //中国墨迹天气url   //高级功能配置项（非必填项）   AUTOADDFRIEND:false,//自动加好友功能 默认关闭   AUTOADDROOM:false,//自动拉群功能 默认关闭   AUTOREPLY:false,//自动聊天功能 默认关闭   AIBOTAPI:'http://www. tuling123. com/openapi/api',//图灵机器人API 注册地址http://www. turingapi. com/   APIKEY:'你的图灵机器人apikey',//图灵机器人apikey   ROOMNAME:'/^你的群名/i', //群名(请只修改中文，不要删除符号，这是正则)   ADDFRIENDWORD:'/你要触发的关键词/i',//自动加好友触发的关键词(请只修改中文，不要删除符号，这是正则)   ADDROOMWORD:'/加群/',//自动发送群图片触发关键词(请只修改中文，不要删除符号，这是正则)   ROOMCODEURL:'http://image. bloggeng. com/qun. png',//群二维码url链接(与本地群二维码路径选填一个)   ROOMLOCALPATH:'. /static/qun. png',//本地群二维码图片路径（与群url选填一个）  }开始运行 npm run start然后掏出你的手机，最好使用小号，扫描控制台的二维码即可 待解决问题:  墨迹天气页面在获取的时候可能会存在延时，有时可能获取不到常见问题处理:  我的微信号无法登陆从2017年6月下旬开始，使用基于web版微信接入方案存在大概率的被限制登陆的可能性。 主要表现为：无法登陆Web 微信，但不影响手机等其他平台。 验证是否被限制登陆： https://wx. qq. com 上扫码查看是否能登陆。 更多内容详见：  Can not login with error message: 当前登录环境异常。为了你的帐号安全，暂时不能登录web微信。 [谣言] 微信将会关闭网页版本](https://github. com/wechaty/wechaty/issues/990) 新注册的微信号无法登陆 执行npm run start时无法安装puppet-puppeteer&amp;&amp;ChromiumCentos7下部署出现以下问题 问题原因:https://segmentfault. com/a/1190000011382062 解决方案: #依赖库yum install pango. x86_64 libXcomposite. x86_64 libXcursor. x86_64 libXdamage. x86_64 libXext. x86_64 libXi. x86_64 libXtst. x86_64 cups-libs. x86_64 libXScrnSaver. x86_64 libXrandr. x86_64 GConf2. x86_64 alsa-lib. x86_64 atk. x86_64 gtk3. x86_64 -y#字体yum install ipa-gothic-fonts xorg-x11-fonts-100dpi xorg-x11-fonts-75dpi xorg-x11-utils xorg-x11-fonts-cyrillic xorg-x11-fonts-Type1 xorg-x11-fonts-misc -y windows下，下载puppeteer失败链接：https://pan. baidu. com/s/1YF09nELpO-4KZh3D2nAOhA提取码：0mrz把下载的文件放到如下图路径，并解压到当前文件夹中即可  支持 红包、转账、朋友圈… 吗支付相关 - 红包、转账、收款 等都不支持  更多关于wechaty功能相关接口参考wechaty官网文档    其他问题解决方案      先检查node版本是否大于10   确认npm或yarn已经配置好淘宝源   存在package-lock. json文件先删除   删除node_modules后重新执行npm install 或cnpm install   注意: 本项目属于个人兴趣开发，开源出来是为了技术交流，请勿使用此项目做违反微信规定或者其他违法事情。 建议使用小号进行测试，有被微信封禁网页端登录权限的风险（客户端不受影响），请确保自愿使用。因为个人使用不当导致网页端登录权限被封禁，均与作者无关，谢谢理解 最后: 因为给这个微信加了自动加好友和拉群功能，所以有兴趣的小伙伴可以加我的微信进行测试，记得在加好友的时候带上暗号：微信每日说，加好友后发送加群，会自动发送群的二维码； 注意 加好友请在验证中填写 微信每日说 才可以自动加好友 赶快亲自试一试吧，相信你会挖掘出更多好玩的功能 github:https://github. com/gengchen528/wechatBot 另外我的公众号已经接入微软小冰，关注后发语音会有小姐姐的声音陪你聊天，也可以和她文字聊天，有兴趣可以试试看，单身的欢迎来撩  作者: Leo_chen，前端工程师，喜欢使用node做各种小项目，就职于大数据公司。本篇文章首发于掘金: 用Node+wechaty写一个爬虫脚本每天定时给女(男)朋友发微信暖心话 "
    }, {
    "id": 363,
    "url": "https://wechaty.js.org/2019/04/02/koa-wechaty-assistant/",
    "title": "使用koa2+wechaty打造个人微信小秘书",
    "body": "2019/04/02 -  你是不是有闲置的微信号? 你想不想有个小秘书定时提醒你将要做的事情？ 你是否为忘记一些纪念日而懊恼？ 你是否加班到很晚，而忘记了今天和别人有约？ 你是不是下班还记得拿快递，到家后才发现忘记了？ 你是不是想学习一下如何做一个微信小秘书？如果以上问题你有一条符合的话，那就可以安心读下去了，因为微信小秘书可以帮你解决大部分的问题。当然没有符合的话，也可以继续读下去，因为既然来了就说明你还是有兴趣的😆。如果小秘书不符合你要求的话《用Node+wechaty写一个爬虫脚本每天定时给女(男)朋友发微信暖心话》也可以看一下奥！ 技术栈: node: 建议最新稳定版，由于wechaty依赖，所以至少node &gt; 10以上版本Koa: web开发框架，用来编写服务端应用程序 MongoDB:非关系数据库 mongoose:连接 mongodb的一个库 wechaty:提供网页版微信相关操作api接口 node-schedule - 定时任务 项目地址: github:https://github. com/gengchen528/wechat-assistant 功能: 很听你话的私人小秘书，帮你创建定时任务，每日提醒，纪念日提醒，当日提醒 文字支持格式：（关键词之间需要用空格分开，特别是昵称和时间要分隔开才行的，时间是24小时制，暂时还不支持表情😭）  “提醒 我 18:30 快要下班了，准备一下，不要忘记带东西” （当天指定时间提醒） “提醒 其他人昵称 2019-09-10 10:00 工作再忙，也要记得喝水”（委托小秘书提醒其他人） “提醒 我 每天 8:00 出门记得带钥匙，公交卡还有饭盒”（每日指定时间提醒） “提醒 wo 2019-09-10 10:00 还有两天就是女朋友的生日，要提前准备一下” （指定日期时间提醒）效果图如下： 提醒自己 委托提醒（前提是你和你想要提醒的人都是小秘书的好友，采用的是昵称查找用户，不是备注要注意） 数据库中已添加任务 准备工作: 由于本项目使用了MongoDB数据库，所以需要在电脑或服务器中自行安装，这里就不在赘述安装过程啦，不懂怎么安装的小伙伴可以戳链接，MongoDB的可视化工具，我在Mac上使用的是mongobooster，有需要的小伙伴可以去下载一下。 代码说明: 目录结构:  config: koa,定时任务器，superagent的配置目录 mongodb: mongodb连接相关配置文件,schema设计与model的主要目录 untils: 抽取的共用方法wechaty核心代码: index. js 微信登录，定时任务初始化，小秘书具体实现的主要文件。接口getScheduleList在每次登陆后会从数据库拉取未执行的定时任务并进行初始化，防止意外掉线后无法恢复定时任务。同时每次设置定时任务，接口addSchedule会直接向数据库中插入一条任务记录并把任务添加到定时任务列表中。每次任务执行完毕后，接口updateSchedule都会更新数据库中指定任务的状态，防止任务重复执行。   import { Wechaty, Friendship } from 'wechaty'  import schedule from '. /config/schedule'  import { FileBox } from 'file-box'  import Qrterminal from 'qrcode-terminal'  import { request } from '. /config/superagent'  import untils from '. /untils/index'  const host = 'http://127. 0. 0. 1:3008/api'  // 每次登录初始化定时任务  initSchedule = async(list) =&gt; {    try {      for (item of list) {        let time = item. isLoop ? item. time : new Date(item. time)        schedule. setSchedule(time, async() =&gt; {          let contact = await bot. Contact. find({ name: item. subscribe })          console. log('你的专属提醒开启啦！')          await contact. say(item. content)          if (!item. isLoop) {            request(host + '/updateSchedule', 'POST', '', { id: item. _id }). then((result) =&gt; {              console. log('更新定时任务成功')            }). catch(err =&gt; {              console. log('更新错误', err)            })          }        })      }    } catch (err) {      console. log('初始化定时任务失败', err)    }  }  // 二维码生成  onScan = (qrcode, status) =&gt; {    Qrterminal. generate(qrcode)    const qrImgUrl = ['https://api. qrserver. com/v1/create-qr-code/?data=', encodeURIComponent(qrcode)]. join('')    console. log(qrImgUrl)  }  // 登录事件  onLogin = async(user) =&gt; {    console. log(`贴心助理${user}登录了`)    request(host + '/getScheduleList', 'GET'). then((res) =&gt; {      let text = JSON. parse(res. text)      let scheduleList = text. data      console. log('定时任务列表', scheduleList)      initSchedule(scheduleList)    }). catch(err =&gt; {      console. log('获取任务列表错误', err)    })  }  // 登出事件  onLogout = (user) =&gt; {    console. log(`${user} 登出了`)  }  // 消息监听  onMessage = async(msg) =&gt; {    const contact = msg. from()    const content = msg. text()    const room = msg. room()    if (msg. self()) return    if (room) {      const roomName = await room. topiac()      console. log(`群名: ${roomName} 发消息人: ${contact. name()} 内容: ${content}`)    } else {      console. log(`发消息人: ${contact. name()} 消息内容: ${content}`)      let keywordArray = content. replace(/\s+/g, ' '). split(   ) // 把多个空格替换成一个空格，并使用空格作为标记，拆分关键词      console. log( 分词后效果 , keywordArray)      if (keywordArray[0] ===  提醒 ) {        let scheduleObj = untils. contentDistinguish(contact, keywordArray)        addSchedule(scheduleObj)        contact. say('小助手已经把你的提醒牢记在小本本上了')      } else {        contact. say('很高兴你能和我聊天，来试试我的新功能吧！回复案例：“提醒 我 18:30 下班回家”，创建你的专属提醒，记得关键词之间使用空格分隔开')      }    }  }  // 添加定时提醒  addSchedule = async(obj) =&gt; {    request(host + '/addSchedule', 'POST', '', obj). then(async(res) =&gt; {      res = JSON. parse(res. text)      let nickName = res. data. subscribe      let time = res. data. time      let Rule1 = res. data. isLoop ? time : new Date(time)      let content = res. data. content      let contact = await bot. Contact. find({ name: nickName })      schedule. setSchedule(Rule1, async() =&gt; {        console. log('你的专属提醒开启啦！')        await contact. say(content)        if (!res. isLoop) {          request(host + '/updateSchedule', 'POST', '', { id: res. data. _id }). then((result) =&gt; {            console. log('更新定时任务成功')          }). catch(err =&gt; {            console. log('更新错误', err)          })        }      })    }). catch(err =&gt; {      console. log('错误', err)    })  }  // 自动加好友  onFriendShip = async(friendship) =&gt; {    let logMsg    try {      logMsg = '添加好友' + friendship. contact(). name()      console. log(logMsg)      switch (friendship. type()) {        /**         *         * 1. New Friend Request         *         * when request is set, we can get verify message from `request. hello`,         * and accept this request by `request. accept()`         */        case Friendship. Type. Receive:          await friendship. accept()          break          /**           *           * 2. Friend Ship Confirmed           *           */        case Friendship. Type. Confirm:          logMsg = 'friend ship confirmed with ' + friendship. contact(). name()          break      }    } catch (e) {      logMsg = e. message    }    console. log(logMsg)  }  const bot = new Wechaty({ name: 'WechatEveryDay' })  bot. on('scan', onScan)  bot. on('login', onLogin)  bot. on('logout', onLogout)  bot. on('message', onMessage)  bot. on('friendship', onFriendShip)  bot. start()    . then(() =&gt; { console. log('开始登陆微信') })    . catch(e =&gt; console. error(e))untils/index. js 这里主要是输入关键词后的处理方法，在index. js中，我把用户输入的关键词根据空格来进行分词处理，放到一个数组中，然后传入contentDistinguish（）方法中。根据关键词的不同来进行处理是否是属于每日任务，当日定时任务，还是属于指定日期任。因为不同的定时任务类型，在时间格式上是有所区分的，每日任务我采用的是Cron风格定时器，类似0 30 8 * * *(每天8点30提醒)这种，而指定日期时间和当日任务我使用的是new Date('2019-9-10 12:30:00')来处理。同时为了兼容性，在日期处理上采用了全角替换半角的冒号格式，内容上为了更符合秘书的身份，将主语我全部替换成你，也处理了自己给自己创建定时任务与你给别人创建定时任务内容上的不同。   getToday = () =&gt; { // 获取今天日期    const date = new Date()    let year = date. getFullYear()    let month = date. getMonth() + 1    let day = date. getDate()    return year + '-' + month + '-' + day + ' '  }  convertTime = (time) =&gt; { // 转换定时格式    let array = time. split(':')    return  0   + array[1] + ' ' + array[0] + ' * * *'  }  contentDistinguish = (contact, keywordArray) =&gt; {    let scheduleObj = {}    let today = getToday()    scheduleObj. setter = contact. name() // 设置定时任务的用户    scheduleObj. subscribe = (keywordArray[1] ===  我 ) ? contact. name() : keywordArray[1] // 定时任务接收者    if (keywordArray[2] ===  每天 ) { // 判断是否属于循环任务      console. log('已设置每日定时任务')      scheduleObj. isLoop = true      scheduleObj. time = convertTime(keywordArray[3])      scheduleObj. content = (scheduleObj. setter === scheduleObj. subscribe) ? scheduleObj. content =  亲爱的  + scheduleObj. subscribe +  ，温馨提醒：  + keywordArray[4]. replace('我', '你') :  亲爱的  + scheduleObj. subscribe +  ，  + scheduleObj. setter +  委托我提醒你，  + keywordArray[4]. replace('我', '你')    } else if (keywordArray[2] &amp;&amp; keywordArray[2]. indexOf('-') &gt; -1) {      console. log('已设置指定日期时间任务')      scheduleObj. isLoop = false      scheduleObj. time = keywordArray[2] + ' ' + keywordArray[3]. replace('：', ':')      scheduleObj. content = (scheduleObj. setter === scheduleObj. subscribe) ? scheduleObj. content =  亲爱的  + scheduleObj. subscribe +  ，温馨提醒：  + keywordArray[4]. replace('我', '你') :  亲爱的  + scheduleObj. subscribe +  ，  + scheduleObj. setter +  委托我提醒你，  + keywordArray[4]. replace('我', '你')    } else {      console. log('已设置当天任务')      scheduleObj. isLoop = false      scheduleObj. time = today + keywordArray[2]. replace('：', ':')      scheduleObj. content = (scheduleObj. setter === scheduleObj. subscribe) ? scheduleObj. content =  亲爱的  + scheduleObj. subscribe +  ，温馨提醒：  + keywordArray[3]. replace('我', '你') :  亲爱的  + scheduleObj. subscribe +  ，  + scheduleObj. setter +  委托我提醒你，  + keywordArray[3]. replace('我', '你')    }    return scheduleObj  }  module. exports = {    getToday,    convertTime,    contentDistinguish  }koa核心代码: koa就不用多说了，TJ大神继express后的又一神作，很轻量，而且摆脱了“回调地狱”的问题，放一张大神头像镇楼（发型很帅啊，哈哈） koa服务默认使用3008端口，如果修改的话，需要在index. js中修改host的地址。这里目前写了三个接口，分别是添加定时任务，获取定时任务列表和更新任务列表，对应的数据库curd操作均在mongodb/model. js中完成 config/koa. js   import Koa from 'koa'  import Router from 'koa-router'  import bodyParser from 'koa-bodyparser'  import model from '. . /mongodb/model'  const app = new Koa()  const router = new Router()  app. use(bodyParser())  router. post('/api/addSchedule', async(ctx, next) =&gt; { // 添加定时任务    let body = ctx. request. body;    console. log('接收参数', body)    let res = await model. insert(body);    ctx. body = { code: 200, msg:  ok , data: res }    next()  })  router. get('/api/getScheduleList', async(ctx, next) =&gt; { // 获取定时任务列表    const condition = { hasExpired: false }    let res = await model. find(condition)    ctx. response. status = 200;    ctx. body = { code: 200, msg:  ok , data: res }    next()  })  router. post('/api/updateSchedule', async(ctx, next) =&gt; { // 更新定时任务    const condition = { _id: ctx. request. body. id }    let res = await model. update(condition)    ctx. response. status = 200;    ctx. body = { code: 200, msg:  ok , data: res }    next()  })  const handler = async(ctx, next) =&gt; {    try {      await next();    } catch (err) {      ctx. respose. status = err. statusCode || err. status || 500;      ctx. response. type = 'html';      ctx. response. body = '&lt;p&gt;出错啦&lt;/p&gt;';      ctx. app. emit('error', err, ctx);    }  }  app. use(handler)  app. on('error', (err) =&gt; {    console. error('server error:', err)  })  app. use(router. routes())  app. use(router. allowedMethods())  app. listen(3008, () =&gt; {    console. log('[demo] route-use-middleware is starting at port 3008')  })mongose核心代码: mongodb/config. js 这里主要是MongoDB的主要配置文件，使用了mongoose链接MongoDB数据库，默认端口27017，创建了一个名为wechatAssitant的库   import mongoose from 'mongoose'  const db_url = 'mongodb://localhost:27017/wechatAssitant'  let db = mongoose. connect(db_url, { useNewUrlParser: true })  //连接成功  mongoose. connection. on('connect', () =&gt; {    console. log( Mongoose connection open to   + db_url)  })  //连接异常  mongoose. connection. on('error', (err) =&gt; {    console. log( Mongoose connection erro   + err);  });  //连接断开  mongoose. connection. on('disconnected', () =&gt; {    console. log( Mongoose connection disconnected  );  });  module. exports = mongoosemongodb/schema. js在Mongoose里一切都是从Schema开始的，每一个Schema都会映射到MongoDB的一个collection上。Schema定义了collection里documents的模板（或者说是框架）,如下代码定义了定时任务的Schema：   import mongoose from '. /config'  const Schema = mongoose. Schema  let assistant = new Schema({    subscribe: String, // 订阅者    setter: String, // 设定任务者    content: String, // 订阅内容    time: String, // 定时日期    isLoop: Boolean, // 是否为循环定时任务    hasExpired: { type: Boolean, default: false }, // 判断任务是否过期    createdAt: { type: Date, default: Date. now },  })  module. exports = mongoose. model('Assistant', assistant)mongodb/model. js 为了使用定义好的Schema，我们需要把Schema转换成我们可以使用的model(其实是把Schema编译成model，所以对于Schema的一切定义都要在compile之前完成)。也就是说model才是我们可以进行操作的handle，具体实现代码mongoose. model('Assistant', assistant)，这里我们已经在schema. js文件中直接导出，直接在model. js中引用   import Assistant from '. /schema'  module. exports = {    insert: (conditions) =&gt; { // 添加定时任务      return new Promise((resolve, reject) =&gt; {        Assistant. create(conditions, (err, doc) =&gt; {          if (err) return reject(err)          console. log('创建成功', doc)          return resolve(doc)        })      })    },    find: (conditions) =&gt; { // 获取定时任务列表      return new Promise((resolve, reject) =&gt; {        Assistant. find(conditions, (err, doc) =&gt; {          if (err) return reject(err)          return resolve(doc)        })      })    },    update: (conditions) =&gt; { // 更新定时任务状态      return new Promise((resolve, reject) =&gt; {        Assistant. updateOne(conditions, { hasExpired: true }, (err, doc) =&gt; {          if (err) return reject(err)          return resolve(doc)        })      })    }  }项目运行: 由于需要安装chromium,所以要先配置一下镜像，注意由于wechaty的限制，必须使用node10以上版本 npm或者yarn 配置淘宝源: (很重要，防止下载chromium失败，因为下载文件在150M左右，所以在执行npm run start后需要等待下载大概一两分钟以上，请耐心等待): npm npm config set registry https://registry. npm. taobao. orgnpm config set disturl https://npm. taobao. org/distnpm config set puppeteer_download_host https://npm. taobao. org/mirrorsyarn yarn config set registry https://registry. npm. taobao. orgyarn config set disturl https://npm. taobao. org/distyarn config set puppeteer_download_host https://npm. taobao. org/mirrors下载项目安装依赖: git clone git@github. com:gengchen528/wechat-assistant. gitcd wechat-assistant. gitnpm installnpm run start扫描登录: 用微信扫描控制台显示的二维码，在手机上同意登录即可。使用其他微信发送指定格式文字进行添加定时任务。 服务器部署: 1、如果需要在服务器中部署，需要先扫描二维码登录一次，生成微信维持登录状态的json文件，如下图： 2、生成此文件后，可以使用pm2工具进行进程守护。由于为了方便，本地开发的时候，我设置的npm run start同时执行了两条命令，所以在服务器端部署的时候，建议先启动koa. js后再启动index. js 常见问题:    我的微信号无法登陆   从2017年6月下旬开始，使用基于web版微信接入方案存在大概率的被限制登陆的可能性。 主要表现为：无法登陆Web 微信，但不影响手机等其他平台。 验证是否被限制登陆： https://wx. qq. com 上扫码查看是否能登陆。 更多内容详见：   Can not login with error message: 当前登录环境异常。为了你的帐号安全，暂时不能登录web微信。   [谣言] 微信将会关闭网页版本   新注册的微信号无法登陆     执行npm run start时无法安装puppet-puppeteer&amp;&amp;Chromium  Centos7下部署出现以下问题 问题原因: https://segmentfault. com/a/1190000011382062 解决方案: 依赖库: yum install pango. x86_64 libXcomposite. x86_64 libXcursor. x86_64 libXdamage. x86_64 libXext. x86_64 libXi. x86_64 libXtst. x86_64 cups-libs. x86_64 libXScrnSaver. x86_64 libXrandr. x86_64 GConf2. x86_64 alsa-lib. x86_64 atk. x86_64 gtk3. x86_64 -y 字体: yum install ipa-gothic-fonts xorg-x11-fonts-100dpi xorg-x11-fonts-75dpi xorg-x11-utils xorg-x11-fonts-cyrillic xorg-x11-fonts-Type1 xorg-x11-fonts-misc -y  windows下，下载puppeteer失败链接：https://pan. baidu. com/s/1YF09nELpO-4KZh3D2nAOhA提取码：0mrz 把下载的文件放到如下图路径，并解压到当前文件夹中即可  支持 红包、转账、朋友圈… 吗支付相关 - 红包、转账、收款 等都不支持  更多关于wechaty功能相关接口参考wechaty官网文档    其他问题解决方案      本地是否安装了mongodb数据库   先检查node版本是否大于10   确认npm或yarn已经配置好淘宝源   存在package-lock. json文件先删除   删除node_modules后重新执行npm install 或cnpm install   注意: 本项目属于个人兴趣开发，开源出来是为了技术交流，请勿使用此项目做违反微信规定或者其他违法事情。 建议使用小号进行测试，有被微信封禁网页端登录权限的风险（客户端不受影响），请确保自愿使用。 最后: 我的小秘书已经学会了自动加好友功能，所以有兴趣的小伙伴可以加我的微信进行测试，她也可以是你的私人小秘书😆（注意别发太多信息，会把她玩坏的） 赶快亲自试一试吧，相信你会挖掘出更多好玩的功能 github:https://github. com/gengchen528/wechat-assistant 另外我的公众号已经接入微软小冰，关注后发语音会有小姐姐的声音陪你聊天，也可以和她文字聊天，有兴趣可以试试看，单身的欢迎来撩  作者: Leo_chen，前端工程师，喜欢使用node做各种小项目，就职于大数据公司。本篇文章首发于掘金: 使用koa2+wechaty打造个人微信小秘书 "
    }, {
    "id": 364,
    "url": "https://wechaty.js.org/2018/11/25/wechat-robot-can-do-anything/",
    "title": "微信机器人能够做些什么事？",
    "body": "2018/11/25 - 作为一个会写代码的产品经理，我最近自己在玩一个微信机器人的开源框架：wechaty，因为上手特别简单，通过修改hello world，我也写出了自己的微信机器人，所以引发了很多的联想，打算和朋友们聊聊这些想法。 只要是用微信客户端，人类可以完成的事情，微信机器人理论上可以做任何事。当然，以下一些限制，还是存在的？  没有朋友圈相关的API，这个没办法。很多基于朋友圈可以做的玩法，现在还不行。 接受“关键字”命令会很擅长，如果要实现自然语言操作（对话），就很困难。其他的，就没啥了。下面开始海阔天空： 记录聊天的历史: 这是我最先尝试的工作，将微信群里聊天的记录，同步到gitter. im去，只要做两个机器人，分别加入微信群和gitter群，然后将微信里收到的消息，实时转发过去就行。稍微困难一点的，是解析各种消息类型，然后正常的转发过去。 这样做的好处只有一个：因为微信无法为后来者，展示群里的过去的聊天记录，而gitter可以做到这一点，这样新人要回看过去的聊天记录，就非常方便了。 社区招新: 现在我们已经可以实现，任何人都可以自动加这个机器人为好友。然后和这个机器人聊天。如果输入“#join 申请加入的理由”，这个人就会被拉到一个微信群中，并且这个微信群里，有一些“面试官”，他们会与这个新人聊天，并确定是否可以接受他的加入申请。 还可以有更进一步的操作，通过#join topic，选择加入不同的微信群。对于一个大的社区，这样应该会很有帮助。 多群直播转发: 这个应该是很容易的工作了，假设一个特别厉害的大牛，在线直播（图文、音频多条记录，再加上答疑）。这就可以先创建1群、2群到n群，然后大牛不必加入任何一个群，只需要对着微信机器人发言就好。机器人就可以把他的授课内容，同步的转发到多个微信群里。 更进一步的，如果有人提问，机器人也可以转发这些问题给讲师（或者再加上一个提问人工审核的中间步骤）。讲师的回答，也可以同步的转发到所有的群里。 于是，微信群的500人上限，就不再是问题了。 按规定改名: 很多的微信群，都会有改名的规范，比如“庄表伟@上海#开源社”代表我的姓名，所在城市与单位。 如果使用微信机器人，完全可以在新人加入群的时候提示一遍。24小时内不改名的，自动踢人。 识别小广告: 参考某种垃圾邮件的过滤算法，只要识别出群里有人发的内容是小广告的，直接踢走。 清理潜水者: 既然可以记录所有的群内聊天记录。那么，长期潜水的群友，在清理之前再刷屏，就已经没啥用了。 一个简单的算法，平均每天发言不少于3条，连续不发言时间小于3天。就可以将潜水者筛选出来，想清理的，就可以直接动手了。 会员等级制度: 一个更加复杂的贡献点制度，也是有可能的。  新加入群的朋友，等级为0。 连续2周活跃，等级为1。 等级为1以上的朋友，可以发言“@某某 谢谢”，或其他关键字 获得感谢超过N的朋友，等级可以升一级 发红包的，直接踢走（不能通过发红包，来买感谢）作为管理员的工具: 在一对一聊天的时候，机器人可以接受更多的命令。比如：  find :name=”张三” kick :name=”张三”, :room=:all ban :name=”张三” broadcast :msg=””, :room=/开源社/g manager add :name=”张三” manager delete :name=”张三” 还可以有很多很多……老用户促活: 曾经活跃的用户，最近一段时间不活跃了。发个消息“撩一下”。如果能够做到更加智能：“某某群里，最近在聊前端的Vue框架，你不打算参与讨论一下吗？” 相信能够拉回来很多人。 工作群——对接工作事项: 工作群可以做的事情就太多了。这里只能先随意的扯几句。  经理：今天的XXX，分析出原因了吗？ 小张：是的，发现了一个问题，我们明天解决 经理：是你去解决吗？ 小张：@李四 明天这个问题解决一下。 @机器人 #newtask 修改XXXX导致的bug 机器人： 已经创建任务单，单号 #13048，责任人：@李四 李四： 收到工作群——ChatOps: 讲微信群的聊天消息，转发到某个支持ChatOps的IM，比如Slack或者BearyChat，那就更加是海阔天空了。 先聊到这里，后续的想法，也欢迎大家一起来讨论。二维码是“开源社-bot”，欢迎添加。功能还很弱，大家轻拍 :)  作者: 庄表伟，开源社理事/执行长。首发于简书: 微信机器人能够做些什么事？ "
    }, {
    "id": 365,
    "url": "https://wechaty.js.org/2018/10/21/microsoft-tech-summit-chatbot-quick-started/",
    "title": "Microsoft Tech Summit - 快速搭建一个聊天机器人",
    "body": "2018/10/21 - 这是我在2018微软技术暨生态大会 动手实验室的分享，2018微软技术暨生态大会10月24日在上海世博中心如约而至。 作为微软最负盛名的技术峰会，此次大会将带领参会者深入领略技术精髓，感受微软黑科技的魅力，探讨在云计算、物联网、移动互联网、大数据和人工智能的发展洪流中，如何洞察新技术与新变革，聚焦解决问题与创造价值，如何开启企业数字化转型之旅。 本次实验帮助开发者从实际业务场景出发，围绕微软Luis 和 Typescript 做实践课，让开发者轻松的做一个微信聊天机器人。另外，对于希望转变为人工智能的传统产品经理或传统工程师而言，可以帮助你快速了解行业背景并快速上手，对于技术决策者，可以在此阶段清楚地了解聊天机器人的局限性和发展。 Luis 介绍: LUIS (Language Understanding Intelligent Service，https://www. luis. ai) 是微软发布的面向开发者的自然语言语义理解模块开发服务。LUIS的使命是让非NLP专业的开发者能够轻松地创建和维护高质量的自然语言理解模型，并无缝对接到相关的智能应用当中。通过LUIS平台，非NLP专业的开发者可以轻松创建一个LUIS App，并通过标注所期望的输入(自然语言指令)和输出(意图和实体)来进一步“培养” 它。在整个开发过程中，开发者并不需要了解背后算法的细节，只需要清晰地定义自己需要让机器理解的用户意图和实体即可。LUIS App 可以是任何传统的应用，包括社交媒体应用，聊天机器人，实体机器人，车载以及支持语音的桌面程序应用。LUIS的开发流程更像是一个教学过程：开发者是老师，LUIS App是学生。老师通过不停地告知学生正确的语义解析结果来完成教学。一个好的教学过程是一个“训练+实践”的闭环：标注一定量的起始数据；训练得到语义理解模型；对模型进行必要的测试；发布模型并应用到真实用户场景；甄选应用日志中的语句；继续标注并更新模型。这个过程周而复始，通过不停地迭代开发，不停地改善理解模型，使其越来越接近人类的理解能力。 实验目标:  搭建一个LUIS 模型 使用wechaty 创建一个微信聊天机器人 将LUIS 模型整合进入微信机器人系统要求:  Ubuntu 18 Microsoft Visual Studio Code (VSCode) Node (version &gt; 10. 0) Github 账号 Luis 账号步骤:  安装Unbutun 18 安装 Node 和 Npm 安装Microsoft Visual Studio Code (VSCode) 安装Github 从Github 上clone 项目：https://github. com/lijiarui/microsoft-summit-chatbot-course实验:  创建一个LUIS模型 创建一个微信机器人 将LUIS 模型整合到微信机器人中实验1–创建一个LUIS模型: 创建一个LUIS 模型可以分为3个步骤: 创建APP，训练模型，发布模型。下面将会进行详细的讲解： 任务1-创建APP: 1. 登陆 www. luis. ai 如果之前注册过就sign in, 注册过直接login 就可以了： 2. 点击左上角的“Create New App” 创建一个新的应用 3. 在弹框中，给你的LUIS模型起个名字，并设置描述，然后选一个应用环境，我们选择中文。然后点击“Done” 4. 然后进去LUIS 模型的主页面，接下来去训练LUIS 模型。 任务2-增加意图和实体: 接下来，我们为我们的APP增加两个意图，意图表示用户希望执行的任务。定义一组意图，对应于用户希望在APP中执行的操作。 1. 点击‘Create new intent’ 创建一个 ‘BookFlight’ 的意图，并把这个意图命名为‘BookFlight’点击‘Done’  2. 输入一个可能的订票话术，比如“帮我订一张去上海的机票”，然后回车： 3. 推荐最少写5个类似的话术，你会发现这些话术会自动的被标注为BookFlight 的意图。 4. 回到点击‘Intent’再添加一个 ‘GetWeather’ 的意图，像刚刚一样，也至少输入5个有表示天气的话术： 定义实体(entities): 你可以创建各种类别的实体。实体代表话术中有用的词语或者短语，他们将是完成任务的关键要素。实体和与之相关的意图对于APP 的任务执行是非常重要的。在我们这个订机票的例子中，“位置”,“日期”，“航空公司”，“舱位”都是非常重要的实体。 实体有多种类型：  Simple： 通过机器学习的方法识别出来，是最简单的实体 Hierarchical: 通过机器学习的方法识别出来，根据上下文关系得到的实体，比如Location，根据上下文知道是ToLocation还是FromLocation. 他们共享一个实体集合，但是根据上下文被分配到不同的实体中。 Composite: 通过机器学习的方法识别出来，有多个实体组成，比如3张去上海的机票，可以是PlaneTicketOrder 的实体，由number 和ToLocation 组成 List: 是通过文本匹配的方法识别出来的，是一组封闭的词语。LUIS 不会为List 自动生成更多的值 Regex: 通过正则表达式识别出来的实体 Pattern. any: 是一种长度可变的占位符，在模板中使用，用来标出实体的起始位置和结束位置。比如搜索书籍： 谁写了{BookTitle}[?]1. 点击‘Create new entity’ 创建新的实体. 2. 在弹框中将实体命名为‘Location’，选择实体类别为’Hierarchical’ 3. 选择实体类别后，会自动跳出’Child name’,点击‘Add a child entity’增加两个Child name, 分为为’ToLocation’和 ‘FromLocation’ 4. 最后，点击’Done’完成保存这个实体。 使用预定义实体(Pre-Build Entities): 接下来，我们增加一个预定义的时间实体。 1. 点击‘Add prebuild Entity’ 2. 预定义实体现在还不支持中文，我们可以选择’number’先来感受一下。 任务3-训练模型: 我们定义了意图和实体以后，需要进行模型的训练。点击右上角的’Train’。当按钮由红色变为绿色以后，训练成功。为了让模型越来越好用，需要添加更多的标注好的意图和实体。 点击‘Publish’可以将这个App发布出去。最后就可以整合到微信机器人中。 实验2–创建一个微信机器人: 这一部分来展示如果快速搭建一个微信机器人 任务1-运行代码: 1. 输入命令git clone https://github. com/lijiarui/microsoft-summit-chatbot-course. git 2. 进入目录microsoft-summit-chatbot-course， cd microsoft-summit-chatbot-course 3. 安装依赖包，运行npm install 任务2-运行代码: 1. 运行 npm run start 实验3–将LUIS 模型整合到微信机器人中: 任务1-发布LUIS版本: 1. 点击LUIS的Publish获取APPID和KEY 2. 发布成功后，可以看到绿色的成功提示，点击Refer to the list of endpoints切换到管理页面： 3. 获取Authoring Key: 4. 点击 Application Information, 获取APP ID 任务2-将LUIS RESTFUL API 接入wechaty: 1. 安装官方的’luis-sdk’,并将获取的key 和 Application ID 填入： 2. 根据已有的LUIS 配置写示例代码： 3. 运行 npm run start： 用户发送，即可得到测试回复： 注意：由于时间关系，本次实验只是讲解了LUIS 的部分，LUIS获取的key 只是免费测试版本，后续需要和Azure 结合，获取到稳定的付费版本接口。 "
    }, {
    "id": 366,
    "url": "https://wechaty.js.org/2018/10/09/birthday-cake-2018/",
    "title": "生日蛋糕",
    "body": "2018/10/09 - 不敢参加同学聚会的你是否敢来参加wechaty的生日宴会？一个关于如何分蛋糕的故事。  计算机科学家：请问想吃生日蛋糕怎么办？微信机器人：获得生日蛋糕分三步：第一步，过生日……计算机科学家：错！第一步是定义“生日”。 2018年10月14日，我们将迎来wechaty诞生的第1110000000天！根据计算机科学家的定义，机器人的世界里逢10000000天就过一次生日。让我们祝wechaty生日快乐！ 过生日的时候最应该感谢谁呢？当然是我们的父母！他们含辛茹苦把我们养大 [默泪]……请注意，wechaty一共有27位父母。 分蛋糕: 那么问题来了，生日宴上该如何为父母们分蛋糕呢？他们平时省吃俭用，没有向wechaty要过一分钱，就盼着生日宴上能吃一口甜美的蛋糕。 平均分可以吗？有一位妈妈提交了147次代码，而有一位爸爸只提交了2次，平均分怎么公平？ 据说这就是爸爸和妈妈的差别 那数提交数好了？有位提交422次的只修改了861行代码，而那位提交147次的妈妈修改了19341行代码！妈妈会不会哭晕在厕所？ …… 不用担心，计算机科学家有办法。今年软件工程领域的顶级会议FSE上横空出世了一篇论文Towards Quantifying the Development Value of Code Contributions，可以更加公平合理地计算开发者对软件项目的代码贡献值。论文有点看不太懂？没关系，知道它很牛就够了！简单来说，这篇论文摒弃了提交数、代码行数这些表面化又很容易造假的指标，而是深入分析代码的内涵，结合代码的内部结构，通过一个基于程序分析和图计算的算法DevRank，获得每次代码提交的价值，进而可以计算出每位爸妈到底为项目做出了多大贡献。那让我们来看一看结果吧！ ……呃，结果还在分析中，生日当天揭晓！敬请期待更新！  Author: 任晶磊，微软亚洲研究院研究员，清华大学计算机系博士。 "
    }, {
    "id": 367,
    "url": "https://wechaty.js.org/2018/09/15/country-wide-developer-conference/",
    "title": "Wechaty Country Wide Developer Conference",
    "body": "2018/09/15 -   The above contributors as follows, sort by the order of the contributor in the photo:  李卓桓, Microsoft AI MVP &amp; Regional Director.  林贻民, CS Student from BUPT, author ofwechaty-puppet-ioscat, which is a ios plugin to help Wechaty to control the Wechat.  李彬彬（杉木）, freelancer, author of padchat-sdk, which is a ipad solution to control Wechat.  高原, Co-founder of BotOrange. author of wechaty-puppet-padchat, which is a ipad plugin to help Wechaty to control the Wechat.  张灵箫, Co-founder of 小理智能, Musical lover, Movie addict. He just integrate wechaty with their information bot.  伍翀, CTO from a listed company called 路骋国旅(831320), mainly focus on data analysis. He wrote a bot share PUFA bank point and share point to get a gift from the bank.  谢扬, ByteDance Hacker, former CTO of Awesome Port. He started his own business when he was a junior student at the university.  丁煜恒, MicroSoft AI engineer, focus on provide AI solution for big company.  李佳芮, Microsoft AI MVP, Founder &amp; Co-founder of BotOrange.  罗淼, Full stack developer at ColorfulClouds, interested in AI, Game and Philosophy. He built a translator bot based on their translate API and wechaty.  龚澄(Gcaufy), Author of WePY, a mini program framework for Wechat. Tencent Engineer. Thanks to 李彬彬（杉木） and 龚澄(Gcaufy), they come to Beijing so we try to have this interesting meet-up, talking about wechaty ideas and chatbot. When 伍翀 heard about 李彬彬（杉木） will come this conference, he bought an airline form Shanghai to Beijing. Here is their sharing:  李卓桓: talk about his ideas about wechaty and some interesting words: hostie, botie and giftie.  龚澄(Gcaufy): talk about his understanding and love for open source, also, he shared his open source project WePY, which is a mini program framework and has more than 14000 stars.  李彬彬（杉木）: talk about ipad network protocal and related technology.  林贻民: talk about how to encapsulate a new puppet when he build wechaty-puppet-ioscat 高原: talk about his experience when encapsulate wechaty-puppet-padchat 谢扬: talk about his new Authenticator System authing 罗淼: talk about his translator bot and the experience using wechaty.  张灵箫: talk about his intresting information bot and the experience using wechaty. Introduction Video:  "
    }, {
    "id": 368,
    "url": "https://wechaty.js.org/2018/08/30/ai-bot-wechaty/",
    "title": "AI、Bot、Wechaty相关思考",
    "body": "2018/08/30 - 人工智能（AI：Artificial Intelligence）经历了六十年几起几落，终于在2016年因为阿尔法狗（AlphaGo）战胜围棋世界冠军而轰动全球，迎来了发展新机遇。2017年中国发布《新一代人工智能发展规划》，准备到2025年把中国建设成为全球最重要的AI创新中心之一。中国新一代AI的创新机会主要在弱AI的广泛应用和强AI的原始创新，而Bot（聊天机器人）是使用AI科技成果的一种最简洁形式。目前市场上具有“公众号+Bot+内容”这样的AI使用解决方案，支持大众以Bot形式使用AI科技成果。同时市场上也有像Wechaty这样的软件开源Bot项目，支持研发人员开发和集成各种各样的Bot引擎，支持Bot引擎的原始创新。显然，把AI、新一代AI、Bot、Wechaty这些概念和关系梳理清楚，有助于我们更好地推动中国AI的发展。 一、对AI的思考: 对AI的思考我们谈三点：AI的基本概念、AI研究的分类、AI研究的关键。 （一）AI的基本概念: AI的基本概念包括AI的含义、AI研究的目的、AI研究的途径。 1．AI的含义: AI是由人类开发的模仿人类智能的机器智能。模仿的形式可以多种多样。一般而言只要模仿出来的机器智能在功能上达到设计要求就行，而不需要完整模仿人类智能活动的中间环节。 2．AI研究的目的: AI研究的目的是用机器智能减轻人类的智能工作负担。因为人类的智能工作种类很多，所以机器能够替代人类智能工作的地方也很多。同时因为人类的有些智能工作是做好事，有些智能工作是做坏事，所以机器智能也既有可能被用来做好事，也有可能被用来做坏事。 3．AI研究的途径: AI研究的最基本途径是仿生学途径，即用机器智能模仿人类智能。 研究AI必须首先研究人类智能，然后才能谈模仿。目前机器模仿人类智能主要是模仿外部功能，而机器实现外部功能的原理和机制可以与人类完全不同。 （二）AI研究的分类: 一般认为AI可以分为三类：弱人工智能（弱AI或Weak AI）、强人工智能（强AI或Strong AI或Artificial General Intelligence）、超人工智能（超AI或Super AI或Artificial Superintelligence）。 1．弱AI: 弱AI主要解决单个或多个特定的局部AI功能问题，如视觉相关的图像识别、听觉相关的语音识别、自然语言理解、机器翻译、专家系统等。 当前不少弱AI技术已经趋于成熟，而且研究主要由大企业承担。新创公司在弱AI领域的机会是弱AI技术的各种推广应用。 2．强AI: 强AI主要解决机器完整模仿人类智能的问题，使得AI系统在处理各种问题的时候能够像一般人类那样表现出类似于人类的完整智能功能。 强AI研究比弱AI研究有更多挑战和机会。什么是人类完整智能，AI系统如何模仿人类完整智能等等问题都还缺乏研究。比如，目前有不少人研究模仿人类大脑的AI系统或芯片，因为人类对大脑的了解才20%左右，所以这些研究不可能完整。 3．超AI: 超AI主要解决AI系统智能超越人类最强智能的问题。这方面的研究隐藏着许多问题如技术奇点（Singularity）危机问题。所谓奇点就是机器智能超越人类最强智能的时候，因为机器系统可以自动复制和自我进化，还可能存在软件臭虫（BUG），所以机器系统就有可能出现故障而导致失控，给人机世界带来预想不到的灾难。 机器智能已经在某些领域超越了人类智能，如视觉识别和语音识别等。机器智能要超越人类最强智能的目标不一定能够实现，但是技术奇点潜在危机却着实令人担忧。人类现在研究AI就要充分考虑如何防止技术奇点危机问题。 （三）AI研究的关键: 我们认为AI研究的关键有三方面：开发人类智能、开发机器智能、维护人机伦理。 1．开发人类智能: 人类必须首先了解自己的智能，才能有效地开发机器智能。AI越深入发展，就越需要人类对自己的智能有深刻了解。这样，AI发展客观上起到了倒逼人类智能挖潜的作用。因为目前人类对自己的智能了解还比较有限，而且人类的智能潜力又是可以无限挖掘的，所以人类智能开发充满挑战和机会。人类智能开发的任何突破，都可能带来机器智能开发的相关突破。 人类智能可以从多角度认识。如智商、情商、德商智能；意识智能，包括视听味嗅触五大意识、潜意识、智慧意识等智能；大脑、心灵、身体智能；生命系统智能等等。 2．开发机器智能: 针对上面提到的人类智能，可以模仿开发对应的机器智能。如开发机器智商、情商、德商智能；开发机器意识智能，包括视听味嗅触五大意识、潜意识、智慧意识等意识智能；开发机器大脑、心灵、身体智能；开发机器生命系统智能等。 因为人类对自己的智能认识还很有限，而且机器模仿人类智能的思路又可以五花八门，所以在机器智能开发上可能产生不同的学派，形成百家争鸣局面。目前开发等比较多的机器智能有机器学习、自然语言处理、语音识别、专家系统、规划、日程、优化、机器人、图像识别、计算机视觉等。 3．维护人机伦理: 机器计算力快速提升、机器智能水平不断提高、机器智能系统能够快速自我复制自我进化等，必然导致机器智能系统数量大量增加甚至超过人类总人口数量，从而引发所谓机器智能大爆炸问题，甚至可能出现技术奇点问题，导致人机世界失控。 为了防止人机世界失控，必须建立和维护正确的人机伦理。比如，可以按照“机法人”的原则建立最基本的人类和机器的伦理关系，机器永远为人类服务，从而让人机双方各安本分、和平相处、和谐共事，更有效地防止人机世界失控。 二、对新一代AI的思考: 从2016年开始AI进入了新的发展时期，形成了新一代AI的概念。 （一）对新一代AI的基本认知: 新一代AI激发了普通大众对AI的兴趣，其驱动技术是计算力、大数据、深度学习算法等几方面的突破，使AI研究可以更加深入，存在很多挑战和机会。 1．新一代AI激发大众兴趣: 2016年3月阿尔法狗（AlphaGo）强势来袭战胜了围棋世界冠军，激发了全球普通大众对AI的兴趣，也标志着人类进入了新一代AI的发展阶段。 2．新一代AI源于技术驱动: 人们普遍认为新一代AI兴起，技术上主要得益于计算能力、大数据、深度学习算法三方面的技术突破。这些技术突破使得研发人员可以快速度、低成本、高效率地试错各种新思路解决AI问题并获得突破。 3．新一代AI有挑战和机会: 我们认为当前新一代AI的发展态势是：传统的弱AI技术趋于成熟，可以开展广泛的推广应用；强AI技术是未来技术创新重点领域，存在很多挑战和机会；超AI技术存在不确定性，需尽早防范潜在的技术奇点危机。 （二）发展新一代AI的价值主张: 发展新一代AI有很多挑战和机会，我们提出的价值主张是：1．同步实施国家AI发展规划、打造智慧智能开放开源平台、从科普切入突破科教人瓶颈。 1．同步实施国家AI发展规划: 中国《新一代人工智能发展规划》中明确提出了三步走发展战略：到2020年要完成AI应用发展目标，到2025年要完成AI理论创新目标，到2030年要完成AI总体全面发展目标，使我国成为世界级的人工智能创新中心之一。我们规划和实施自己的新一代AI研究计划，需要参考国家的发展规划，助力实现国家的发展规划。 2．打造有特色优势的AI开放开源平台: 开放开源平台是推动全球AI创新发展的一种有效模式，全球很多企业都在实践这种模式。中国《新一代人工智能发展规划》中也明确提倡这种模式。我们规划和实施自己的新一代AI研究计划，需要打造具有特色优势的AI开放开源平台。 3．从AI科普教育切入突破科教人瓶颈: 中国新一代AI发展，可能最大的瓶颈还是在科技、教育、人才三个方面。其中人才又是最关键的环节。为此我们提出从AI科普教育切入，开展全民AI教育培育人才，并希望通过人才的创新创业开拓来突破这三大瓶颈。 （三）发展新一代AI的全民AI教育方案: 我们的全民AI教育有三方面：AI科普教育、人类智能开发、机器智能开发。 1．AI科普教育: AI科普教育是我们的切入点，任务是提供AI科普解决方案，使普通大众都有机会不需掌握要软件开发技能就可以使用AI科技成果。我们的AI科普解决方案是：公众号+Bot+内容。人人都可以使用该解决方案。 其中，“公众号”是微信公众号，腾讯公司允许每个人免费创建和运营。“Bot”是聊天机器人，北京雷风科技有限公司推出的图灵机器人允许每个人免费创建和运营，而且可以把每个人的Bot与微信公众号绑定在一起使用，用Bot与公众号用户聊天。“内容”是每个人的个性化内容，可以导入Bot的资料库中，以便Bot按照所导入的用户个性化内容与公众号用户聊天。通过导入不同的用户个性化内容，就可以控制Bot按照不同的内容回复公众号用户的信息，完成不同公众号的不同使命。 2．人类智能开发教育: 因为AI的智能是模仿人类智能的结果，所以，人类对自己智能的了解将极大地影响人类对AI智能的理解、定义、设计、开发等。为此，我们把人类智能开发教育摆在人工智能教育的最重要位置。 我们希望通过正规学校教育等形式开发人类智能，全面、系统、深入地提升学习者的智能水平。使得学习者在参与机器智能开发的时候，对人类自己的智能有足够充分的了解，从而更好地开发机器智能。 比较完整的人类智能可以从多角度来探讨，如“智商+情商+德商等智能”、“视觉听觉嗅觉味觉触觉五大意识+潜意识+智慧意识等生命意识智能”、“大脑+心灵+身体等生命子系统智能”、“生命思维+分析+决策等智能”、“生命整体智能”，等等。 3．机器智能开发教育: 过去六十年AI智能开发主要集中在弱AI的智能开发，模仿了人类的一些局部智能如视觉、听觉、嗅觉、味觉、触觉五大意识智能，还有一些人类思维、分析、决策等智能，还有就是大脑的某些局部智能等。 新一代AI的主要创新机会在强AI的智能开发上。因为强AI研究的目标是模仿比较完整的人类智能，使得机器智能系统能够完成需要比较完整的人类智能才能完整的人类智能工作。 通过人类智能开发教育之后，学习者能够比较全面、系统、深入地了解人类比较完整的智能，从而更好地参加“机器智能开发教育”，更好地学习如何规划、设计、开发比较完整的机器智能。 同时，这里的机器智能开发将针对科普教育解决方案“公众号+Bot+内容”进行开发，希望能够创造性地改进这个解决方案，特别是Bot的智能引擎改进与原创。 当然，这里的机器智能开发需要学习者掌握一定的软件编程、AI算法、AI引擎、机器学习、深度学习、AI数据、AI大数据等相关开发技能。 三、对Bot的思考: Bot是使用AI科技成果的一种最简洁产品形式，这是我们在“公众号+Bot+内容”解决方案之中选择Bot的主要原因。下面我们从教学内容、教学手段、教学成果三方面比较深入第探讨一下对Bot的思考。 （一）Bot是教学内容: 在我们的“公众号+Bot+内容”解决方案中，Bot首先是教学内容。 1．Bot的最简使用: 作为教学内容，Bot可以给我们带来最简的AI使用体验。比如，每个用户只需要到图灵机器人的官方网站http://www. tuling123. com上注册登录，然后创建自己的Bot机器人，并把所创建的Bot机器人与用户自己的微信公众号绑定起来，这样，被绑定的公众号就可以使用Bot与用户聊天。整个过程只需要几分钟就可以完成。通过这样的学习和使用Bot的过程，用户就可以获得学习和使用AI的信心。 2．Bot的AI多种功能使用: 可以通过Bot学习使用多种AI功能。比如，图灵机器人的官方网站除了给用户提供免费的Bot机器人创建和运营服务之外，同时还提供每月几十元到一百多元多档次的收费服务，支持用户为自己的Bot机器人配置使用多种收费的AI功能，如图像识别、语音识别与合成、自然语言智能等。 3．Bot的个性化内容开发和运营: 解决方案“公众号+Bot+内容”是普通大众用户创建和运营自己的微信公众号、Bot聊天机器人、个性化内容的完整解决方案。使用该解决方案，用户可以为自己的公众号客户提供资讯媒体、产品营销、客户服务、教育培训等多种服务，开发和运营用户的个人或企业品牌。其中，在Bot中导入不同的用户个性化内容，就可以改变Bot聊天的资料库内容，从而改变Bot的服务的内容，适应不同的个性化服务需求。 （二）Bot是教学手段: 在我们的AI教育中，Bot还可以作为一种教学工具来使用，即通过为Bot导入不同的课程内容改变Bot的聊天内容，为不同的课程提供教学问答服务。 1．用Bot获得最简的智能教学体验: 使用Bot作为教学手段（软件工具），可以可以通过简洁的Bot问答模式实现教学服务，获得最简的智能教学体验。这应该是一种比较容易被接受的教学手段。 2．用Bot提供不同的课程教学内容: 不同的教学课程有不同的教学内容。使用Bot作为教学手段，只需要把课程内容按照Bot要求的数据格式导入Bot，就可以让Bot按照所导入的课程内容聊天。 从课程教学内容讲，数据格式可以分为简单的问答格式、复杂的语义网络格式和知识树格式等。简单的Bot或Bot引擎只能处理简单的数据格式，复杂的Bot引擎才能处理复杂的数据格式。 3．用Bot提供不同的教学创新探索: Bot或Bot引擎或Bot智能引擎是机器模仿人类智能的系统，因此，人类的教学创新智能可以通过Bot引擎来模仿，使Bot成为教学创新的工具。 （三）Bot是教学成果: 在我们的AI教育解决方案中，Bot不仅是教学内容和手段，而且还是教学成果。至少有三类潜在的Bot教学成果：最简教学示范类Bot、各种创新探索类Bot、各种重点原创类Bot。 1．开发教学示范类Bot: 选择一种功能最简洁的开源Bot项目，组织学习者对Bot项目从产品管理、编程开发、敏捷开发等角度出发进行开发，展示更加完善的Bot示范功能。 2．开发创新探索类Bot: 选择各种感兴趣的开源Bot项目，组织学习者对不同的Bot项目从产品管理、编程开发、敏捷开发等角度出发进行开发，展示各种Bot创新探索成果。 3．开发原始创新类Bot: 根据国家《新一代人工智能发展规划》的指导，首先开展Bot应用开发，然后提出新一代AI原创理论，并开发相应的Bot原创技术和产品，展示我们在AI理论原创和Bot技术原创方面的成果。 四、对Wechaty的思考: Wechaty是一个使用Nodejs的开源Bot项目https://github. com/wechaty/wechaty，我们用Wechaty实现了微信群自动邀请入群的功能，获得了一点使用体验，而且感觉可以在AI教育之中用Wechaty开源项目做不少事情。 （一）理解Wechaty的价值: Wechaty的价值至少有三个方面：Bot聊天机器人、微信Web接口中间件、开放开源的Bot开发平台。 1．Wechaty是一种Bot: Wechaty是一种在微信环境下使用的Bot。一个微信用户登录Wechaty后，就可以把Wechaty与微信用户账号绑定在一起，使Wechaty代替该微信用户完成微信社交功能，包括聊天、邀请好友入群、从微信群移出用户等。 2．Wechaty是一种微信Web接口中间件: Wechaty把微信Web的公开接口汇聚在一起，包装成为微信Web接口中间件，具有微信Web接口提供的各种功能。开发者可以使用Wechaty开发与微信接口相关的各种Bot功能或产品。 3．Wechaty是一种开放开源的Bot开发平台: Wechaty作为一个软件开源项目，支持开发者开发自己的Bot技术和产品、开发基于Wechaty的各种开源项目等，可以说Wechaty是一种开放开源的Bot开发平台。 （二）使用Wechaty的体验: 2018年3月我们开始启动一个科技类的百场公益系列演讲，并把参加演讲的听众都汇聚在一个群里面进行后续的互动交流。为了实现Bot自动邀请入群的目的，我们在网上研究对比了一些微信Bot工具，发现Wechaty是当时最好的一个选择。 1．使用Wechaty实现自动邀请入群: 大家知道微信群人数少于100的时候，可以通过扫描群二维码入群。当人数达到100人之后，就必须通过好友邀请才能入群。为此，一个群主如果要把一些陌生人（如某个讲座的部分听众）加入微信群中，那么就必须首先加好友，然后再从微信群里面去邀请好友入群，被邀请的人接受邀请之后才可以完成入群的全部过程。 选择Wechaty之后，参照Wechaty提供的代码例子，我们很快编写完成了满足我们需求的一段JavaScript代码，并且按照Wechaty提供的操作说明，顺利通过了NPM和Docker两种运行模式的测试。从此之后我们每次演讲活动都可以使用群二维码和Wechaty自动地把新来的听众加入微信群，减轻了我们的相关智能工作。 2．使用Wechaty实现自动邀请入群的代码: 我们参照Wechaty代码例子改写的源代码如下： import { Wechaty, Room } from 'wechaty'const bot = Wechaty. instance()bot . on('scan', (url, code) =&gt; {  if (!/201|200/. test(String(code))) {   console. log(/201|200/. test)   const loginUrl = url. replace(/\/qrcode\//, '/l/')   require('qrcode-terminal'). generate(loginUrl)  }  console. log(url) }) . on('login', user =&gt; {  console. log(`${user} login`) }) . on('friend', async function (contact, request) {  if (request) {   await request. accept()   console. log(`Contact: ${contact. name()} send request ${request. hello}`)   let keyroom = await Room. find({ topic:  BIT百场讲座群  })   console. log( 邀请加入群：  + keyroom)   if (keyroom) {    await keyroom. add(contact)   }  } }) . on('message', async function (m) {  const contact = m. from()  const content = m. content()  const room = m. room()  console. log( 当前Room:   + room)  if (room) {   return //在群里都不说话  } else {   console. log(`Contact: ${contact. name()} Content: ${content}`)  }  if (m. self()) {   return  }  let keyroom = await Room. find({ topic:  BIT百场讲座群  })  if (keyroom) {   m. say( 您好！我是Bot，邀请您加入【BIT百场讲座群】 )   await keyroom. add(contact)  } }) . start()3．使用Wechaty实现自动邀请入群的效果: 减轻了群主邀请入群的智能工作负担，被邀请入群的朋友感觉Wechaty这个自动邀请入群的功能很有趣，激发了对Bot的一定兴趣和热情。 Wechaty没有运行的时候，微信用户也可以扫描群二维码要求入群，虽然自动邀请入群的功能无法实现，但是还是可以通过手工操作的方式把要求入群的微信用户加入目标微信群中。因此，使用Wechaty没有带来什么副作用。 （三）挖掘Wechaty的潜力: 我们感觉Wechaty具有很多潜力可以挖掘。比如我们可以从AI教学内容、AI教学手段、AI教学成果三个方面挖掘Wechaty在AI教育领域的潜力。 1．Wechaty作为AI教学内容: Wechaty本身包含很多内容，这些内容都可以作为AI教学内容来对待。 首先，作为AI教学内容，Wechaty可以引出这样一种解决方案：微信号+Wechaty+Bot引擎。其中，微信号是用户的微信号，Wechaty作为一种中间件或开发运营平台可以绑定用户的微信号和用户的Bot引擎，Bot引擎是由用户选择的可供Wechaty调用的具有各种各样功能的Bot引擎（如自动邀请好友加入微信群）。 其次，作为AI教学内容，Wechaty可以在上述解决方案中提供一些可以实际使用的Bot引擎供用户选用和定制开发。如用Wechaty自动邀请好友入群、根据他人的聊天内容而发布给定的聊天信息、调用任意给定的外部Bot引擎等。这样，Wechaty就可以成为一种实际可用的工具投入实际运营，快速解决各种实际问题。 最后，作为AI教学内容，Wechaty可以用于软件开源项目教学。学习者可以学习到的内容包括开源项目实践、Nodejs编程、微信接口使用、Bot引擎编程等，这些可以支持学习者在Wechaty开源项目基础上开发各种AI功能。 2．Wechaty作为AI教学手段: Wechaty作为开源项目，在其基础上可以开发各种AI功能，因此Wechaty可以作为AI教学手段或软件工具来对待。 首先，Wechaty作为AI编程的教学手段（软件工具），使用体验很简洁，而且可以很快解决微信社交中所遇到的问题（如自动邀请好友加入微信群）。 其次，Wechaty作为AI编程的教学手段，可以支持不同的课程教学实训，如Nodejs编程开发、微信接口使用、Bot引擎开发等。 最后，Wechaty作为AI编程的教学手段，可以支持不同的教学创新探索，特别是Bot引擎的创新探索。 3．Wechaty作为AI教学成果: 我们不仅可以使用Wechaty作为教学内容和教学手段，而且还可以通过Wechaty相关的AI教育，完善Wechaty这个开源项目本身，使其也成为AI教学成果。 首先，可以完善“微信号+Wechaty+Bot引擎”这个解决方案，提供SaaS服务模式为更多的用户服务。这样普通大众不需要做任何代码开发就可以使用Wechaty。 其次，在“微信号+Wechaty+Bot引擎”这个解决方案的SaaS服务平台上不断添加新的功能供用户选择使用，如更多的微信社交功能、更多的Bot引擎等，使Wechaty的这套解决方案具有更强的功能、更多的用户、更高的价值。 最后，通过“微信号+Wechaty+Bot引擎”这个解决方案的SaaS服务平台开发，使Wechaty这个软件开源项目更有价值，成为开放开源的AI创新创业平台。用户不仅可以在这个平台上开展AI教学、学习这个平台相关的AI教学内容，而且可以开发各种创新创业开源项目，特别是新一代人工智能的Bot引擎项目。 五、小结: 新一代AI热潮袭来，带来很多挑战和机会。我们希望通过全民AI教育来探讨这些挑战和机会。我们的全民AI教育从AI科普教育切入，开发人类智能和机器智能。Bot作为AI成果使用的形式，是我们全民AI教育的教学内容、教学工具、教学成果，贯穿于AI科普教育、AI开发教育、AI创新教育之中。Wechaty作为我们试用过的Bot开源项目在全民AI教育中可以发挥的地方很多。  Author: @李彬 ，清华大学博士。硅谷智慧科技公司创始人，贵州博士科技有限公司CEO。聚焦智慧AI创新创业，从AI科普教育切入，开展人机智慧智能开发教育，打造全民AI教育开放平台。30年前在清华大学电子工程系开始研究机器翻译，20年前到硅谷开始学习探索智慧智能科技，10年硅谷与国内高科技创业经历。 "
    }, {
    "id": 369,
    "url": "https://wechaty.js.org/2018/08/14/wechaty-lightbot-analytics/",
    "title": "Lightbot统计分析管理平台",
    "body": "2018/08/14 - 感谢 @lijiarui 邀请我分享我们的LIGHTBOT统计分析管理平台，希望能够帮助开发者使用wechaty提供更多的业务方向。 本人刚开始学习使用node，因此代码相对比较low，还请见谅。😄 项目介绍:  Lightbot统计分析管理平台在光链项目微信群中将主要起到两方面的作用，分别是维护管理和数据抓取两方面。机器人将做到内容的简单回复，包括好友自动通过，回复关键词自动邀请加入群组，这两个功能将保证投资人入群申请能够及时通过。在日常的群维护上，机器人将做到记录用户违规回复，超过3次警告并删除，同时，进行非工作时间常规问题关键词的自动回复，这两个功能将做到群维护的24小时无间断执行。同时也涉及到关键词管理，包括常规关键词和违规关键词，关键词将由管理员在后台进行设定，同时也能够根据群聊环境和项目进展进行及时调整。在违规用户方面，后台也将进行记录，方面管理员进行提醒和处理。在数据和人员管理方面，Lightbot统计分析管理平台将根据回复计算统计群成员，包括用户和管理员的的总体日活，周活和月活，方便群内做好正对性运营和管理。在文字方面，也将做好统计，具体体现在字数上，这一点也将对群聊质量进行把控。在用户分析上，后台数据将协助进行用户画像的归纳，包括性别，地域等，在群聊习惯方面，也将汇总回复时间等，方便管理员进行更有针对性的群聊回复。在机器人的后台，可以查多个微信群的具体的聊天记录，同时提供角色设置功能，角色包括用户、管理员、水军等，这两个功能将使管理员在后台查看具体至每个群每个角色的具体聊天内容，在统计数据的同时将完整的聊天记录同时抓取。 整个项目分为4大模块：  lightbot机器人（已完成） api接口服务（已完成50%） web端展示界面（已完成50%） cron定时任务（开发中）Lightbot功能: 自动抓取群信息:  通过遍历用户固定的群组，抓取群信息和群成员信息。并自动抓取用户的文本和图片留言。  我们在微信机器人登录的同时遍历要抓取的群组，抓取成功后做插入或更新操作，之后抓取群成员信息，同样在抓取成功后做插入或更新操作。缓存用户信息的目的是为了后期做用户活跃度统计，同时还可针对性筛选用户进行对话模式展示。 const bot = new Wechaty({ puppet: 'padchat' })const default_rooms = ['Test1','Test2','Test3'];bot. on('login', async user =&gt; {  default_rooms. forEach(async topic =&gt; {    let r = await bot. Room. find({      topic: topic    });    console. log(`The room ${topic} is ${isNotEmpty(r)}`);    if (r) {      saveRoom(r);    }  })})代码: // 保存群组信息const saveRoom = async function (room) {  let record = {};  record. id = room. id;  record. topic = await room. topic();  let members = await room. memberList();  record. member_num = members. length;  Query. saveRoom(record);  members. forEach(async c =&gt; {    if (c &amp;&amp; !c. self()) {      saveUser(c, room. id);    }  });}// 保存用户信息const saveUser = async function (contact, roomid) {  Query. isExisted(contact. id, roomid, async res =&gt; {    if (res === false) {      return;    }    try {      if (roomid) {        let user = new User(contact);        user. setRoomid(roomid);        user. setGender(contact. gender());        if (isNotEmpty(res) &amp;&amp; parseInt(res. id || 0) !== 0) {          user. setId(res. id);          if (isEmpty(res. name + '')) {            Query. syncContactName(user, res =&gt; {              info. info(`同步用户${contact. name()}昵称`);            });          }          if (res. avatar == null || res. avatar == 0) {            let avatar = await contact. avatar();            avatar = await avatar. toDataURL();            Query. insertImage(avatar, imgId =&gt; {              user. setAvatar(imgId);              Query. syncContactAvatar(user, res =&gt; {                info. info(`同步用户${contact. name()}头像`);              });            })          }        } else {          let avatar = await contact. avatar();          avatar = await avatar. toDataURL();          Query. insertImage(avatar, imgId =&gt; {            user. setAvatar(imgId);            Query. addUser(user, res =&gt; {              info. info(`新增用户${contact. name()}信息`);            });          })        }      }    } catch (e) {      err. error(e. message);    }  });} 其中Query是我写的一个数据库存储的工具类  用户头像我是用base64转码存储到数据库中，因此我会先保存用户头像，然后关联到用户表中，整个项目的所有图片我都是采用这种方式存储的，介于base64转码后，字符串过长，因此单独提取出来做一个表存储。通过id的形式关联到各主表中。 智能回复:  我们监听了用户的发言，根据用户的发言做智能回复。因为我们是要做留言字数的统计，从而区分优劣会员，因此我们只抓取文本和图片形式的留言。（图片形式的后期考虑引入AI识别功能，自动对图片做分析。） 管理平台有一套关键词的管理功能，可自行设置关键词的内容，支持模糊匹配和完全匹配。同时我们还添加了敏感词过滤，但凡踩坑3次以上的用户，那不好意思了～88了您嘞。做这个功能的主要目的还是为了保证和谐的群环境。 我们的智能回复并不是24小时都回复，只是为了减少我们运营人员的工作量，只在他们休息的时候工作，做到群管理无人值守。业务代码: // 消息自动回复bot. on('message', async function (message) {  if (message. self()) {    return  }  const content = message. text()  const sender = message. from()  const room = message. room()  if (message. type() !== Message. Type. Text &amp;&amp; message. type() !== Message. Type. Image) {    info. info(`消息类型：${message. type()},content=${content}`);    return  }  let topic = room ? await room. topic() : null;  if (room &amp;&amp; default_rooms. indexOf(topic) != -1) {    try {      // 判断是否是新用户，若是保存到数据库      saveUser(sender, room. id);    } catch (e) {      err. error(`saveUser error When get message. Error is : ${e}`);    }    try {      // 记录聊天信息      if (message. type() == Message. Type. Image) {        // 存储图片        let filebox = await message. toFileBox();        let msgContent = await filebox. toDataURL();        Query. addChat(msgContent, sender. id, room. id, 5);      } else {        // 存储文本        Query. addChat(content, sender. id, room. id, 6, async chatId =&gt; {          // 判断回复内容是否违规          Query. isFoul(content, chatId, async kid =&gt; {            if (kid != 0) {              // 记录并查询用户违规次数              Query. recordFoul(sender. id, room. id, chatId, kid, async times =&gt; {                if (times &gt; 2) {                  await room. say(`您已违规3次！`, sender);                  await room. del(sender);                } else {                  await room. say(`您的回复内容已违规，再违规${3-times}次将被踢出群组。`, sender);                }              });            } else {              let now = moment();              // 判断是否在机器人工作时间              if (now. isAfter(rest_time[0]) &amp;&amp; now. isBefore(rest_time[1])) {                // 查看是否踩中了关键词                Query. queryKeyword(content, chatId, 1, async reply =&gt; {                  await room. say(reply, sender);                });              }            }          });        });      }    } catch (e) {      err. error(`When save message. Error is ${e}`);    }  }})自动通过好友并回复信息: 为了减少运营人员对新用户申请的处理，我们借助wechaty实现了好友自动通过并回复信息的动能。并指示用户下一步的操作，可以回复指定内容自助加入群组。 bot. on('friendship', friendship);相关代码: const friendship = async friendship =&gt; {  if (friendship. type() === Friendship. Type. RECEIVE) { // 1. receive new friendship request from new contact    const contact = friendship. contact()    let result = await friendship. accept()    if (result) {      let msg = `你好，光链小助手欢迎你！回复“加入光链群”即可加入光链微信群，回复“联系小助手”稍后小助手将回复您。光链是全球首个“安全性，高性能，去中心化”三要素完备的公链。请关注光链其它社群及推广渠道：telegram电报群: t. me/lightchain_cn官方新浪微博：LightChain光链一直播ID：346346982交易平台：OKEx: www. okex. comIDAX：www. idax. mnKKcoin: www. kkcoin. com`;      contact. say(msg);      info. info(`Request from ${contact. name()} is accept succesfully!`)    } else {      err. error(`Request from ${contact. name()} failed to accept!`)    }  } else if (friendship. type() === Friendship. Type. CONFIRM) {    // 2. confirm friendship    info. info(`new friendship confirmed with ${contact. name()}`)  }}bot. on('message', async function (message) { . . .  if (content == '加入光链群' &amp;&amp; room == null) {    Query. queryRoomRandom(async res =&gt; {      const room = bot. Room. load(res. roomid);      if (room) {        let topic = await room. topic();        try {          await room. add(sender);          await room. say(`欢迎 ${sender. name()} 加入 ${topic} `, sender);        } catch (e) {          err. error(`Can't join room. ${e}`);          console. error(e)        }      }    });    return  } . . . }); 监听好友申请，自动通过申请，并提示下一步操作。  在监听消息时，如果完全匹配到加入光链群，并且是直接发给机器人的，那么会根据群组人数排序加入群组。 统计分析平台: 架构设计:  渲染引擎是React  前端框架采用的是阿里巴巴蚂蚁金服开源的Ant Design。  整体架构是在Ant Admin基础上改的。  数据库采用的mysql8. 0  服务是node server我自己封装的。 业务功能:  目前只实现了各个模块的管理功能  统计相关功能将在月底前开发完成，届时我会上来更新blog，感谢大家的支持。 关键词管理:  关键词分页查询  关键词支持完全匹配和模糊匹配，优先完全匹配。  支持查询条件筛选 敏感词管理:  对敏感词的管理 聊天管理: 聊天记录 根据群，用户角色和时间进行分页查询 对话模式 根据群，特定用户，时间进行数据筛选  过滤掉多余人员的发言，只显示筛选用户的聊天记录 用户管理:  快速查看用户基本信息  设置用户的角色（用户，水军，管理员），从而进行群活跃分析。 群组管理:  查看群组信息  设置责任账户（这个是为了体现运营人员水平而设置的） 统计分析: 功能开发中，敬请期待。。。  Author: @LittleStrong, WEB Development Manager at iTrustdata, 喜欢挖坑与填坑😝 "
    }, {
    "id": 370,
    "url": "https://wechaty.js.org/2018/08/14/docker-wechaty-getting-started/",
    "title": "Docker Wechaty Getting Started",
    "body": "2018/08/14 -  GitHub Repo: https://github. com/wechaty/docker-wechaty-getting-started Features:  Wechaty is fully dockerized. So it will be very easy to be used as a MicroService.  Clone the above repository, then you will be able to use Docker to run Wechaty with ZERO configuration. Requirements:  Docker Global Internet ConnectionUsage: It’s very easy to use Wechaty with Docker. 1. Run TypeScript Example: bash -x bin/docker-run-typescript. sh2. Run ES6 Javascript Example: bash -x bin/docker-run-javascript-esm. shRun Vanilla Javascript Example: We will not support CommonJS after we upgrade to Wechaty v1. x Docker: 1. Install Docker: Quick &amp; easy install Docker via: curl -sSL https://get. docker. com | shOr wget -qO- https://get. docker. com/ | shGet to know more about Docker at: https://www. docker. com/ Network Issues: If you have been experiencing issues with Docker in China, you can try to use a VPS out of China and see if it helps. Most of the time, it will be a good idea to use a VPS out of China. "
    }, {
    "id": 371,
    "url": "https://wechaty.js.org/2018/08/13/wechaty-xiaoli-bot/",
    "title": "用wechaty实现新闻资讯播报机器人",
    "body": "2018/08/13 -  感谢 @lijiarui 邀请我分享我们的智能内容服务，以及在wechaty上的应用场景。 我们在小理智能开发了一套智能内容服务系统，能够为各个领域提供智能资讯接口，包括新闻搜索、主题订阅、日报订阅等，帮助开发者将内容服务整合到自己的系统和产品中（关于小理内容接口的详细介绍看这里）。 在小理内部，我们用这些接口进行社群自动化运营，比如给群里定时推送某一个主题的新闻资讯，自动维护群的活跃度，并且带来额外流量。以下给出两个典型的应用场景：智能资讯问答以及日报定时推送。 智能资讯问答: 新闻资讯的查询、播报是很多智能对话机器人技能中很重要的一环，一个经典的场景就是用户就自己感兴趣的关键词提问，机器人返回和该关键词相关的最新新闻资讯，如下图： 以上场景中我们询问了机器人关于微信机器人的最新消息，并且查看了其中一条新闻的详细内容。利用wechaty和小理的内容接口，我们可以很方便的实现以上功能。直接上代码： const bot = new Wechaty({  profile: config. default. DEFAULT_PROFILE,})bot. on('message', onMessage)async function onMessage(msg) {  let msgText = msg. text()  // A super naive implementation of intent detection for news query  if (msgText. endsWith( 最新消息 ) &amp;&amp; msgText. length &gt; 4) {    respText = await searchNews(msgText. substring(0, msgText. length-4)) // call xiaoli's news API    await msg. say(respText)  }}我们监听消息发送事件，并且对收到的消息进行意图识别。这里我们做最简单的实现：只要收到XXX最新消息这种模式的信息，就提取前面的XXX部分作为关键词，来进行新闻查询。目前一些开源或商业的解决方案，如科大讯飞等，可以实现更加准确的意图识别供开发者使用，这里不赘述。 接下来实现searchNews方法的业务逻辑。我们只要传入消息中的关键词，调用小理的新闻搜索API，对结果进行处理后返回即可： import fetch from 'node-fetch'/** * query xiaoli's api for news related to the keyword * @param keyword: search keyword */async function searchNews(keyword) {  let searchURL = 'https://api. xiaoli. ai/v1/api/search/basic'  let postBody = {     keywords : [keyword],     token :  45d898b459b4a739474175657556249a   }  let okCallback = makeSearchResponseText  let resText = await fetchXiaoliAPI(searchURL, postBody, okCallback);  return resText}以上代码中，postBody中的token用于验证用户身份；fetchXiaoliAPI是一个异步方法，使用了node-fetch这个第三方库进行网络调用，将小理API返回的JSON数据解析后返回具体的数据，或者错误信息： /** * Fetch response from xiaoli API * @param URL * @param postBody * @param okCallback: covert json to msg text when fetch succeeds */async function fetchXiaoliAPI(URL, postBody, okCallback) {  let resText = null  try {    let resp = await fetch(      URL,      {        method:  POST ,        body: JSON. stringify(postBody), // put keywords and token in the body      }    )    let resp_json = await resp. json()    if (resp. ok) {      // status code = 200, we got it!      resText = okCallback(resp_json['data'])    } else {      // status code = 4XX/5XX, sth wrong with API      resText = 'API ERROR: ' + resp_json['msg']    }  } catch (err) {    resText = 'NETWORK ERROR: ' + err  }  return resText;}成功获取数据的回调方法makeSearchResponseText提取返回数据中的的新闻标题（title字段），拼成一段字符串回复给用户。 /** * parse the returned json for a list of news titles */function makeSearchResponseText(json_obj) {  preNewsList = []  let newsList = json_obj. contents  if (newsList. length === 0) {    return  暂无相关新闻   }  let newsText = ''  for (let i = 0; i &lt; newsList. length; i++) {    newsText += (i+1) + '. ' + newsList[i]. title + '\n'    preNewsList. push(newsList[i]. news_abstract) // Save the news details for later queries  }  newsText +=  \n回复\ #+数字\ (例如\ #1\ )看详情   return newsText}以上我们实现了最简单的新闻查询功能。 接下来，我们希望用户能够回复数字看某条新闻的详情，这也能够通过小理的接口实现。小理对每篇新闻自动提取了摘要，我们可以将新闻的摘要存在临时变量里面，当用户输入数字的时候返回对应的结果。 首先定义临时变量: let preNewsList = []查询新闻时暂存这些新闻的摘要（news_abstract字段）: function makeSearchResponseText(json_obj) {  //. . .   for (let i = 0; i &lt; newsList. length; i++) {    //. . .     preNewsList. push(newsList[i]. news_abstract) // Save the news details for later queries  }  //. . . }监听到数字模式，返回对应结果： async function onMessage(msg) {  let msgText = msg. text()  // query for news details  if (msgText. startsWith('#')) {    newsNum = parseInt((msgText. substring(1)), 10) - 1    if (newsNum &lt; preNewsList. length &amp;&amp; newsNum &gt;= 0) {      await msg. say(preNewsList[newsNum])    }  }}到此，一个简单的新闻查询机器人就大功告成啦。除了这个例子中用到的新闻标题和摘要字段，接口还提供了时间、图片、url等基本信息；我们还支持包含复杂条件组合的多关键词搜索。开发者可以用这些接口完成更加复杂的功能。 日报定时发送: 微信群是目前进行兴趣交流、社群运营的一个重要工具。为了保持微信群的活跃度，群主往往需要定期在群里推送和群主题相关的聚合内容。例如，在一个人工智能交流群里，群主会定期整理人工智能相关资讯，在群里推送。 利用wechaty和小理的日报接口，我们就能把这项任务完全自动化！先看效果图： 小理会针对一些行业自动整理每天的相关新闻，生成一份日报，其中包含了多个主题版面，还能够通过智能分析算法自动生成新闻头条。接下来，我们就给机器人增加这个功能，让它每天定时在群里推送这样一份人工智能日报。首先实现sendDaily方法： async function sendDaily() {  const room = await bot. Room. find({topic: '小桔和小理'}) //get the room by topic  console. log('Sending daily to room ' + room. id)  let dailyText = await getDaily()  room. say(dailyText)}我们找到需要推送的群，往里面发送文本形式的日报。getDaily方法通过小理接口拿到日报数据： /** * query xiaoli's api for a daily news brief */async function getDaily() {  const dailyUuid = 'e02e6f14-3212-4d44-9f3d-1d79538c38f6'  let dailyURL = 'https://api. xiaoli. ai/v1/api/briefing/' + dailyUuid  let postBody = {     token :  45d898b459b4a739474175657556249a   }  let okCallback = makeDailyResponseText  let resText = await fetchXiaoliAPI(dailyURL, postBody, okCallback)  return resText}function makeDailyResponseText(json_obj) {  let secList = json_obj. sections  let newsText = '今日' + json_obj. title + '\n\n'  for (let i = 0; i &lt; Math. min(secList. length, 5); i++) {    newsText += secList[i]. title + '\n'    let newsList = secList[i]. contents    for (let j = 0; j &lt; Math. min(newsList. length, 3); j++) {      newsText += (j+1) + '. ' + newsList[j]. title + '\n'    }    newsText += '\n'  }  return newsText}其中，getDaily方法中的dailyUuid变量是人工智能日报的唯一标识（更多日报主题看这里）。日报由多个section（版面）组成，每个section包含一个当日相关新闻的列表。回调函数makeDailyResponseText中，我们取日报中前5个section，每个section取前三个新闻，拼成字符串。 接下来我们让机器人登录后定时调用sendDaily函数即可。这里我们用第三方模块node-schedule: import schedule from 'node-schedule'bot. on('login', onLogin)async function onLogin(user) {  schedule. scheduleJob('0 0 9 * * 1-5', sendDaily);}以上代码表示机器人会在周一到周五每天9:00am准时给群里发送一份人工智能日报。 到这里，这个又能查新闻，又能发日报的wechaty机器人就完成啦（完整代码看这里）。 附：如何使用小理的内容接口: 以基本的资讯接口为例：用户可以指定任意关键词，小理的接口能够返回和关键词相关的最新新闻。 例如，如果想要查询和”人工智能”相关的最新新闻，可以向小理的搜索接口地址https://api. xiaoli. ai/v1/api/search/basic发送包含如下数据的post请求： {  keywords : [ 人工智能 ],  token :  45d898b459b4a739474175657556249a }以上代码中的token用于验证用户身份。通过解析返回的JSON串，可以获得包含标题、URL、摘要等信息的最新相关新闻列表： {   data : {     contents : [      {         img_url :   ,         news_abstract :  . . . 在韩国，政府在2018年提出将在未来5年内投资2. 2万亿韩元(约合130亿元人民币)用于开发核心人工智能技术，并且计划在2022年前成为该领域的全球巨头。因此，全球人工智能已经进入加速发展期，主要国家争先在人工智能领域进行布局。未来，人工智能的发展将形成国家竞争的新分水岭，将成为世界主要国家产业博弈的核心阵地。新时代我国必须树立实体经济发展的新理念，深化人工智能技术在实体经济中的广泛应用，实现实体经济与人工智能的深度融合。 ,         pub_date :  2018-08-13T08:36:57. 950927 ,         seed_title :  中国网 ,         title :  推动实体经济与人工智能深度融合 ,         url :  https://base. xiaoli. ai/item/7b8803dc-1bab-43ba-a824-7db94c7a8cb2?app_uuid=516e44a5-06d0-403b-ab31-4a193c564cb4       },      {         img_url :   ,         news_abstract :  . . . 那么，什么才是人工智能企业的核心竞争力？对于初创企业来说，如何才能站稳脚跟而不被市场淘汰？直面隐忧，中国人工智能企业的机会何在？. . . 隐忧一：发展结构“头重脚轻”. . . 重点突破基础领域，建立自己的生态体系. . . 早在2015年，谷歌开放其内部使用的机器学习软件TensorFlow源代码，脸书、亚马逊和微软也纷纷发布其工程师用于机器学习的开源软件。似乎AI进入了“免费原材料”时代，人人都可以顺手取材。但是，“国外的开源布局对于我国AI行业发展而言，埋藏着巨大隐患。”远望智库人工智能事业部部长、图灵机器人首席战略官谭茗洲指出。 ,         pub_date :  2018-08-13T08:24:15. 201051 ,         seed_title :  人民网 ,         title :  直面隐忧 中国人工智能企业机会何在 ,         url :  https://base. xiaoli. ai/item/0ae5b7d2-a52f-4fef-9fc3-7296aec45ad0?app_uuid=516e44a5-06d0-403b-ab31-4a193c564cb4       },      . . .     ],    . . .   }}更多功能请开发者们参考小理的接口文档。 测试Token: 我们的系统目前属于内测阶段，尚未开放注册。调用接口需要使用验证token，为了方便大家测试，这里为大家准备了3个测试用的token： 45d898b459b4a739474175657556249a6d3b08ef9188c4d5c22739fb2f073b20ecefeb8778165cbdfb2bfaa66be42bfb以上token供大家测试功能使用，会有一定的频率和次数限制。 日报: 小理每天为近100个行业主题自动生成日报，并且支持用户自定义任意主题的日报。这里为大家准备了一些日报的dailyUuid： 互联网医疗日报: '60108efa-2a78-41d1-994d-cb53e0b66d2e'互联网社交娱乐日报: '07c3f2a1-9f2d-4e58-b324-54cd944adb17'互联网大数据日报: '6e442691-43b6-4e14-ae06-25089e53b9f6'云计算日报: 'bc30500e-3032-415d-9d40-c64e1f76b8e3'互联网金融日报: '639b5a58-1f86-463d-9358-d4369831711f'人工智能日报: 'e02e6f14-3212-4d44-9f3d-1d79538c38f6'如果有进一步的需求，欢迎大家通过微信(judaschrist)或者邮件(zhanglx@induta. com)和我们联系。 "
    }, {
    "id": 372,
    "url": "https://wechaty.js.org/2018/08/09/heroku-deploy-button-for-wechaty-starter-template/",
    "title": "Deploying Wechaty Bot from GitHub to Heroku as Easy as Clicking a Button",
    "body": "2018/08/09 -  GitHub Repo: https://github. com/wechaty/heroku-wechaty-getting-started At Chatie, we’ve created several getting-started tutorials to make developers’ lives easier. Deploying Wechaty Bot has involved following their prospective README’s step-by-step guides. Today, we’re starting to make deploying Wechaty Bot as easy as clicking a button – the Heroku button. What’s the Deploy to Heroku Button:  The Deploy to Heroku button enables users to deploy apps to Heroku without leaving the web browser, and with little or no configuration. The button is ideal for customers, open-source project maintainers or add-on providers who wish to provide their customers with a quick and easy way to deploy and configure a Heroku app. Learn more at: Creating a ‘Deploy to Heroku’ Button What Will I Benefit From the Deploy to Heroku Button:  You can deploy Wechaty Bot in your browser with one click, get your bot online on Heroku, and it’s free; You can clone heroku-wechaty-getting-started repository and modify it to fit your needs, then you will get your own Deploy to Heroku button for your own customized bot. Until then, enjoy! "
    }, {
    "id": 373,
    "url": "https://wechaty.js.org/2018/07/24/wechaty-installation-in-windows-10/",
    "title": "在 Windows 10 下安装 Wechaty",
    "body": "2018/07/24 -  感谢 @huan @lijiarui 让我在此分享我在 Windows 10 Home 平台安装 Wechaty 的经历，希望我对安装过程的记录和分析能帮助在此平台下安装 Wechaty 的人。 介绍: Wechaty 是一个对话机器人软件开发包，它可以帮你用 6 行 JavaScript 代码实现一个微信个人账号。由于使用 node 技术，它支持 Linux、Windows、macOS 平台和 Docker 容器。它的安装过程和其它 node 包类似，首先 git clone 源代码，再使用 node 的 npm 命令 npm install &amp; npm start 实现开箱即用，同时官方也提供了入门案例：Wechaty getting started。而在国内，实际安装过程中可能会因某些软件依赖的原因遇到问题，本文记录了安装过程中可能会出现的错误及解决办法，下面描述详细的步骤和说明：  项目地址: Wechaty Wechaty 起步: Wechaty Getting Started Wechaty 文档: Wechaty Documents概念:  Puppet: 一个包含了机器人对话逻辑的抽象类，是 Wechaty 技术架构的一部分。继承实现 Puppet 抽象类（协议）的组件，即可实现更广泛的与联系人、消息/一对一对话、群组/聊天室/多对多对话等相关逻辑。Puppet 的中文是木偶，用在这里相当传神。 node-gyp: 基于 gyp 编写的用来编译 node 本地扩展模块的 node 包，而 gpy 是 Chromium 项目上用于实现跨平台编译的工具。可参考 安装文档 windows-build-tools: node 包装的 Windows 平台的编译工具 node-expat: 基于 libexpat 的用来处理 XML 的 node 包，libexpat 是一个号称最快的 XML 解析库，纯 C 语言编写。Wechaty 使用它解析基于 XML 的通讯。可参考 安装文档 Python 2. 7: 一门愈久弥新的语言，node-gyp 的依赖 Python 2. 7 实现跨平台编译 puppeteer: 可编程的 Google Chrome， Google Chrome 团队官方出品。 Chromium: puppeteer 依赖一个特定的 Chromium 版本，Chrome 就是 开源 Chromium + Google 开发的闭源的扩展包。安装步骤: 一、下载 Wechaty 源代码 二、安装 Wechaty 依赖并配置 三、启动 Wechaty 详细步骤: 一、下载 Wechaty 源代码 首先我们建立源代码目录，本文使用 D:\code。如果你使用了其他目录，在后文中作相应的替换即可。 让我们从入门项目开始，运行以下命令下载，并进入项目目录： git clone https://github. com/lijiarui/wechaty-getting-started. gitcd wechaty-getting-started二、安装 Wechaty 依赖并配置 首先安装 node-v10. x. x。在 Windows 下，推荐使用官方提供的安装包，截至本文 最新 64 位系统安装包，如果网速不够，建议使用迅雷下载。 除了 node-v10 ，Wechaty 也依赖其它软件，而由于众所周知的网络原因，安装它们并不会太顺利。 此时，如果运行 npm install &amp; npm start，会报以下错误: Microsoft Windows [版本 10. 0. 16299. 492](c) 2017 Microsoft Corporation。保留所有权利。D:\code&gt;cd wechaty-getting-startedD:\code\wechaty-getting-started&gt;npm installnpm notice created a lockfile as package-lock. json. You should commit this file. added 134 packages from 94 contributors and audited 324 packages in 22. 581sfound 0 vulnerabilitiesD:\code\wechaty-getting-started&gt;npm start&gt; wechaty-getting-started@0. 1. 0 start D:\code\wechaty-getting-started&gt; node examples/starter-bot. js01:59:34 INFO Wechaty &lt;default&gt; start() v0. 18. 5 is starting. . . 01:59:34 INFO Wechaty initPuppet() using puppet: default01:59:34 INFO PuppetConfig installPuppet(wechaty-puppet-puppeteer@^0. 4. 2) please wait . . . npm:&gt; node-expat@2. 3. 16 install D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expat&gt; node-gyp rebuildnpm:D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expat&gt;if not defined npm_config_node_gyp (node  D:\Program Files\nodejs\node_modules\npm\node_modules\npm-lifecycle\node-gyp-bin\\. . \. . \node_modules\node-gyp\bin\node-gyp. js  rebuild ) else (node  D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\bin\node-gyp. js  rebuild )npm: gypnpm: ERR! configure errorgyp ERR! stack Error: Can't find Python executable  C:\Python36\python. EXE , you can set the PYTHON env variable. gyp ERR! stack   at PythonFinder. failNoPython (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure. js:483:19)gyp ERR! stack   at PythonFinder. &lt;anonymous&gt; (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure. js:508:16)gyp ERR! stack   at D:\Program Files\nodejs\node_modules\npm\node_modules\graceful-fs\polyfills. js:284:29gyp ERR! stack   at FSReqWrap. oncomplete (fs. js:158:21)gyp ERR! System Windows_NT 10. 0. 16299npm: gyp ERR! command  D:\\Program Files\\nodejs\\node. exe   D:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp. js   rebuild gyp ERR! cwd D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expatgyp ERR! node -v v10. 7. 0gyp ERR! node-gyp -v v3. 6. 2gyp ERR! not oknpm: npm WARNnpm: wechaty-puppet-puppeteer@0. 4. 2 requires a peer of brolog@^1. 6. 5 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of file-box@^0. 8. 22 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of hot-import@^0. 2. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of lru-cache@^4. 1. 3 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of qr-image@^3. 2. 0 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of promise-retry@^1. 1. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of rxjs@^6. 2. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of rx-queue@^0. 4. 26 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of state-switch@^0. 6. 2 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of watchdog@^0. 8. 10 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of wechaty-puppet@^0. 6. 4 but none is installed. You must install peer dependencies yourself. npm: npm ERR!npm: code ELIFECYCLEnpm ERR! errno 1npm ERR! node-expat@2. 3. 16 install: `node-gyp rebuild`npm ERR! Exit status 1npm: npm ERR!npm ERR! Failed at the node-expat@2. 3. 16 install script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm:npmnpm: ERR! A complete log of this run can be found in:npm ERR!   C:\Users\username\AppData\Roaming\npm-cache\_logs\2018-07-22T17_59_53_633Z-debug. log01:59:53 ERR PupptConfig puppetResolver(default) install fail: Command failed: npm install wechaty-puppet-puppeteer@^0. 4. 2gyp ERR! configure errorgyp ERR! stack Error: Can't find Python executable  C:\Python36\python. EXE , you can set the PYTHON env variable. gyp ERR! stack   at PythonFinder. failNoPython (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure. js:483:19)gyp ERR! stack   at PythonFinder. &lt;anonymous&gt; (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure. js:508:16)gyp ERR! stack   at D:\Program Files\nodejs\node_modules\npm\node_modules\graceful-fs\polyfills. js:284:29gyp ERR! stack   at FSReqWrap. oncomplete (fs. js:158:21)gyp ERR! System Windows_NT 10. 0. 16299gyp ERR! command  D:\\Program Files\\nodejs\\node. exe   D:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp. js   rebuild gyp ERR! cwd D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expatgyp ERR! node -v v10. 7. 0gyp ERR! node-gyp -v v3. 6. 2gyp ERR! not oknpm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of brolog@^1. 6. 5 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of file-box@^0. 8. 22 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of hot-import@^0. 2. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of lru-cache@^4. 1. 3 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of qr-image@^3. 2. 0 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of promise-retry@^1. 1. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of rxjs@^6. 2. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of rx-queue@^0. 4. 26 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of state-switch@^0. 6. 2 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of watchdog@^0. 8. 10 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of wechaty-puppet@^0. 6. 4 but none is installed. You must install peer dependencies yourself. npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! node-expat@2. 3. 16 install: `node-gyp rebuild`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the node-expat@2. 3. 16 install script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in:npm ERR!   C:\Users\username\AppData\Roaming\npm-cache\_logs\2018-07-22T17_59_53_633Z-debug. log{ Error: Command failed: npm install wechaty-puppet-puppeteer@^0. 4. 2gyp ERR! configure errorgyp ERR! stack Error: Can't find Python executable  C:\Python36\python. EXE , you can set the PYTHON env variable. gyp ERR! stack   at PythonFinder. failNoPython (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure. js:483:19)gyp ERR! stack   at PythonFinder. &lt;anonymous&gt; (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure. js:508:16)gyp ERR! stack   at D:\Program Files\nodejs\node_modules\npm\node_modules\graceful-fs\polyfills. js:284:29gyp ERR! stack   at FSReqWrap. oncomplete (fs. js:158:21)gyp ERR! System Windows_NT 10. 0. 16299gyp ERR! command  D:\\Program Files\\nodejs\\node. exe   D:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp. js   rebuild gyp ERR! cwd D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expatgyp ERR! node -v v10. 7. 0gyp ERR! node-gyp -v v3. 6. 2gyp ERR! not oknpm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of brolog@^1. 6. 5 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of file-box@^0. 8. 22 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of hot-import@^0. 2. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of lru-cache@^4. 1. 3 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of qr-image@^3. 2. 0 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of promise-retry@^1. 1. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of rxjs@^6. 2. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of rx-queue@^0. 4. 26 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of state-switch@^0. 6. 2 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of watchdog@^0. 8. 10 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of wechaty-puppet@^0. 6. 4 but none is installed. You must install peer dependencies yourself. npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! node-expat@2. 3. 16 install: `node-gyp rebuild`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the node-expat@2. 3. 16 install script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in:npm ERR!   C:\Users\username\AppData\Roaming\npm-cache\_logs\2018-07-22T17_59_53_633Z-debug. log  at ChildProcess. exithandler (child_process. js:291:12)  at ChildProcess. emit (events. js:182:13)  at ChildProcess. EventEmitter. emit (domain. js:442:20)  at maybeClose (internal/child_process. js:961:16)  at Process. ChildProcess. _handle. onexit (internal/child_process. js:248:5)killed: false,code: 1,signal: null,cmd: 'npm install wechaty-puppet-puppeteer@^0. 4. 2 ' }01:59:53 ERR Wechaty start() exception: Command failed: npm install wechaty-puppet-puppeteer@^0. 4. 2gyp ERR! configure errorgyp ERR! stack Error: Can't find Python executable  C:\Python36\python. EXE , you can set the PYTHON env variable. gyp ERR! stack   at PythonFinder. failNoPython (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure. js:483:19)gyp ERR! stack   at PythonFinder. &lt;anonymous&gt; (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure. js:508:16)gyp ERR! stack   at D:\Program Files\nodejs\node_modules\npm\node_modules\graceful-fs\polyfills. js:284:29gyp ERR! stack   at FSReqWrap. oncomplete (fs. js:158:21)gyp ERR! System Windows_NT 10. 0. 16299gyp ERR! command  D:\\Program Files\\nodejs\\node. exe   D:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp. js   rebuild gyp ERR! cwd D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expatgyp ERR! node -v v10. 7. 0gyp ERR! node-gyp -v v3. 6. 2gyp ERR! not oknpm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of brolog@^1. 6. 5 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of file-box@^0. 8. 22 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of hot-import@^0. 2. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of lru-cache@^4. 1. 3 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of qr-image@^3. 2. 0 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of promise-retry@^1. 1. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of rxjs@^6. 2. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of rx-queue@^0. 4. 26 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of state-switch@^0. 6. 2 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of watchdog@^0. 8. 10 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of wechaty-puppet@^0. 6. 4 but none is installed. You must install peer dependencies yourself. npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! node-expat@2. 3. 16 install: `node-gyp rebuild`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the node-expat@2. 3. 16 install script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in:npm ERR!   C:\Users\username\AppData\Roaming\npm-cache\_logs\2018-07-22T17_59_53_633Z-debug. log{ Error: Command failed: npm install wechaty-puppet-puppeteer@^0. 4. 2gyp ERR! configure errorgyp ERR! stack Error: Can't find Python executable  C:\Python36\python. EXE , you can set the PYTHON env variable. gyp ERR! stack   at PythonFinder. failNoPython (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure. js:483:19)gyp ERR! stack   at PythonFinder. &lt;anonymous&gt; (D:\Program Files\nodejs\node_modules\npm\node_modules\node-gyp\lib\configure. js:508:16)gyp ERR! stack   at D:\Program Files\nodejs\node_modules\npm\node_modules\graceful-fs\polyfills. js:284:29gyp ERR! stack   at FSReqWrap. oncomplete (fs. js:158:21)gyp ERR! System Windows_NT 10. 0. 16299gyp ERR! command  D:\\Program Files\\nodejs\\node. exe   D:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp. js   rebuild gyp ERR! cwd D:\code\wechaty-getting-started\node_modules\wechaty\node_modules\node-expatgyp ERR! node -v v10. 7. 0gyp ERR! node-gyp -v v3. 6. 2gyp ERR! not oknpm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of brolog@^1. 6. 5 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of file-box@^0. 8. 22 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of hot-import@^0. 2. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of lru-cache@^4. 1. 3 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of qr-image@^3. 2. 0 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of promise-retry@^1. 1. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of rxjs@^6. 2. 1 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of rx-queue@^0. 4. 26 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of state-switch@^0. 6. 2 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of watchdog@^0. 8. 10 but none is installed. You must install peer dependencies yourself. npm WARN wechaty-puppet-puppeteer@0. 4. 2 requires a peer of wechaty-puppet@^0. 6. 4 but none is installed. You must install peer dependencies yourself. npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! node-expat@2. 3. 16 install: `node-gyp rebuild`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the node-expat@2. 3. 16 install script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in:npm ERR!   C:\Users\username\AppData\Roaming\npm-cache\_logs\2018-07-22T17_59_53_633Z-debug. log  at ChildProcess. exithandler (child_process. js:291:12)  at ChildProcess. emit (events. js:182:13)  at ChildProcess. EventEmitter. emit (domain. js:442:20)  at maybeClose (internal/child_process. js:961:16)  at Process. ChildProcess. _handle. onexit (internal/child_process. js:248:5)killed: false,code: 1,signal: null,cmd: 'npm install wechaty-puppet-puppeteer@^0. 4. 2 ' }D:\code\wechaty-getting-started&gt;通过阅读上述日志，分析依赖关系如下: wechaty-puppet-puppeteer  --&gt; node-expat    --&gt; node-gyp      --&gt; gyp        --&gt; Python 2. 7 &amp; Windows Build Tools接下来要做的就是一一从依赖的最底层安装 1. 安装 Python 2. 7 至 C:\Python27\python. exe ，设置环境变量 PYTHON=C:\Python27\python. exe 注意 node-gyp 并不支持 Python 3. x，如果你安装了 Python 3. x，错误日志如下: Can't find Python executable  C:\Python36\python. EXE , you can set the PYTHON env variable. 你可能会疑惑这个本来存在的 Python 3 路径，个人认为这个不准确错误提示可以算入 npm 包的 Bug 2. 安装 windows-build-tools 参考 windows-build-tools 官方文档，有以下两种方式：  Visual C++ Build Tools Visual Studio 2017 vs Visual Studio 2015我这里由于已经安装 Visual Studio 2017 社区版，所以没有尝试其他选项。这里的关键是需要一个 VC++ 编译器来编译 Windows 本地程序。而 Visual C++ Build Tools 在微软官方地址已失效，不容易找到，npm 官方推荐了安装 Visual Studio 2015。安装结束后，可以使用 npm install node-expat 验证上述安装配置是否成功 4. 安装 puppeteer 由于网络原因，puppeteer 依赖的 Chromium 并不能顺利安装。此时，我们可以借助一个阿里巴巴公司提供的 cnpm 特色工具安装: npm install -g cnpm --registry=https://registry. npm. taobao. orgcnpm install puppeteerPS: 如果你遇到 Chromium revision is not downloaded. 时，在解决办法中看到的设置 PUPPETEER_SKIP_CHROMIUM_DOWNLOAD 其实是一个误导， 这个选项并不能帮助你安装 puppeteer，而是让你在更新时不必每次都下载 Chromium 二进制。 这里还有一个手动安装办法，但不推荐：可以手动下载 chromium 安装包，放在 /node_modules/puppeteer/. local-chromium/ 下，例如: D:\code\wechaty-getting-started\node_modules\_puppeteer@1. 6. 0@puppeteer\. local-chromium\win64-571375这个地址在 macOS 上如下，其中的数字可能不同: ~/node_modules/puppeteer/. local-chromium/mac-526987/chrome-mac4. . NET Framework 4. 5. 1 [仅 Windows Vista / 7 需要] 如果 Windows Vista / 7 版本，则需要手动安装 . Net Framework 5. 如果使用的是 PadChat 组件的 Wechaty，且已有相应 token 则还需要设置以下几个环境变量: WECHATY_LOG=sillyWECHATY_PUPPET=padchatWECHATY_PUPPET_PADCHAT_TOKEN=*YOUR-TOKEN*三、启动 Wechaty npm install &amp; npm start运行后，程序会在控制台窗口打开一个文本的二维码，在二维码下方是该二维码的网址。 如果你对扫描控制台的文本二维码遇到问题，可以参考我的 一篇关于二维码 的博文。 总结: 由于已成功启动项目，所以我并没有在 Windows 7 系统 或 32 位机上进行配置，主要问题应该差不多。解决办法建议查阅上述出现错误的软件文档来解决。 当然，如果你遇到了任何其他问题，也欢迎 我的Github 上联系我。 "
    }, {
    "id": 374,
    "url": "https://wechaty.js.org/2018/07/12/wechaty-new-release-version-0.18/",
    "title": "Wechaty New Release Version v0.18: SLOC from 27,630 to 7,817",
    "body": "2018/07/12 -   Picture Credit: Thumber. com All about Wechaty v0. 18 is to: Reduce Weight! With v0. 17, we have 27,630 source line of code with 377 unit tests(you can check it out at here if you are interested). Start from v0. 18, we have 7,817 lines of code left(v0. 17 is 353% of this!), with 10+ related npm modules. Let’s back to May 2016, when the first version of Wechaty was published, it only contains thousands of lines of the code, and at the end of the year 2016, we have about 10,000 lines of the code. (you can read our blog at this time) As the time passed by in 2017 &amp; 2018, we added more features to Wechaty, like send attachment files, support WeChat protocol other than web like ipad, which means we write more and more codes in Wechaty repository… at last we get almost 30,000 lines of the code, and to be precise: 27,630. (with 377 unit tests, you can check it out at here if you are interested) Is that fat? 30,000 lines of the code, is not too much, but it is not a small number too. After we finished abstracting the puppet base class after v0. 16, it seems we have very good reason to begin reducing weight:  Abstract Puppet Class need to be imported by every puppet implementations, and it should to be a solo npm module, with good version management.  Every Puppet Implentation Class is better to be a solo npm module, becasue we can only install the required source code that we needed. So at this version (v0. 18), we have the follow npm modules that splited out from Wechaty: WECHATY PUPPET LIST: 1. For Puppet User:       Stage   Name   Wechaty Puppet   Backend   Version         Release   puppeteer   PuppetPuppeteer   Web API via Browser Hooking          Beta   padchat   PuppetPadchat   iPad Protocol          Alpha   wechat4u   PuppetWechat4u   Web API via HTTP          Alpha   ioscat   PuppetIoscat (WIP)   iPhone App Hooking          Alpha   service   PuppetService   Chatie Cloud          TBW   Android       Android Hook   0. 0. 0       TBW   Win32       Win32 Hook   0. 0. 0   2. For Puppet Builder:       Stage   Name   Wechaty Puppet   Backend   Version         Release   N/A   Puppet   Abstract Base Class          Release   mock   PuppetMock   Mocking      If we count the other npm modules that split out from Wechaty before, we can also list them as the following:  @chatie/angular: Wechaty Component NgModule for Angular @chatie/graphql: GraphQL Schema, Providers and APIs for Chatie @chatie/grpc: gRPC for Chatie auth-angular: An Angular NgModule That Provide Auth0/Authing RxJS-ified Service with Lock UI botbuilder-wechaty-connector: Microsoft Bot Framework v3 Connector for Wechat PERSONAL Account Brolog: Brolog is Logger for Angular in Browser like Npmlog.  cloneClass: Clone an ES6 Class as Another Class Name for Isolating Class Static Properties.  finis: Node. js program finisher - run your last callback with exit code and signal name as arguments FileBox: Pack a File into Box for easy move/transfer between servers no matter of where it is. (local, remote url, or cloud storage) FlashStore: FlashStore is a Key-Value persistent, storage with easy to use ES6 Map-like API(both Async and Sync support), powered by LevelDB and TypeScript.  hotImport: Hot Module Replacement(HMR) for Node. js Listag: List Manager for Array Operations &amp; Query by Tag MemoryCard: Memory Card is an Easy to Use Key/Value Store Implements ES6 Map with Async API, with Swagger &amp; Serialization Support.  RxQueue: Easy to Use RxJS Queue for Throttle/Debounce/Delay/DelayExecute StateSwitch: State Switch is a Monitor/Guard for Managing Your Async Operations.  Watchdog: An Timer used to Detect and Recover from MalfunctionsHmm… lots of them aha? So how can we keep all of them in one repository and manage them easily? It must be a nightmare! So at last, as we published the v0. 18, we only left 3,853 source lines of the code in Wechaty repository(7,817 physical lines). We can see a timeline from the history: Source Lines of Code for Wechaty:       Date   SLOC   Factor(%)         2016. 5   3,000   38%       2017. 1   10,000   128%       2018. 1   20,000   256%       2018. 6   27,630   353%       2018. 7   7,817   100%   From 27,630 to 7,817, we are 72% off than before, cheers! Change Log: v0. 18. 0 (2018-07-11): Full Changelog Implemented enhancements:  PuppetPadchat Upgrade TODO Lists #1442 Dynamic install puppet implementations instead of pre-install #1437 Split PuppetWechat4u as a NPM module #1419 PuppetPadchat: The contact. star() doesn’t work #1413 Promote PuppetPuppeteer to SOLO NPM Module wechaty-puppet-puppeteer #1371 Promote Puppet to SOLO NPM Module wechaty-puppet #1370 New Puppet: PuppetMock for Testing &amp; Starter #1177Fixed bugs:  Cannot detect the the environment WECHATY_PUPPET v0. 17. 118 #1456 PuppetPadchat Server logout and login cycle average 3-5mins #1446 WARN PuppetPuppeteer initWatchdogForPuppet() dog. on(reset) last food:inited, timeout:120000 #1439 ts-node 7. 0 breaking change: Skip files by default #1383 Can not find room after add member to the room #1380 PuppetPadchat: friend value of ContactPayload is undefined #1359 WXGetContact cannot get user_name #1358 leveldown::Database::Close: Program terminated with signal SIGSEGV, Segmentation fault. #1355Closed issues:  QR Code problem under screen/xterm #1455 How to get the room title in v0. 17 wechaty? #1454 should not download chromium by default #1451 PuppetPadChat:Send media file. #1436 PuppetPadchat:My wechat accou can not login. #1416 It reports errors when the room delete one member. #1415 cannot get user\_name from raw payload: {} \[object Promise\] Error #1399 Where can I see the complete API documentation of puppet-padchat, such as createRoom and Moment #1391 still restart #1378 WARN PuppetPuppeteer #1376 m. say() repeat many many times #1216 room. say mention is not work #1185 获取所有群 #1020 Any way to keep login for days? #988Merged pull requests:  update version of puppet-padchat #1457 (windmemory) catch error when get undifined user_name in room #1408 (lijiarui) add a more suitable time to sync Contact and Room #1407 (lijiarui) mock self bot when WXGetContact() return null user_name #1405 (lijiarui) sync contact and room per hour #1402 (lijiarui) add friend in ContactPayload #1401 (lijiarui) fix Contact. findaAll() cannot get contact when user_name return undifined #1389 (lijiarui) fix bug that after a room add, the room id get removed from cache #1384 (windmemory)"
    }, {
    "id": 375,
    "url": "https://wechaty.js.org/2018/06/24/migrating-wechaty-v0.14-to-v0.18-guide-from-puppeteer-to-padchat-zh/",
    "title": "如何将业务代码从Puppeteer 迁移到Padchat",
    "body": "2018/06/24 - Wechaty 近期有了很大的升级，从0. 14版本之后，开始陆续支持各类非Web 版本的解决方案。我的业务逻辑代码重度依赖于wechaty，所以自从wechaty release 了0. 15 版本以后，我开始将我们的业务逻辑代码陆续从Web版本迁移到了非Web版本上来。 本篇博客主要介绍了我是如何将业务逻辑代码，从Puppeteer 迁移到 Padchat上的。 1. Puppeteer VS Padchat: 首先进行一下名词解释，在说这两个名词之前，先介绍一下Puppet Puppet 系统是一个用来连接Wechaty API 和其他的微信实现方式的连接器。简单的来说，通过微信API进行微信自动化操作会有很多种不同的是实现方式，比如基于网页微信的实现，基于ipad协议的实现，基于ios hook 的实现，基于windows hook 的实现，基于Android xposed的实现等等。不同的实现方法代码是完全不一样的。如果没有puppet 帮助桥接不同的实现方法，开发者就会有不同的接入API，这对上层业务逻辑的开发非常不方便，因此这是Puppet 系统设计的初衷。 现在再来介绍Puppeteer 和 Padchat 就会比较清楚了:  Puppeteer: 基于网页微信的实现，通过puppet连接到Wechaty API。 Padchat: 基于ipad 协议的实现，通过puppet 连接到Wechaty API。具体的Puppet 和各个实现方法，可以参考下图和这篇博客：Wechaty New Version 0. 16(BETA, with super power) Released 2. 如何无缝切换: 默认情况下，启动wechaty 是使用puppeteer的，切换成padchat 需要再运行的时候设置环境变量。 更多信息详细见wikiHow to run a new wecahty-puppet-padchat Git 源码的方式: 1. 拉下github最新的代码: git pullrm -rf package-lock. jsonrm -rf node_modules/npm install2. 获取token并设置环境变量: 在Wechaty v0. 17 Padchat Testing: Win32/iPad/Android/iOS/API Puppets Support are comming! 中进行alpha test 版本的内测报名，并获取到token： WECHATY_PUPPET_PADCHAT_TOKEN 3. 设置环境变量并运行: 记得要设置WECHATY_PUPPET=padchat 来切换puppet版本。 WECHATY_PUPPET_PADCHAT_TOKEN=your padchat token WECHATY_PUPPET=padchat node examples/ding-dong-bot. jsNPM: 1. 安装到最新版本的npm: npm install wechaty@next2. NPM下获取token并设置环境变量: 在#1296 中进行alpha test 版本的内测报名，并获取到token： WECHATY_PUPPET_PADCHAT_TOKEN 3. NPM下设置环境变量并运行: 记得要设置WECHATY_PUPPET=padchat 来切换puppet版本。 WECHATY_PUPPET_PADCHAT_TOKEN=your padchat token WECHATY_PUPPET=padchat  node examples/ding-dong-bot. jsDocker: 1. 拉下最新版本的docker 镜像: docker pull zixia/wechaty:latest2. 获取token: 在#1296 中进行alpha test 版本的内测报名，并获取到token： WECHATY_PUPPET_PADCHAT_TOKEN 3. Docker 下设置环境变量并运行:  记得要设置WECHATY_PUPPET=padchat 来切换puppet版本。 记得docker 版本不要重复安装wechaty 的npm 包，检查方法： 查看node_module 是否有wechaty，如果有就删掉它docker run -t -i -e WECHATY_PUPPET= padchat  -e WECHATY_PUPPET_PADCHAT_TOKEN= your token  --volume= $(pwd) :/bot --name=wechaty zixia/wechaty:latest examples/ding-dong-bot. ts3. 代码检查: wechaty 是使用typescript 写的，都是强类型的，我之前的代码没有统一typings，由于切换到padchat 以后，很多函数由同步变成了异步，所以索性我的代码也统一用了typings，并进行了类型检查。 人是一定会出错的，所以我们需要通过代码检查工具来发现代码错误、统一代码风格。我使用 TSLint 进行 TypeScript 的代码检查，编辑器用的是VSCODE。TSLint 支持自定义的代码检测规则。 为什么需要代码检查: 有人会觉得，JavaScript 非常灵活，所以需要代码检查。而 TypeScript 已经能够在编译阶段检查出很多问题了，为什么还需要代码检查呢？ 因为 TypeScript 关注的重心是类型的匹配，而不是代码风格。当团队的人员越来越多时，同样的逻辑不同的人写出来可能会有很大的区别：  缩进应该是四个空格还是两个空格？ 是否应该禁用 var？ 接口名是否应该以 I 开头？ 是否应该强制使用 === 而不是 ==？ 是否需要分号？这些问题 TypeScript 不会关注，但是却影响到多人协作开发时的效率、代码的可理解性以及可维护性。 这篇文章 给了很好的例子和相关说明，有兴趣的同学可以移步去看看 简单的说，虽然发现代码错误比统一的代码风格更重要，但是当一个项目越来越庞大，开发人员也越来越多的时候，代码风格的约束还是必不可少的。 使用tslint 工具代码检查: 1. 安装: TSLint 的使用比较简单，参考官网的步骤安装到本地即可： npm install --save-dev tslintnpm install tslint-config-standard2. 创建配置文件: 创建配置文件 tslint. json tslint 和tsconfig 建议参考wechaty 的配置：  tslint 配置文件 tsconfig 配置文件这里针对wechaty 的一些配置进行说明  “strict” : true 启用所有严格类型检查选项。 启用 –strict相当于启用 –noImplicitAny, –noImplicitThis, –alwaysStrict,–strictNullChecks和 –strictFunctionTypes和–strictPropertyInitialization。 “noEmitOnError”       : true 报错时不生成输出文件。 “noUnusedLocals”       : true 若有未使用的局部变量则抛错。 “noImplicitReturns”     : true 不是函数的所有返回路径都有返回值时报错。 “noFallthroughCasesInSwitch” : true 报告switch语句的fallthrough错误。（即，不允许switch的case语句贯穿） “strictNullChecks”      : true 在严格的 null检查模式下， null和 undefined值不包含在任何类型里，只允许用它们自己和 any来赋值（有个例外， undefined可以赋值到 void） “noImplicitAny”       : true 在表达式和声明上有隐含的 any类型时报错。 相关issue: ts-node 7. 0 breaking change: Skip files by default “no-floating-promises”: true 如果有async 方法，要求必须使用await。相关issue: Prevent the Floating Promise in the Async/Await Code “noUnusedParameters”     : true 若有未使用的参数则抛错。 “noImplicitThis”       : true 当 this表达式的值为 any类型的时候，生成一个错误。更多参考typescript 文档 3. 为 package. json 添加 tslint 脚本: {   scripts : {     lint :  tslint --project . src/**/*. ts src/**/*. tsx ,  }}其中 –project . 会要求 tslint 使用当前目录的 tsconfig. json 配置来获取类型信息，很多规则需要类型信息才能生效。 此时执行 npm run lint 即可检查整个项目 4. 在 VSCode 中集成 TSLint 检查: 在 VSCode 中安装 tslint 插件即可，安装好之后，默认是开启的状态。 5. 彩蛋: 唔。。。这里再赠送一个VSCode 插件彩蛋：editorconfig : 让使用不同编辑器的开发者在共同开发一个项目时“无痛”地遵循编码规范。更多说明见editorconfig官网 wechaty 的配置见 . editorconfig 4. BREAKING CHANGES: wechaty 升级版本后(参考博客)，虽然尽可能的减少接口变动，但是为了适配padchat， 还是会有一些接口有了不同程度的变化。因此在进行代码迁移的时候，我们也需要修改原来的部分代码，我把相关内容列在下面了，更多内容，建议仔细阅读CHANGE LOG bot. init() 变成了 bot. start(): bot. quit() 变成了 bot. stop(): FriendRequest 改成了 Friendship: FriendRequest class refactored. 之前 (v0. 14 或者更低): wechaty. on('friend', (contact, request) =&gt; { if (!request) {  // this is a friend request confirmation event } else {  // this is a friend request }})之后 (v0. 16 或者更高): wechaty. on('friendship', request =&gt; { switch (request. type()) {  case FriendRequest. Type. RECEIVE:   // this is a friend request request   break  case FriendRequest. Type. CONFIRM:   // this is a friend request confirmation   break }})建议仔细看代码friend-bot. ts 相关issue:  BREAKING CHANGE: v0. 16 on(‘friend`) arguments changed! BREAKING CHANGES v0. 16: FriendRequest class will be replaced with FriendshipMessage. content() 改成了 Message. text(): 从 v0. 16, Message. content() 依然是可被兼容的状态. 从 v0. 18, Message. content() 会彻底弃用. 相关issue:  BREAKING CHANGE: v0. 16 will replace Message. content() with Message. text()MediaMessage 将会被弃用: 从 0. 16, MediaMessage 依然是可被兼容的状态. 从 v0. 18, MediaMessage 会彻底弃用. 未来统一使用 Message 代码变化 - bot. say(new MediaMessage('/image. png')+ bot. say(new Message('/image. png')相关issue:  BREAKING CHANGE: v0. 16 will remove MediaMessage class介绍一个好用的发送图片的功能: 介绍一个非常好用的包: FileBox 官网, 一个将文件数据打包方便读取的npm 包，可以轻松地在具有最少有效负载的服务器之间进行传输，而不会比其位置（本地路径，远程URL或云存储）。详细使用方法见官网。 const fileBox = FileBox. fromStream(fs. createReadStream(BOT_QR_CODE_IMAGE_FILE),BOT_QR_CODE_IMAGE_FILE,)Wechaty. self() 改成了 Wechaty. userSelf(): 相关issue:  BREAKING CHANGE v0. 16 Wechaty. self() eprecated, use Wechaty. userSelf() insteadContact. personal() 和 Contact. official() 改成了 Contact. type(): 之前: const isPersonal = contact. personal()const isOfficial = contact. official()现在:  /**  * Return the type of the Contact  *  * @returns ContactType - Contact. Type. PERSONAL for personal account, Contact. Type. OFFICIAL for official account  * @example  * const isOfficial = contact. type() === Contact. Type. OFFICIAL  */ const type = Contact. type()相关issue:  BREAKING CHANGE v0. 16 Contact. personal() and Contact. official() deprecated, use Contact. type() insteadRoom. add() 返回值从 Promise&lt;boolean&gt; 变成了 Promise&lt;void&gt;: 相关issue:  BREAKING CHANGE v0. 16 room. add return Promise&lt;void&gt; instead of return Promise&lt;boolean&gt;Room. topic() 从Sync 变成了 Async: Room. topic() 之前: const topic = room. topic()Room. topic() 现在: const topic = await room. topic()相关issue:  BREAKING CHANGE: v0. 16 Room. topic() change from Sycn to AsyncRoom. alias(contact) 从Sync 变成了 Async: Room. alias(contact) 之前: const alias = room. alias(contact)Room. alias(contact) 现在: const alias = await room. alias(contact)相关issue:  BREAKING CHANGE: v0. 16 Room. alias(contact) change from Sycn to AsyncRoom. memberList() 从Sync 变成了 Async: Room. memberList() 之前: const memberList = room. memberList()Room. memberList() 现在: const memberList = await room. memberList()相关issue:  BREAKING CHANGE: v0. 16 Room. memberList() change from Sycn to AsyncRoom. member() 从Sync 变成了 Async: Room. member() 之前: const contact = room. member('Huan')Room. member() 现在: - const contact = room. member('Huan')+ const contact = await room. member('Huan')相关issue:  BREAKING CHANGES: v0. 16 Room. member() from sync to asyncRoom. has(contact) 从Sync 变成了 Async: Room. has(contact) 之前: const exist = room. has(contact)Room. has(contact) 现在: const exist = await room. has(contact)相关issue:  BREAKING CHANGE: v0. 16 Room. has(contact) change from Sycn to AsyncMessage. mention() 从Sync 变成了 Async: Message. mention() 之前: const mentionList = message. mention()Message. mention() 之后: - const mentionList = message. mention()+ const mentionList = await message. mention()相关issue:  BREAKING CHANGE: v0. 16 Message. mention() change from sync to asyncscan 事件参数发生了变化: 对老代码是兼容的 scan 事件之前: https://github. com/wechaty/wechaty/blob/860e85ec776ac20e92751ec4b67e0d539ef40a16/examples/ding-dong-bot. ts#L74-L77 scan 事件之后: https://github. com/wechaty/wechaty/blob/07008dff17ccc46b347ba28b85af167984573ea0/examples/ding-dong-bot. ts#L74-L76 请注意我们删除了 const loginUrl = url. replace(/\/qrcode\//, '/l/') 相关issue:  BREAKING CHANGE: v0. 16 scan event args will be different!Room,Contact,Message,FriendRequest在不能直接实例化: 相关错误信息:  Error: class can not be instanciated directly! Error: must not use the global Message/Contact/Room. use a cloned child via cloneClass instead由于 Contact, FriendRequest, Message, 和 Room 这些类要和 Puppet 绑定，所以这些类不能直接实例化 他们需要先有一个 cloneClass(), 然后才能和Puppet 绑定, 之后才能像下面一样使用:  wechaty. Contact, or puppet. Contact, etc. ~错误的做法~: import { Room } from 'wechaty'const room = await Room. create(. . . )上面的代码出出错 正确的做法: - import { Room } from 'wechaty'+ import { Wechaty } from 'wechaty'- const room = await Room. create(. . . )+ const wechaty = new Wechaty()+ const room = await wechaty. Room. create(. . . )Contact, FriendRequest, and Message这些也一样 Related Link  Error: class can not be instanciated directly! BREAKING CHANGE v0. 16 Contact, FriendRequest, Message, and Room classes will not be able to instantiate directly Error: static puppet not found Wechaty Multi-Instance Suport NPM clone-class https://github. com/huan/node-clone-class/issues/5Message. ext() 返回 . ext 而不是 ext: 根据ext() 在 Node/Python/C# 中的实现，我们的 ext() 也返回包括. 的文件扩展名。 所以更新如下： const ext = message. ext()// assume the filename is `test. txt`之前 (v0. 14 或更早): assert(ext === 'txt') 现在 (v0. 16 或之后): assert(ext === '. txt') 相关链接  BREAKING CHANGE: v0. 16 Message. ext() return ‘. ext’ instead of ‘ext’ before嗯，这大概就是所有的迁移记录了，谢谢！希望大家使用顺利！ "
    }, {
    "id": 376,
    "url": "https://wechaty.js.org/2018/06/24/migrating-wechaty-v0.14-to-v0.18-guide-from-puppeteer-to-padchat-en/",
    "title": "Migrating Wechaty v0.14 to v0.18 Guide - From Puppeteer To Padchat",
    "body": "2018/06/24 - Wechaty has been updated to version 0. 16(BETA) these days and begin to support all kinds of wechat solutions including web, ipad, ios, etc. My product based on wechaty has to migration from wechaty solution based on web to ipad solution. This blog introduces how to porting code from wechaty puppeteer to padchat.  1. Puppeteer VS Padchat: Puppet System means to connect Wechaty API to any kinds of Puppets, including Web, iPad, Android, Windows Hook and ios. Different implements of these puppets are totally different, without the puppet, using one API to bridge all implement is very difficult, so we had Puppet System.   Puppeteer: a solution based on Web Wechat Padchat: a solution based on Ipad WechatYou can find more in this blog: Wechaty New Version 0. 16(BETA, with superpower) Released 2. How to run puppet-padchat: Wechaty will start with puppeteer(web solution) by default, if you want to change to padchat, you need to set the environmental variable. See more in wechaty wiki: How to run a new wecahty-puppet-padchat Start with Github repo: 1. Pull the latest code: git pullrm -rf package-lock. jsonrm -rf node_modules/npm install2. Get Token: Participate in our alpha test here: Wechaty v0. 17 Padchat Testing: Win32/iPad/Android/iOS/API Puppets Support are coming! and Get WECHATY_PUPPET_PADCHAT_TOKEN 3. Set environment variable and run: Remeber to set WECHATY_PUPPET=padchat to change from puppeteer to padchat WECHATY_PUPPET_PADCHAT_TOKEN=your padchat token WECHATY_PUPPET=padchat node examples/ding-dong-bot. jsNPM: 1. Install: npm install wechaty@next2. Get token: Participate in our alpha test here: Wechaty v0. 17 Padchat Testing: Win32/iPad/Android/iOS/API Puppets Support are coming! and Get WECHATY_PUPPET_PADCHAT_TOKEN 3. Set environment variable &amp; run: Remeber to set WECHATY_PUPPET=padchat to change from puppeteer to padchat WECHATY_PUPPET_PADCHAT_TOKEN=your padchat token WECHATY_PUPPET=padchat  node examples/ding-dong-bot. jsDocker: 1. Install Docker: docker pull zixia/wechaty:latest2. Get Token for Docker: Participate in our alpha test here: Wechaty v0. 17 Padchat Testing: Win32/iPad/Android/iOS/API Puppets Support are coming! and Get WECHATY_PUPPET_PADCHAT_TOKEN 3. Set environment variable and Run:  Remeber to set WECHATY_PUPPET=padchat to change from puppeteer to padchat Remove wechaty in node_module if exist. docker run -t -i -e WECHATY_PUPPET= padchat  -e WECHATY_PUPPET_PADCHAT_TOKEN= your token  --volume= $(pwd) :/bot --name=wechaty zixia/wechaty:latest examples/ding-dong-bot. ts3. Check Code: Wechaty is written by typescript, all with strong typing. Since to change all wechaty code, I change my logic product to strong typing. We need tools to help us check our code errors. I use TSLint to help me to check typescript code and use VS CODE as my IDE. Why we need to check code: Maybe you think JavaScript is so flexible so it needs to be checked, but typescript has been able to check out a lot of problems when compiling. Why do we still need to check the code? This is because TypeScript focuses on the type of match, not the code style. When there are more and more people on our team, the same logic may be totally different in different people:  Four spaces indentation or two spaces indentation? Should we disable var? Should all the interface name begin with I? Should it be mandatory to use === instead of ==? Should we need a semicolon?TypeScript will not concern these problems, but these affect the efficiency of multi-person collaboration when developing, and how easy the code to read and maintain. This blog explain why we need to check code in typescript. In one word, though code errors are more important than the uniform code style when a project becomes bigger and more and more developers join in, the code style constraints are still very important. Using TSLint: TSLint is an extensible static analysis tool that checks TypeScript code for readability, maintainability, and functionality errors. It is widely supported across modern editors &amp; build systems and can be customized with your own lint rules, configurations, and formatters. Learn more in TSLint Website 1. Install TSLint: npm install --save-dev tslintnpm install tslint-config-standard2. Config File: Create config file tslint. json I suggest to refer wechaty config about tslint and tsconfig  tslint config file in wechaty tsconfig config file in wechatyHere are some tips about wehcaty config:  “strict” : true Enable all strict type checking options.  Enabling –strict enables –noImplicitAny, –noImplicitThis, –alwaysStrict, –strictNullChecks, –strictFunctionTypes and –strictPropertyInitialization “noEmitOnError”       : true Do not emit outputs if any errors were reported.  “noUnusedLocals”       : true Report errors on unused locals.  “noImplicitReturns”     : true Report error when not all code paths in function return a value.  “noFallthroughCasesInSwitch” : true Report errors for fallthrough cases in switch statement.  “strictNullChecks”      : true In strict null checking mode, the null and undefined values are not in the domain of every type and are only assignable to themselves and any (the one exception being that undefined is also assignable to void).  “noImplicitAny”       : true Raise error on expressions and declarations with an implied any type.  Related issue: ts-node 7. 0 breaking change: Skip files by default “no-floating-promises”: true Check the floating promise。Related issue: Prevent the Floating Promise in the Async/Await Code “noUnusedParameters”     : true Report errors on unused parameters. 。 “noImplicitThis”       : true Raise error on this expression with an implied any type. see more in official website 3. Add tslint script for package. json: {   scripts : {     lint :  tslint --project . src/**/*. ts src/**/*. tsx ,  }}-- project . require all tslint to use tsconfig. json configuration of the current directory to get the information. Then run npm run lint will check the whole code. 4. Add TSLint to VSCode: Search tslint and install a plugin for vscode. It is enabled by default. 5. Sweet Tips: I also recommend another plugin in vscode: editorconfig: EditorConfig helps developers define and maintain consistent coding styles between different editors and IDEs. see more: Official EditorConfig Website You can find wechaty editorconfig in . editorconfig 4. BREAKING CHANGES: After upgrade wechaty, see more inblog. Although we are trying to minimize API changes, there are some breaking changes. I really suggest you reading CHANGE LOG. Also, I list some important changes here: bot. init() change to bot. start(): bot. quit() change to bot. stop(): FriendRequest change to Friendship: FriendRequest class refactored. Before (v0. 14 or below): wechaty. on('friend', (contact, request) =&gt; { if (!request) {  // this is a friend request confirmation event } else {  // this is a friend request }})After (v0. 16 or above): wechaty. on('friendship', request =&gt; { switch (request. type()) {  case FriendRequest. Type. RECEIVE:   // this is a friend request request   break  case FriendRequest. Type. CONFIRM:   // this is a friend request confirmation   break }})Related link:  friend-bot. ts BREAKING CHANGE: v0. 16 on(‘friend`) arguments changed! BREAKING CHANGES v0. 16: FriendRequest class will be replaced with FriendshipMessage. content() change to Message. text(): From v0. 16, Message. content() will be deprecated. From v0. 18, Message. content() will be removed. Related Link:  BREAKING CHANGE: v0. 16 will replace Message. content() with Message. text()Remove MediaMessage class: From v0. 16, MediaMessage will be deprecated. From v0. 18, MediaMessage will be removed. Use Message instead. Migration Example - bot. say(new MediaMessage('/image. png')+ bot. say(new Message('/image. png')Related issue  BREAKING CHANGE: v0. 16 will remove MediaMessage classA useful tip to send the image: FileBox, FileBox is a virtual container for packing a file data into it for future readers, and easily transport between servers with the least payload, no mater than where it is (local path, remote URL, or cloud storage). const fileBox = FileBox. fromStream(fs. createReadStream(BOT_QR_CODE_IMAGE_FILE),BOT_QR_CODE_IMAGE_FILE,)Wechaty self() change to Wechaty. userSelf(): Related issue:  BREAKING CHANGE v0. 16 Wechaty. self() eprecated, use Wechaty. userSelf() insteadContact. personal() and Contact. official() change to Contact. type(): Contact. personal() Before: const isPersonal = contact. personal()const isOfficial = contact. official()Contact. personal() sAfter:  /**  * Return the type of the Contact  *  * @returns ContactType - Contact. Type. PERSONAL for personal account, Contact. Type. OFFICIAL for official account  * @example  * const isOfficial = contact. type() === Contact. Type. OFFICIAL  */ const type = Contact. type()Related issue  BREAKING CHANGE v0. 16 Contact. personal() and Contact. official() deprecated, use Contact. type() insteadRoom. add() return from Promise &lt;boolean&gt; to Promise&lt;void&gt;: Related issue:  BREAKING CHANGE v0. 16 room. add return Promise&lt;void&gt; instead of return Promise&lt;boolean&gt;Room. topic() change from Sycn to Async: Room. topic() Before: const topic = room. topic()Room. topic() After: const topic = await room. topic()Related issue:  BREAKING CHANGE: v0. 16 Room. topic() change from Sycn to AsyncRoom. alias(contact) change from Sycn to Async: Room. alias(contact) Before: const alias = room. alias(contact)Room. alias(contact) After: const alias = await room. alias(contact)Related issue:  BREAKING CHANGE: v0. 16 Room. alias(contact) change from Sycn to AsyncRoom. memberList() change from Sycn to Async: Room. memberList() Before: const memberList = room. memberList()Room. memberList() After: const memberList = await room. memberList()Related Issue:  BREAKING CHANGE: v0. 16 Room. memberList() change from Sycn to AsyncRoom. member() from sync to async: Room. member() Before: const contact = room. member('Huan')Room. member() After: - const contact = room. member('Huan')+ const contact = await room. member('Huan')Related Issue:  BREAKING CHANGES: v0. 16 Room. member() from sync to asyncRoom. has(contact) change from Sycn to Async: WARNING: This change will let us make more mistakes: if (room. has(contact)) { console. error('here will always be executed because Promise === true')}Room. has(contact) Before: const exist = room. has(contact)Room. has(contact) After: const exist = await room. has(contact)Related Link:  BREAKING CHANGE: v0. 16 Room. has(contact) change from Sycn to Async Detect missing await in TypeScriptMessage. mention() change from Sync to Async: BREAKING CHANGE: v0. 16 Message. mention() change from sync to async Message. mention() Before: const mentionList = message. mention()Message. mention() After: - const mentionList = message. mention()+ const mentionList = await message. mention()Related issue:  BREAKING CHANGE: v0. 16 Message. mention() change from sync to asyncscan Event args will become different: The good news is: the old code seems will run without problem, because it will just do nothing: const loginUrl = url. replace(/\/qrcode\//, '/l/') scan Event Before: https://github. com/wechaty/wechaty/blob/860e85ec776ac20e92751ec4b67e0d539ef40a16/examples/ding-dong-bot. ts#L74-L77 scan Event After: https://github. com/wechaty/wechaty/blob/07008dff17ccc46b347ba28b85af167984573ea0/examples/ding-dong-bot. ts#L74-L76 Notice that we deleted the const loginUrl = url. replace(/\/qrcode\//, '/l/') Related Issues:  BREAKING CHANGE: v0. 16 scan event args will be different!Class cannot be instantiated directly: Error Message:  Error: the class cannot be instantiated directly! Error: must not use the global Message/Contact/Room. use a cloned child via clone class insteadCurrently, the Contact, FriendRequest, Message, and Room classes will not be able to instantiate directly, because they must attach with a Puppet. They need to be cloneClass()-ed first, then attach the puppet, and at last they will be ready for use by:  wechaty. Contact, or puppet. Contact, etc. ~Do Not~: import { Room } from 'wechaty'const room = await Room. create(. . . )The above code will throw an error. Do: - import { Room } from 'wechaty'+ import { Wechaty } from 'wechaty'- const room = await Room. create(. . . )+ const wechaty = new Wechaty()+ const room = await wechaty. Room. create(. . . )So does Contact, FriendRequest, and Message. Related Link  Wechaty Multi-Instance Support #518 NPM clone-class https://github. com/huan/node-clone-class/issues/5Related issue  Error: class can not be instanciated directly! BREAKING CHANGE v0. 16 Contact, FriendRequest, Message, and Room classes will not be able to instantiate directly Error: static puppet not found Wechaty Multi-Instance Suport NPM clone-class https://github. com/huan/node-clone-class/issues/5Message. ext() return ‘. ext’ instead of ‘ext’ before: According to the ext() methods behavior in Node/Python/C# etc, the ext() always return the filename extension that including the dot(. ). So the following BREAKING CHANGE was made in v0. 15: const ext = message. ext()// assume the filename is `test. txt`Before (v0. 14 or earlieer): assert(ext === 'txt') After (v0. 16 or later): assert(ext === '. txt') Related Link  BREAKING CHANGE: v0. 16 Message. ext() return ‘. ext’ instead of ‘ext’ beforeHmmm… That’s all and wish you can have a good coding experience, thanks! "
    }, {
    "id": 377,
    "url": "https://wechaty.js.org/2018/06/21/wechaty-new-release-version-0.16/",
    "title": "Wechaty New Version 0.16(BETA, with super power) Released",
    "body": "2018/06/21 -  The Wechaty has been updated to version 0. 16(BETA) today. This release is a BETA release which had been improved with lots of huge refactoring since v0. 14. With v0. 16, we can use the branding new Puppet System to connect Wechaty API to any kinds of Puppets, for example:  Mocking - PuppetMock Web API via HTTP - PuppetWechat4U Web API via Browser - PuppetPuppeteer (our classic PuppetWeb) Maybe a Official Account Puppet? #1016If you are using Wechaty in a production environment, It is recormmand to skip this version and wait to the next version of 0. 18 because this version is still in testing stage and will be continue developing as v0. 19. However, if you want to try the new Puppet like the PuppetPadchat which is powered by the Wechat Pad Protocol, you can upgrade to this version and get the following benifits from it:  Be able to login with the newly registered Wechat Account. (#872) Get wechat id for contacts. (#133) Get consistent room id for rooms across login session.  (#90) … To be discovered by you …Learn more about how to use the PuppetPadchat from Wechaty v0. 15 Alpha Testing: Win32/iPad/Android/iOS/API Puppets Support are comming! #1296 Please file a new issues if you meet any bug or have any feature suggestions, and PR is always welcome(with an issue created first). Huan LI CHANGE LOG:  BREAKING NEWS: Wechaty logo color was changed from green to blue! There will be a migration guide from v0. 14 to v0. 16 will be published on our blog later. 1. BREAKING CHANGES: 1. 1 Class Removal:  BREAKING CHANGE: v0. 16 will remove MediaMessage class #1164 BREAKING CHANGES v0. 16: FriendRequest class will be replaced with Friendship #1312 BREAKING CHANGE v0. 16 Contact, FriendRequest, Message, and Room classes will not be able to instantiate directly #13641. 2. Sync to Async:  BREAKING CHANGE: v0. 16 Room. topic() change from Sycn to Async #1295 BREAKING CHANGE: v0. 16 Room. alias(contact) change from Sycn to Async #1293 BREAKING CHANGE: v0. 16 Room. memberList() change from Sycn to Async #1290 BREAKING CHANGE: v0. 16 Room. has(contact) change from Sycn to Async #1289 BREAKING CHANGE: v0. 16 Message. mention() change from sync to async #1259 BREAKING CHANGES: v0. 16 Room. member() from sync to async #12581. 3. Argument / Return Value:  BREAKING CHANGE v0. 16 room. add return Promise&lt;void&gt; instead of return Promise&lt;boolean&gt; #1362 BREAKING CHANGE: v0. 16 scan event args will be different! #1262 BREAKING CHANGE: first arg of room-leave event licener changed from Contact to Contact[] #723 BREAKING CHANGE: v0. 16 on(‘friend`) arguments changed! #11961. 4. Deprecated:  BREAKING CHANGE v0. 16 Wechaty. self() eprecated, use Wechaty. userSelf() instead #1369 BREAKING CHANGE v0. 16 Contact. personal() and Contact. official() deprecated, use Contact. type() instead #1366 BREAKING CHANGE: v0. 16 will replace Message. content() with Message. text() #11632. New Features:  feat: Add for await (const contact of room) {} support by ES6 iterators override #1198 [todo] allow Wechaty to be multi-instance #518 [New Puppet] Plan to support WECHATY_HEAD=WECHAT4U #69 TravisCI Conditional Deployment #1211 Puppet padchat #1245 (lijiarui) Multi-Instance Support #1159 (zixia)3. Bug Fixes:  Update the peerDependencies of rx-queue: rxjs@6 from rxjs@5 #1205 How to avoid the memory leak #981 Should throw Exception when there have API Error. #6834. Enhancements:  Prevent the Floating Promise in the Async/Await Code #1346 Upgrade Docker Base Image from Ubuntu 17. 10 to 18. 04 #1239 Continious Deploy to NPM with @next tag when the MINOR version number is odd(in developing branch) #1158 Should throw Exception when there have API Error. #683 Decouple: Make Contact, Room, Message, and FriendRequest class Abstract. #1160 (zixia) Update to node 10 in . travis. yml #1231 (zixia)Learn more between version at:  Full Changelog Source Code of Wechaty v0. 16 (2018-06-21) Commits Between v0. 14 and v0. 16CONTRIBUTORS: Thank you all contributors, Wechaty could not release version 0. 16 without your help!  @lijiarui: #1375 #1374 #1373 #1352 #1351 #1348 #1347 #1344 #1341 #1338 #1333 #1331 #1325 #1318 #1313 #1308 #1283 #1282 #1271 #1256 #1246 #1245 #1116 #1086 #816 #812 #805 #798 #757 #729 #725 #651 #627 #619 #604 #515 #490 #440 #370 #364 #362 #328 #324 #323 #321 #318 #303 #292 #275 #266 #264 #249 #239 #234 #211 #199 #182 #162 #139 #112 #110 #93 #92 #91 #87 #38 @zixia: #1160 #1274 #1273 #1260 #1232 #1231 #1190 #1159 #1143 #1131 #1083 #1075 #1074 #1073 #1072 #1071 #860 #854 #841 #831 #810 #644 #643 #608 #569 #560 #542 #496 #495 #469 #462 #455 #449 #396 #351 #317 #316 #315 #314 #313 #312 #311 #168 #158 #149 #146 #143 #142 #141 #25 @mukaiu: #1089 #962 #337 #470 #438 #421 #420 #415 #376 @binsee: #844 #811 #771 #744 #727 #714 @JasLin: #404 #358 #105 #100 #78 #76 @xinbenlv: #1017 #935 #388 #361 #280 @suntong: #1129 #1123 @hczhcz: #684 #640 @zhenyong: #770 @IdiosApps: #1087 @hiwanz: #1036 @TingYinHelen: #605 @imerse: #578 @FlyingBlazer: #531 @xjchengo: #416 @htoooth: #1014 @ax4: #380 @Gcaufy: #310 @cherry-geqi: #97 @lpmi-13: #681"
    }, {
    "id": 378,
    "url": "https://wechaty.js.org/2018/05/06/talk-about-wechat-robot/",
    "title": "我在微信机器人方向的探索和看法",
    "body": "2018/05/06 - 首先，谢谢Huan LI的邀请，让我有机会写这么一篇博文。其实我做跟微信机器人相关的调研也不是很久，而且中间中断了很长时间，最早是在去年 6 月份开始，做了两个月更换了几个版本和不同方式把产品做了出来，之后就是今年 4 月份，又有这方面的需求于是又重新接触了微信机器人。 基于网页版微信 http api lib: 这种库就很多了，我们的wechaty核心也是这种方式，还有其他各种语言的实现:       Project   Intro   Comments         youfou/wxpy   优秀的 api 包装和配套插件，微信机器人/优雅的微信个人号 API   [个人评价: 支持 python2/3 api 包装不错 文档写的满分 基于 itchat 开发，也开放了 itchat 的原始数据接口，自由度和封装美化兼顾 ]       liuwons/wxBot   类似的基于 Python 的微信机器人   [个人评价: 不支持 python3 utf-8 支持不好 ]       sjdy521/Mojo-Weixin   使用 Perl 语言编写的微信客户端框架，可通过插件提供基于 HTTP 协议的 api 接口供其他语言调用   [未使用]       HanSon/vbot   基于 PHP7 的微信个人号机器人，通过实现匿名函数可以方便地实现各种自定义的功能   [未使用]       littlecodersh/ItChat   wxpy 就是基于此开发           …   …   …   最早的需求是群发和自动回复， 我先用python实现了一个集中式的机器人(单例，多群管理，需要用户将机器人拉入群，python 异步瓶颈很快出现了，后来改成集中式多例， 用户自己登陆自己管理群，效果也不甚理想)。 然后尝试使用 node 来实现， 用了wechaty， 第一眼感觉好酷， 好全， 好牛逼， ts+docker 简直无敌， 但是我在安装的时候觉得体积有点庞大， 而且还绑定了浏览器实例(所以当时好像只能单例机器人)， 感觉有些臃肿当时就没有深入了解。 而且另一个很令人头疼的事情， 就是微信会对 hack 网页版微信的行为作出封号的惩罚， 具体的表现就是一段时间(我遇到的最短几周，最长半年多)限制登录网页版微信， 而且新注册的微信号无法登录网页版微信。 也就是说网页版微信会慢慢被淘汰掉， 显然有这个问题， 基于网页版微信做的机器人都会难以商用。 适逢当时看到谷歌团队新开的 puppeteer 项目， 于是我想会不会用浏览器模拟用户操作， 可以减少被封的概率呢(当时觉得可能所有的库都无法做得和微信的客户端一样， 稍有一个 cookie 什么的没传对就可能导致被封)，于是开始做 puppteer 的机器人。 用 puppeteer/phantomjs 操作网页版微信: puppeteer 的出现， 让 phantomjs 的作者直接放弃更新了。 它一出现就意味着浏览器环境将会发生很大的变化， 防爬虫更难做了， 浏览器界面的自动化测试也变得可能， 客户端安全对于开发者来讲更难了。 对于我们要 hack 微信这件事， 它也能发挥一定的价值。实现起来其实就很简单了， 用 puppeteer 打开网页版微信， 用户正常登陆微信， 你可以注入你的 js 脚本， 也可以模拟任意 element 上的点击， 可以任意调用该生命周期下的方法和变量， 可以模拟用户的键盘输入(带延迟的)，甚至可以模拟上传文件(用此实现发送图片)。 如果你用 headless 方式启动浏览器， 用户甚至毫无感知。用这种方式实现的机器人， 被封的概率很低(但是也有个别用户反映有， 不知道是不是他们同时在用别的机器人)， 稳定性基本能达到商用的地步。 在 windows 下使用 hook 操作微信 pc 端: 这种方式我本人没有尝试过， 我的同事用 C#实现了一个版本， pc 版的微信的界面也是 html 渲染的， 所以 windows 无法获得页面里面控件的句柄， 所以需要一些很 hack 的方式去做， 我不太喜欢这种(主要我不太熟 windows)。 这种的好处就是， 就算网页版被封了， pc 版暂时还不受什么影响。 在 Android 下使用 hook 操作微信安卓版: 今年 4 月份的时候，运营提出需求需要群管理，几百个 100 人的群，需要自动回复，自动踢人(发重复消息的， 发关键字的， 发太长信息的。。。)，管理员踢人，防止该群名，黑名单(加入黑名单在所有群里都一进群就踢)等功能， 一开始我用wechaty做了一个版本， 但是第二天就被封号了(运气实在太差了喂)。 然后就想到 android 上面有 xposed 这个东西， 可以作为 android 的 hook 来修改一些 apk 的行为，摘一段官方的介绍:  Xposed is a framework for modules that can change the behavior of the system and apps without touching any APKs 接下去就是找找现成模块有没有能用的， 如果不够用， 就找找有没有开源， 改改代码。 实在不行也可以自己写， xposed 模块还是挺好写的。对了还有一个叫VirtualXposed的东西，修改微信 hook 的事情，这个足够了， 不需要 root。iOS 下也有Method Swizzling之类的 hook 方式， 我还没有尝试过， 因为买几台 iPhone 放在办公室当服务器还是觉得有点厉害贵。 总结: 微信机器人这个事情， 毕竟是在 hack 大厂的产品， 希望哪天他们能开放出开发者接口， 这样其实安全性也高一点(有了接口大部分人应该不会选择 hack 了)， 对开发者也更友好一点。 肚子里墨水比较少， 开发经验也很有限， 如果各位大佬觉得有什么地方不对， 还请不吝指正!  Author: nbwsc "
    }, {
    "id": 379,
    "url": "https://wechaty.js.org/2018/04/23/blessed-twins-bot/",
    "title": "New Feature: Multi-Instance Support for Wechaty v0.16(WIP)",
    "body": "2018/04/23 -  Wechaty v0. 16 is working in progress.  Good news: We will be able to run as many as Wechaty instances than only one singleton before! Bad news: BREAKING CHANGES were introduced. This enhancement has no BC any more!Wechaty could only be able to instantiate once before. This comes for one reason: I’m lazy at the beginning. I’m lazy because there’s need some works to support the second instance. For example, we can image when we are using Contact. find('name') to search contacts, Contact must know the exactly wechat account we are using. When we have one, it’s all ok, but when we got the second one, we have to make a choice. That’s the problem, Contact is very hard to choose because it knows nothing about anything. To make it work, we designed a strange pattern: clone the Contact class and using it’s static properties to store information for future usage.  Please let me know if you know any design pattern similar to it, or it’s a confirmed an anti-pattern. TL;DR: Talk is cheap, show me the code. const bot1 = new Wechaty({ profile: 'bot1' })const bot2 = new Wechaty({ profile: 'bot2' })const room1 = await bot1. Room. find('my room')const room2 = await bot2. Room. find('my room')That’s all. Instead of Wechaty. instance(), we now support instanciated Wechaty directly, without any limitations. The BREAKING CHANGES is: when you want to use Room, Contact, FriendRequest, and Message, you can not call them directly anymore, because they will become the Abstract Class soon, which means cannot be instantiated.  Update 2018-05: We can still be able to instanciate the bot. Message by using clone-class NPM module Instead, use bot. Room, bot. Contact, bot. FriendRequest, and bot. Message, which bot is the instance of Wechaty. THE LONG STORY: To allow multi-instance is on our todo list for many months. (See Github Issue #518) It will be straightforward to design all the class methods with a puppet parameter, which can solve the problem but we have to remember the puppet in the userspace code and pass it in for every call. I do not like that. I write four versions of Proof of Concept Code to store and hide the puppet. 1. PoC V1: ES6 Proxy: The first PoC is to use ES6 Proxy. It’s very straightforward just to wrap the original class and set the puppet when it is being called. const Bot1Contact = new Proxy(Contact, handlerFactory(puppet1))But we need a new class is instanceof the original class, which means Bot1Contact instanceof Contact should be true. Proxy cannot meet this goal. Full ES6 Proxy PoC source code is at https://github. com/wechaty/wechaty/issues/518#issuecomment-383319998 2. PoC V2: Class. bind({}): The second PoC is to bind the Class to a new context object by using Contact. bind({}) const Bot1Contact = Contact. bind({})By doing this, we can get a branding new Bot1Contact which we can set static properties on, and Bot1Contact instanceof Contact will be true. However, by this technology, we can not get the right static properties inside the instance methods. We always got the static properties from the original class, which means it’s utterly useless for us if we can not get back the information we need on the static properties from the new class. Full Class. bind({}) source code is at: https://github. com/wechaty/wechaty/issues/518#issuecomment-383357185 3. PoC V3: eval: How about creating a new class by eval the source code from original class? const Bot1Contact = Function('return ' + Contact. toString())It works like a charm, and it will be qualified if we can set the Bot1. Contact. prototype to the Object. create(Contact. prototype), which could make instanceof works. However, I found that the Bot1. Contact. prototype could not be changed because it’s configurable &amp; writable properties are set to false, and the writable could not be changed by Reflect. defineProperty(), which means it will not be able to support the Bot1Contact instanceof Contact. Full eval source code is at https://github. com/wechaty/wechaty/issues/518#issuecomment-383384175 4. PoC V4: class extend: After lots of massive research &amp; experiment work, I decided to extend the original class to create a new one for our usage. class Bot1Contact extends Contact {}By this technic, the code is very clean, the instanceof work as expected, everything as my wish finally! MODULIZE: After all the work, I modulized this part of the code as my new npm module: clone-class at https://github. com/huan/node-clone-class, with automatic unit tests and deploy to NPM by CI/CD.  And finally, I can create as many bots as I need than before! NPM @latest v. s. @next: Another enhancement had been implemented while developing this new feature, is that we can publish the NPM package with @next tag instead of @latest when the version indicates that this is a development release. For example: if the current version’s minor number is odd, which means it is a development release, then when publishing it to the NPM, it will be set dist-tag to the @next instead of @latest. So the regular users will always use the stable/production version when they try to npm install wechaty or npm install wechaty@latest. If they want to use the development release version, they have to opt-in by run npm install wechaty@next. See more about this by reading the GitHub Issue: Continious Deploy to NPM with the @next tag when the MINOR version number is odd(in developing branch) CONCLUSION: The Simplicity Behind Complexity: The complex is easy; simple is hard.  Designing and developing anything of consequence is incredibly challenging. Our goal is to try to bring a calm and simplicity to what are incredibly complex problems so that you’re not aware really of the solution; you’re not aware of how hard the problem was that was eventually solved. ”– Sir Jonathan (Jony) Ive  Wechaty twins bot powered by blessed-contrib, terminal session recorded at https://asciinema. org/a/177857 "
    }, {
    "id": 380,
    "url": "https://wechaty.js.org/2018/04/18/botbuilder-wechaty-connector/",
    "title": "Integrate Wechat Personal Account to Microsoft BotFramework with a BotBuilder Wechaty Connector",
    "body": "2018/04/18 -  Microsoft BotFramework is a robust platform that supports almost all kinds of the instance messengers like Facebook messenger, Skype, Slack, and backed by the powerful Cognitive Services like LUIS. ai, QnAMaker. ai, Azure Machine Learning. BotBuilder is a powerful SDK provides all we need when we are developing a ChatBot. I started learning them about 18 months ago, and I love them very much. However, it does not support Wechat Individual Account, so I decided to make some fun on it: connect Wechat PERSONAL Account to the BotBuilder by creating a new Connector: botbuilder-wechaty-connector. Update:  Jan 14, 2019: The botbuilder-wechaty-adapter realeased for Bot Builder V4 support.  Apr 18, 2018: The botbuilder-wechaty-connecter realeased for Bot Builder V3 support. )The Connector is a bridge between the BotBuilder and the Instance Messenger, in our case, Wechat. There’s some document at Bot Builder for Node. jsLibraries - Interface IConnector with two examples: ChatConnector and ConsoleConnector. However, I found the most useful example is a Wechat Official Account Connector: https://github. com/jyfcrw/botbuilder-wechat-connector whose code is concise and clean, so I decided to start from here. It’s not very difficult for me to replace the two NPM module wechat &amp; wechat-api to wechaty, and rewrite all the code to TypeScript, then add linting &amp; testing, setup DevOps CI/CD to publish on NPM. It takes me about three hours to finish them. Contract to the Wechat Official Account, Personal Account will be very easy to start because you only need to scan the QR code on the phone to log in instead of register an official account with APP_ID &amp; APP_SECRET. The following code simple setup a connector between BotBuilder and Wechat, ask and answer elementary questions:  What’s your name? OK, ${your name} What’s your age? All right, ${your age} How are you, ${your name}import * as builder from 'botbuilder'import { WechatyConnector } from 'botbuilder-wechaty-connector'// Create wechat personal account connectorconst wechatyConnector = new WechatyConnector()const bot = new builder. UniversalBot(wechatyConnector)// Bot dialogsbot. dialog('/', [ function (session) {   if (session. userData &amp;&amp; session. userData. name) {    session. send('How are you, ' + session. userData. name)   } else {    builder. Prompts. text(session, 'Whats your name?')   } }, function (session, results) {   session. userData. name = results. response   session. send('OK, ' + session. userData. name)   builder. Prompts. text(session, 'Whats your age?') }, function (session, results) {   session. userData. age = results. response   session. send('All right, ' + results. response) },])wechatyConnector. listen() The above example is borrowed from botbuilder-wechat-connector. Hope you will like it and could make fun of it too, cheers! See Also:  GitHub: https://github. com/huan/botbuilder-wechaty-connector NPM: https://www. npmjs. com/package/botbuilder-wechaty-connector Create a bot with the Bot Builder SDK for Node. js Key concepts in the Bot Builder SDK for Node. js VIDEO: Become a Bot Builder with Microsoft Bot Framework - James Mann speaking at dotnetsheff in April, 2017"
    }, {
    "id": 381,
    "url": "https://wechaty.js.org/2018/03/10/wechat-protocol-reference-guide/",
    "title": "微信App通信协议案例学习参考指南",
    "body": "2018/03/10 - 在1月初无意看到某微信爱好者学习交流群里发现讨论一个名为 MicroChat （基于Mars）利用微信AndroidAPP客户端通讯协议代码！！， 震惊之余，已对作者膜拜。心情激动之下下载了下来，参考了一些文章对原始版本进行了部分修正和应用测试。 后测试增加了一些功能实现以及对扩展模拟任意设备方式登入验证，和特定功能处理的思路。本人能力有限，技术很菜很水，但是秉着对技术向往以及分享我的坑给更多的学习者科普了解，故整理编辑了一篇文章带领大家先一睹为快。并且对MicroChat基础功能做了一些扩展思路，如果有错误的地方，欢迎批评指正 ！ 准备工作:  开发环境： 开发工具: Visual Studio 2015 及以上版本(marsWin32SDK 需要vc140以上)抓包和分析工具： Wireshark / Fiddler / Charles、TCPDump编译配套： Boost 、 ATL 附加目录 如果本机缺少引用目录请手动附加 其他提醒 编译顺序为： Mars相关依赖 / SQLite3 -&gt; MicrochatSDK(基于Mars Win32 Example) -&gt; MicroChat(用户层)微信是如何通信的呢？:  端口 经过使用扫描器对微信常用域名的扫描发现远程端口有： 80 443 8080 5222 5223 5228 等  域名 dns. weixin. qq. comsupport. weixin. qq. com  80/8080short. weixin. qq. com    443/8080 (sz)long. weixin. qq. com     80/443 (sz)wx. qlogo. cn          80timg. cn 等 基本执行过程概况  程序启动后，优先尝试DNS解析特定域名（上述域名，会返回所有节点）;dns查询dns. weixin. qq. com返回一组IP地址long. weixin. qq. com返回一组IP地址，本次通信中，微信使用了最后一个IP作为TCP长连接的连接地址。http://dns. weixin. qq. com/cgi-bin/micromsg-bin/newgetdns?uin=0&amp;clientversion=620888113&amp;scene=0&amp;net=1用于请求服务器获得最优IP路径。服务器通过结算返回一个xml定义了域名:IP对应列表。仔细阅读，可看到微信已经开始了国际化的步伐：香港、加拿大、韩国等。具体文本，请参考：https://gist. github. com/yongboy/9341884获取到long. weixin. qq. com最优IP，然后建立到101. 227. 131. 105的TCP长连接 如果DNS查询不可用，程序转为使用hardcode的ip链接服务； 如果dns可用，返回的ip为根据ISP智能解析的结果，程序使用返回的ip链接服务; 程序在注册、验证、解封、小程序等内置内容请求、阶段会使用https链接，加密协议为腾讯的mmtls; 客户端使用tcp 80/8080连接远端服务器。80/8080两个端口同时或任何单独一个，均可提供服务; 80端口为短链接，8080为长链接， 程序会优先使用8080端口;请求确认连接后获取数据。提交请求中包含 账号 密码 登录方式(可以模拟任何设备~) 设备信息 网络信息 网络设备信息 地理位置 等~POST http://short. weixin. qq. com/cgi-bin/micromsg-bin/getprofile HTTP/1. 1 (application/octet-stream)返回一个名为“micromsgresp. dat”的附件，个人信息POST http://short. weixin. qq. com/cgi-bin/micromsg-bin/whatsnews HTTP/1. 1 (application/octet-stream)仍然返回一个名为“micromsgresp. dat”的附件大概是微信新版本介绍和验证之类的、资讯、订阅更新等. . . POST http://short. weixin. qq. com/cgi-bin/micromsg-bin/downloadpackage HTTP/1. 1 (application/octet-stream)输出为micromsgresp. dat文件然后还会再有一个 micromsgresp. dat创建，大概可能是未读消息和联系人列表吧(测试大概总共会有1~3次)GET http://support. weixin. qq. com/cgi-bin/mmsupport-bin/reportdevice?channel=34&amp;deviceid=A952001f7a840c2a&amp;clientversion=620888113&amp;platform=0&amp;lang=zh_CN&amp;installtype=0 HTTP/1. 1客户端自身信息和设备信息校验反馈POST http://short. weixin. qq. com/cgi-bin/micromsg-bin/reportstrategy HTTP/1. 1 (application/octet-stream)返回分块数据GET http://wx. qlogo. cn/mmhead/Q3auHgzwzM7NR4TYFcoNjbxZpfO9aiaE7RU5lXGUw13SMicL6iacWIf2A/96图片等一些静态资源都会被分配到wx. qlogo. cn域名下，会根据加载或手动访问情况异步多线程下载缓存在本地目录。 当连续2次心跳发送失败时，客户端会弹出提示“当前网络状况不好，是否提交反馈数据”，确认后客户端试图通过web提交反馈数据;心跳频率约为5分钟登陆之后，会建立一个long. weixin. qq. com的HTTP长连接，端口号为8080具体查看长连接初始数据通信，没有发现任何包含 HTTP 字样的数据，以为是微信自定义的TCP/HTTP通信格式。据分析，用于可能用于获取数据、心跳交换消息等用途吧。初始消息传输个人资料、离线未阅读消息部分等通过 POST HTTP短连接单独获取。如上. . 二进制简单分析抽取微信某次HTTP协议方式通信数据，16进制表示，每两个靠近的数字为一个byte字节。 协议文本分析 微信协议报文可能如下： 一个消息包 = 消息头 + 消息体消息头固定16字节长度，消息包长度定义在消息头前4个字节中。 单纯摘取第0000行为例，共16个字节的头部: 00 00 00 10 00 10 00 01 00 00 00 06 00 00 00 0f16进制表示，每两个紧挨着数字代表一个byte字节。 微信消息包格式：  前4字节表示数据包长度，可变 值为16时，意味着一个仅仅包含头部的完整的数据包（可能表示着预先定义好的业务意义），后面可能还有会别的消息包 2个字节表示头部长度，固定值，0x10 = 16 2个字节表示谢意版本，固定值，0x01 = 1 4个字节操作码说明数字，可变 序列号，可变 头部后面紧跟着消息体，非明文，加密形式 一个消息包，最小16 byte字节如果对报文不是很了解可以学习参考一下其他底层通信协议 比如. . ModbusTCP通过数据多次采样分析： 0000 - 0040为单独的数据包0050行为下一个数据包的头部，前四个字节值为0xca = 202，表示包含了从0050-0110共202个字节数据一次数据发送，可能包含若干子数据包换行符\n，16进制表示为0x0a，在00f0行，包含了两个换行符号一个数据体换行符号用于更细粒度的业务数据分割 是否蒙对，需要问问做微信协议的同学所有被标记为HTTP协议通信所发送数据都包含换行符号动手试试猜想，模拟微信TCP长连接开始很不解为什么会出现如此怪异的HTTP双通道长连接请求，难道基于TCP通信，然后做了一些手脚？很常规的TCP长连接，传输数据时(不是所有数据传输)，被wireshark误认为HTTP长连接。这个需要做一个实验证实一下自己想法，设想如下： 写一个Ping-Pong客户端、服务器端程序，然后使用Wireshark看一下结果，是否符合判断。  测试服务端代码 https://gist. githubusercontent. com/yongboy/9341037/raw/pong_server. c /** * nieyong@youku. com * how to compile it: * gcc pong_server. c -o pong_server /usr/local/lib/libev. a -lm */#include &lt;arpa/inet. h&gt;#include &lt;stdlib. h&gt;#include &lt;stdio. h&gt;#include &lt;string. h&gt;#include &lt;fcntl. h&gt;#include &lt;errno. h&gt;#include &lt;err. h&gt;#include &lt;unistd. h&gt;#include  . . /include/ev. h static int server_port = 8080;struct ev_loop *loop;typedef struct {  int fd;  ev_io ev_read;} client_t;ev_io ev_accept;static void free_res(struct ev_loop *loop, ev_io *ws);int setnonblock(int fd) {  int flags = fcntl(fd, F_GETFL);  if (flags &lt; 0)    return flags;  flags |= O_NONBLOCK;  if (fcntl(fd, F_SETFL, flags) &lt; 0)    return -1;  return 0;}static void read_cb(struct ev_loop *loop, ev_io *w, int revents) {  client_t *client = w-&gt;data;  int r = 0;  char rbuff[1024];  if (revents &amp; EV_READ) {    r = read(client-&gt;fd, &amp;rbuff, 1024);  }  if (EV_ERROR &amp; revents) {    fprintf(stderr,  error event in read\n );    free_res(loop, w);    return ;  }  if (r &lt; 0) {    fprintf(stderr,  read error\n );    ev_io_stop(EV_A_ w);    free_res(loop, w);    return;  }  if (r == 0) {    fprintf(stderr,  client disconnected. \n );    ev_io_stop(EV_A_ w);    free_res(loop, w);    return;  }  send(client-&gt;fd, rbuff, r, 0);}static void accept_cb(struct ev_loop *loop, ev_io *w, int revents) {  struct sockaddr_in client_addr;  socklen_t client_len = sizeof(client_addr);  int client_fd = accept(w-&gt;fd, (struct sockaddr *) &amp;client_addr, &amp;client_len);  if (client_fd == -1) {    fprintf(stderr,  the client_fd is NULL !\n );    return;  }  client_t *client = malloc(sizeof(client_t));  client-&gt;fd = client_fd;  if (setnonblock(client-&gt;fd) &lt; 0)    err(1,  failed to set client socket to non-blocking );  client-&gt;ev_read. data = client;  ev_io_init(&amp;client-&gt;ev_read, read_cb, client-&gt;fd, EV_READ);  ev_io_start(loop, &amp;client-&gt;ev_read);}int main(int argc, char const *argv[]) {  int ch;  while ((ch = getopt(argc, argv,  p: )) != -1) {    switch (ch) {    case 'p':      server_port = atoi(optarg);      break;    }  }  loop = ev_default_loop(0);  struct sockaddr_in listen_addr;  int reuseaddr_on = 1;  int listen_fd = socket(AF_INET, SOCK_STREAM, 0);  if (listen_fd &lt; 0)    err(1,  listen failed );  if (setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuseaddr_on, sizeof(reuseaddr_on)) == -1)    err(1,  setsockopt failed );  memset(&amp;listen_addr, 0, sizeof(listen_addr));  listen_addr. sin_family = AF_INET;  listen_addr. sin_addr. s_addr = INADDR_ANY;  listen_addr. sin_port = htons(server_port);  if (bind(listen_fd, (struct sockaddr *) &amp;listen_addr, sizeof(listen_addr)) &lt; 0)    err(1,  bind failed );  if (listen(listen_fd, 5) &lt; 0)    err(1,  listen failed );  if (setnonblock(listen_fd) &lt; 0)    err(1,  failed to set server socket to non-blocking );  ev_io_init(&amp;ev_accept, accept_cb, listen_fd, EV_READ);  ev_io_start(loop, &amp;ev_accept);  ev_loop(loop, 0);  return 0;}static void free_res(struct ev_loop *loop, ev_io *w) {  client_t *client = w-&gt;data;  if (client == NULL) {    fprintf(stderr,  the client is NULL !!!!!! );    return;  }  ev_io_stop(loop, &amp;client-&gt;ev_read);  close(client-&gt;fd);  free(client);}客户端https://gist. githubusercontent. com/yongboy/9319660/raw/PingClient. java /** * Ping Client * @author nieyong */package com. learn;import io. netty. bootstrap. Bootstrap;import io. netty. buffer. ByteBuf;import io. netty. buffer. PooledByteBufAllocator;import io. netty. channel. ChannelFuture;import io. netty. channel. ChannelHandlerContext;import io. netty. channel. ChannelInboundHandlerAdapter;import io. netty. channel. ChannelInitializer;import io. netty. channel. ChannelOption;import io. netty. channel. EventLoopGroup;import io. netty. channel. nio. NioEventLoopGroup;import io. netty. channel. socket. SocketChannel;import io. netty. channel. socket. nio. NioSocketChannel;import java. util. concurrent. TimeUnit;class PingClientHandler extends ChannelInboundHandlerAdapter { private final ByteBuf firstMessage; public PingClientHandler() {  firstMessage = PooledByteBufAllocator. DEFAULT. buffer(22);  // weixin 16 byte's header  firstMessage. writeByte(0);  firstMessage. writeByte(0);  firstMessage. writeByte(0);  firstMessage. writeByte(16);  firstMessage. writeByte(0);  firstMessage. writeByte(16);  firstMessage. writeByte(0);  firstMessage. writeByte(1);  firstMessage. writeByte(0);  firstMessage. writeByte(0);  firstMessage. writeByte(0);  firstMessage. writeByte(6);  firstMessage. writeByte(0);  firstMessage. writeByte(0);  firstMessage. writeByte(0);  firstMessage. writeByte(1);  // just for /n  firstMessage. writeByte('\n'); // 1 byte  // footer 16 byte  String welcome =  hello ; // 5 byte  firstMessage. writeBytes(welcome. getBytes()); } @Override public void channelActive(ChannelHandlerContext ctx) {  ctx. writeAndFlush(firstMessage); } @Override public void channelRead(final ChannelHandlerContext ctx, final Object msg)   throws Exception {  ctx. executor(). schedule(new Runnable() {   @Override   public void run() {    ctx. channel(). writeAndFlush(msg);   }  }, 1, TimeUnit. SECONDS); } @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {  ctx. flush(); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {  System. err. println( Unexpected exception from downstream :     + cause. getMessage());  ctx. close(); }}public class PingClient { private final String host; private final int port; public PingClient(String host, int port) {  this. host = host;  this. port = port; } public void run() throws Exception {  EventLoopGroup group = new NioEventLoopGroup();  try {   Bootstrap b = new Bootstrap();   b. group(group). channel(NioSocketChannel. class)     . option(ChannelOption. TCP_NODELAY, true)     . handler(new ChannelInitializer&lt;SocketChannel&gt;() {      @Override      public void initChannel(SocketChannel ch)        throws Exception {       ch. pipeline(). addLast(new PingClientHandler());      }     });   ChannelFuture f = b. connect(host, port). sync();   f. channel(). closeFuture(). sync();  } finally {   // Shut down the event loop to terminate all threads.    group. shutdownGracefully();  } } public static void main(String[] args) throws Exception {  String host =  127. 0. 0. 1 ;  int port = 8080;  if (args. length == 3) {   host = args[0];   port = Integer. parseInt(args[1]);  }  new PingClient(host, port). run(); }} 结论 若使用原始TCP进行双向通信，则需要满足以下条件，可以被类似于Wireshark协议拦截器误认为是HTTP长连接： 使用80/8080端口（81/3128/8000经测试无效） 也许8080一般被作为WEB代理服务端口，微信才会享用这个红利吧。输出的内容中，一定要包含换行字符”\n”因此，可以定性为微信使用了基于8080端口TCP长连接，一旦数据包中含有换行”\n”符号，就会被Wireshark误认为HTTP协议。可能微信是无心为之吧。  SyncRecv 新消息获取  TCP长连接接收到服务器通知有新消息需要获取(消息，朋友圈，附近人，好友请求，瓶子，通知，摇一摇等) APP发起一个HTTP POST请求获取新状态消息，会带上当前SyncKey 地址为：http://short. weixin. qq. com/cgi-bin/micromsg-bin/reportstrategy HTTP/1. 1，看不到明文(这是一个数据块，也可能是多个数据块) APP获取到新的消息，会再次发起一次HTTP POST请求，告诉服务器已确认收到，同时获取最新SyncKey 地址为：http://short. weixin. qq. com/cgi-bin/micromsg-bin/kvreport，看不到明文 接受一个消息，TCP长连接至少交互两次，客户端发起两次HTTP POST请求 具体每次交互内容是什么，有些模糊 服务器需要支持：状态消息获取标记，状态消息确认收取标记。只有被确认收到，此状态消息才算是被正确消费掉 多个不同设备同一账号同时使用微信，同一个状态消息会会被同时分发到多个设备上（如：模拟PC版 或IPAD MAC WINPHONE在线时） 特殊接收操作，红包功能、小程序、转账、表情、VOIP 发送类(发消息,上传，发朋友圈，查看附近人,加好友等其他请求)  发送消息走已经建立的TCP长连接通道，发送消息到服务器，然后接受确认信息等，产生一次交互。 小伙伴接收到信息阅读也都会收到服务器端通知，产生一次交互等。 可以确定，微信发送消息走TCP长连接方式，因为不对自身状态数据产生影响，应该不交换SyncKey。 在低速网络下，大概会看到消息发送中的提示，属于消息重发机制 网络不好有时客户端会出现发送失败的红色感叹号 已发送到服务器但未收到确认的消息，客户端显示红色感叹号，再次重发，服务器作为重复消息处理，反馈确认 上传图片/视频，会根据图片大小，分割成若干部分（大概1. 5K被划分为一部分），同一时间点，客户端会发起若干次POST请求，各自上传成功之后，服务器大概会合并成一个完整图片，返回一个缩略图，显示在APP聊天窗口内。APP作为常规的文字消息发送到服务器端 上传音频，则单独走TCP通道，一个两秒的录制音频，客户端录制完毕，分为两块传输，一块最大1. 5K左右，服务端响应一条数据通知确认收到。共三次数据传输。音频和纯文字信息一致，都是走TCP长连接，客户端发送，服务器端确认。 发朋友圈和发消息同理，自行抓请求地址测试。 加好友会根据双方关联状态加密 自身 + 好友或关联关系 的 wxid/uin/chatroom -&gt; v1， 非已有关联关系型模型的好友服务器会增加返回二次验证v2验证回调信息。通过结果会从验证中解密为 添加好友方式 / 关联的群 。。 旧版本和PC/MAC版则无二次验证。目前已修复。 获取附近人、摇一摇、漂流瓶、雷达加好友的信息，通过长连接SYNC中返回数据解析 (仅作为学习研究，严禁用于黑产！) 小程序和内置浏览器就不过多介绍了。COOKIE操作和微信返回的SEESION验证权限和提交一些数据。 加群，拉群，访问网页参数 A8KEY 中包含地址。 特殊操作，抢红包(接收后红包信息，网络分配取随机金额后短连接请求)、转账、发送扩展表情、VOIP请求等 获取设置绑定信息，账户余额等操作属于扩展HTTPS请求 其他特殊请求微信运动等，获取传感器开放数据后手动请求上传或定时。 收付款功能还没研究 微信 CommandSchedule自定义协议 weixin:// 手动根据功能解析 profile获取和展示、View跳转等。可手动解析实现模拟手机端.  协议小结  发布的消息对应一个ID（只要单个方向唯一即可，服务器端可能会根ID判断重复接收），消息重传机制确保有限次的重试，重试失败给予用户提示，发送成功会反馈确认，客户端只有收到确认信息才知道发送成功。发送消息可能不会产生新SyncKey。 基于版本号（SynKey）的状态消息同步机制，增量、有序传输需求水到渠成。长连接通知/短连接获取、确认等，交互方式简单，确保了消息可靠谱、准确无误到达。 客户端/服务器端都会存储消息ID处理记录，避免被重复消费客户端获取最新消息，但未确认，服务器端不会认为该消息被消费掉。下次客户端会重新获取，会查询当前消息是否被处理过。根据一些现象猜测。 总体上看，微信协议跨平台（TCP或HTTP都可呈现，处理方式可统一），通过“握手”同步，很可靠，无论哪一个平台都可以支持的很好 微信协议最小成本为16字节，大部分时间若干个消息包和在一起，批量传输。微信协议说不上最简洁，也不是最节省流量，但是非常成功的。 若服务器检测到一些不确定因素，可能会导致微启用安全套接层SSL协议进行常规的TCP长连接传输。短连接都没有发生变化MicroChat使用指南:  请求地址 #define CGI_NEWSYNC  /cgi-bin/micromsg-bin/newsync  //同步服务端最新消息#define CGI_MANUALAUTH  /cgi-bin/micromsg-bin/manualauth  //登录#define CGI_NEWSENDMSG  /cgi-bin/micromsg-bin/newsendmsg  //发送文字消息#define CGI_NEWINIT  /cgi-bin/micromsg-bin/newinit  //首次登录,初始化数据库#define CGI_GETPROFILE  /cgi-bin/micromsg-bin/getprofile  //获取个人信息#define CGI_SEARCHCONTACT  /cgi-bin/micromsg-bin/searchcontact  //搜索新朋友#define CGI_GETCONTACT  /cgi-bin/micromsg-bin/getcontact  //查找新朋友#define CGI_VERIFYUSER  /cgi-bin/micromsg-bin/verifyuser  //添加好友#define CGI_BIND  /cgi-bin/micromsg-bin/bindopmobileforreg  //首次登录短信授权其他功能 自行添加请求地址，如 FindNearBy 附近人等~ /测试请手动修改登录设备信息//登录设备硬件信息#define DEVICE_INFO_GUID      A31d2152a33d83e7   //GUID#define DEVICE_INFO_CLIENT_SEQID    A31cc712ad2d83e6_1512965043210  //GUID_LOCATION地址#define DEVICE_INFO_CLIENT_SEQID_SIGN   e89b238e77cf988ebd09eb65f5378e99  //MD5#define DEVICE_INFO_IMEI      865167123366678   //手机IMEI#define DEVICE_INFO_ANDROID_ID     eabe1f220561a49f      //设备ID#define DEVICE_INFO_ANDROID_VER     android-26         //安卓版本#define DEVICE_INFO_MANUFACTURER   CStringA2Utf8( iPhone )   //设备名称 随便填#define DEVICE_INFO_MODELNAME     CStringA2Utf8( X )       //型号名称 随便填#define DEVICE_INFO_MOBILE_WIFI_MAC_ADDRESS  01:67:33:56:78:11          //WIFI MAC地址#define DEVICE_INFO_AP_BSSID     41:25:99:22:3f:14      //手机信号基站 MAC地址#define DEVICE_INFO_LANGUAGE     zh_CN            //语言//下面2个是设备 com. tencent. mm 包信息 及 设备信息（使用上面宏）#define DEVICE_INFO_SOFTINFO     &lt;softtype&gt;&lt;lctmoc&gt;0&lt;/lctmoc&gt;&lt;level&gt;1&lt;/level&gt;&lt;k1&gt;ARMv7 processor rev 1 (v7l) &lt;/k1&gt;&lt;k2&gt;&lt;/k2&gt;&lt;k3&gt;5. 1. 1&lt;/k3&gt;&lt;k4&gt;%s&lt;/k4&gt;&lt;k5&gt;460007337766541&lt;/k5&gt;&lt;k6&gt;89860012221746527381&lt;/k6&gt;&lt;k7&gt;%s&lt;/k7&gt;&lt;k8&gt;unknown&lt;/k8&gt;&lt;k9&gt;%s&lt;/k9&gt;&lt;k10&gt;2&lt;/k10&gt;&lt;k11&gt;placeholder&lt;/k11&gt;&lt;k12&gt;0001&lt;/k12&gt;&lt;k13&gt;0000000000000001&lt;/k13&gt;&lt;k14&gt;%s&lt;/k14&gt;&lt;k15&gt;&lt;/k15&gt;&lt;k16&gt;neon vfp swp half thumb fastmult edsp vfpv3 idiva idivt&lt;/k16&gt;&lt;k18&gt;%s&lt;/k18&gt;&lt;k21&gt;\ wireless\ &lt;/k21&gt;&lt;k22&gt;&lt;/k22&gt;&lt;k24&gt;%s&lt;/k24&gt;&lt;k26&gt;0&lt;/k26&gt;&lt;k30&gt;\ wireless\ &lt;/k30&gt;&lt;k33&gt;com. tencent. mm&lt;/k33&gt;&lt;k34&gt;Android-x86/android_x86/x86:5. 1. 1/LMY48Z/denglibo08021647:userdebug/test-keys&lt;/k34&gt;&lt;k35&gt;vivo v3&lt;/k35&gt;&lt;k36&gt;unknown&lt;/k36&gt;&lt;k37&gt;%s&lt;/k37&gt;&lt;k38&gt;x86&lt;/k38&gt;&lt;k39&gt;android_x86&lt;/k39&gt;&lt;k40&gt;%s&lt;/k40&gt;&lt;k41&gt;1&lt;/k41&gt;&lt;k42&gt;%s&lt;/k42&gt;&lt;k43&gt;null&lt;/k43&gt;&lt;k44&gt;0&lt;/k44&gt;&lt;k45&gt;&lt;/k45&gt;&lt;k46&gt;&lt;/k46&gt;&lt;k47&gt;wifi&lt;/k47&gt;&lt;k48&gt;%s&lt;/k48&gt;&lt;k49&gt;/data/data/com. tencent. mm/&lt;/k49&gt;&lt;k52&gt;0&lt;/k52&gt;&lt;k53&gt;0&lt;/k53&gt;&lt;k57&gt;1080&lt;/k57&gt;&lt;k58&gt;&lt;/k58&gt;&lt;k59&gt;0&lt;/k59&gt;&lt;/softtype&gt; #define DEVICE_INFO_DEVICEINFO     &lt;deviceinfo&gt;&lt;MANUFACTURER name=\ %s\ &gt;&lt;MODEL name=\%s\ &gt;&lt;VERSION_RELEASE name=\ 5. 1. 1\ &gt;&lt;VERSION_INCREMENTAL name=\ eng. denglibo. 20171224. 164708\ &gt;&lt;DISPLAY name=\ android_x86-userdebug 5. 1. 1 LMY48Z eng. denglibo. 20171224. 164708 test-keys\ &gt;&lt;/DISPLAY&gt;&lt;/VERSION_INCREMENTAL&gt;&lt;/VERSION_RELEASE&gt;&lt;/MODEL&gt;&lt;/MANUFACTURER&gt;&lt;/deviceinfo&gt;  验证 LOGIN_RSA_VER //秘钥版本 LOGIN_RSA_VER158_KEY_E //秘钥加密 LOGIN_RSA_VER158_KEY_N //混淆后?? SYNC验证 SYNCKEY //收消息验证KEY  Profile #pragma once#include &lt;string&gt;#include  db/db. h class CAuthInfo{public: CAuthInfo() {  InitializeCriticalSection(&amp;m_cs_syncKey); } string m_UserName; //昵称 string m_WxId; //wxid 或 老微信号 DWORD  m_uin = 0;  //uin 唯一标识 string m_Alias;   //微信号 string m_Session; //SessionKey DWORD  m_ClientVersion;  //客户端版本 string m_guid_15;  //guid 15位 string m_guid;    //guid string m_androidVer; //安卓版本 string m_launguage;  //lang string m_cookie;   //置入浏览器的Cookie string GetSyncKey(); void SetSyncKey(string strSyncKey); static CAuthInfo *GetInstance(); //获取短信验证码凭据 string m_mobilecode_authticket; //接受短信号码(当前默认使用登录账号) string m_mobileNum;private: static CAuthInfo * m_Instance; CRITICAL_SECTION  m_cs_syncKey;};#define pAuthInfo (CAuthInfo::GetInstance()) 扩展多设备在线  二维码扫码登录 （获取扫码方式从Android版无法获取,需要从IPAD版抓包） 抓包不同设备登录请求，自定义登录请求参数即可模拟.  仅仅是登录验证。SYNC部分未实现，部分平台略有不同。。。 UI实现 代码中使用了Duilib界面，因为微信消息功能复杂DUILIB都在一个Notify中数据处理会比较麻烦，建议大家可以考虑QT / MFC / WebUI 实现View层。或者使用winform 或 WPF实现会更加简单。  借助开源库完善其他功能  FFmpeg 视频音频文件转码与播放 Avcodec 音频文件转码与播放 CEF3  提供模拟微信内置浏览器访问功能(小程序不支持) 截图工具 proxy SQLite3附录: Microsoft Exchange Active Sync协议，简称EAS，分为folderrsync(同步文件夹目录，即邮箱内有哪几个文件夹)和sync（每个文件夹内有哪些文档）两部分。 某网友总结的协议一次回话大致示范： Client:  synckey=0 //第一次key为0Server: newsynckey=1235434  //第一次返回新keyClient:  synckey=1235434  //使用新key查询Server: newsynckey=1647645,data=*****//第一次查询，得到新key和数据Client:  synckey=1647645Server: newsynckey=5637535,data=null //第二次查询，无新消息Client:  synckey=5637535Server: newsynckey=8654542, data=****//第三次查询，增量同步上页中的相邻请求都是隔固定时间的，如两分钟客户端每次使用旧key标记自己的状态，服务端每次将新key和增量数据一起返回。key是递增的，但不要求连续请求的某个参数决定服务器是否立即返回传送门: 原版Github传送门(已修复DNS错误301问题)：  https://github. com/InfiniteTsukuyomi/MicroChat/ Python版  https://github. com/InfiniteTsukuyomi/MicroChat/tree/master/test 感谢: 特别鸣谢 CSDN博客、博客园的微信协议分析文章作者，是你们的文章参考带领我参考学习和验证。给了很大启发和帮助。 代码由 @InfiniteTsukuyomi 公开发布代码。 感谢腾讯WXG的开源精神奉献，给了大量的开源参考和文章讲解。 参考链接： http://www. blogjava. net/yongboy/archive/2014/03/05/410636. html 严重声明:  请勿外传用于任何商业用途，违者后果自负！Blog: https://www. icefox. org "
    }, {
    "id": 382,
    "url": "https://wechaty.js.org/2018/03/09/can-typescript-really-live-up-to-its-hype/",
    "title": "Can Typescript really live up to its hype?",
    "body": "2018/03/09 -  Big companies or organizations push forward adopting of Typescript for a reason, mostly to prevent some dummies to shoot their own feet really easily – The (almost only) advantage of Typescript is to point out, at the compile time, that the following usage is wrong: var x = 'A';x = x + 5But is it really? If you are a seasoned programmer and you are coding for yourself only, are you willing to get your hands tied up by MS Typescript, and suffer all its drawbacks in the mean time? About Pure ES6 instead of Typescript: When I code customization code for wechaty, I write everything in pure ES6 instead of Typescript, and there are strong reasons for that. Typescript is not necessary:  Looking at the ES6 support in Node. js, I can see really really few ES6 features are unsupported now. I. e. , only very few extreme end-cases are left.  Furthermore, I don’t know how well the transpiling is, e. g. , for the advanced ES6 features like map, filter and reduce, I don’t know how efficient the transpiled code is.  Starting with version 8. 5. 0, Node. js even supports ES modules natively, so we can do import {add} from '. /lib. mjs'; directly in ES6 now.  I. e. , the ES6 is ready for prime time use, writing in TypeScript then have it transpiled into ES6 code seems like a redundant step now. (I’m not saying that TypeScript is not helpful, it is still good in big projects that you have some dummies really easily to shoot their own feet) Moreover, most of wechaty examples are in fact plain ES6, not TypeScript (because of missing type declaration for every variable, which is the # 1 feature that TypeScript boasts with), so making such extra transpiling step seems even more unnecessary to me. ES6 is the future, not Typescript: Here is some good reading that I want to share with you, When are you better off without Typescript? –When you can’t afford an extra transpilation tax  There are no plans to support TypeScript natively in the browsers. Chrome did some experiment, but later cancelled support. I suspect this has something to do with unnecessary runtime overhead. If someone wants training wheels, they can install them. But bikes shouldn’t come with permanent training wheels. This means that you will always have to transpile your TypeScript code before running them. For standard ES6, it’s a whole different story. When ES6 is supported by most browsers, the current ES6 to ES5 transpilation will become unnecessary. ES6 is the biggest change to the JavaScript language, and I believe most programmers will just settle with it. But those brave few who want to try the next version of JavaScript’s experimental features, or the features not yet implemented on all browsers — they will need to transpile anyway. Typescript has an evil source and evil goal: Typescript is from Microsoft, which is the source of all evil. From above article,  The old Microsoft used to take standard tools — Java for example — and add proprietary non-standard features to them — in this case resulting in J++. Then they would try to force developers to choose between the two. TypeScript is exactly the same approach — this time for JavaScript. By the way, this isn’t Microsoft’s first fork of JavaScript. In 1996, they forked JavaScript to create JScript. JavaScript has no types, this has it advantages and disadvantages. However, IMHO, its disadvantages has been over-proportionally emphasized and exaggerated, and its advantages has been down-played greatly. If using Typescript, then such advantages will be completely lost, and you’ll get completely restrained, that’s what MS does best. Here is a little example, out of the very limited hours I’ve been using JavaScript – to write a wechaty simulation driving code, it’d be impossible to write such simulation in such simple way, had I been writing my code in TypeScript. Typescript is using the out-dated technology: But someone may say, “if Typescript is not allowing you do that, then you must be doing something wrong”. Well, truth is, The modern programming paradigm has advanced way over the OO era, and “interface” has become the new way of thinking. The loosely coupled interface has much more benefit than the tightly coupled OO polymorphism, which means that MS using type checking to tie peoples hands up is so 19-century in this 21-century world, and will be left in the dust by most knowledgeable programmers. Interface compatibility is much more tolerant than OO polymorphism, that if both the two types satisfy the minimum interface requirement of the accepting parameter, than either of the two unrelated types can be used as the argument. And JavaScript, not Typescript, allows that. This is the reason why I can write such simulation in such simple way using JavaScript, but not Typescript. So, thank but no thanks to MS’ JScript, or TypeScript, without the type restriction, the rest of the TypeScript hypes are actually come from ES6, which is what I’ll stick to instead. Typescript will be abandoned: Who still remember MS’ JScript? Typescript will be left in the dust by most programmers, and it will be abandoned by Microsoft, eventually. Mark my words for it. The philosophy that I resist anything that MS proposes has a long history of me, as a programmer, who was forced onto the MS band wagon for their shinny new toys, then get thrown under the bus when MS abandon them. Not many programmers start the love-hate affair with MS since DOS2. 0, through DOS3. 0 all they way to DOS5. 0. Not many programmers have ever heard of OLE, DDE, DAO, ADO, ADO2, and the stories behind their rise and fall, yet I was the one who bite the bullet and gone through them all. Even today, I’m still living through the consequences of MS abandoning silverlight, for all these past several years. In summary: I know TypeScript does has its place, and the first part of the above article did list many of them. But still I’ll never buy it. Quoting a sentence I like from the above article,  TypeScript haters are gonna hate, either because of fear of change or because they know somebody who knows somebody who is afraid of it. Life goes on and TypeScript introduces new features to its community anyway. All in all, I’ll stick to ES6 and never use TypeScript. It might be my personal choice, but I’m glad I’m not along – check this out Don’t Transpile JavaScript for Node. js Postlude: PS, if I do have to write something that has to be transpiled first before running, it is got to be the Dart programming language, because of the new Google’s mobile UI framework, Flutter, introduce on February 27, 2018, at Mobile World Congress 2018. Don’t get me started on this, but check out the following yourself: Google announced the first beta of Flutterhttps://flutter. io/?utm_source=google&amp;utm_medium=blog&amp;utm_campaign=beta_announcement Flutter Will Take Off in 2018https://codeburst. io/why-flutter-will-take-off-in-2018-bbd75f8741b0 What’s Revolutionary about Flutterhttps://hackernoon. com/whats-revolutionary-about-flutter-946915b09514 Why we chose Flutter and how it’s changed our company for the betterhttps://medium. com/@matthew. smith_66715/why-we-chose-flutter-and-how-its-changed-our-company-for-the-better-271ddd25da60 Google跨平台UI框架 Flutter beta 重磅发布https://juejin. im/post/5a964adf5188257a690f9a85 Why I moved from JavaScript to Darthttps://hackernoon. com/why-i-moved-from-javascript-to-dart-9ff55a108ff4#. ezyej7cdr Why I moved from Java to Darthttps://hackernoon. com/why-i-moved-from-java-to-dart-8f3802b1d652 "
    }, {
    "id": 383,
    "url": "https://wechaty.js.org/2018/02/06/techie-festival-faq/",
    "title": "女生科技体验节，Wechaty杂货铺",
    "body": "2018/02/06 - 这篇文章主要针对女生科技体验节Wechaty专场，同学们问的问题的汇总。因为很多同学没有太多编程基础，所以这篇文章讲解会比较基础。 故事从哪里说起呢？通过这次女生科技体验节活动，同学们遇到的问题主要来自三方面，第一，是docker安装方面的问题；第二，是对一些专有名词的不理解；第三，是程序运行和代码编写方面的问题。那么，我会把重心放在，程序编写和运行中遇到的问题，和对同学们来说比较陌生的专业术语的解释上。因为，安装的问题五花八门，安装好以后大家都就可以随心所欲的写自己的机器人了，遇到更多的是程序代码上的问题。还有，我对安装真的不是特别在行。。。。 So，这篇文章主要以问答的形式来写，并且，后面遇到新的问题，也可以告诉我，我会及时的补充。 1.  Wechaty微信机器人可以用到公众号上吗？: 不能用于公众号，公众号本身有自动回复的功能，可以直接调用公众号的接口，具体可以查看文档，使用Wechaty制作微信机器人只能用在个人微信号上。但是wechaty 有计划把公众号整合进来，详细讨论见 issue1016 2.  docker的镜像加速器: 因为国内访问Docker 官方的Docker Hub有时候速度会很慢，此时就可以配置镜像加速器。比如：阿里云加速器，DaoCloud加速器等。配置方法就是，我们注册新用户之后，申请加速器，会获得一个地址，然后我们将这个地址配置给Docker引擎，添加到docker的registry-mirrors中。Docker Hub是仓库集中存放镜像的地方，Docker官方维护了一个公共的仓库Docker Hub，可以通过docker pull来将需要的镜像下到本地。 这里我们的雨鸟助教将wechaty的镜像直接放在了registry. docker-cn. com一个国内的hub ，我们就可以很快速的拉取镜像。 拉取镜像的命令：docker pull registry. docker-cn. com/zixia/wechaty将Wechaty版本号指定到最新的版本docker tag zixia/wechaty:latest启动程序docker run zixia/wechaty 3. 在运行李佳芮讲师的get start代码的时候，为什么自己发的信息不能回复: 其实单从Wechaty来说是可以自己发信息，自己回复的，但是自己给自己发信息会进入一个死循环。 讲师提供的get start 的代码，有这么一句 if(m. self()){ return;}当接收到的消息是自己发出的，就直接终止代码继续往后执行。 4.  Windows7下发送不了中文message: 这是MinGW的问题。MinGW 是一组包含文件和端口库，其功能是允许控制台模式的程序使用微软的标准C运行时（C Runtime）库。简单的说，有一些软件必须在Linux的环境下运行，MinGW可以在Windows上提供一套Linux的运行的环境，表象的说就是可以在Windows上执行Linux的命令。但是MinGW对中文的支持很不友好。 我们在安装git的时候会自动安装MinGW。所以导致同学们发送不了中文的message。具体的解决方法就是：使用命令docker-machine ssh，ssh连接到docker镜像内部，然后再运行。ssh是一种网络协议。用户想要通过本地计算机登录到远程计算机，就要使用ssh。具体想要多了解的可以看阮一峰的这篇小白入门文章：http://www. ruanyifeng. com/blog/2011/12/ssh_remote_login. html 。这里我们使用docker-machine ssh访问到docker镜像，因为docker内部就是linux环境，所以内部没有用到MinGW，这样就解决了系统的兼容性问题。但是ssh进入内部，就不能直接使用docker run -t挂载本地目录，因为现在命令的执行是直接在虚拟机内部的，操作不了宿主机的文件。解决的方法是，把本地的目录挂在到docer虚拟机内部，然后ssh连接进虚拟机，docker run -t是挂载虚拟机内部的目录。 这里感谢我们的远程助教杉木和Fery提供的解决方案。 5. 正则表达式: 因为在机器人拉人入群的时候，我们主要采用的是，好友输入入群的关键词，然后机器人匹配关键词，自动拉人入群。这里我们就要用到正则表达式。 首先理一下什么是正则表达式：正则表达式是一种文本模式，可以是普通的字符，也可以是特殊字符。正则表达式使用单个字符串来描述、匹配一系列某个句法规则的字符串。可能这样说大家还不是很明白，举一个例子：我们希望拉人到test群，希望好友向机器人发送“room”，机器人收到这个词，才会将好友自动添加到test群里。那么我们就需要用到正则表达式来匹配。这里提一下一位同学写的非常具有教育意义的代码。可以看出这位同学有一定的编程基础，她想实现的功能是，当好友在输入：“Hello”或者”Hi”的时候，都能自动添加到群里。下面是代码： if(/Hello || Hi/. test(content)){ . . . }js的正则表达式中“或”是这么写的/Hello|Hi/，并且中间不能有空格，如果有空格，正则也将匹配到空格，好友必须输入”Hello ”或者” Hi”才能匹配上。正则表达式学起来很繁琐，但是功能很强大，感兴趣的同学需要自己下来花时间学习。 6.  Typescript: Javascript是一个弱类型语言，就是说变量类型是不确定的，比如： var x = 5;x = x + 'A'声明x的时候是一个数值，但是第二句直接把x变成了一个字符串。也就是说js中变量的类型完全是由当前的值来决定的。这样对于最初的js作为一个脚本语言来说是很方便简单的，但是随着项目的逐渐变大，用这种弱类型的语言一直要到程序运行的时候才能检测出错误，为了开发人员能够在编译时就能发现代码的问题，现在很多大型的项目都希望Js能够支持强类型，就是指定变量的类型，比如Flow，Typescript。Typescript 是微软2012年推出的一种编程语言，属于 JavaScript 的超集，可以编译为 JavaScript 执行。 它的最大特点就是支持强类型和 ES6 class。 Wechaty本身是使用的Typescript编写。我们在编写机器人的时候，也可以使用Typescript。 7. 怎么知道好友自动通过的条件: 有同学问，不想通过所有的好友请求，怎么办呢？ 这里可以参考这个示例：https://github. com/wechaty/wechaty/blob/main/example/friend-bot. ts和friend Event API：https://wechaty. github. io/wechaty/#Wechaty+on Wechaty提供的接口可以通过验证信息来过滤掉一部分发送请求的好友。具体的的代码： . on('friend', async (contact, request) =&gt; { if (request &amp;&amp; request. hello == ‘ding’) {  request. accept() }}）当验证信息是’ding’才会自动添加好友。 8. 支持红包类型的消息吗？: Wechaty提供的接口可以识别机器人接收到的消息时什么类型的，因为Wechaty是基于web的，所以不能做领取红包的操作。 可以参考我的这个代码:https://github. com/TingYinHelen/wechaty-test/blob/master/index. js在49行的地方，判断message的类型，红包信息的m. type() =10000，当m. type() == 10000的时候，说明是红包，机器人就会@一下我自己，提醒我赶紧抢红包。 9.  如何防止封号: 需要控制消息发送频率，过高的发送频率会容易被识别。另外账号最好是经过认证、绑定过银行卡，日常也在手机端正常使用（如发朋友圈之类）。总而言之，让你的号行为看起来像是一个真人在用。 还有很重要的，别用于发广告、骚扰，否则被举报很容易被封。 10. 自己的账号登录不了网页版微信: 微信账号太年轻，需要换一个早期注册的账号。其实就是遭遇了上面所说的号被封了。 11. 机器人掉线问题解决: 这里建议使用Server酱。网页版微信会经常把用户踢下线，Server酱可以帮助我们知道Wechaty发生了哪些异常。 Server酱，他是一个能从服务器推报警和日志到手机的工具，非常简单易操作： 1. 用GitHub账号登入后，获得一个SCKEY（在「发送消息」页面） 按照引导，点击“微信推送”，扫码关注“方糖”后即可完成绑定 2. 在login、logout、scan、和error事件触发后，将一些关键信息往 http://sc. ftqq. com/SCKEY. send 发Get请求，我自己的微信里就收到消息了。 这样，当我的机器人出现各种异常情况，我随时随地都可以知道，需要再扫码进入的时候，方糖这公众号就会把二维码推到我的手机上，我只要用机器人的微信扫码就可以了。 12.  怎么终止程序: 终止程序命令: ctrl + c 13. 怎么区分群和私聊: 机器人在获取message的时候可以判断message. room()方法返回值，当返回是null，就说明是私聊，返回不是null就是群聊。null在js 中转为Boolean之后是false。所以直接看代码 const room = m. room()if(room){ //这里是群聊}else{ //这里是私聊}14. wechaty的适用场景: Wechaty的适用场景非常的广泛，Wechaty 提供了一套非常方便的接口。以前我们总是去App store中安装App，然后使用App来满足我们对应用场景的一些需求。然后现在使用手机，大多数的时间都花在了微信上。不管是私聊，群聊还是看朋友圈，我们不得不承认，微信占据了我们生活的很大一部分时间。那么为何不省去下载App的时间，就在微信上满足我们对应用的需求。预定机票，酒店，租房，天气查询，周边美食查询。可以说，chat bot可以实现大多数App实现的功能，只是需要开发者自己设计。chat bot能简化一切机械的人力成本，比如：拉人入群，发送欢迎语，自动添加好友，自动踢人。说到自动踢人，其实很多群里是群主手动踢人，在wechaty developer home微信群中，实现自动踢人，当有人在群里发送无关消息时，群里的成员可以@此人，用微信表情投票，得票超过三个，机器人将自动踢人。所以chat bot能做的事情是在太多了。如果你感兴趣在可以在Wechaty的blog中有发现很多开发者写得技术文章https://wechaty. github. io/，和wechaty的实际应用。当然你也可以发挥想象，做出更加有意思的微信机器人。 15. 执行docker run要在项目目录下: 很多同学都有这个问题，在下载get start项目之后，没有进入到项目目录就开始运行代码了，需要进入到项目目录下再运行 cd wechaty-getting-started 下面是五花八门的安装问题 16. 安装docker的问题: Error with pre-create check: “This computer doesn’t have VT-X/AMD-v enabled. Enabling it in the BIOS is mandatory” Looks like something went wrong in step ´Checking if machine default exists´… Press any key to continue… 重启进Bios设置一下 Security-&gt;Virtualization-&gt;Intel(R)Virtualization Technology From Disabled-&gt;Enabled 17. ash. exe找不到的问题: 如果安装路径不在C盘可能遇到这个的问题,手工浏览一下就好 18. boot2docker下载不了: 手工下载下来,放在C:\users\用户名. docker\machine\cache下 19. bash. exe找不到问题: 下载下面提供的链接，然后安装。https://github. com/boot2docker/boot2docker/releases/download/v18. 01. 0-ce/boot2docker. iso  作者: @Helen, Lenovo  女生科技体验节的志愿者助教。 "
    }, {
    "id": 384,
    "url": "https://wechaty.js.org/2018/01/29/girl-techie-festival/",
    "title": "女生科技体验节，Wechaty专场技术复盘",
    "body": "2018/01/29 - 女孩子天生喜欢漂亮的衣服，衣柜里琳琅满目的首饰，化妆品。周末和闺蜜约会，逛街，喝下午茶。这似乎是众人眼中的姑娘们的标配。然而又有着这么一群女孩，她们喜欢编程，用代码改变着身边细小的事情，改变着世界。聪明，具有创造力，她们用行动诠释了新时代女性的性感。一个女孩的美丽不仅仅来自她的外表，更来自她的思想。2018年女生科技体验节，便是一道独有的风景线，讲师李佳芮带领女孩子们体验使用Wechaty制作自己的微信机器人。 在2018女生科技体验节中，讲师李佳芮向大家讲解了《从0到1，搭建你的个人智能助理》，基于同学们大多没有太多编码经验，所以这篇文章做一个技术复盘，把课程中讲到的技术知识点做一个总结。 OK，时间是把杀猪刀。课程第一步做了什么呢？嗯，做了课前准备。对，就是整个课程最复杂最麻烦的一步！很多同学在就牺牲在了第一步，俗话说得好，万事开头难，开了头就可以骑着马跑~为了保证到场人数达标，活动方派出了两位助教帮助同学们装环境。 这里我需要花一定的篇幅来表扬我们的助教雨鸟同学，他乐于助人，是身边的活雷锋，在前期准备工作中，雨鸟同学帮助100多位女生安装docker，搭建环境，手都抽经了。作为一个高级运维，雨鸟在课程中，不仅解决环境搭建的问题，还帮着同学们解bug，成为了一大波女生心中的偶像。 下面开始讲技术。 安装Wechaty有两种方法，Node和Docker。课前希望同学们能安装好。因为安装会花费很多时间，一个是本身软件很大，再加上wechaty镜像很大，如果全在会场来下载，会场的网络怕是扛不住的。。。具体安装方法，安装成功的标志是，在命令行中输入node –version，会显示node的版本。 接下来讲一下docker， docker是一个简化部署的工具。为什么我们需要docker？对于初学者来说可能比较难理解，打一个比喻，集装箱！在集装箱出现之前，我们是怎么运输货物的呢，货物从工厂生产出来之后装箱，然后一箱箱的搬到卡车上，然后再一箱箱卸下来，一箱箱送上火车，运送到码头附近的火车站，再一箱箱卸下来，装上卡车，拉到货轮上，再一箱一箱的装上。可以看出在这个整个流程中，大量的时间，人力 ，物力全部浪费在了中间的装卸上。集装箱重要在它提供了一种通用的封装货物的标准规格（尺寸，外形符合统一标准）。只需要在运输前一次性封装，集装箱就可以放上火车，卡车，拉到码头，直接放在货船上这里后面还会具体介绍。理解就是，docker可以把整个开发环境中所需要应用按照一定的格式封装，开发者可以直接拉取镜像进行安装，就可以很容易的获取一套开发环境。如果把镜像比喻成面向对象中的类，容器就是一个实例。容器的实质就是一个进程。 docker安装好的标志是命令行运行：docker --version会显示docker的版本号。 好了，安装好docker之后我们要做的就是download wechaty的镜像 获取镜像的命令：docker pull [选项] [Docker Registry 地址]&lt;仓库名&gt;:&lt;标签&gt; 获取wechaty的镜像：docker pull [registry. docker-cn. com/zixia/wechaty] 获取镜像之后 运行 docker run zixia/wechaty 如果看到wechaty的欢迎界面就表示已经在本地成功运行wechaty 以上是环境搭建，搭好环境之后就可以编写我们想要的微信机器人了。 Wechaty: Wechaty是一个为个人微信号搭建的chat bot框架。这里讲师给大家提供了一个机器人代码，实现了简单的自动通过好友请求，拉人入群，欢迎新人入群，踢人等功能。 需要大家拉下这个仓库，使用命令git clone https://github. com/lijiarui/wechaty-getting-started. git，没有安装git的同学可以直接下载这个仓库。下载好仓库后，需要进入到项目目录下（使用命令行：cd wechaty-getting-started），然后运行项目（使用命令行：docker run -ti --volume= $(pwd) :/bot --rm zixia/wechaty mybot. ts）这里我解释一下这两句命令行的意思： 1. cd wechaty-getting-started就是进入到wechaty-getting-started这个文件夹下面； 2. docker run -ti --volume= $(pwd) :/bot --rm zixia/wechaty mybot. ts docker run的意思是创建一个新的容器，并运行一个命令，语法是docker run [OPTIONS] IMAGE [COMMAND] [ARG. . . ]  -ti是两个命令：-i是以交互模式运行容器，-t是为容器重新分配一个伪输入终端，这里我们打算进入bash执行一些命令并查看返回结果，因此我们需要交互式终端。 —rm这个参数是指容器退出后随之将其删除。 --volume是增加一个数据卷，具体什么是数据卷，将在后面的文章详细讲，这里只需要理解–volume=”$(pwd)”:/bot的意思就是把当前目录映射到容器里的bot 然后就是运行的zixia/wechaty这个镜像下的mybot. ts文件。 可能对js有了解的同学可能会问. ts文件和. js文件的区别，Wechaty框架是使用Typescript编写的项目，TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，TypeScript 通过类型注解提供编译时的静态类型检查。我们也可以直接用JavaScript进行编写 讲师提供的这个机器人做了一件什么事儿呢？ 首先，当有好友请求添加好友的时候，能够自动添加为好友。 具体是这段代码 . on('friend', async function (contact, request) { if (request) {  await request. accept()  console. log(`Contact: ${contact. name()} send request ${request. hello}`) }})然后当接收到消息的时候，当对方说“hello”，机器人就会回应：”hello how are you”。这里的代码有一个小bug，就是回应的语句中也含有“hello”这个词，所以发生的当天著名的炸群事件，群里一个劲儿的回复“hello how are you”，导致当天有同学的微信号被封了。要修改这个bug很简单，就是将回复语中的“hello”换成其他词。继续往后，当同学们输入”room”的时候，机器人会找到一个名为“test”的群，然后将该同学拉进群里，并且会说：“welcome！${同学的名字}”, . on('message', async function (m) {  const contact = m. from()  const content = m. content()  const room = m. room()  if (/room/. test(content)) {   let keyroom = await Room. find({ topic:  test  })   if (keyroom) {    await keyroom. add(contact)    await keyroom. say( welcome! , contact)   }  } })当同学发送“out”这个信息的时候，会把自己从“test”这个群里把自己踢出去（这个功能也是很有意思的，自己把自己踢出群）   if (/out/. test(content)) {   let keyroom = await Room. find({ topic:  test  })   if (keyroom) {    await keyroom. say( Remove from the room , contact)    await keyroom. del(contact)   }  }好了，我把代码实现的功能讲述了一边，具体的就需要同学们自己去看代码了。这里我重点给大家介绍一下这段代码中用到的wechaty的几个类，分别是Wechaty、Contact、Message、和FriendRequest。每次我们只需要引入需要用到的类就可以使用类提供的方法了。还提供了一些事件：‘scan’（扫描二维码），,’login’（机器人登录），‘logout’（机器人退出），‘message’（接收到新消息），‘error’（程序报错），‘friend’（好友请求）等。Wechaty提供了一套非常方便的API，供开发者方便的使用，满足机器人来管理群。 Server酱: 网页版微信会经常把用户踢下线，Server酱可以帮助我们知道Wechaty发生了哪些异常。Server酱，他是一个能从服务器推报警和日志到手机的工具，非常简单易操作： 1. 用GitHub账号登入后，获得一个SCKEY（在「发送消息」页面） 按照引导，点击“微信推送”，扫码关注“方糖”后即可完成绑定 2. 在login、logout、scan、和error事件触发后，将一些关键信息往 http://sc. ftqq. com/SCKEY. send 发Get请求，我自己的微信里就收到消息了。 这样，当我的机器人出现各种异常情况，我随时随地都可以知道，需要再扫码进入的时候，方糖这公众号就会把二维码推到我的手机上，我只要用机器人的微信扫码就可以了。 UNIT: 最后，我们向大家介绍了怎么去制作智能微信机器人，使用了百度的UNIT框架。UNIT不需要有开发经验，我们需要做的是了解机器人使用在什么样的场景下，如何理解、如何回应用户。机器人是通过识别意图和词槽理解用户的。我们通过建立词槽，引入词典，配置词槽的澄清话术。配置回复文本及触发条件，配置引导话术、引导目标和触发条件，最后保存所有配置，导入语料，编辑对话模板，最后训练并生效模型。 这篇文章先写到这里，后面将会对同学们在课程中遇到的问题和一些专有名词进行解释。 文章最后还是提一下我自己的志向，我希望做一个面向女性和儿童的程序员社区，希望有更多的女性加入到编程行业，成为行业的引领者。同时大力提倡儿童编程，如果想跟我聊一聊的，下面是我的联系方式。   作者: @Helen, Lenovo  一个爱玩的程序员，喜欢折腾新技术，还喜欢研究框架源码。不写代码时喜欢跳舞，架子鼓，马拉松，是这次女生科技体验节的志愿者助教。 "
    }, {
    "id": 385,
    "url": "https://wechaty.js.org/2018/01/25/how-to-build-face-blinder-bot/",
    "title": "构建脸盲聊天机器人--Wechaty Blinder",
    "body": "2018/01/25 - 这是我在2017 北京 谷歌开发者节 TensorFlow 分会场的分享，本次活动是由谷歌（中国）、谷歌北京开发者社区主办，北京邮电大学协办的2017谷歌开发者节北京站在北京邮电大学圆满举办。我主要介绍了如何使用开源项目Wechaty-Blinder快速搭建一个微信脸盲机器人，迅速帮助你识别照片里的人。 Who am I: 在分享这个开源项目之前，我先介绍一个我的先天性缺陷：  近视+散光，但是每年带眼镜的次数是个位数。 先天性记不住人样貌。 每天还要见好多人，微信有大几千好友。通常情况下我会和一个人在微信上聊的火热，然后在一次活动见面又聊的很开心，然后过了几个月再次见面的时候，我们双方热情打招呼后心里默默嘀咕这个人是谁。。。。为了不让大家觉得我是一个高冷の女子，在我经常活动的地方，只要有人往我这看,我就热情的打招呼，也许对方也在默默嘀咕这是哪个神经病。。。。对，我有脸盲。而今天介绍的脸盲机器人，用人工智能，专门帮助我认识各种人的。 Content: 我会从5个角度来做这场分享，首先简单的介绍下TensorFlow, 然后介绍下Google 的Facenet，再来介绍下我们的3个开源项目：Wechaty, Node-Facenet, Wechaty-Blinder, 最后会给大家做现场的代码演示。之所以介绍wechaty-blinder 的项目要介绍wechaty 和node-facenet，是因为wechaty-blinder 是基于wechaty 和 node-facenet 这两个开源项目的。 Google TensorFlow: 脸盲机器人wechaty的底层用到了TensorFlow, 今天要介绍的wechaty-blinder 是一个基于TensorFlow 和google 的论文 Facenet 实现的node. js 开源项目，可以帮助解决人脸认证、识别和聚类等问题。 Google Facenet: Facenet 来源于Google 的论文FaceNet: A Unified Embedding for Face Recognition and Clustering，是一个用来给人脸做分类的神经网络。与其他的深度学习方法在人脸上的应用不同，FaceNet并没有用传统的softmax的方式去进行分类学习，然后抽取其中某一层作为特征，而是直接进行端对端学习一个从图像到欧式空间的编码方法，然后基于这个编码再做人脸识别、人脸验证和人脸聚类等，欧式集合距离可以直接来代表脸的相似度。FaceNet算法有2个特点：  去掉了最后的softmax，而是用元组计算距离的方式来进行模型的训练。使用这种方式学到的图像表示非常紧致，使用128位足矣。 元组的选择非常重要，选的好可以很快的收敛。Open Source Chatie: Wechaty 是一个开源的针对个人号的微信机器人框架，仅仅使用6行JavaScript代码就可以实现一个简单的机器人，同时支持Linux，Windows，Darwin(OSX/Mac) 和 Docker。博客地址是 https://wechaty. github. io 最简单的6行代码代码在这里，也可以去我的项目wechaty-getting-started下快速入门wechaty。wechaty 最终运行页面就是右手边的样子。 Github, Docker, npm 相关地址在这里，wechaty有非常完善的devOps，一旦代码提交，就会自动进行自动化测试，当测试通过后，会自动打包更新docker 和npm， 所以也欢迎各位开发者来pull request。 Wechaty 现在有非常完善的开发者社区，开发者覆盖了全球，包括中国、美国、澳洲、英国等。这是一部分的contributor的列表，同时chatie 下面也有几个分值项目来支持微信机器人。 Node-FaceNet 是一个基于TensorFlow和facenet ，解决人脸认证、识别和聚类问题的开源项目。它是一个用node封装的python的Facenet库，主要实现了下面三个主要功能：  把不同的脸放在一个欧几里得空间中，不同脸之间的距离代表着脸的相似度。 很好的优化了识别脸的性能，一张脸只要128维向量即可表示。 在LFW 数据集上可以达到99. 63% 的准确率，在YouTube 数据集上可以达到95. 21% 的准确率。Open Source Node-FaceNet: 这个开源项目核心是2个类和3个方法，更多的细节可以参考我写的文档。两个主要的类是：  Face, 毫无疑问代表一张脸 Facenet, 代表的是一坨脸。。。三个主要的方法是:  aling()， 从一张图中找出包含的所有的脸，通过先找到脸的坐标，然后生成一个Face 实例数组。换句话中，传一张图片给align，他会突出一个脸的array.  embedding()， 将脸转换成一个128维向量 distance()，计算两个脸的距离 这是一个简单的例子，我们来读左边的代码。先新建一个Facenet 的实例，然后传入照片，看打印出来的face的结果。右边是打印的结果。通过这个我们可以看出来，align 函数在图片上找出这张脸的坐标以后，生成一个Face实例，把所有的实例放在一个数组里面。 这个坐标包括两种，一种是能够框出这个脸的框框，另外一个是脸上关键性的5个特征点。看log感受一下：  bounding box: 用来框出脸的框框，用两个关键点表示：一个是左上角的点，一个是右上角的点。 landmarks:代表脸上关键性的5个特征点，左眼、有眼、鼻子、左边的嘴、右边的嘴 embedding: 代表脸的128维向量, Facenet 论文中的embedding 代表一个脸部特征矩阵，是一个128维向量。 这是另外一个例子，把脸和脸之间的距离可视化。我们可以看到这个绿色的框框就是上面我说的align出来的能够框出脸的框框，1. 45，1. 47, 0. 66 三个数字分别代表了两个脸的相似程度，可以看出，数字约小，脸约像。如果两个脸是属于一个人的，他们的距离通常是0. 75。当然这只是一个经验性数字，还要具体情况具体分析。 Open Source Wechaty-Blinder: 终于讲到了今天的主角，脸盲机器人的开源项目wechaty-blinder, 其实当你了解了上面两个项目以后，wechaty-blinder 就非常好理解了。 这个项目是可以记住你所有的微信好友的脸。 一旦机器人帮你记住了这张脸，你随时随地都可以为这张脸命名。他有下面3个功能：  记住群里所有好友的脸 记住通讯录里所有好友的脸 记住你发的每张照片中的脸当然，他就可以帮助你认出你发的照片、群、和好友中哪些是同一个人啦。 这是使用wechaty-blinder 的效果图，看到当我发甄子丹和刘德华的脸的时候，他会自动吐出库里面和这个相似的所有的脸，并可以随时给他们改名字。简单的说就是两点：  识别出脸 给脸起名字大家可以体验一下，这个是我预先为这个活动创建好的wechaty-dev-facenet 微信群，群里面有机器人，扫码进去就可以体验这个功能了。 这个机器人已经用Docker 封装好了，运行下面的命令，就可以启动这个机器人了，WECHATY_TOKEN=TOKEN 是可以你随便起名字的。 docker run -d --restart=always --volume=/workdir:/workdir -e WECHATY_TOKEN=TOKEN zixia/wechaty-blinder如果你想随时在网页上控制这个机器人怎么办呢？很简单，跟着我做下面这五步：  打开 https://wechaty. github. io/angular/ ，然后点击 Click to run 在输入框填入你的 WECHATY_TOKEN ，然后点击 Set Token 等待显示登录二维码，然后用手机摄像头（微信内长按不可以）扫描登录 建立一个新群，建群后不要做任何操作，先把群名修改为任意包含 facenet 的字符串 在群里面发图片，附体在你身上的机器人就会施法了。最后，感谢Google 办了这么一场有趣的活动: 本次活动邀请到了来自海内外数十位资深工程师，除了 Google的研发专家团队，还邀请到了JetBrains团队，这也是 JetBrains 团队在中国大陆首次针对Kotlin的官方分享。另外，该活动还邀请到了国内诸多一线研发团队，滴滴、Strikingly、百度、集智社区，桔子互动等公司，带来他们近期的一线研发经验。 DevFest 是 Google 每年秋季在全球GDG（谷歌开发者社区）推行的，针对 Google 技术开发者、爱好者所举办的技术交流活动。其主要目的在于同步 Google 相关各种先进技术，并进行推广与应用，促进本地社区成员的交流。DevFest活动除设置有吸引力的主题分享，还有互动参与环节和来自 Google 的正版周边礼物，对于 Google 技术开发者、爱好者都是不可错过的体验机会。 "
    }, {
    "id": 386,
    "url": "https://wechaty.js.org/2018/01/14/wechaty-contributor-dinner-data-girl/",
    "title": "Wechaty Contributor Dinner with Data Girls",
    "body": "2018/01/14 -  This Wechaty Contributors Dinner is sponsored by Data Girl. The above contributors are:  李佳芮, Microsoft AI MVP, Founder &amp; CEO of BotOrange 王海良, Microsoft AI MVP, Founder &amp; CEO of ChatOpera 李卓桓, Microsoft AI MVP &amp; Regional Director, Author of Wechaty 尹婷, Microsoft VS MVP, Frontend Developer in ChengDu 梁迪, CPM at Microsoft 雨鸟 , A devops engineer focus on Kubernetes 令狐曦, CS Student from BUPT, Baidu AI UNIT Lecturer 谢扬, ByteDance Hacker, former CTO of Awesome Port 胡莺夕, CS Student from BUPT, NLP Algrithm Intern at Microsoft Research Aisa 王宁, CS Student from BUPT, Frontend Intern at AlipayIntroduction Video:  "
    }, {
    "id": 387,
    "url": "https://wechaty.js.org/2018/01/09/all-you-need-to-know-about-chatbot/",
    "title": "关于聊天机器人你需要知道的东西",
    "body": "2018/01/09 - 2018年已经到来，一觉醒来，各种社交媒体已经被18岁刷屏有这样的： 当然还有这样的： 已经陷入正态分布式懵逼的我决定请教我的私人助手———Siri 这让我不禁好奇起来Siri到底有多大? 好吧，女孩子是要神秘一点才美丽。那么看淡一切，不拘小节的知名佛系青年——龙泉寺的贤二总不会不告诉我吧。 聊天机器人的历史: 世界上第一个聊天机器人叫做ELIZA，今年已经50多岁了。由麻省理工学院教授Joseph Weizenbaum在20世纪60年代开发。 ELIZA最初是为了模仿“无定向的心理治疗师在最初的精神病学访谈中的反应”而开发的，据此验证人与机器之间到底是如何进行交流。她使用了能够识别某些模式和关键词的脚本，并据此产生响应。令Joseph没有想到的是，ELIZA可以像心理治疗师那样与人交流，其中还和其中一些人产生了情感联系。 ELIZA之后激发了大量的聊天机器人，像 PERRY、 ALICE、Mitsuku、Albert One等等。 SmarterChild是其中最受欢迎的。开发于2000年，00后的它，现在即将成年，是正儿八经的18岁。它搭上了当时短信服务正流行的东风，并加入了前沿的自然语言处理能力。已经能够理解人类的语言并给予回应。 在2002年一款让全球用户开心大笑的聊天机器人诞生了——SimSimi。它是由韩国科技公司ISMaker创建的应用程序，画面清新可爱，尤为受女生欢迎。由于吉祥物是一只黄色的鸡，在中国又得名小黄鸡。这只小黄鸡凭借其幽默诙谐的应答几乎一夜爆红…在网络上还刮起了人鸡对话的旋风。 它利用了大约1000万个问答对话的基础，并且词汇量会随着用户的输入而增长。一旦小黄鸡没有数据可以回答，用户可以选择“教学”选项卡教小黄鸡学习新的词语。这让用户仿佛觉得自己是在和多年亲密好友短信交流，在空虚寂寞冷时候给你送来温暖。 你以为聊天机器人只能搞笑吗？你错了。在2010年Siri出生了，她几乎重新定义了聊天机器人的功能。这位始终对年龄秘而不宣的神秘女郎今年竟然才刚刚8岁！ 用户不仅可以通过信息与Siri进行查询和对话，还可以享受你文本，音频，图像和视频多种方式。 除此以外，苹果公司给siri增加了一系列的实用功能：  提醒备忘，小case！  帮你叫车，easy job！  懒得读邮件，siri替你读！ 从打电话、寻找路线、歌曲识别到设置闹钟，你想到的她都能帮你。那么至于siri有多会聊天？  有趣的是，Siri发布时，Eliza也被再次请出进行对话。当时，Eliza和 Siri 之间年龄相差 45 岁，内存相差 200 万倍。 在Siri之后，不到4岁amazon的alexa则让聊天机器人更进一步。她现在内置于Amazon Echo，Echo Dot，Echo Show，Fire TV等多种智能家居设备中。所有你需要做的就是说“Alexa，播放一些音乐”或“Alexa，打开电视机”，就可以轻松命令家里的所有家电了。Amazon甚至允许开发人员使用Alexa技能工具包（ASK）为Alexa创建和发布技能。您可以使用Alexa应用免费下载技巧。 最后那位表情永远呆萌佛系青年贤二僧人究竟年龄几许呢？这款聊天机器人界的“扫地僧”的生日是2015年10月1日，当天是师父主持龙泉寺工作十周年的日子。它不仅也就是说他不过才1岁半，这么看出家人果然不打诳语。别看他年龄最小，听贤二一席话，能用禅意净化心灵，指引人生方向。 风起云涌的商业应用: 随着消息应用程序在使用中继续超越社交媒体网络，聊天机器人在商业范围内变得越来越流行，它的不断优化与进步也正在对企业产生显著的变化。现在，越来越多的企业开始在客服渠道引入聊天机器人，以替代使用体验不佳的客服语音系统。这么一来，用户再也不用不耐烦地经过层层系统才能获得资讯或是和人类客服沟通，对商家而言，聊天机器人可以更低的成本提供与客服中心类似的服务。如果第三方开发者能够快速开发出功能丰富的聊天机器人，更多的企业和商户将会利用聊天工具建立和消费者、老顾客之间的沟通管道。  在3个月内聊天机器人甚至实现了170%的增长 在2016年4月份的F8开发者大会上，Facebook宣布为Messenger平台启用聊天机器人(chatbot)，商家可以通过它的即时通聊天机器人，提供各种如客服、指引和互动的服务。在线花卉零售商1-800 Flowers的公司总裁克里斯·麦坎（Chris McCann）称在Facebook Messenger中推出聊天机器人发布几个月内，“70%通过聊天机器人达成的公司订单都是新客户订单。这些用户比公司的普通用户更为年轻。”可以说，聊天机器人在迎合了正成为消费主力军的千禧一代(1984-1995年出生）的喜好。 与此同时一向高冷的各大时尚品牌，诸如Burberry，维多利亚的秘密,Tommy Hilfiger也加紧引进聊天机器人的步伐。你可以浏览本季最新款式，翻看商品目录。聊天机器人会询问你的身材尺码，所在国家，服饰喜好等等来协助你选择商品。如果感兴趣，选择更详细地查看该项目或进行购买，你立即被带到品牌网站，整个产品线以各种颜色和尺寸都会展现眼前。她让我觉得就算闺蜜不在，依然有人陪你一起买买买。 与此同时，国内的各大电商也早已开发并引进机器人客服，并且效果显著。2016 年，合众人寿引入了蚂蚁金服客服能力，在线客服、自动外呼、智能质检，对作业效率和作业质量的提升明显。机器人解决率高达 83%，呼出产能提升 15%，呼入产能提升 10%。 自动应答以及聊天机器人并不是噱头或是营销活动，而是新的用户界面的范例。当用户通过消息与企业进行交互，他能够感觉到在进行真实的对话交流。而消息这种交互方式具有天生的再联功能，因为用户与消息应用中的聊天机器人能够真正交互。企业花费数百万美元以及数年时间推出移动应用程序的情形已经不复存在。 聊天机器人如何工作: 那么问题来了，聊天机器人是如何实现的呢？现在的聊天机器人大致分为两种类型：一种的运行基于一套完整规则；另一种是更高级的版本，使用机器学习。这是什么意思？ 第一种基于规则的聊天机器人的功能是非常非常有限的。它只能回应非常具体的命令。如果你说错了，它不知道你的意思。而之前我们介绍的大多数聊天机器人则是使用机器学习功能的聊天机器人：当你说话的时候，你不一定非常具体。它理解语言，而不仅仅是命令。它从与人的对话中学习，从而不断变得更聪明。 机器学习中：你需要一个样本集来训练一个在给定用户输入时能从所有可能的内容（例如，买票、检查航班状态、获取详细信息等）中选择的分类器。 比如“我想在1月31号从法国巴黎去意大利的威尼斯”。在这个场景中，对于城市和日期的理解输入并返回一个合适的答案是非常关键的。聊天机器人可能会在数据库（或者在线查询）中查找在给定日期从威尼斯到巴黎的机票。因此，聊天机器人需要对输入进行信息提取来获得重要的实体：位置、航班、机场、日期等等。对输入进行分类和从中提取信息是需要时刻谨记的两个重要观念。 这里提到聊天机器人，我们不得不提到NLP的概念：  NLP，即自然语言处理技术，是研究计算机处理人类语言的一门技术，它包括句法语义分析，信息抽取，文本挖掘（或者文本数据挖掘），机器翻译，信息检索，问答系统，对话系统。它可以对于给定的句子，进行分词、词性标记、命名实体识别和链接，并且从给定文本中抽取重要的信息，比如，时间、地点、人物、事件、原因、结果、数字、日期、货币、专有名词等等。通俗说来，就是要了解谁在什么时候、什么原因、对谁、做了什么事、有什么结果。涉及到实体识别、时间抽取、因果关系抽取等关键技术。不仅如此，NLP也可以通过文本聚类、分类、信息抽取、摘要、情感分析，实现对挖掘的信息和知识的可视化、交互式的表达界面。在运用到聊天机器人时，系统通过一系列的对话，跟用户进行聊天、回答、完成某一项任务。NLP涉及用户意图理解、通用聊天引擎、问答引擎、对话管理等技术。为了体现上下文相关，还具备多轮对话能力。此外，为了体现个性化，还要开发用户画像以及基于用户画像的个性化回复。  特朗普对希拉里：Twitter 上的情感分析 不只是聊天机器人，NLP技术如今在深度学习的领域内发展迅猛，比如词嵌入，情感分析，情感神经元的应用，与自动翻译一样的自动概括等等。 发展的天花板: 在2015年的七夕节前后微软微信上发布了全新的第三代小冰，用户可以通过公众号“领养”。小冰”在公测运行3天即覆盖近150万微信群用户，之后则惨遭腾讯微信封杀。仅仅三天的时间，“小冰”在微信上瞬间火爆，又转瞬熄灭，其兴也勃焉，其亡也忽焉，兴亡之间宛如昙花一现。 无独有偶，微软在国外也遭遇了滑铁卢。Tay是微软专为18至24岁的年轻人设计的人工智能聊天机器人，虚拟年龄为19岁。她首次亮相社交网站推特时，Tay表现得彬彬有礼。她活泼健谈，会“观察”你的昵称、性别、喜欢吃的东西以及感情状态等资料。还会会和你玩游戏，给你说笑话、讲故事、谈星座……然而，上线不久， Tay的表现就向着不可控的方向发展。在网友的“调教”下，这个单纯的美国姑娘不但学会了出言不逊、脏话不断，言语甚至涉及种族主义、色情、纳粹，充满歧视、仇恨和偏见。最后微软不得不在巨大的公众压力的把Tay紧急下线。 很难想像微软在一系列变故之后的心情…… 一个智能的聊天机器人能自我学习，随着时间变得越来越聪明，它能够确保基本听懂你说的所有话。虽然机器学习是伟大的人工智能神药，但同时也是人工智能的绊脚石。比如“Tay”，她曾是真的人工智能，它可以通过自我学习来进行与人类的交流。不过正是这个自我学习把微软着急坏了，不得不出面向公众道歉，给他擦屁股。 此外，虽然很多聊天机器人都宣称自己是“人工智能（AI）”，但是大部分实际上并不智能。 那么，非智能的聊天机器人什么样呢？比如Facebook的Messenger上面提供给企业的聊天机器人，你只能按照他们事先设定好的模式去操作。 如果你在Facebook Messenger或者与微信公众号的聊天机器人聊天，你会发现，这些“智能”聊天机器人，目前根本只是一个嵌在程序内的新闻推送功能。而如果你想利用Jello Labs的Spring聊天机器人去买鞋子，你可能只会收到无休止的商品推荐信息。 语言是进化史上最复杂的产物之一，将人类自然语言的力量与先进的机器智能相结合并非一朝一夕之事。尽管先进的存储技术与机器学习的快速发展让人觉得制作一个聊天机器人看非常简单，但要创造一个真实良好互动体验还有许多障碍需要克服。 现在,你很难想象一个没有Siri和其他语音助手的世界，但几年前，与你的电话交谈告诉它该做什么的想法似乎很荒谬。聊天机器人可以安排会议，告诉你天气，并提供各种支持。而这仅仅是一个开始。可以预想的是，聊天机器人在未来一定会融入生活方方面面，创造更多的惊喜。 参考文献：  How chatbots could change customer service over the next 5 years Customer service and virtual assistant bots will be prevalent for online businesses in many markets Conversational Interfaces: The Future of Chatbots Burberry, Victoria’s Secret, Tommy Hilfiger: how major fashion retailers experiment with chatbots 11000个聊天机器人齐犯尴尬癌:用户对其爱不起来想知道更多关于聊天机器人的轶事吗？想学习如何制作聊天机器人吗？快来参加2018女生科技体验节！新的一年给自己一个成长的机会。1. 14我们在北京等着你！ 点我查看活动详情及报名 关于DataGirls: DataGirls是一个专注中国女性的有趣有料的数据分析学习社区，旨在成就更多女性成为数据驱动思考者，运用数据化决策帮助她们实现事业，家庭和个人的高度平衡，收获独立，自由和幸福的人生。关注微信公众号 “DataGirls”了解更多。 "
    }, {
    "id": 388,
    "url": "https://wechaty.js.org/2017/12/25/wechaty-mail-tool/",
    "title": "Wechaty-Mail: An email tool build on Wechaty",
    "body": "2017/12/25 - As soon as I learn how to use 6 lines of JavaScript to achieve a simple chatbot based on Wechaty, I was deeply attracted and decide to develop an easy-to-use email tool based on it. Wechaty-Mail is an application based on Wechaty which can help you get notifications in WeChat when you receive new emails.  Screenshot of the Application: For example, my binding email address is 346786495@qq. com How to use Wechaty-Mail?:  Support email types: Gmail/Outlook/Netease mails(163/126)/QQ mail/Sina mail.  authorize the mailbox and turn on the IMAP service in mail settings.  Configure your own email address and password in the source code and enjoy it.  Ding-dong! you’ve just got an email notification from WeChat FileHelper!Find more details in my github repository Wechaty-Email Appendix: Packages We Used:  Wechaty: A great and easy-to–use WeChat middleware.  Imap: An IMAP client module for node. js.  Mailparser: An advanced email parser for Node. js. "
    }, {
    "id": 389,
    "url": "https://wechaty.js.org/2017/11/26/wechaty-electron-making-your-wechaty-as-a-client-service/",
    "title": "wechaty-electron 把你的wechaty 变成客户端",
    "body": "2017/11/26 - 初识wechaty: 去年的这个时候，我刚到现在的公司任职，发现同事正在用微信做转播，就是把几个微信群里有价值的发言同步到其他几个群里，同时还要存入数据库以便在论坛上也能看到相关讨论。当时同事用的是chrome插件的方式，那是第一次知道微信还可以这么玩。惊奇的同时我也发现了一个很严重的问题，就是插件跑一段时间，网页就卡死了，就得重启。 于是我在网上找不同的解决方案，github 真是一个神奇的地方，很快我就找到了好几个版本的微信机器人，人气最高的当属wechaty，另外还有一个比较看好的是一个python的项目。由于本人对nodejs 对偏爱，选择了wechaty。 为什么要electron: 从Qt到Adobe的AIR，一直未放弃过使用js和html开发桌面应用的尝试和实践，直到出现了electron。我感觉总算出现了一个完美的方案。当然还有NW. js, NW也是一个不错的解决方案。最初NW做的并不如electron，这也导致了我并没有对NW继续关心。不过目前看来NW. js 已经完全具备了与electron 一争高下的实力。找到了wechaty，我的项目才刚刚开始，由于转播过程需要人为的实时干预，甚至当一些bug出现的时候需要手动操作来纠正（当时wechaty还不能发图片，需要手动转发）。如此一来，在服务器端部署wechaty的愿望被打破了。如果能用electron 做个客户端就好了，直接发给运维，解放程序员，就是解放生产力。electron 本身就是在pc端运行node环境，完全符合wechaty的运行环境要求。 wechaty-electron 最初的想法: 很快我的项目进入了实施阶段，wechaty的api 确实非常简单。一个微信转播的客户端很快就完成了，并且实现了与网站上文字直播的互动。 启动界面:选择服务器，并选择一个直播间 操作界面，选择要共享的群，可以使用正则表达式来过滤不想同步的消息，只看嘉宾功能提供单向转播。 web端:微信里的用户发言会直接发布到文字直播间，被标注为微信用户，并显示微信头像。相当于多个群的成员可以共享消息 微信群: 可以选择把信息分发到所有到群里 唯一让我不满足的是，使用electron 客户端启动wechaty 仍然要打开一个网页来登录微信。 electron 本身就是基于chrome内核的。浏览器能做的它都能做，浏览器不能做的，它也能做。完全没有必要启动一个webdriver来登录微信。只需要new 一个window 或者打开一个webwiew 即可代替 浏览器，并且可以随心所欲的隐藏显示。wechaty只需要关心与electron 的webcontent 交互即可。另外，electron 本地代码与webcontent交互更加方便，除了完善的网页事件，更有ipcMain 和ipcRenderer 交互机制。wechaty 完全不必再额外启动一个express server 来建立socket 通道（当时没有puppeteer）。更有价值的一点是，wechaty 可以拥有一个随时随地使用的多平台客户端！ wechaty-electron 实现: 我常常会为自己有一些自我感觉很棒多想法而窃喜。但是鼓起勇气去写又是另一回事了。我仔细的阅读wechaty的源码和electron的api 进行对比和测试。刚有所得时，puppeteer出现了，wechaty 出现了一个较大版本的变动。puppeteer 简直太好用了，比electron的api更全面（我猜测electron也许会因此而更新版本），然而问题也来了，puppeteer 实现的接口electron做不到了！比如 获取页面的弹窗，比如class ElementHandle…我采用最谨慎和保守的方式对 wechaty／puppet-web 进行改写：  新增electron-driver. ts 实现wechaty 中用到的puppeteer的所有接口方法 在wechaty－bro. js中使用ipcRenderer 来发送和接收electron 的事件和指令， 新增emit方法（electron 接口中没有puppeteer 的 exposeFunction方法 ） bridge. ts中增加 bindEvents方法，使用ipcMain. on(event,handler)来订阅页面回传的事件以上最主要的几处修改保证对原来项目改动最小化。经过测试，基本功能已经可用，但是仍然有些许bug，需要后续继续修正。项目地址：wechaty-electron run demo: git clone https://github. com/GuoYingxu/wechaty. gitgit checkout wechaty-electronnpm installnpm run distnpm start参考 https://github. com/GuoYingxu/wechaty/tree/wechaty-electron/example quick start: wechaty-electron 使用方式跟原谅一样。只是注意要再electron 初始化完成之后启动wechaty即可。 //demo codeconst {app, BrowserWindow} from 'electron'const {wechaty} from '. . /dist/index'let window;app. on('ready', () =&gt; { //eletron init code window = new BrowserWindow(); window. loadURL(url. format({  pathname: path. join(__dirname, '. /index. html'),  protocol: 'file',  slashes: true })) //wechaty init const bot = Wechaty. instance({ profile: config. default. DEFAULT_PROFILE }) bot  . on('logout', user =&gt; log. info('Bot', `${user. name()} logouted`))  . on('login', user =&gt; {   log. info('Bot', `${user. name()} login`)   bot. say('Wechaty login'). catch(console. error)  })  . on('scan', (url, code) =&gt; {   if (!/201|200/. test(String(code))) {    const loginUrl = url. replace(/\/qrcode\//, '/l/')    QrcodeTerminal. generate(loginUrl)   }   console. log(`${url}\n[${code}] Scan QR Code above url to log in: `)  })  . on('message', async m =&gt; {   //---  }) bot. start()})更多想法: 国内ip受限，npm install puppeteer 和electron 都非常不容易。所以我单独开了一个分支，删除了puppeteer。我想如果wechaty能把 puppet 做成插件模式，需要那个安装哪个，会不会体验更好？甚至后面还会有更多的 wechaty－puppet－engine ，比如wechaty-nw for NW. js。这样，wechaty 本身只关心 微信 api，puppet 只关心与engine通信，应该是一个比较完美的结构。 微信机器人的使用会导致ip被封。暂时还无法确定使用electron 能否减少被封的概率。前面经验告诉我，如果微信被封号，换个ip是可以登录的，electron的客户端安装要比部署服务简单的多。 期待与各位有更多的交流。 ps: 这几天听闻微信网页端要封的消息，尚不知真假。不过，技术本身更加吸引我。倘若web端被封杀，肯定会涌现出新的解决方案，对技术本身而言，也不算一件坏事情。  作者: 郭英旭 "
    }, {
    "id": 390,
    "url": "https://wechaty.js.org/2017/11/25/analysis-and-enhancement-wechaty/",
    "title": "解析WebWxApp代码来增强wechaty功能（一）",
    "body": "2017/11/25 -  一个菜鸟如何通过解析webWxApp与wechaty代码，来给wechaty增加新特性的回顾。 简述: 我对wechaty一开始是因为兴趣，而并非是项目需要，因此只是观望。直到看到美女lijiarui提出的issue#710 Cannot send pdf file using MediaMessage，被赏金诱惑才尝试着手来解决这个问题(:joy:)，并陆续提交了一些pr来增强wechaty的功能(论激励的重要性:joy:)。  Pull requests list:#714 send any type file#727 Add Message. forward() forward message#744 emit RECALLED type msg(fix #8)#771 Support for send 25Mb+ files 在这个过程过，为了实现这些功能，不得不尝试去阅读WebWxApp及wechaty的源码，来了解他们的功能结构，以及学习typesrcipt。本文通过记录解决这几个问题的过程，来对WebWxApp和Wechaty的进行一些解读。 我接触wechaty时是在V0. 8. x版本，此文提及的pr代码及对wechaty结构的理解适用于V0. 8. x版本，最新的0. 10. x版本的puttet-web进行了重构，一些地方会有不同，因此仅做参考。 作为一个菜鸟，对一些知识的理解认识不足或错误的地方，希望大佬们指正。 计划内容:  wechaty结构的简单分析 捕捉撤消信息事件 实现转发信息功能（在下篇文章中写） 完善发送文件功能（在下篇文章中写）WebWxApp与wechaty的大概框架结构: WebWxApp: WebWxApp是基于angular开发，使用webpack打包的前端项目，可在Chatie的webwx-app-tracker项目查看其格式化过的代码。 WebWxApp内定义了一些功能模块，下面列举一些涉及主要功能的: angular. module( Controllers ). controller( loginController , . . . )angular. module( Controllers ). controller( contentChatController , . . . )angular. module( Controllers ). controller( contentContactController , . . . )angular. module( Controllers ). controller( chatSenderController , . . . )angular. module( Controllers ). controller( emojiController , . . . )angular. module( Controllers ). controller( createChatroomController , . . . )angular. module( Controllers ). controller( transpondDialogController , . . . )angular. module( Services ). factory( appFactory , . . . )angular. module( Services ). factory( chatFactory , . . . )angular. module( Services ). factory( chatroomFactory , . . . )angular. module( Services ). factory( accountFactory , . . . )angular. module( Services ). factory( confFactory , . . . )angular. module( Services ). factory( contactFactory , . . . )angular. module( Services ). factory( loginFactory , . . . )angular. module( Services ). factory( utilFactory , . . . )angular. module( Services ). factory( emojiFactory , . . . )angular. module( Services ). factory( mmHttp , . . . )我对angular并没有什么研究，有兴趣的朋友可以自行阅读相关源码。 在wechaty中，我们要实现、完善一些功能，需要参考webwxapp中相关代码的逻辑结构和流程。 需要说明的是，webwxapp中并没有对所有事件、信息进行同样的处理，某些特性是wechaty默认捕捉不到的。比如撤回信息的 RECALLED类型信息，因此我们就必须要阅读webwxapp的源码，梳理其代码流程，来找到切入点解决问题。 wechaty: wechaty设计进行分层、抽象化封装。  如将联系人Contact、信息Message、群Room、好友请求friend-request 按功能进行封装，提取主要数据并通过方法及obj属性对外暴露，以供访问使用。（可查看Contact、Message、Room这三个类中定义的rawObj及obj属性。前者为原始数据结构，后者为封装提取后的数据） 另外实现了Puppet类接口，作为实现操纵微信的通道。目前仅有puppet-web，基于webWxApp操作微信的实现。而未来，我们会尝试实现基于微信PC版的puppet，甚至是ipad版的puppet，那样会比Web版微信能做的更多。puppet功能: 这里以puppet-web来简单说明一下，puppet的功能。 简单来说，puppet-web通过浏览器驱动(selenium-webdriver、puppeteer)创建一个浏览器环境（下称web环境）来加载WebWxApp(wx. qq. com)，并通过浏览器驱动将代码注入进web环境。注入web环境的代码（以下称wechatyBro）会通过websocket来连接wechaty创建的websocket服务端，这样就可以在WebWxApp与wechaty之间进行通讯了。由于websocket协议是异步请求，因此对webWxApp的操作仍需要使用浏览器驱动将代码注入web环境执行的方式，来确保对webWxApp操作的同步性。 关于浏览器驱动： puppet-web先后使用过selenium-webdriver和puppeteer，最新版本中使用的是puppeteer。 puppet-web的模块化puppet-web中对将功能拆分为不同模块：  puppet-web puppet-web的主体部分，初始化并调度其他模块的操作，实现上传文件功能。 bridge 封装需要注入web环境的代码，为puppet-web提供各项功能操作的方法。如send()方法 browser 封装对浏览器驱动的操作。如bridge需要通过browser封装的execute方法将js代码注入到web环境执行。 firer 封装一些信息解析、事件检查工作。 friend-request 封装好友请求操作。 server 封装了websocket服务端操作，并继承EventEmitter，将websocket接收到的信息以event方式广播。 event 封装了对server事件的监听处理。 watchdog wechatyBro 注入web环境运行的代码，实现对webWxApp的各种操作。wechatyBro中监听webWxApp中的信息事件，然后通过websocket把事件信息发送给puppet-web。而wechaty通过puppet-web操纵webWxApp。由于websocket不能同步返回处理结果，因此需要通过浏览器驱动将js代码注入进web环境执行（调用wechatyBro中的方法来操作webWxApp），并返回Promise将操作同步化。(可见/src/puppet-web/bridge. ts中proxyWechaty()) 例如：wechaty中发送一条信息，会按以下顺序执行： //伪代码，标记调用过程Message. say() -&gt; puppetInstance. send() // 调用puppet的send()方法PuppetWeb. send() -&gt; bridge. send() -&gt; bridge. proxyWechaty()// proxyWechaty() 中会封装代码，调用wechatyBro中对应的方法，以操作webWxApp// 可见`/src/puppet-web/bridge. ts`中`proxyWechaty()`bridge. proxyWechaty() -&gt; bridge. execute() -&gt; browser. execute()-&gt; driver. executeScript. apply(this. driver, arguments)// 最终调用浏览器驱动的`executeScript`或`executeAsyncScript`方法// 将js代码注入web环境执行，并Promise以返回执行结果puppet-web功能简述 puppet-web创建一个websocket服务端用来接收wechatyBro的通信 puppet-web通过浏览器驱动将wechatyBro的js代码注入进入web环境执行。 WechatyBro进行初始化工作：连接puppet-web的websocket服务端，监听webWxApp的事件并进行处理后通过websocket发送给puppet-web。 wechaty通过puppet-web执行各项功能时（如发送信息、创建群、拉人、踢人等主动操作），puppet-web会通过浏览器驱动将代码注入进web环境执行，以Promise返回执行结果以上对wechaty进行一个大概的了解，下边来以几个pr的实现来进一步了解wechaty。 puttet-web操作webWxApp的关键点WebWxApp内部实现了一些功能模块，来封装不同的功能代码。在wechaty-bro的glueToAngular()方法中，通过使用angular. element(document). injector(). get(name)来获取不同的功能模块并保存在WechatyBro. glue中，使在WechatyBro中可以调用WebWxApp的功能代码，来实现不同的功能。 WechatyBro初始化时会调用hookEvents()来监听WebWxapp的事件，如页面初始化root:pageInit:success、新信息message:add:success，并通过websocket将信息发送到puppet-web。 而wechatyBro中封装了一些操作，需要puppet-web通过浏览器驱动将代码注入web环境来调用，并返回其运行结果，浏览器驱动会将运行结果以Promise返回隔天puppet-web。 webwxApp中的工厂factory有很多，WechatyBro获取了一些需要用到的保存在内部，以便调用： //此部分代码从 WechatyBro 中摘出var injector = angular. element(document). injector()var accountFactory = injector. get('accountFactory')var appFactory   = injector. get('appFactory')var chatroomFactory = injector. get('chatroomFactory')var chatFactory   = injector. get('chatFactory')var contactFactory = injector. get('contactFactory')var confFactory   = injector. get('confFactory')var emojiFactory  = injector. get('emojiFactory')var loginFactory  = injector. get('loginFactory')var utilFactory   = injector. get('utilFactory')var http      = injector. get('$http')var state      = injector. get('$state')var mmHttp     = injector. get('mmHttp')// 保存到WechatyBro. glueWechatyBro. glue = { injector:    injector , http:     http , mmHttp:    mmHttp , state:    state , accountFactory: accountFactory , chatroomFactory: chatroomFactory , chatFactory:   chatFactory , confFactory:   confFactory , contactFactory: contactFactory , emojiFactory:  emojiFactory , loginFactory:  loginFactory , utilFactory:   utilFactory , rootScope:  rootScope , appScope:   appScope , loginScope:  loginScope , contentChatScope: contentChatScope}捕捉撤消信息事件: 以前wechaty是捕捉不到撤回消息的RECALLED事件的（最早见issues#8），原因在于webWxApp的messageProcess中，对RECALLED事件的处理与其他类型的信息事件不一致。 我们看下webWxApp中处理消息的messageProcess()方法代码： messageProcess: function(e) { var t = this,  a = contactFactory. getContact(e. FromUserName,   , !0); if (!a || a. isMuted() || a. isSelf() || a. isShieldUser() || a. isBrandContact() || titleRemind. increaseUnreadMsgNum(), e. MMPeerUserName = t. _getMessagePeerUserName(e), e. MsgType == confFactory. MSGTYPE_STATUSNOTIFY) return void t. _statusNotifyProcessor(e); if (e. MsgType != confFactory. MSGTYPE_SYSNOTICE &amp;&amp; !(utilFactory. isShieldUser(e. FromUserName) || utilFactory. isShieldUser(e. ToUserName) || e. MsgType == confFactory. MSGTYPE_VERIFYMSG &amp;&amp; e. RecommendInfo &amp;&amp; e. RecommendInfo. UserName == accountFactory. getUserInfo(). UserName)) {  switch (t. _commonMsgProcess(e), e. MsgType) {   case confFactory. MSGTYPE_APP:    try {     e. MMIsAppMsg = !0, t. _appMsgProcess(e)    } catch (e) {}    break;   case confFactory. MSGTYPE_EMOTICON:    t. _emojiMsgProcess(e);    break;   case confFactory. MSGTYPE_IMAGE:    t. _imageMsgProcess(e);    break;   case confFactory. MSGTYPE_VOICE:    t. _voiceMsgProcess(e);    break;   case confFactory. MSGTYPE_VIDEO:    t. _videoMsgProcess(e);    break;   case confFactory. MSGTYPE_MICROVIDEO:    t. _mircovideoMsgProcess(e);    break;   case confFactory. MSGTYPE_TEXT:     newsapp  == e. FromUserName ? t. _newsMsgProcess(e) : e. AppMsgType == confFactory. APPMSGTYPE_RED_ENVELOPES ? (e. MsgType = confFactory. MSGTYPE_APP, t. _appMsgProcess(e)) : e. SubMsgType == confFactory. MSGTYPE_LOCATION ? t. _locationMsgProcess(e) : t. _textMsgProcess(e);    break;   case confFactory. MSGTYPE_RECALLED:    return void t. _recalledMsgProcess(e); //注意这里是return   case confFactory. MSGTYPE_LOCATION:    t. _locationMsgProcess(e);    break;   case confFactory. MSGTYPE_VOIPMSG:   case confFactory. MSGTYPE_VOIPNOTIFY:   case confFactory. MSGTYPE_VOIPINVITE:    t. _voipMsgProcess(e);    break;   case confFactory. MSGTYPE_POSSIBLEFRIEND_MSG:    t. _recommendMsgProcess(e);    break;   case confFactory. MSGTYPE_VERIFYMSG:    t. _verifyMsgProcess(e);    break;   case confFactory. MSGTYPE_SHARECARD:    t. _shareCardProcess(e);    break;   case confFactory. MSGTYPE_SYS:    t. _systemMsgProcess(e);    break;   default:    e. MMDigest = _( 938b111 )  }  e. MMActualContent = utilFactory. hrefEncode(e. MMActualContent);  var n = contactFactory. getContact(e. MMPeerUserName);  e. MMIsSend || n &amp;&amp; (n. isMuted() || n. isBrandContact()) || e. MsgType == confFactory. MSGTYPE_SYS ||   (accountFactory. isNotifyOpen() &amp;&amp; t. _notify(e), accountFactory. isSoundOpen() &amp;&amp; utilFactory. initMsgNoticePlayer(confFactory. RES_SOUND_RECEIVE_MSG)),   t. addChatMessage(e),   t. addChatList([e]) }},注意代码中处理confFactory. MSGTYPE_RECALLED类型信息的方式，是使用了return的，不会再执行下边的t. addChatMessage(e)。 我们看下webWxApp中 addChatMessage()的代码： addChatMessage: function(e) { if (e) {  var t = this,   a = (e. FromUserName,    e. ToUserName,    _chatMessages[e. MMPeerUserName] || (_chatMessages[e. MMPeerUserName] = []));  _addedMsgIdsMap[e. MsgId] ||   (_addedMsgIdsMap[e. MsgId] = !0,    _msgMap[e. MsgId] = e,    a. push(e),    $rootScope. $broadcast( message:add:success , e),    t. getChatList()) }},wechatyBro中监听webWxApp事件的代码如下： rootScope. $on('message:add:success', function(event, data) { if (!isLogin()) { // in case of we missed the pageInit event  login('by event[message:add:success]') } WechatyBro. emit('message', data)})addChatMessage()中使用$rootScope. $broadcast( message:add:success , e)来广播信息事件，而wechatyBro通过rootScope. $on('message:add:success', function(event, data) {})监听信息事件，从而获得webWxApp的信息（包含系统信息事件）。 而由于messageProcess()中对confFactory. MSGTYPE_RECALLED类型的信息使用了return，因此wechatyBro捕捉不到RECALLED事件的信息，wechaty自然也就无法得知某条消息被撤消了。 解决方案: 既然messageProcess()中对RECALLED类型信息使用了return，但先调用了t. _recalledMsgProcess(e)，那么我们可以使用在wechatyBro中hook t. _recalledMsgProcess() 的方式来获得RECALLED类型的事件信息。 通过分析webWxApp代码，得知_recalledMsgProcess()是chatFactory中的方法（善用搜索）。那么我们在wechatyBro中，就要hookchatFactory. _recalledMsgProcess()方法了。 在wechatyBro中，使用WechatyBro. glue. chatFactory来获得webWxApp的chatFactory。 我们添加以下代码： function hookRecalledMsgProcess() { var chatFactory = WechatyBro. glue. chatFactory // 保存webWxApp自身的处理代码副本 chatFactory. __recalledMsgProcess = chatFactory. _recalledMsgProcess // 定义一个新的处理方法替换原始处理代码 chatFactory. _recalledMsgProcess = function(msg) {  chatFactory. __recalledMsgProcess(msg) //调用原始处理代码  //. . . 下边就可以写我们的处理代码了 }}// init()方法中需要添加调用 hookRecalledMsgProcess()function init(){ // . . .   hookEvents()  hookRecalledMsgProcess() //添加到hookEvents()后边 // . . . }webwxApp中_recalledMsgProcess()会对撤回信息进行解析处理，我们需要分析其代码，获取被撤回的信息内容，并通过websocket发给puppet-web。 _recalledMsgProcess: function(e) { var t, a, n = this,  // 解码  i = utilFactory. htmlDecode(e. MMActualContent),  o =   ,  r = _( ded861c ),  //获取指定用户的聊天信息数组  c = n. getChatMessage(e. MMPeerUserName);  //对emoji进行转码 if (i = utilFactory. encodeEmoji(i), //解析（可在chrome中使用调试查看微信下发的信息内容格式）  o = utilFactory. xml2json(i). revokemsg,  //如果信息内没有标明msgid  0 == o. msgid) {  for (var s = c. length - 1; s &gt;= 0; --s)   if (c[s]. FromUserName == accountFactory. getUserName()) {    t = s;    break   } } else {  // 从用户聊天信息数组中获取指定的信息id  t = n. _findMessageByMsgId(c, o. msgid); } if (t &gt; -1) {  var l = c[t];  if (l. MMIsSend) a = _( df1fd91 );  else {   var d = contactFactory. getContact(e. MMActualSender, e. MMPeerUserName);   a = d ? d. getDisplayName(e. MMPeerUserName) :     }  //显示撤回信息提醒  angular. extend(l, {   MMRecall: !0,   MsgType: confFactory. MSGTYPE_SYS,   MMActualContent: a + r,   MMDigest: a + r,   _h: 0  }), n. getChatList() }},因此我们来用以下代码进行实现： function hookRecalledMsgProcess() { var chatFactory = WechatyBro. glue. chatFactory var utilFactory = WechatyBro. glue. utilFactory var confFactory = WechatyBro. glue. confFactory // hook chatFactory. _recalledMsgProcess, resolve emit RECALLED type msg chatFactory. __recalledMsgProcess = chatFactory. _recalledMsgProcess chatFactory. _recalledMsgProcess = function(msg) {  chatFactory. __recalledMsgProcess(msg)  //复制一个msg副本  var m = Object. assign({},msg)  //解码信息内容  var content = utilFactory. htmlDecode(m. MMActualContent)  content = utilFactory. encodeEmoji(content)  //获取撤回信息  var revokemsg = utilFactory. xml2json(content). revokemsg  if (revokemsg. msgid) {   //获取指定用户的聊天信息数组   var chatMsgs = chatFactory. getChatMessage(m. MMPeerUserName)   // 获取被撤回信息在聊天信息数组中的序号   var i = chatFactory. _findMessageByMsgId(chatMsgs, revokemsg. msgid)   if (i &gt; -1) {    //获取被撤回的原始信息    m = chatMsgs[i]    //标记信息类型为撤回信息    m. MsgType = confFactory. MSGTYPE_RECALLED   } else {    //如果没有找到被撤回的原始信息，则将本次信息id修改为被撤回的原始信息id    m. MsgId = revokemsg. msgid    // 修改信息内容    m. MMActualContent = m. Content = revokemsg. replacemsg. replace(/ /g,  )   }   //调用emit()将信息通过websocket发送给puppet-web   WechatyBro. emit('message', m)  } }}// 由于webWxApp的_recalledMsgProcess() 中使用到了 utilFactory，而wechatyBro并没有获取 utilFactory ，因此我们需要加上function glueToAngular() { //. . .  var loginFactory  = injector. get('loginFactory') var utilFactory   = injector. get('utilFactory') //. . .  WechatyBro. glue = {  //. . .   , loginFactory:  loginFactory  , utilFactory:   utilFactory  //. . .  } //. . . }完整patch代码见PR commit#174b6775c End: 感谢zixia的邀请，很抱歉拖了这么久才写了这篇文章。感谢Chatie的各位贡献者，有大家的共同努力，wechaty才会愈发的好用。也感谢耐心看完文章的你，希望我的文章没有浪费你的时间。谢谢！ "
    }, {
    "id": 391,
    "url": "https://wechaty.js.org/2017/11/08/red-pocket-wechaty-iyjian/",
    "title": "我用wechaty做了一个积分红包机器人",
    "body": "2017/11/08 - 我是个半路出家的程序员，有一个爱玩信用卡的老婆，老婆总逼着我我参加银行的积分活动，为了节省时间，我用wechaty做了一个积分红包机器人。 以下是流水账格式，先介绍了我有一个什么需求，然后介绍了我怎么找到wechaty的，最后说了一些我用wechaty的心得和遇到的坑。 我用wechaty很巧合。某银行信用卡有个活动，消费会得到一个红包，红包打开有积分，但是分享给朋友后，朋友也可以得到积分。当然也意味着你可以从朋友那里领取他红包里的积分，每天可以从不同的15个朋友那里各领一个红包！ 这个活动虽小，可玩的人特别多。虽然银行的本意是希望大家用这种分享红包的方式让更多没有卡的人眼馋这个积分，然后对这个信用卡产生兴趣而来办卡，但是信用卡迷们互相之间交换一下红包也没什么问题啊。奈何大家身边不可能恰巧有这么多有这个信用卡的朋友可以互相交换红包，这些善于折腾的人就发明了微信群，16个人一个群，大家互相在里面发红包交换。产品做出来后我通过腾讯分析搜集到一些用户信息，我不知道腾讯怎么知道这些人的学历的，但这数据要是真的，那你别说这群人挺无聊，可他们学历还挺高，本科的不少呢。 我老婆呢也是个信用卡迷，没事总喜欢折腾折腾信用卡，她也正好在一个微信群里和微信好友们这样每天不厌其烦的交换着红包，而她也要求我着这样做。可我是个懒人，倒腾这点积分浪费我那么多时间我实在是有点心疼！所以三天两头就会忘记这件事情，弄的群里的人对我都有意见，后来有次和朋友吃饭我就抱怨起这个事情，一个朋友和我推荐说有个微信红包机器人可以简化这件事情，只要把红包发送给机器人，机器人会自动返还给你其他人的红包，我立刻关注去看了下，还真的如他所说，是一个微信个人号在提供这个功能，非常神奇。我脑子转了转，觉得这个功能并不算太复杂，其实就是个库存系统，然后通过一定的算法来合理的分配，虽然要解决些信用的问题（因为可以作弊）需要费点时间，但是如何实现微信个人号的自动化是个关键问题，我准备着手研究一下。 我自诩是一个数据工程师，但是算算也有5年多没有怎么碰过数据了，我的前同事们很多都在各大公司的大数据部门干活，奈何我折腾不出名堂，才开始对自己并不擅长，怎么学也学不好的编程产生了极大的兴趣，用了五年时间也算入了门，至少可以写出能运行的代码。 说干就干，我首先去github上搜索了微信，wechat等关键字，发现微信个人号的自动化很早就有人做了，从框架的语言上有perl、python、 js、 C#等，从实现原理上最多的是直接用网页版的接口，也有用Android的客户端做钩子的，用iOS客户端做钩子的开源项目倒是没找到，估计都做黑产挣大钱去了吧。 虽然我是个二流的程序员，但是我什么语言都能用，在我眼里无非是if/then/else/for，反正我也没有什么面相对象的思想 ；）。于是我就挑选了一个我还算熟悉的用perl语言做的框架来试验，我写了第一个hello word应用 — 收到一条消息后拼接“你个头！”然后自动回复，于是朋友和我打招呼说“hey”，就会回复 “hey 你个头！”，问我“在吗”就会回复“在吗你个头！”。做完后，我部署到自己的个人号，把朋友们可逗乐好一阵子。至此我认为我已经具备了做一个红包机器人的能力。如果我决定花时间来做这件事情，我希望这件事情可以长久一点，我把我能找到的框架比较了一下后发现还是wechaty不错，文档清晰，commit很多，star也很多，而且是用比较新颖的typescript写的，说明作者紧跟时代。我看完文档还发现这个作者很用心，他用程序自动获取微信网页版的代码，自动比较代码的diff，如果有改动会弄个什么issue出来，我觉得这样很先进，毕竟这种框架还是很依赖微信，最担心的就是微信整出什么幺蛾子。有这种运营开源项目精神一定值得信赖。 我又找了一个朋友一起玩这个东西，他负责产品设计，我来负责写代码，这样我们都可以专注一点。我们从开始做这件事情到暂时停止使用个人号大概2个多月的时间，最多的时候三台手机同时使用wechaty（因为一个个人号最多5000人就满了），期间发生了太多太多的事情无法一一流水账的记录，但我准备把遇到的一些和wechaty有关以及微信个人号运营可能会碰到的问题写出来和大家分享一下，如有不对的地方，还请大家斧正（刚学的词）。 主动加人: 我们刚开始做完整套系统后，没有地方宣传，也没有用户，我们很苦恼，于是跑到信用卡论坛上去找一些人留的二维码来加他们（他们为了找互相分享红包的好友也会留自己的微信在论坛上），我们一个人一个人的推广，结果第一天加了20个人就加不上了，后来查了些资料才发现微信对主动加人有限制，并且对附近的人，摇一摇，扫码等都有各种频率限制，但你的好友基数比较大，或者微信号年龄较大可以拥有多一点的限额。果然，我们坚持了两天后每天可以加到五六十个人，原来这玩意得养啊，后来我们发现很多东西都得养。 被动加人: 后来我们做的有点口碑了，已有玩家里也有些有影响力的人开始帮我们宣传，第一次宣传就很厉害，第一天就给我们带来了300多个新用户，这些人加着加着，自动通过好友的功能就不好使了，但是我们可以在手机上点击好友通过，后来因为每天都会有很多人来加我们，所以我们准确的计算出这个功能会崩掉，也就是微信网页版的接口限制为24小时内100人，只要超过100个人，妥妥的不能自动通过好友，那就得傻傻的在手机上一个个点通过。两个月后有一天一个微信号上来了800多个人，这时我们发现点到500个人，手机上也不能点击通过了，而这个封锁的时间达到48小时。这个玩意是不能养的，我们后期没办法，人太多了，不能自动通过的就丢在那里，他愿意再加一遍就再加一遍，不愿意就只能拉倒。 改备注: 因为微信网页版里没有太好的办法拿到用户的唯一编号，wechaty上也是建议把用户通过Contact. alias()方法改个备注名来管理，我刚开始也就是简单的用个随机数生成个md5来作为用户的备注名，这样在通讯录列表里虽然看起来有点怪，但是是唯一的。这样做其实也有个坑，因为这个改名的接口也会崩掉，改太多了就会崩，自动通过好友后如果立刻进行改名会更容易崩，这个接口的频率我们一直到最后也没整明白，因为他总是比自动通过好友的接口要先挂掉，到底什么时候挂也不知道。但是如果自动改名坏掉了，照样可以按照改备注后的名字继续提供服务，因为wechaty内部存储了用户的临时的唯一编号，改名的时候其实是现在wechaty内部的Contact对象里修改，然后同步到网页版上,wechaty和网页版通讯的时候还是通过这个临时唯一编号通讯的，所以只要wechaty不重启，即使改名失败了，仍然不会出问题。但是一旦重启就全乱了。一旦出现这个问题后，我们就不敢重启了，我们就开始在手机上一个个改名（还是那个问题，网页版接口频率限制了客户端还是可以），一定要改成当初分配给他的那个md5串，这个串在数据库有一份记录。这个是很痛苦的，我们用苹果的电脑和手机之间的云粘贴功能从数据库表里复制到手机上才能快一点，但是每天也要改上一个多小时，眼睛都要看瞎了。 回消息: 回消息当然也是有频率限制的，如果你回复的过快，轻则禁言，重则和你的好友互相解除好友关系，我们那次一天来了800多个人的时候就是提示消息回复过快而自动删除了很多好友。但是这个频率也是可以提高的，我们最开始做的1号机器人高峰时每个小时有1万条消息也照样可以处理，我们一个用户一次给微信号发了50条消息，我分别回复了他50条也并没有提示禁言，这算是养出来了。而2号机器人也就是碰到那天来800多个人的时候就一下子顶不住垮掉了。 重启: wechaty在启动的时候会初始化Contact对象，如果联系人比较少，这个过程就很快，根本感觉不出来，如果超过3000个人就可能会出问题。首先这服务器得比较好，开始我就弄了个1核1G普通硬盘的的云服务器，到1000多人的时候Contact就初始化不动了，经常初始化失败，后来我意识到自己可能会有很多号，也会加很多人，就直接用了12核12G固态硬盘的服务器，这样子撑到一台服务器三个微信号，单个号3000人没有出现过问题，但是到了3000多人如果在处理消息高峰时期，也就是一个小时有一万条消息的时候重启，那也是歇菜了，别指望可以初始化成功，我们碰到过好多次，在忙乱之中去翻了一下wechaty的源码，也是没有调试出原因。关于重启有一些小经验，首先我们有数据统计，知道什么时候不是高峰，那么找非高峰时期来重启。大家看下我们某个微信号的非高峰时间，这真的很痛苦，一般都是重启完才能睡着的。 其次，你可以在服务器上对每个微信号启动两份docker，比如bot1, bot1Shadow，对应同一个微信号，这样如果bot1正在运行，需要它重启的时候就去启动bot1Shadow然后扫码把bot1踢下来，这样可以减少宕机时间。另外wechaty的Contact有个findAll方法，可以自己加一个消息指令，比如checkContacts，然后重启好以后发送一下，看看Contacts是不是加载完了，你有这个指令以后就会发现Contacts初始化还是需要一点点时间的，这期间如果根据alias查找联系人是会报错的，可以单独和用户沟通一下：），每次在手机上和用户沟通用户都会很惊讶怎么机器人会说话。 和公众号的互动: 我们使用个人号最根本的原因是公众号无法方便的接收图文消息，因为银行的那个活动分享出来的红包是图文消息，用公众号也可以实施但是体验就很差了。但是个人号运营很痛苦，有被腾讯封杀网页版接口的风险，被封杀了会提示你新注册的账号无法使用网页版，这当然是个说辞，来了这个提示你就无法使用wechaty来自动化你的微信了。但是如果你有耐心过段时间时间（大概是一个月）腾讯会解封这个限制，但还是有被封的可能。有这些痛苦就有了和公众号的互动的想法，我现在还没有开始实施，但是已经有了方案，大致思路是用公众号作为保留客户的基地，然后通过一些方法通知到用户让他们去加个人微信号，这样可以操作的手段就多了，可以做到足够分散和均匀，比如你可以给他发指定的邀请码和个人号二维码，让他在加好友的时候备注这个邀请码，然后个人号收到这个邀请码后再通过，至于如何绑定个人号和公众号，可以通过在个人号的欢迎语里加一个绑定链接，绑定链接带上个人号的临时唯一编号，然后通过公众号的隐式授权获得公众号的openid(我不知道微信公众号这些接口的字段命名为什么这么恶心，为什么不用驼峰式，搞的我代码里一会驼峰一会小写！)，然后服务器再去通知wechaty把个人号的备注改成这个openid或者是用户的某个编号。 一些杂七杂八的事情: 微信桌面客户端（我用的是mac)和微信网页版对视频poster的提取是不一样的，我的合伙人是个做产品的，他做完视频以后会让poster上显示一个他觉得满意的画面，每次都是mac客户端发给我，看起来都是赞赞的，可是我放到wechaty里发出去以后并不是显示的那一帧poster，找了很久原因才想到两个版本的poster提取方法不一样。docker容器中默认的时间不是东八区，一定要重新搞一下，我吃了很多亏，数据库和服务器上报的时间不一致，但是我刚写这个东西的时候发现已经支持时区更改了：Add timezone in to Dockerfile。我开始写代码的时候把业务逻辑和wechaty对微信自动化的逻辑都写到一个项目了，这样维护的时候很痛苦，改动一个业务逻辑就必须重启一次wechaty，会有服务中断，后来把业务逻辑包装成http请求，wechaty里只做简单的收发消息，踢人，拉人，自动好友等操作，把消息发给业务逻辑，然后再得到指令后操作，这样可以维护的方便一点。群邀请也是需要养的，新建的一个群别指望发群邀请把人拉进来，最开始无法拉人，需要给用户回复一张群二维码让他扫码进群，等人多一点，但是不要等到100个人，因为100个人以后就只能通过邀请才能加人了。 先写这么多吧，最后说一下，我的个人号已经于9月份全军覆没了，正好是我过生日的那天，还是在三亚度假的时候，我整个人都有点懵了，但仔细想想一点都不可惜，有了这些经验东山再起不是什么问题，我和那个产品经理已经重新开始弄公众号了，圈子里有了品牌，用户做起来是分分钟的事情，待把公众号做稳一点了，还是会继续实施上面的公众号和个人号互动的想法，应该没那么容易被封了，不会傻乎乎的一个号上整那么多人，给自己找那么多麻烦了。以上这么多废话是答应lijiarui小姐9月份写的，可是又要忙工作，又要忙这个娱乐项目，每天都是凌晨2，3点睡觉，6，7点起床，直到现在也如此，实在没有什么完整的时间，对于这种严重的拖延我深表歉意。 最后，谢谢你用这么多时间看了我写的字。 "
    }, {
    "id": 392,
    "url": "https://wechaty.js.org/2017/10/28/ten-minutes-to-build-a-daily-paper-bot/",
    "title": "Ten minutes to build a daily paper bot",
    "body": "2017/10/28 - I built a bot to deliver the daily paper about machine learning and fintech to the users. Considering the development of lowest cost, I chose wechaty. It’s so awesome that it only took me 10 mintues to make the bot work.  Before the bot work, I had really done a lot of work to crawl data and filter data, I won’t talk about the data here, just about the Wechaty! Screenshot: My development steps with wechaty:  Watch the tutorial video. It took me 4 mintues.  Copy the code in the video. It took me 30 seconds to create a file and paste the code in.  Use the docker. I used the docker to run the bot, which protected me from the troubles of dependency problems. It’s so easy that just took me 10 seconds to know how to start.  Run the docker. Actually, one line code is enough to run the docker. But downloading the image of wechaty wasted some time, which cost 4 minutes.  Code the bot. I had prepared the API of the daily paper, so what I need to do is just wrote some codes to get the data from the API, which cost 1 mintues. (Using axios and async function also saved a lot of time).  Test and Debug. It worked correctly, which cost 20 seconds. More: I also added some functions such as automatic reply to the bot, which made our users more active in the group. Some advices:  Just use the docker, which is so easy and can save a lot of time.  Read the documents to know how powerful wechaty is. Finally, I like wechaty, thanks to all the contributors of wechaty! "
    }, {
    "id": 393,
    "url": "https://wechaty.js.org/2017/10/06/wechat-pc-impactor/",
    "title": "关于对微信PC版Hook的一点研究分享",
    "body": "2017/10/06 -  因为易语言代码有的朋友们可能看起来怪怪的 如果没有接触过它，并不是那么通俗易懂。所以改成了cpp代码供审阅.  由于书写仓促 错误的部分希望大家指正，小弟在此多谢！ 感谢 易语言精易论坛坛友(xdssoft,恨不能遗忘,gh0st少主)分享的开源代码参考！  准备工作： PEid、Ollydbg、IDA pro、CheatEngine、DLL自动注入工具、微信电脑版2. 4. 1. 37/79关于对微信PC版Hook的一点研究分享: HOOK 注入类 hookinject. h:  这里的例子是用Version. dll 因为version. dll优于WeChatWin. dll先加载 version. dll是Windows NT系统以上版本检测应用程序接口相关文件。这里就用这个用途不是很必要的DLL模拟注入。 首先需要载入真正的 Version. dll ////// TODO:安装我们伪造的 Version. Dll///class hookInject {  public:  const DLL_PROCESS_DETACH = 0  //进程卸载 系统查看当前映射到进程空间中的所有DLL文件映像  const DLL_PROCESS_ATTACH = 1  //进程映射 系统查看当前映射到进程空间中的所有DLL文件映像  const DLL_THREAD_ATTACH = 2   //线程映射  const DLL_THREAD_DETACH = 3   //线程卸载  const DLL_PROCESS_VERIFIER = 4 //进程更改 系统查看当前映射到进程空间中的所有DLL文件映像  const WM_COPYDATA =0x4A     //  int lib = 0;  int GetFileVersionInfoA;  int GetFileVersionInfoByHandle;  int GetFileVersionInfoExW;  int GetFileVersionInfoSizeA;  int GetFileVersionInfoSizeExW;  int GetFileVersionInfoSizeW;  int GetFileVersionInfoW;  int VerFindFileA;  int VerFindFileW;  int VerInstallFileA;  int VerInstallFileW;  int VerLanguageNameA;  int VerLanguageNameW;  int VerQueryValueA;  int VerQueryValueW;  BOOL inst_VersionLib(){  lib = LoadLibraryA ( C:\windows\system32\Version. dll );  if(lib == 0){    //载入不成功则返回0 则返回注入失败！    return FALSE;  }    GetFileVersionInfoA = GetProcAddress(lib, GeFileVersionInfoA );    if(GetFileVersionInfoA = 0){      ::FreeLibrary(lib)      return FALSE;    }    //*    其他的函数也一样需要写. . 检测真正Version动态库    调用时 每个函数所在内存的地址.  否则可能会造成 crash !!    FARPROC GetProcAddress(      HMODULE hModule, // DLL模块句柄      LPCSTR lpProcName // 函数名    );    *//    VerQueryValueW = GetProcAddress (lib, VerQueryValueW );    if(VerQueryValueW = 0){      ::FreeLibrary (lib)      return FALSE;    }    return TRUE;   //如果所有  }  // 接下来呢是伪造所有的函数调用  int GetFileVersionInfoA(int i,int j,int k,int q){    return Jmp(GetFileVersionInfoA,i,j,k,q);  }  /// . . . 其他 同理  int Jmp(int addr ,int i = NULL,int j = NULL, int k = NULL,int q = NULL,int w = NULL,int e = NULL,int r = NULL,int t = NULL,int y = NULL,int u = NULL,int o = NULL,int a = NULL,int s = NULL,int d = NULL){    return _Jmp(addr,i,j,k,q,w,e,r,t,y,u,i,o,a,s,d);  }  int _Jmp(*p ,int i,int j, int k,int q,int w,int e,int r,int t,int y,int u,int o,int a,int s,int d){    __asm{      LEAVE;       //清空堆栈      POP EAX;      //把EAX重新压入栈      XCHG [ESP],EAX;   //数据交换      JMP EAX;      //再跳到eax寄存器    }    return 0;  }}应用注入类     Impactor. h: class Impactor{  public:  static int baseAddr = 0; //初始化 0 就是木有！  void GetBaseAddress(){    HANDLE hSnapShot;    int last;    string m_Module;    stringstream ss;    MODULEENTRY32 buffer; //struct    while(baseAddr = 0){      hSnapShot = ::CreateToolhelp32Snapshot(8,GetCurrentProcessId());       //创建系统快照      buffer. dwSize = 0x224; // 初始化buffer大小 548      //buffer. dwSize = sizeof(buffer); 检测大小      last = ::Module32First(hSnapShot,&amp;buffer);      while(last !=0){        // m_last = boost::lexical_cast&lt;string&gt;(buffer. szModule) //ANSI -&gt; string        ss&lt;&lt;buffer. szModule;        ss&gt;&gt;m_Module;        if(m_Module == WeChatWin. dll ){          baseAddr = buffer. modBaseAddr          break;        }        last = ::Module32Next(hSnapShot,buffer);      }      CloseHandle(hSnapShot);      sleep(50);    }  }  ///  /// 获取收发类型和内容 相当于 WxSync  ///  ///param 之所以用整形 因为 他们都是指针形式~  ///  ///  void GetSyncType (int msg,int wxid,int type){    /*    string str;    int len=str. size();    const char *pstr = str. c_str();    for (int i=0;i&lt;len;i++){      (short)*pstr++;    }    */    //const unsigned char *buf;    /* 这里有错误~~~看原版吧    取出传址内存指针 3000字节 长度的的字符数组(串)    传递给全局变量 SyncType    */  }}自己信息获取    GetProfile. h: class GetProfile{  CALLBACK wxAlias;  CALLBACK wxNickName;  CALLBACK wxId;  void GetProfile(){    //callback方式 取 下列    //看易语言版本的代码吧    //三个指针地址分别为    //0x169fc9    //0x2db500    //0x2db695    /*    ;//取微信号和昵称的 CALL    PUSHAD    CALL 00000006    POPAD    ;//取WXID的CALL    PUSHAD    PUSH DWORD PTR [ESP+20]    CALL 0000000A    POPAD    */  }  void GetNickName(){    __asm{      MOV [EBP-4],ECX    }    //取 100字节大小数据地址 就是微信号 需要转换 Unicode  }  void GetWxAlias(){    __asm{      MOV [EBP-4],EAX;    }    //取 100字节大小数据地址 就是微信号    //手机号 也可以同时取出. 预留30个字节的内存空间    ReadProcessMemory(-1,baseAddr+0xE2EE20,手机号,30,0);  }  void GetWxId(int wxid){    //根据WXID指针传递取 100字节大小数据地址 就是wxid  }}好友读取 (列表)类  GetContact. h: class GetContact{  void GetContactList(){    //方法和上面类似    //0x30c820  WXID    //0x30c839  微信号    //0x30c8a2  备注    //0x30c8b8  昵称    /*    ;CALL    PUSHAD    CALL 00000006    POPAD    */  }  //获取微信号  void GetAlias(){    /*    MOV [EBP-4],EAX    */  }  //获取头像  void GetAvatar(){    /*    MOV [EBP-4],EAX    */  }  //获取昵称  void GetNickName(){    /*    MOV [EBP-4],EAX    */  }  //获取备注  void GetRemarkName(){    /*    MOV [EBP-4],EAX    */  }  //获取WXID  void GetWxid(){    /*    MOV [EBP-4],EAX    */    //需要1000字节地址大小    //遍历  }}注入执行类 WechatWatchDog. cpp: #include  stdafx. h  #include &lt;cstdio&gt;#include &lt;iostream&gt; #include &lt;string&gt;#include &lt;vector&gt; #include &lt;Windows. h&gt;#include  impactor. h #include  hookinject. h #include  GetProfile. h #include  GetContact. h using namespace std;int _tmain(int argc, _TCHAR* argv[]){  hookInject::inst_VersionLib();}void hook_install(){  CALLBACK Hook_Get_Type_CallBack;  CALLBACK Sync_CallBack;     //User Msg  CALLBACK Collect_CallBack;   //Image  Impactor::GetBaseAddress();  GetProfile::GetProfile();  GetContact::GetContactList();  //根据基址增加偏移0x237A78  //(微信基址+偏移,修改内存数据的方式,执行方法指针,偏移)  Hook_Get_Type_CallBack. Install(baseAddr + 0x237A78 ,&amp;_asmGetTypeCall,&amp;Impactor::GetSyncType, *GetSyncType,0x11);  /*  PUSHAD  PUSH EAX  PUSH DWORD PTR [ESP+548]  PUSH DWORD PTR [ESP+4AC]  CALL 00000015  POPAD  */  //根据基址增加偏移0x1412D7  Sync_CallBack. Install(baseAddr + 0x1412D7,&amp;_asmGetSyncCall, *GetSync,0x7);  /*  PUSHAD  PUSH EAX  MOV EAX,[EDI+4C]  PUSH EAX  CALL 0000000B  POPAD  */  void _asmGetTypeCall(){    __asm{      PUSHAD      PUSH EAX      PUSH DWORD PTR [ESP+548]      PUSH DWORD PTR [ESP+4AC]      CALL 00000015      POPAD    }  }  void _asmGetSyncCall(){    __asm{      PUSHAD      PUSH EAX      MOV EAX,[EDI+4C]      PUSH EAX      CALL 0000000B      POPAD    }  }  void SendCollectImg(*SendCollectImg){    //监听收藏的图片发送    //也可以把机器图片放入内存再根据地址发送~    //释放CALL  }  void SendUserAndMsg(int Msg,int User){    //相当于 SYNC 消息监听！    /*死循环判断 10000字节地址是否有内容，转换Ansi    判断内容报头 是否为 列表数组成员 ，如果带有 @chatroom就是 群组    输出打印  或者通过socket方式传递给外部程序~~    */  }}DLLMain. cpp: 略后记: 里面有一套源码的DLL动态自动注入 非常不错~ 附件：微信PC Hook易语言源码 （共3套）附带 etcp. dll 源码 VS2013 编译通过 CALLBACK 类 因为在原代码中没有公开，是调用其他人开发的 ecom (相当于可集成的 Com组件/Lib)所以这里我也不太清楚这个如何实现. . 因本人能力有限，欢迎大家共同研究参与补充 ~谢谢！下载：Download Src 完整下载地址：附带微信2. 4. 5. 73安装包 没有微信2. 4. 1. 79 链接：download full package  密码：wttk 感谢@huan 的邀请。  h4dex 2017年10月6日 "
    }, {
    "id": 394,
    "url": "https://wechaty.js.org/2017/10/04/wechaty-new-release-version-0.9.0/",
    "title": "Wechaty New Version 0.9.0 Released",
    "body": "2017/10/04 -  The Wechaty has been updated to version 0. 9. 0 today. This release contains a number of bug fixes, security updates and feature enhancements. If you find new issues, please let us know by visiting our Github issue page and filing a bug. Huan LICreator of Wechaty Change Log: v0. 9. 0 (2017-10-04): Full Changelog BREAKING CHANGES:  [Announcement] Drop support for phantomjs #763NEW FEATURES:  Support hot-reload for Wechaty events listeners #820 Add Transpond Message #726 [Feature request] @mention support? #153 Support Message Type of Image/Video #4 [new feature] add function message. mention() #216 [feature request] fire room-join when someone joins from a QR Code #155 #4 send image/video #337 (mukaiu) #3 support send gif #438 (mukaiu) add room. say(MediaMessage) #420 (mukaiu) add room-leave event #370 (lijiarui) Add mention #362 (lijiarui) added hot load bots #310 (Gcaufy)BUG FIXES:  [bug] Support for send 25Mb+ size files #766 Cannot send pdf file using MediaMessage #710 [enhancement] Add pdf, docx etc support to MediaMessage(now only picture is supported) #538 Send(upload) an image twice will cause error. #422 Cannot send image after restart #777 Room. alias() should return null if we have not set the alias in the room #283 Fix chrome driver path problem in Windows #416 (xjchengo) fix upload media url error #415 (mukaiu) Add missing %s content for leaver not found error #388 (xinbenlv) fix jsdoc flush issue #378 and minor fix on the doc examples #380 (ax4) fix_function_room. member_#173 #211 (lijiarui) [bug]Cannot read property ‘getUserName’ of undefined #772 Cannot send pdf file using MediaMessage #710 Click Web Wechat Switch Account Automatically to get qrcode immediately when bot logout #636 Concat. avatar() faild ,when hostname changed from https://wx. qq. com to https://wx2. qq. com #418 it seems RECALLED: 10002 message dose’t trigger on\(‘message’\) event #8ENHANCEMENTS:  [jsdoc] additional optimizations #774 chrome-headless support #739 Click Web Wechat Switch Account Automatically to get qrcode immediately when bot logout #636 use babel-node to run javascript(. js) file inside docker #507 [Docker] add a onbuild image to Wechaty #147 add room-bot-leave event #250 Limit video file size #421 (mukaiu) support brand checking of contact #404 (JasLin) Limit the size of the sending file #376 (mukaiu) room. memberAll() &amp; change room. member() query to 3 types #364 (lijiarui) Printout entire error trace when unhandledRejection was caught #361 (xinbenlv) load all memberList #275 (lijiarui) add-sys-message-in-friendrequest #266 (lijiarui) enhance #155 fire room-join when someone joins from a QR Code #162 (lijiarui)MISC:  Use Sentry. io to report exceptions #580 [todo] Change to use native Dom Websocket instead of socket. io library #502 License Change: from ISC to Apache-2. 0 #474 requesting a new QR code cost more than 2 minutes #434 [doc] To Embed Document in Wechaty Code for Generating Automaticly #73 Promote StateMonitor to a solo NPM module: StateSwitch #466 Lazy to create a stream #470 (mukaiu) add magic code for room. say() when @bot happen #440 (lijiarui) first item of memberList as owner is confusion #358 (JasLin) Add JsDoc for Class Contact #321 (lijiarui) Add print nodejs version #280 (xinbenlv) #291 change throw error to return null #292 (lijiarui) roomJoinFailed #249 (lijiarui) add warn log when function Room&amp;Contact. find() return more than one value #239 (lijiarui) rename the nick/remark/display for contact/room #217 #234 (lijiarui) friendrequest #199 (lijiarui) #181 fix #182 (lijiarui)CONTRIBUTORS: The following contributiveness since v0. 7. 0 had been contributed. Thank you all contributors, Wechaty could not release version 0. 9 without your help!  @lijiarui: #816,#812,#805,#798,#757,#729,#725,#651,#627,#619,#604,#515,#490,#440,#370,#364,#362,#328,#324,#323,#321,#318,#303,#292,#275,#266,#264,#249,#239,#234,#211,#199,#182,#162 @zixia: #841,#831,#810,#644,#643,#608,#569,#560,#542,#496,#495,#469,#462,#455,#449,#396,#351,#317,#316,#315,#314,#313,#312,#311 @mukaiu: #337,#470,#438,#421,#420,#415,#376 @binsee: #844,#811,#771,#744,#727,#714 @xinbenlv: #388,#361,#280 @hczhcz: #684,#640 @JasLin: #404,#358 @FlyingBlazer: #531 @zhenyong: #770 @lpmi-13: #681 @xjchengo: #416 @TingYinHelen: #605 @imerse: #578 @ax4: #380 @Gcaufy: #310"
    }, {
    "id": 395,
    "url": "https://wechaty.js.org/2017/09/20/add-wechaty-jsdoc/",
    "title": "Using Jsdoc to sync the doc with the latest code",
    "body": "2017/09/20 - In order to sync the doc with the latest code, it’s best to use jsdoc to describe the API and use jsdoc-to-markdown to generate markdown format documents to the docs directory.  Yes, we planned to do this for nearly a year… Thanks to @Huan, @ax4,@hczhcz, @William, by the end of August, we finally convert all the doc to jsdoc. And I’d like to share some jsdoc experience here.  We need to document them better, not only the public but also the internal modules and methods. Finally we decided to use the classic jsdoc to embed document in TypeScript, then generate document to docs/ by jsdoc2md. – @Huan said in issue 73 in Nov 2016. At first, we write the doc in wiki, and it lasts for nearly a year…. . A lot of developers use wiki to learn wechaty, but the wiki’s performance is not good, it cannot update automatically and doesn’t base on user’s most demand.    some minor fix (such as the different naming Message Class &amp; Class Room)  improvement on the formatting, e. g. the level setting of each title  maybe, add an index for better guiding– In Feb 2017, @ax4 creat an issue and expressed his willingness to contribute the document.  I like @ax4’s idea about the document guide:  First: Learn the awesome features of Wechaty Second: See more advanced functions Third: Reach the boundary? Help us develop WechatyThanks for @ax4’s suggestion and we decide to do the doc as soon as possible. JsDoc &amp;&amp; jsdoc2md: JsDoc is an API documentation generator for Javascriptjsdoc-to-markdown is a tool to help developers create markdown API document from jsdoc-commented JsDoc: JSDoc’s purpose is to document the API of your JavaScript application or library. It is assumed that you will want to document things like modules, namespaces, classes, methods, method parameters, and so on. JSDoc comments should generally be placed immediately before the code being documented. Each comment must start with a /** sequence in order to be recognized by the JSDoc parser. Comments beginning with /*, /***, or more than 3 stars will be ignored. This is a feature to allow you to suppress parsing of comment blocks. The simplest documentation is just a description /** This is a description of the foo function. */function foo() {}Reference:  *jsdoc Introduction *jsdoc English document *jsdoc Chinese document *Document This I use vscode as my editor, and use Document This “Document This” is a Visual Studio Code extension that automatically generates detailed JSDoc comments for both TypeScript and JavaScript files. You can use Ctrl+Alt+D and again Ctrl+Alt+D to generates documentation for whatever the caret is on or inside of. jsdoc2md: Generates markdown API documentation from jsdoc annotated source code. Useful for injecting API docs into project README files. When you document your code using valid jscode comments and run jsdoc command (e. g. jsdoc2md example. js), then you can get a markdown output easily. At first, I just write all of jsdoc in the code and link wechaty/docs/index. md to the users, but I cannot sync README. md file with the code and make readme as simple as it can, so I have to do some else. First, I should know how jsdoc2md works. How jsdoc2md works: This is the main use case (render documentation) sequence:  User runs jsdoc2md example. js.  jsdoc-api is used to obtain the raw jsdoc data for the input source code provided. (a kind of JSON output) this data is transformed into something suitable for passing into a template by jsdoc-parse (which also adds support for the jsdoc2md-specific tags like @typicalname, @done, @category etc).  the resulting template data is passed into dmd. This output is returned to the user. In order to pick function name from the full api doc, I learnt about dmd, it is the default output templates for jsdoc-to-markdown. It contains handlebars partials and helpers intended to transform jsdoc-parse output into markdown API document. For the wechaty document, I change two following dmd partials:  link. hbs sig-link-parent. hbsWechaty Progress on JsDoc &amp;&amp; jsdoc2md: Discussion history: Related Issue: @Huan, @ax4,@hczhcz, @William and I talked a lot about wechaty document on the following issues:  issue73: [doc] To Embed Document in Wechaty Code for Generating Automaticly issue252: [doc] Contribute to the doc editing[ jsdoc / jsdoc2md / typedoc ]Related PR: Also, @hczhcz and @ax4 and I contribute a lot on the document:  PR378: jsdoc2md may flush some pieces of the embedded doc PR380: fix jsdoc flush issue #378 and minor fix on the doc examples PR640: add documentation TODO entries PR725: add wechaty document PR321: Add JsDoc for Class ContactDoc basic line: For the convenience of developers, our doc guideline as follows:  Simple and clear Generate markdown for better readable version control and GitHub page hosting. Auto-doc working flow:  Develop in TypeScript Embedded doc insert in TypeScript Compile TypeScript into JavaScript, using npm run dist Run jsdoc / jsdoc2md, using npm run doc Get the final doc, in index. md, config it to wechaty. github. io/wechatyWechaty Jsdoc file: We embed doc into the following file:  src/wechaty. ts src/message. ts src/room. ts src/contact. ts src/friend-request. tsWechaty jsdoc2md progress: 1. Generate jsdoc2md file: Using the following command can generate document easily. jsdoc2md dist/src/{wechaty,room,contact,friend-request,message}. js dist/src/puppet-web/friend-request. js&gt;&gt; docs/index. md2. Use template to Sync Readme with api doc: Actually, the first step is enough, but I think we need insert and sync all of the API docs into README, so I use a template by the following command: jsdoc2md --template docs/partials/README. hbs dist/src/{wechaty,room,contact,friend-request,message}. js dist/src/puppet-web/friend-request. js&gt;&gt; README. mdThen add the partials {{&gt;member-index-list~}} to show the API directory, because the full doc is too big to put in README, and it is not necessary. 3. Linkable Code References: After the second step, I found the link jsdoc2md generate is an anchor link(#), it means I cannot link it to other pages(https://wechaty. github. io/wechaty), this is very inconvenient for readers. Inspired by [jsdoc2md-issue-123], @KevinAst using jsdoc-to-markdown wrote a beatutiful doc: astx-redux-util. I found maybe I can created a custom partial too. Then I override the following templates in docs/partials/overrides, adding https://wechaty. github. io/wechaty in the link:  link. hbs sig-link-parent. hbsThis is the reason why I add the following script in package. json : jsdoc2md --partial docs/partials/overrides/*. hbs --template docs/partials/README. hbs dist/src/{wechaty,room,contact,friend-request,message}. js dist/src/puppet-web/friend-request. js&gt;&gt; README. md--partial command override link. hbs and sig-link-parent. hbs Then, all done! To Contributor: How to add jsdoc when contributing: For other developers, I tried my best to make it easier to add doc, just the following 2 steps: 1. Add jsdoc in your code like the following shows: /** This is a description of the foo function. */function foo() {}2. Run the following command: npm run docThen you can find the generated jsdoc here: wechaty/docs/index. md Cheers! "
    }, {
    "id": 396,
    "url": "https://wechaty.js.org/2017/09/18/wechaty-selfie-bot/",
    "title": "Score Your Face Photo: a ML & Wechaty practice",
    "body": "2017/09/18 - Recently I found a fun and easy middleware to use for WeChat, called Wechaty. Wechaty can help developers quickly build applications based on Wechat, and it was born with a huge number of Potential users. So I build a fun application based on Wechaty, called wechaty_selfie, which is a ChatBot that can score self-portraits.  Say goodbye to your choice of difficulty! Screenshot of the application: Our development steps: Once you have a little nodejs knowledge, and a little deep learning basis, you can build it. :)  Crawl data: The most important of this application is data. We crawled data(eg. picture URL, release time, the number of praise, the number of comments) with ‘selfie’ label from instagram.  Filter data: In order to make the training data more convincing, we crawl the data with earlier release time. It is obviously that if a selfie has just been released, then it must not get enough exposure, so the number of comments and comments at this time is unstable. Considering this, we set the realease time threshold to 2000 seconds. We will filter out data which have realease time smaller than the threshold.  Scoring strategy selection: We get the data(picture URL, the number of praise, the number of comments) for visual analysis， and found that most of the number of praise are between 0-10, so we simply consider the number of praise as the selfie’s score.  Download pictures: We download the selfies that we will use by URL that we already have, and reshape them into 224 * 224 dimensions.  Build DL model: In order to build the neural network quickly, we choose the pre-build model VGG16 in keras, and add five full connection layer on the top of it. The top of our model is a softMax layer with 10 categories.  Build project &amp; training model: Build wechaty project and the training of deep learning model.  Debugging, success!Appendix, packages we used:  pylab: for drawing matplotlib: for drawing requests: handle http requests numpy: matrix operations h5py: formatting data sets keras: deep learning Wechaty: wechat middleware Fs: transfer picturesSome optimization recommendations: If you are interested what I have done and would like to Develop a similar application.  If you want to use pictures from Instagram that have the selfie label as the training data, you should crawl the pictures with earlier release time.  You may try several different scoring strategies.  You can build a more complex deep learning model. Finally: I strongly recommend that you now click on the link below, there are surprises waiting for you！  Wechaty :) What a Deep Neural Network thinks about your #selfieAnd more details about my selfie bot, you can find in my github repository at: wechaty_selfie  Author: @huyingxi enjoying ML&amp;Wechaty at BUPT "
    }, {
    "id": 397,
    "url": "https://wechaty.js.org/2017/09/10/wechaty-the-bot-sdk/",
    "title": "Wechaty - the missing bot SDK for WeChat",
    "body": "2017/09/10 - Recently I was in San Francisco talking to a lot of my friends in the Chatbot community, and realized how the Wechaty community is becoming central to Chatbot development in China. A lot of Americans look to China and WeChat for the future of Chatbots, but in fact Tencent has still not released an official “Chatbot SDK”. Unlike Facebook, Slack, LINE, Telegram and every other messaging platform. bot. QQ. com is still just a teaser of what might be. If you are determined enough, you can still build chatbots for WeChat but it feels like swimming upstream without a guide. For those who don’t know, Wechaty allows you to turn a wechat personal account into a chatbot, and provides a javascript API to talk to WeChat. So in many ways Wechaty is becoming the missing bot SDK for WeChat, and it’s community is the main gathering point for all types of chatbot and NLP discussion in China. Additionally the core wechaty team make a big effort to use English in their documents and community. So this community is the gateway to China for international chatbot companies too. It’s great to get some ideas from outside of the genepool too XD Groups APIs and multiuser chatbots: So far the Tencent official APIs have only addressed 1:1 chatbots. Wechaty API is addressing an extra layer with addressing for users within groups. In the US Slack is providing new APIs for botmakers, such as “buttons” that you can use to make choices in a shared chat. This brings up surprising design problems such as - if one person pushes a button to change state, should everyone else in the group see that state reflected? Or should each person get the chance to make their own decision, such as for a voting app, where everyone can vote differently. Slack is providing infrastructure to support both use cases. The official tencent API allows for messages to single users, but Wechaty also has a ‘room’ concept to allow the multiuser messaging. With a group shared experience, there is a huge benefit to chatbots. Suddenly you can see what other people are doing. You can learn how to “use” the bot just by watching someone else’s conversation. You can do tasks together such as peer-learning. The simple text UI suddenly becomes a huge benefit as it’s easy to update a shared state. With Wechaty’s ability to provide an API to a personal account, in many ways it’s showing the way ahead for Wechat and how chat platforms can be a huge benefit to users over conventional websites and apps. Bot to Bot communications: This talk of groups and multiuser communication reminds me of a meeting last week in SF with Beerud from Gupshup. As well as being a major player in the bot authoring space, they also run lots of infrastructure for things like telco messaging. He has a vision called “interbot” which is about bot to bot communication channels Of course this won’t replace APIs but sometimes for a small business like a restaurant, a “chatbot” maybe the only API they’ll provide to their menu, or making a booking for example. Gupshup is developing wrappers to allow you to compose new bots by configuring and routing messages. This is a little bit similar to some of the bots people have made with Wechaty that for example route messages between different chat groups. They compare the Bot-to-bot vs traditional APIs: Bot to Bot  Connect bots without coding skills Bots are generally flexible and fault tolerant Bots are asynchronous, enable more possibilities Bots can do bi-directional messaging Bots can talk to bots and humans alikeAPIs  Integrating APIs requires coding skills APIs are fragile; they break with input errors APIs are synchronous; they don’t like delays APIs are uni-directional APIs are meant for computers aloneThere are some fascinating ideas here for a language to compose bots This operator is used to compose a composite bot. User's can assign a botname to a concatenated set of bots. Usage: @C = @A | @BHere, @C is a composite bot of 2 bots A &amp; B concatenated serially. Analytics for Bots: One of those from overseas who works with the Wechaty team is Dennis Yang from Dashbot. io, one of the leading analytics providers purely for ‘bots. The ‘bot industry outside of China is at this established stage where the ecosystem is growing enough to have all types of companies from authoring to analytics to AI. Dennis is planning to support the Wechaty API to make it easy for developers to immediately get great analytics for their wechat and wechaty bots. Ping them if you would like to get advance access! Dennis gave me some natty dashbot socks to share with the Wechaty dev team :) The future of Wechaty: Previously I’ve seen unofficial APIs be embraced by forward looking platforms. For example this blog post from Discord  The Robot Revolution has Unofficially Begun (Unofficial API):  … a dedicated group of ballers have reverse engineered our API to create what we’re calling the official unofficial Discord API … I believe the Telegram API also began as a reverse engineering project, that gave inspiration to the telegram team to embrace and create their own bot platform. Let’s hope that Tencent will look to Wechaty and enable more functions for chatbot developers, or even provide a full Chatbot SDK! Join Us: Join the group to chat with us on wechat! Wechaty is used in many ChatBot projects by hundreds of developers. If you want to talk with other developers, just scan the following QR Code in WeChat with secret code wechaty, join our Wechaty Developers’ Home now. Wechaty Developers’ Home Scan now, because other Wechaty developers want to talk with you too! (secret code: wechaty) "
    }, {
    "id": 398,
    "url": "https://wechaty.js.org/2017/08/28/wechaty-shanghai-meetup/",
    "title": "Shanghai WWDC - Wechaty Worldwide Developers Conference",
    "body": "2017/08/28 - Most of the Wechaty core team are in Beijing, but there are a few of us here in Shanghai too. @lijiarui was in town for a few days and so we had a small get together! We talked devops, chatbot games, NLP and more! Wechaty Infrastructure and DevOps: One of the issues for people running wechaty services is dev ops. Especially if you want to have many bots running. Wechaty itself is nicely docker-ized, but running multiple instances of the container, and orchestrating them is something a few companies are seeing as a common next step. We discussed ways to communicate between different node services. In Wechaty core there’s much discussion on this topic, so if this is a sub project you would like to see happen please let us know below! DNode vs. REST APIs: For inter-bot communication, we talked about a few methods and ax4 shared his experience of using DNode. I’ll let @ax4 explain:  Dnode is not a substitute of REST API.  REST API is essential and powerful, in all kinds of programming (cross language and cross platform). Dnode is simple and useful for Javascript stack, and only have several languages support in perl / ruby/ php/ php-sync/java (check https://github. com/substack/dnode#dnode-in-other-languages) Dnode is much easier and lightweight to configure in small projects, rather than heavy SOAP for RPC. However, in more complicated projects (for example. 5000 RPC interfaces, with high frequency of calling), you have to design your own Nameservice, and especially the request handling.  Since Javascript programming is all about “function”s. Dnode would be helpful, for small team to skip binding their “function”s with REST, and directly deliver the “functions” as RPC to other NodeJS/Browser instance! And, bi-direction call !These type of services will enable bot-to-bot communications in the future. This is becoming a topic in the US now too, with so many chatbots. For many companies a chatbot maybe the only “API” they have. For example a local pizza shop won’t hire a web developer to make their API, but you could ‘query’ their chatbot to find out their hours or prices. Chinese NLP libraries: No bot developers meetup would be complete without a discussion of NLP libraries. We talked about the various low-level tools such as segmenters and POS taggers. @ax4 mentioned bosonNLP but Jieba and SnowNLP seem like good options too. Personally I have had best quality from the Stanford NLP libraries but it’s a hassle to maintain a Java stack so we mostly use Jieba now. At a high level we compared yige and API. ai which seems to be flaky to connect to and use since they were acquired by Google and started moving to Google infrastructure. Well, that opens up the field for more local companies! Groups Bots and Games: One of the things Wechaty enables is bots in groups, not just 1:1 between a single person and an official account. This opens up a whole number of design questions shared experiences, and technical decisions like how to share state between users. DC built a text adventure game called “Pirates” that can be played within a group. All the users see the results of any players actions, as you are travelling as a “party”. It’s interesting to watch people playing. One person will try something, then maybe give up, and then someone else will take over. It’s almost like passing the steering wheel to your friend to try driving for a bit! On the other hand, scoring was implemented per user. @hczhcz told us about bots for playing werewolf, you can read more about that at his wechaty blog post. Games have already spent a lot of time thinking about multiplayer and the chat platforms related to games do too, for example Discord has a rich API for Guild management There is much that Wechaty can provide on the server APIs, but client modifications need to be added by the platform. For example Slack has the concept of a “ Chatbots Shanghai Community: The first Wechaty DevCon was just four of us but there are more and more ‘bot makers in Shanghai! @lijiarui is a Wechaty core contributor and runs batorange. com They manage more than 30k wechat groups and she also keeps the Wechaty community humming along. @Ax4 and @hcz are two young “sea turtles” who both studied in the US and now came back to Shanghai to start their businesses. They met at a science fair competition. @ax4 is working on a startup that analyzes official Wechat posts, and uses NLP to turn the unstructured data into searchable and useful structured data. The company name isn’t decided yet :) @dcsan started RIKAI Labs and we build bots for other companies, as well as running our own “TeacherBot” - an AI chatbot to help Chinese students to learn English. Please get in touch if you’d like to know about the next Shanghai Wechaty WWDC and be invited! Join Us: Wechaty is used in many ChatBot projects by hundreds of developers. If you want to talk with other developers, just scan the following QR Code in WeChat with secret code wechaty, join our Wechaty Developers’ Home now.  Scan now, because other Wechaty developers want to talk with you too! (secret code: wechaty)  Author: @dcsan, making Chatbots at RIKAI Labs "
    }, {
    "id": 399,
    "url": "https://wechaty.js.org/2017/07/17/run-your-telegram-bot-with-wechaty/",
    "title": "Run Your Telegram Bot with Wechaty",
    "body": "2017/07/17 - Before introducing Wechaty Telegram Bot Adaptor, I would like to say something about Telegram chatbots. Recent days, I have a lot of fun playing chatbots on Telegram. After lynched hundreds of tanners in Werewolf games, I realized that a chatbot can bring so much fun to users.  Playing Werewolf on Telegram: What are the differences between a chatbot and a game app? A chatbot is much more accessible. You do not need to let your friends download and install it. Instead, just say “hey, let’s play Werewolf/UNO/Avalon…” and the chatbot will be ready for your friends and you. The process of playing the game and the process of chatting are actually “fused” together. In addition to games, chatbots can involve in one’s daily life from many aspects. When I wake up in the morning, I can call a bot to add myself to the list of early-morning guys (even if I get up later than 10 a. m. XD). I can keep tracking the updates from GitHub via a bot. A bot can also get random XKCD comics, Konachan wallpapers or Wikipedia entries for me. There are some super funny chatbots. One of them would let you ban a user in a group for several seconds but you have a probability of 50% that gets yourself banned. Another will pair the parentheses you sent. For example, if you say something like “（逃”, it will reply “） ○(￣^￣○)”.  A Bot Involves in Your Daily Life (via Imgur): Chatbots are good at encouraging user-generated contents. There are auto-reply bots in Telegram which allow users to add their own reply rules. Since auto-reply bots were added to our group, we fed a lot of interesting rules to it. Now, it looks like:  someone: 今日运程  bot: 手机掉到了沟里  someone: 四字真言  bot: 多喝热水  another bot: 多喝开水  someone: 。。。。。。  bot: 你是豌豆射手吗？ So, Why WeChat and Wechaty?: WeChat is a great chatting application and it may be the most functional one. It can even call a taxi for you. But a concern is it lacks an official API for chatbots. Although third-party developers have made a lot of effort to bring APIs and tools, the number of chatbots is still limited. On the other hand, there are so many chatbots available on Telegram and, as we can see, chatbots are bringing a huge impact on the application and its users. It would be really cool to introduce them to WeChat users. Taking MESE bot as an example, it is a Telegram chatbot of a business simulation game MESE. Several months ago, I ported it to WeChat because the majority of MESE players in China do not use Telegram. The idea is creating a mock Telegram chatbot library which provides Telegram’s interface but interacts with WeChat internally. It is somewhat a dirty hack. The mock library processes text message only, and the user identification still works in WeChat’s way. I slightly modified the code of MESE bot so that it works as expected. Since then, by writing the code once, the new feature of MESE bot will be deployed to both Telegram and WeChat.  Telegram MESE Bot: WeChat MESE Bot: Now, when creating a new Telegram chatbot, I would like to run it on WeChat too. Considering each chatbot has its own needs and the solution from MESE bot can not cover all of them, it requires a more general way to adapt between Telegram and WeChat. The difference here is that a “general” library should be strictly compatible (as much as it can be) with Telegram’s API standard like using an integer as a user ID and providing complete message objects as defined in Telegram Bot API. That is why I started the project to build a WeChat adaptor for Telegram Bot API. “An adaptor” means it has two ends. On Telegram’s side, it clones the interface of node-telegram-bot-api which implements the latest version of Telegram Bot API. On WeChat’s side, I decided to use Wechaty because it is well maintained by an active community. For this project, it is important to keep both ends work well. The WeChat’s side worth more attention since WeChat’s protocol is not officially provided to developers. An active community like Wechaty’s can help a lot in keeping the library updated in this case. From a Technical Perspective: Let us move on to the implementation of Wechaty Telegram Bot Adaptor. The library is basically a class called WechatyTelegramBot just like the original TelegramBot in node-telegram-bot-api. It maintains a Wechaty instance internally: this. wechaty = wechaty. Wechaty. instance(this. options. wechaty);The adaptation between node-telegram-bot-api and Wechaty falls into these parts: Events: When receiving an event from Wechaty, it needs to be translated as an update object as in Telegram. The update handling system is the same as the original one which supports event emission and regular expression matching. Why we do not skip the update objects and emit an event directly? The reason is that the update handling system itself is defined in Telegram Bot API and bots may pass mock updates to it (actually, it is a useful skill when developing a Telegram bot). Methods: Some methods are not supported in WeChat like message pinning and callback queries. The adaptor would support alternative behaviors. For example, pinning a message could be translated as sending a message with an “@all”. Since these hacks are not standard and might be tricky, they are configurable in options. This part is still in development. There are really a lot of work to do. Objects: There are some differences in the structure and content of objects. For example, in Telegram, groups and private chat is differentiated by a chat object while it is a Message. room() call in Wechaty. So it needs some code like: message = {  from: &lt;translate message. from() as a user object&gt;,  chat: message. room()    ? &lt;translate message. room() as a chat object&gt;    : &lt;translate message. from() as a chat object&gt;,  . . . }The most difficult part is managing IDs. Telegram assigns a permanent ID to each user, each group, and each message. As mentioned in Wechaty FAQ, an alias which contains a unique ID would be able to identify a user. The unique ID is generated based on the timestamp and ensured uniqueness by spining: while (Date. now() === lastID) {  // spin}lastID += 1;For groups and messages, I added a fallback mechanism which keeps the ability of identification in a single session but loses it when the chatbot logs out. The implementation is as simple as remembering the latest groups and messages. The number is limited to prevent the memory leak. Besides, Message. entities in Telegram requires parsing the text of a message. It is still working in progress. Sessions/Polling: Wechaty is based on sessions. Currently, polling is implemented as simply start/stop the session. In the future, it will be implemented with an update object queue, so that it would support manually polling. startPolling(options = {}) {  if (options. restart) {    return this. stopPolling(). then(() =&gt; {      return this. wechaty. init();    });  } else {    return this. wechaty. init();  }}stopPolling() {  return this. wechaty. quit();}Finally: I am really glad to share the story of Wechaty Telegram Bot Adaptor to you. Wechaty is cool! As well, the community’s blog and WeChat group benefit developers a lot. There are still a lot of work to do. If you are interested in making this adaptor work better, please feel free to submit issues/PRs. In addition, some parts of Wechaty still lack documentation. I have had some discussion with @huan and @ax4 about it. If you are interested in adding documentation to them, it would be helpful to many projects powered by Wechaty including this one. "
    }, {
    "id": 400,
    "url": "https://wechaty.js.org/2017/07/13/how-to-build-a-chatbot/",
    "title": "如何编写聊天机器人",
    "body": "2017/07/13 -  Chatbot，聊天机器人，用于和人类用户聊天的电脑程序。它是场交互革命，也是一个多技术融合的平台。桔子互动创始人根据自己的经验告诉大家，该如何来编写微信聊天机器人。 What are chatbots and why the hype: 早在80年代，大家普遍使用PC上网，所有网上交互都是通过PC客户端去实现的。随着网速变得越来越快，浏览器开始普及。 智能手机出现以后，人们使用电脑的时间越来越少，手机里安装的APP则越来越多。 而现在就到了聊天机器人的时代。所有bots都搭载在message的平台上，去实现所有APP上的服务。 我觉得公众号、直达号和H5这些在最开始的时候都是很像chatbot的雏形。APP实在是让用户太焦虑了，大家都希望有一个可以简单迅速找到服务的程序。 因为数据、计算能力和网速都在迅速发展，在message这种消息的APP上会出现很多有意思的应用和服务，就像PC到Web，APP到chatbot这个过程的转换一样。 我认为chatbot是未来，接下来的所有服务可能都是通过chatbot去实现的。 Chatbot Magazine创始人Matt Schlicht对chatbot的定义是：“A chatbot is a service,powered by rules and sometimes artificial intelligence,that you interact with via a chat interface. ” 聊天机器人是一种由规则和一部分人工智能驱动的服务，通过聊天接口进行交互。 现在的交互方式已经发生了新的改变，我们可以通过说话去实现所有的功能。在Web和APP的时代，人要像计算机一样思考，而chatbot则是让计算机像人一样思考，做到“no UI”。 当今用户不喜欢使用APP，因为不仅用户下载的成本高，APP的开发和升级成本也非常高，而且只有极少数的APP还处于活跃状态。 而bots搭建在message平台上，无需安装，甚至在网速不佳的情况下也能进入它的服务。Chatbot处于“no UI”状态。如果只是关注逻辑层面去解决一些场景上的问题，开发的成本不会很高。 Overview of the bot ecosystem: Facebook Message已经向开发者开放了，Apple ios Message APPS也在开放，Slack、Kik、Telegram和Skype都支持相关的接口。 Facebook收购了Wit. ai，google收购了Api. ai，微软推出了luis. ai。我认为这三个都是实现一样的功能，就是实行意图识别。 微软还有一个Bot Framework去做整个chat中控的系统，以及IBM推出了Watson Conversation API。 Facebook Message上面有超过10万个bots，大概有10万个开发者在Facebook Message上进行这些bots的开发。 有超过200万的用户每天在和chatbot进行交互。 在其它平台如Skype、Telegram上也有上千的bot。 消费者能够真正接触到的chatbots大概分为三类： 第一类是个人助理，帮助用户实现各种服务。 第二类是虚拟客服，根据用户的问题给相应回答。 第三类是提高生产力的工具，可以做一些信息的收集、分发消息等工作。 Chatbot是一个很大的产业，它不是只有AI和deep learning，不一定要high tech去做，也不只有算法。而是要真正去解决一些实际问题。未来它就会像APP一样在我们身边，为我们提供非常一些简洁的服务。 Requirement和正常软件开发相似，然后写一些需求的文档和需求说明。 做软件开发或APP的时候会做一些线框图或流程图。Chatbot是一个“no UI”的体验，所以要写script，了解如何收集用户的信息、怎样理解用户，并把这些用户的话术整理出来。它就是一个和用户交流的线框图的概念。 接下来要做架构开发，它同样分为前端和后端。前端就是script，更完整地收集用户信息。收集好了做成一个action给到后端，和其它的Web service做整合。 在做chatbot开发的时候，往往会陷入编码和测试反复的循环之中，因为交互还不是结构化的数据，所以会有点复杂。 Chatbot里做的测试和一般的APP测试不一样。在APP里可以简单暴力地做测试，但在chatbot里，不同的message有不同的需求或限制。做测试的时候要摸清不同message平台的区别。 要部署到一个可托管的环境并时刻去监控它，然后做推广。 最后还要做chatbot的分析，需要知道每一个会话时长是怎样的、用户对什么最感兴趣。拿到这些数据后再去调研用户的需求，形成一个循环。Chatbot主要是从场景入手，更关注的是解决一些问题和创新的点，而不是底层的开发。我认为接下来各种开发者也会从APP开发者转换成chatbot开发者，只是时间问题。 itdakashuo-how-to-build-a-chatbot: Wechaty是一个可以让微信变成机器人的接口，利用这个框架可以把个人微信号变成机器人，能自动回复和提供一些服务。 Wechaty的实现原理主要是监听网页上的信息，把信息封装然后给开发者调用，开发者发送信息的时候让浏览器去实现这些功能。 Side project通过代码追踪的方式应对微信网页变化。 Wechaty的七个基本事件分别是error、scan、login、logout、message、friend和join。 Related Scene: 我们已经实现了微信群的CRM管理、通过各种方式邀请好友进群以及做一些多群的直播。 还有一些有意思的东西想和大家分享。 挑选一个最吸引人的头像到微信上。通过用户点赞数分析出哪些头像在男性和女性中分别最受欢迎，帮助用户挑选微信头像。 存储文件。把微信和云盘打通，可以直接把微信上收到的文件转给机器人，让机器人存进云盘里。 把歌词生成一张好看的图片。订机票、车票、酒店等。Github的通知。把用户关注的动态实时发送到微信群里，让微信群和各种平台的信息做对接，也可以收集群里的消息做分析和训练。 Chatbot确实是一个可以帮我们解决生活中很多问题的工具，只要是开发者都能去实现它。 "
    }, {
    "id": 401,
    "url": "https://wechaty.js.org/2017/07/06/wechaty-sticker-on-sale/",
    "title": "Wechaty Sticker is ON SALE!",
    "body": "2017/07/06 -  We had just made very high quality Wechaty Logo Stickers recently! If you are using Wechaty and you love Wechaty, from now you can buy our logo sticker online. I ❤ Wechaty1:  Order from Etsy: https://www. etsy. com/listing/541157219 (Worldwide2) Order from JD: https://item. jd. com/12994583384. html Order from TMall: https://detail. tmall. com/item. htm?id=552823238544         Disclaimer: The seller is not wechaty/wechaty but a 3rd party partner.  &#8617;        Worldwide: International shipping with PayPal/Credit Card support.  &#8617;    "
    }, {
    "id": 402,
    "url": "https://wechaty.js.org/2017/06/24/an-interesting-weekend-with-wechaty/",
    "title": "An interesting weekend with Wechaty",
    "body": "2017/06/24 - Thanks for inviting me to write this article that give me a chance to share my story for each other. And Wechaty is a very awesome library that is powerful and easy to use. The most important point is that is interesting for Wechat users and developers. Last week, I want to help my friend to make a chat bot. Because she is a manager of a technic community and she is also a owner of a chat group. In her daily life, many people add her to be the bunny on wechat. Then she needs add these persons into wechat group. It is a manual work, right? So I want to help her to lessen workload. So I ready to use wechaty. Firstly, I implemented some basic features. Like below The chat bot can receive the friend request automatically: const bot = Wechaty. instance({profile: 'secretary'});bot. on('friend', async function(contact, request){ if(request){  await request. accept()  await contact. say('您好，我是 FCC（freeCodeCamp成都社区）的姜姜姜，很高兴认识你*^_^*回复暗号”FCC成都社区”， 加入FCC成都社区群。直接聊天，请 随意…') }})Input keyword then add him/her into the chat group:  bot. on('message', async function(m){  const fromContact = m. from()  const fromContent = m. content()  const room = m. room()  if(/FCC成都社区/. test(fromContent)){   let keyroom = await Room. find({topic: 'FreeCodeCamp-成都'});   if(keyroom){    await keyroom. add(fromContact);    await keyroom. say(`欢迎 @${fromContact. name()} 加入FCC(freecodecamp)成都社区*^_^*`)   }  } })The above feature has already help her lessen some work. But my friend think it is not enough to satisfy her requirement. She is a very beautiful girl, so there is someone always asked her if she has boyfriend. That makes her boyfriend a little annoyed. So she want me to implement a feature that is if someone in this chat group ask her something about her bf the chat bot can send a photo of her bf. Wow I’m honoured to develop this feature. So I started to read the doc of wechaty. But I can’t get how to send a media message. I continued reading all of the issues that let me know wechaty can send a media message but I don’t know the details. Then I try to use another methods. I try to use node. js to resolve. I want to change the images to be the buffer of base64. But it didn’t work, users just receive some strange string…. . Finally I ask @huan directly. He sent me an article 给机器人添加发送图片视频功能. This article analysis the principle about how the wechat sends images. It says wechat use “MediaId” to store the information of media and blablablabla……Finally the Wechaty contributors got the “MediaId”. WoW so cool! They integrate this function in Wechaty which use say(MediaMessage(filename)).  If someone interested in this principle can read this article. In the end of the article says ding-dong-bot. ts has already implement it. So I found this file that use like below: import { MediaMessage } wechatyawait m. say(new MediaMessage(__dirname + '/. . /image/BotQrcode. png'))I tried immediately, it does work. haha~perfect~Then I use api. ai. If someone say: ‘Does @姜姜姜 have boy friend?’ or say some synonym the chat bot will send a photo of her bf automatically. Well that was I did in last weekend. I think wechaty is an interesting library. At the end, I help the author of Wechaty add this api to the Wechaty documentation.  Well, the complete codes like below: import 'babel-polyfill'import { Wechaty, Room, MediaMessage, log } from 'wechaty'import apiai from 'apiai'const app = apiai('46a33e7a9cb741fb96e0dcc3d2d03a6c');const bot = Wechaty. instance({profile: 'secretary'});bot. on('scan', (url, code)=&gt;{ log. info(url);}). on('login', user =&gt; { log. info(`${user} is login`)}). on('friend', async function(contact, request){ if(request){  await request. accept();  await contact. say('您好，我是 FCC（freeCodeCamp成都社区）的姜姜姜，很高兴认识你*^_^*回复暗号”FCC成都社区”， 加入FCC成都社区群。直接聊天，请随意…') }}). on('message', async function(m){ if(m. self()){  return; } const fromContact = m. from(); const fromContent = m. content(); const room = m. room(); const noAtMention = fromContent. replace(/@\w+/ig, ''); let roomTopic; const request = app. textRequest(noAtMention, {  sessionId: '1234567890' }); request. on('error', function(error) {  log. error(error); }); request. on('response', async function(response) {  const speech = response. result. fulfillment. speech;  if(/FCC成都社区/. test(fromContent)){   let keyroom = await Room. find({topic: 'FreeCodeCamp-成都'});   if(keyroom){    await keyroom. add(fromContact);    await keyroom. say(`欢迎 @${fromContact. name()} 加入FCC(freecodecamp)成都社区*^_^*`)   }  }  m. type() == 10000 &amp;&amp; m. say('@Helen') // Umm. . shame on me. . . . If someone give out a Red packet the chat bot will @ myself  if(room &amp;&amp; room. rawObj. NickName == 'FreeCodeCamp-成都'){   if(/jiangjiangjiang/. test(speech)){    await m. say(new MediaMessage('images/test. jpg'))   }else{    m. say(speech)   }  }else if(!room){   m. say(speech)  } }) request. end();}). init()Finally, I want to thank our teammate @拖拉机 @姜姜姜 @glowd @myself  Author: @Helen, Lenovo  Helen is a full stack engineer living in Chengdu, familiar with D3. When not coding, she loves dancing, sings and play Erhu. "
    }, {
    "id": 403,
    "url": "https://wechaty.js.org/2017/06/06/the-first-chatie-wwdc-party/",
    "title": "The First Wechaty WWDC Party in 2017",
    "body": "2017/06/06 - On June 6, 2017, 6 pm, we have a great first Wechaty World Wide Developer Conference (WWDC) at Su Shi Restaurant of Wudaokou, Beijing. Topic: Wechaty and Artificial Intelligence Attendees:  Huan, creator of Wechaty, Angel Investor Jiarui LI, Founder of Orange Interactive Zainan ZHOU, who graduated from Tsinghua University, currently works in Google Adwords Daohan CHOU, who majored in business and undergraduates in Europe, and will be admitted to the University of Birmingham in computer science department Shuai ZHOU, who works in the Chinese Academy of Sciences Institute in Automation, in CBSR Laboratory, and researches in face recognition and face attribute analysis Wenjun ZHAO, who is a graduate student in Beijing University of Posts and Telecommunications, studying assiduously in Machine LearningThis is the greetings video from the above person:  "
    }, {
    "id": 404,
    "url": "https://wechaty.js.org/2017/06/05/a-simple-wechaty-bot-with-intelligence-powered-by-tf/",
    "title": "A Simple Wechaty Bot with Intelligence Powered by TensorFlow",
    "body": "2017/06/05 - Wechaty is an powerful library to help developers interact with WeChat programmatically, creating a bot for a varity of purposes. A very significant purpose of a bot is to chat with users, implementing tons of businesses within only a message app instead of a website or other apps1 (Raval, 2016). A chatbot is extremely useful for businesses such as custom services. A traditional way to implement a chatbot is to write all possible responses. It would cost a large amount of time and money and seems to be ‘mission impossible’. With the growth of Artificial Intelligence, machines could learn from a large number of dialogues generated by human beings automatically so that programmers do not have to ‘teach’ these machines step by step. In this article, I will introduce a few codes of TensorFlow to make our chatbots more ‘intelligent’.  A brief introduction of Artificial Intelligence: Artificial Intelligence (aka. AI) is a very hot topic at present time. A big news is that DeepMind’s AlphaGo won three matches against Ke Jie2 (Russel, 2017). The method to beat him is not magic. It is ‘learning’ of machine from a very big data set. By doing a lot of training, machines could do better than human in some specific fields. Go is a very recent example. The chatbot is a similar topic. We have a lot of resources to train our chatbot, such as the scripts of TV and movies. As a result, the problem of intelligence could become that of big data. ‘Talk is cheap, show me the code. ’ Let’s look a bit inside into it.  Model training: We are going to use the code written by Sir Raval to train our model: https://github. com/llSourcell/tensorflow_chatbot. To get rid of difficulties of fetching dataset, it is highly recommended to use my repo with the dataset ready. In addition, the details of the usage for TensorFlow will not be included in this article. Because there are too many details to write about. Dependencies: You must install the following dependencies:    Python 2. 7     numpy (pip install numpy)     scipy (pip install scipy)     cuda and cudnn (optional, but highly recommended)     tensorflow (0. 12), it would be much better if you have a GPU which supports cuda accelerating the traning process     The dependencies in ui/requirements. txt:   click==6. 6Flask==0. 11. 1itsdangerous==0. 24Jinja2==2. 8MarkupSafe==0. 23Werkzeug==0. 11. 10   Train the model: In the project directory, execute python execute. py, starting the tranning process: Note: The training process will take a lot of time, even if on good GPUs. In my case, I spent over 1 hour training this model to make the perplexity less than 10, on GTX 1080. The lower perplexity is, the better quality the chatbot is. When you feel your model ready, just press Ctrl + C to terminate the training process. Test the model: Modify seq2seq_serve. ini, changing mode = train to mode = test. Then execute python execute. py again. The ‘test’ UI will be presented: Well, it doesn’t look so smart. As mentioned before, the quality of AI is highly dependent on your dataset. Our dataset is Cornell Movie Dialogue dataset and we our neutral network is relatively simple. Consequently, our bot has less intelligence. Providing an HTTP API for Wechaty: Fortunately, this repo has provided an HTTP server with flask. We can easily start it by executing PYTHONPATH=$(pwd) python ui/app. py . After that, we can see a very simple UI with this chatbot: Note: the token _UNK is for special words such as names of video games and places. As seen from ui/app. py, an API to chat with this bot has been defined: @app. route('/message', methods=['POST'])def reply():  return jsonify( { 'text': execute. decode_line(sess, model, enc_vocab, rev_dec_vocab, request. form['msg'] ) } )We will take advantage of this API in Wechaty. Set up Wechaty: # In our project directory:npm init -ynpm install --save wechatyWrite a simple bot which send all the messages regardless those in groups to the AI server (flask) in last section: // bot. jsimport { Wechaty, MsgType } from 'wechaty';import request from 'request';const bot = Wechaty. instance({ profile: 'tensorflow' });bot. on('message', (message) =&gt; {  if (!message. room() &amp;&amp; !message. self() &amp;&amp; message. type === MsgType. text) {    // If it is not a group message nor message posted by self    const content = message. content();    request. post({      url: 'http://localhost:5000/message',      form: { msg: content }    },      (err, httpResponse, body) =&gt; {        if (!err &amp;&amp; body) {          const data = JSON. parse(body);          const response = data. text;          console. log('message:', content, 'response:', response);          message. say(response);        }      })  }})bot. init();Run this script node bot. js, each time while receiving message, Wechaty will post it to the AI API (flask web server) [Message] &lt;=&gt; [Wechaty] &lt;=&gt; [AI] then get the response.  At present, we could implement a very basic chatbot with TensorFlow. The code can be found at: https://github. com/imWildCat/wechaty_and_tensorflow_chatbot Limitation and summary: The chatbot is not so smart due to the insufficiency of data. In addition, it can only ‘understand’ English sentences instead of other languages. When comes to Chinese, it could be much more complex. The whole topic of Artificial Intelligence and Machine Learning is too large to be involved in this article. The aim of this blog is just to illustrate the potential at a glance instead of in detail. Although there would be a number of challenges in the future, it is desirable to know more about Machine Learning, making your bot powered by Artificial Intelligence. Bibliography: Author: @imWildCat, University of Birmingham       Siraj Raval, 2016. How to Make an Amazing Tensorflow Chatbot Easily. Retrieved from: https://www. youtube. com/watch?v=SJDEOWLHYVo &#8617;        Russell Jon, 2017. Google’s AlphaGo AI wins three-match series against the world’s best Go player. Retrived from: https://techcrunch. com/2017/05/24/alphago-beats-planets-best-human-go-player-ke-jie/ &#8617;    "
    }, {
    "id": 405,
    "url": "https://wechaty.js.org/2017/05/25/use-interval-in-wechaty/",
    "title": "How to use interval in Wechaty to overcome some web-wechat API limitations",
    "body": "2017/05/25 -  Hello, first of all, thanks for inviting me to write a knowledge sharing post in Wechaty. I am just starting to learn Wechaty and immediately fall in love with it. It’s really easy to get started to make your own wechatbot. :-) I am currently exploring all the examples from the Wechaty and try to customize it to make my own requirements happening. Everyday I try to think of a user case that I can use wechaty to make it happen. So I had a particular evil thought in my mind one day. I wanted to add a Wechaty bot to any chatrooms and sent bot a command, then somehow the bot can start to send Friend Requests to all the people in the room. Below is the code snippet function sendFriendRequest(room, msg) {  if (!room) {    console. log('Bot', 'there is no room yet');    return;  }  let content = msg. content();  if (msg &amp;&amp; /希望和大家做朋友/. test(content)) {    let contacts = room? room. memberList({}) : [];    for (let i = 10; i &lt; contacts. length; i ++) {      let contact = contacts[i];      let request = new FriendRequest();      request. send(contact,  Hi 很高兴认识您 )        . then( result =&gt; {          console. log( Friend Request Send  , contact. name(), result);        })        . catch(e =&gt; {          console. log('Bot', 'Friend Request Error: %s', e. stack);        })    }  }}The code is simple, when the bot saying 希望和大家做朋友, the bots will get all the contacts from the room and start to send FriendRequest. However, it failed quickly with some exceptions in the log sometimes, or the Send Friend Request is always False. At this stage, the Send Friend Request is pretty much useless. So I created ISSUE in github and asked around. The original ISSUE link: https://github. com/wechaty/wechaty/issues/540 Thanks for the help from @huan and @lijiarui, which let me understand the Limitations of web-wechat and I did some research online saying web-wechat only allows to send 100 user request per day. And the api call throttle need to be steady. Obvisouly the original For-Loop is just too fast. I am wondering is there any kinda Sleep function in javascript? Thanks for the help from @huan. Turns out there is a built in Sleep function already. Here is how to use Wechaty Sleep. async function asyncAwait() {  for (let i = 0; i &lt; 10; i++) {    console. log( Knock , i);    await Wechaty. sleep(5000);  }}asyncAwait();And I used same technics to finally make my Send Friend Request stable. Below is the full code. Bear in mind, I set the sleep time threshold to 2mins, which successfully send out 100 Friend Requests before web-wechat shut me down. import { Message, Room, FriendRequest, Wechaty } from 'wechaty';exports = module. exports = async function onMessage (msg) {  const room   = msg. room();  const sender  = msg. from();  const content  = msg. content();  if (msg. self()) {    sendFriendRequest(room, msg);    return;  }}async function sendFriendRequest(room, msg) {  if (!room) {  console. log('Bot', 'there is no room yet');    return;  }  let content = msg. content();  if (msg &amp;&amp; /希望和大家做朋友/. test(content)) {    let contacts = room? room. memberList({}) : [];    if(!contacts || contacts. length == 0) {      return;    }    console. log('Contacts Size:', contacts. length);    for (let i = 10; i &lt; contacts. length; i ++) {      let contact = contacts[i];      let request = new FriendRequest();      request. send(contact,  Hi 很高兴认识您 )        . then( result =&gt; {          console. log( Friend Request Send  , contact. name(), result);        })        . catch(e =&gt; {           console. log('Bot', 'Friend Request Error: %s', e. stack);        })      await Wechaty. sleep(1000*60*2); // 2 mins is a good threshold    }  }}I think it’s a common pattern when we are using Wechaty to do sth in the For-Loop block. It’s better to make it wait a bit. Hopefully this article helps. ThanksSeabook Author: Seabook, @kungfu-software, Founder of Kungfu Software "
    }, {
    "id": 406,
    "url": "https://wechaty.js.org/2017/05/17/deliver-dialogs-with-superscript/",
    "title": "Deliver dialogs with SuperScript",
    "body": "2017/05/17 -  Hailiang WANG is Lead of Rockq Community and also a software developer. He used to work in IBM China Innovation Center and IBM China Development Lab. Since last year, he has focused on deep learning technologies, NLP, chatbot and conversational UIs. 现在时间是7点半，8点下班回家，在这半个小时，让我们来聊聊SuperScript 和 Wechaty 结合带来的巨大前景。 Wechaty就像是连到母体的管道，当我们还在思考着是吃红药片还是蓝药片的时候，pia，zixia就把Wechaty给做出来。然后呢？！ 对话，对话，对话。 SuperScript: SuperScript是一个开源的对话引擎。使用SuperScript定义的语法，书写脚本文件，然后使用编译工具，生成对话元数据。 脚本:  简单+ 你好- 你好用户说”你好”，bot回复”你好”  变形+ 你(在|毕业于)哪个学校- {keep} 北京信息科技大学+ 清河小营 [校区]- {keep} 我也在附近“你在哪个学校”，”你毕业于哪个学校”，都会得到回复：”北京信息科技大学” “清河小营”，”清河小营校区”，都会得到回复: “北京信息科技大学”  插件+ 聊天是一门艺术- {keep} ^checkMessageFeatures() 编程是一项工艺+ &lt;nouns&gt;是中国首屈一指的学府- {keep} ^checkMessageFeatures() 北京邮电大学也是checkMessageFeatures 是一个插件，在SuperScript里，插件就是一个被注入了对话上下文环境的JavaScript函数。利用函数，我们可以实现任何业务逻辑。  关键词提取// Generic wildcards+ 他在旧金山创立的对冲基金 (*) 依靠 (*) 算法来处理所有的交易- {keep} &lt;cap1&gt;是一家公司&lt;cap2&gt;// Exact length wildcards+ 家里 *2 坏了// 此处匹配两个字- {keep} &lt;cap1&gt;坏了很多次了// Min-max wildcards+ 今天是 *(5-8)// 此处匹配5-8个字- {keep} 祝大家玩的开心+ [今天] (*) 天气(怎么样|如何|好么)- {keep} ^getWeather(&lt;cap1&gt;)所以，在回复中，&lt;capN&gt; 对应着 开场白里的 *。 注意上面的 ^getWeather，这里是插件。getWeather可以实现天气查询功能。 更多介绍。 SuperScript and Wechaty: git clone git@github. com:Samurais/ss-wechaty. git &amp;&amp; cd ss-wechatyscripts/start-docker-compose. shTake a close look: git@github. com:Samurais/ss-spa. git &amp;&amp; cd ss-spanpm installcp config/environment/development. sample. js config/environment/development. js # 修改配置文件npm run dev:start在ss-spa中，参考 chat/zh_CN. ss，书写新的脚本，依然放在 chat目录下，ss-spa会热加载。 测试对话 open http://localhost:3001以任何用户名登入，并开始对话。 同时支持使用 docker-compose 快速开始。 cd ss-spascripts/build-docker-image. shscripts/start-docker-spa. shDeliver dialog with Wechaty: 现在，回到ss-wechaty。  如果之前有启动，先停止并删除容器。 scripts/start-docker-compose. sh后记: 现在是8:03分了，bye. 下期再见！ Click here to get the repo Author: @hain, Lead of Rockq Community, Wechaty Contributor "
    }, {
    "id": 407,
    "url": "https://wechaty.js.org/2017/04/21/wechaty-meeting-dinner/",
    "title": "Wechaty Contributor Dinner",
    "body": "2017/04/21 -  With the development of science and technology, the progress of the society is related to create something useful. And to a certain extent,  the software developers are capable of changing the world.  Last Friday, I was lucky for having an enjoyable conversation with several coders together. There were 7 guys came to the gathering (including me), 6 programmers, and one used to work for a technical community. We met at 7 pm and would have dinner together in a Chinese restaurant. We’d like to introduce ourselves to each other at the beginning of the meeting with a video recorded. Huan LI An Angel Investor, Paragliding Pilot and Full Stack Developer. He founded serial enterprises with strong technical background and rich social network experience. He is also the organizer of the meetup. Hailiang WANG is the leader of Rockq Community and a chatbot developer. He used to work in IBM Innovation Center and the Development Labs. Now he works for Lingling English and in charge of the AI Lead. Yu XIANG, a Tech geek, employed by the Lenovo Group and he’s also a full- stack developer. He involved a lot of experience about web crawler, 3D Printing and front-end development . As a wechaty contributor, he realized the function of sending pictures. Jiarui LI, full-stack developer and chatbot developer, also funder of  OrangeInteraction. Fascinated with Jazz, she set up a dancing community in her spare time, and the videos are played more than 10 million times. She is a wechaty contributor too, and an organizer of the wechaty community as well. Lianxiang LIU, funder of DotEngine, he is a continuous entrepreneur in the domain of RTC. Yang BAI, majored in French at her university but works as a marketing specialist. She is the formal community manager and marketing specialist of Juejin, a technical community. At present, she works at  tag Design, and responsible for planning and organizing activities. Lei ZHAO, born in 1996, he is still a college junior student. Doing well in Python and Web Crawler, as well as the framework of digitalized campus, he is addicted to the system of investment bank’s quantitative-trading. All these influence his major for studying abroad. It is such an honor to meet all these guys and I really appreciate for their sharing. Hope more and more meetups will be started. Here is the video.  Here is the Chinese version. 4 月 21 日，周五，在北京这个妖风四起满世界柳絮的春天，跟几个朋友一起吃了顿饭。 虽然讲是“吃饭”，其实主要是跟几个技术圈的朋友聊聊天，互通有无，搞技术的人，最怕故步自封，多交流才能保持进步，吃饭只是顺便的事儿。 下午 7 点，虽然晚高峰，但是大家都很给力，如约到达了事先约好的地方。其实这次线下聚会的 7 个人并非都是互相熟悉的，所以刚开始见面的时候，颇有种“见网友”的感觉，好在开发者谈起技术问题来，就满腔热忱，口若悬河，所以大家很快就熟悉了。 简单介绍一下大家： 李卓桓：PreAngel 投资人。zixia BBS、叽歪网创始人，优酷网首席科学家，水木清华BBS站长。清华大学本科，中欧国际工商学院EMBA。清华企业家协会移动互联网副主席，中欧移动互联网协会发起人。 王海良：Rockq 社区领袖，呤呤英语 AI Lead，曾就职 IBM 创新中心、研发中心，他也是 Chatbot 开发者。 向宇：Tech geek，全栈开发工程师，就职于联想。对爬虫，3D打印，前端开发，网络等方向积累丰富经验。他也是 wechaty contributor，贡献了 wechaty 发送图片功能。 李佳芮：全栈开发、chatbot 开发者，桔子互动创始人，爵士舞爱好者，业余创建舞蹈社群，全网播放过千万，wechaty contritubor，wechaty 社群发起人。 刘连响：DotEngine 创始人， 音视频实时通信领域连续创业者。 羊三岁： 前掘金社区运营、市场策划，掘金翻译计划负责人，目前就职于 tag Design ，负责市场活动和内容运营，是一个会讲法语的市场妹子。 赵磊：96 年大三小鲜肉，擅长 Python 网络及爬虫开发，大型数字化校园系统架构开发，钟情研究投行量化交易系统，并希望以此作为出国读研学习方向。 很开心大家能聚在一起，共同探讨技术问题并增进对彼此的了解，希望日后能多一些线下交流的机会。 Author: Yang BAI, formal community manager at JueJin(Chinese Hacker News) "
    }, {
    "id": 408,
    "url": "https://wechaty.js.org/2017/04/21/interact-wechaty-with-ruby-on-rails-from-scratch/",
    "title": "Interact Wechaty with Ruby on Rails from scratch",
    "body": "2017/04/21 -   Ruby on Rails is a extremely powerful web framework with a long history, which can simplify our development process, making it more enjoyable. As it known to all, many well-known sites are built on this framework, such as GitHub, Unsplash, Airbnb, Dribbble and Product Hunt1. For most developers without so much experience about Rails, setting up a development environment for this stack is not a easy task. This blog would introduce how to interact Wechaty with Rails with an example of a group message logger, trying to Keep it simple, stupid (the KISS principle). Note: This blog will mainly illustrate the tutorial on macOS. The situations can be very different on other platforms such as Windows and Linux. Due to the limitations of this author’s time, these topics cannot be covered. Moreover, the final version of code has been published on GitHub: https://github. com/imWildCat/blog-post-interact-wechaty-with-rails-from-scratch Prerequisites: Ruby and Rails: It is better to manage Ruby versions with rbenv. On macOS, # Install brew (https://brew. sh):➜ /usr/bin/ruby -e  $(curl -fsSL https://raw. githubusercontent. com/Homebrew/install/master/install) # Install rbenv (a Ruby version manager, https://github. com/rbenv/rbenv):➜ brew install rbenv ruby-build# Install Ruby (2. 4. 1)➜ rbenv install 2. 4. 1➜ gem install rails --pre --no-ri --no-rdocCheck your Ruby runtime: ➜ ruby -vruby 2. 4. 1p111 (2017-03-22 revision 58053) [x86_64-darwin16]# Or something like thatNode. js: # Install node. js with nvm (if you have installed node. js, skip this step):➜ brew install nvm &amp;&amp; nvm install v7. 9. 0Check your node. js runtime: ➜ node -vv7. 9. 0# Any node. js version above 6. 0 is fine :)PostgreSQL (Optional): PostgeSQL is a database, usually used for Rails apps. On macOS, it is recommended to use Postgres. app. It can also be installed by brew: ➜ brew cask install postgresHowever, it doesn’t matter if you use MySQL or even SQLite. This tutorial offers this flexibility to use any database supported by ActiveRecord (the ORM framework of Rails). Get started for Wechaty: First of all, we prefer to create a directory for our project: mkdir chatiemecd chatiemeIn this directory, firstly, create a directory for Wechaty, naming it chatieme-worker and setting up the project: mkdir chatieme-workercd chatieme-workernpm init -yAdd dependencies for wechaty: npm i --save wechaty chromedriver requestThen create a new file named bot. js with this code base: import { Wechaty } from 'wechaty';function startBot() {  const bot = Wechaty. instance({ profile: 'chatieme' });  bot. on('scan', (url, code) =&gt; console. log(`Scan QrCode to login: ${code}\n${url}`))    . on('login', user =&gt; console. log(`User ${user} logined`))    . on('message', message =&gt; console. log(`Message: ${message}`))    . init();}startBot();Since we’d like to send the message to Rails app, we have to build a JSON object: import { Wechaty } from 'wechaty';function startBot() {  const bot = Wechaty. instance({ profile: 'chatieme' });  bot. on('scan', (url, code) =&gt; console. log(`Scan QrCode to login: ${code}\n${url}`))    . on('login', user =&gt; console. log(`User ${user} logined`))    . on('message', onMessage)    . init();}function onMessage(message) {  const room = message. room();  const sender = message. from();  const receiver = message. to();  const content = message. content();  if (!room || !receiver) {    // onPersonalMessage(message);    return;  }  const topic = room. topic();  const from_name = sender. name();  const data = {topic, from_name, content};  console. log(data);}startBot();Run the bot node bot. js, logging in with your WeChat account. The output can be like: { topic: 'wechaty', from_name: 'WildCat', content: 'Hello, World!' }Get started for Rails: Go back to the parent directory, create a rails project with rails command line, then enter this directory: cd . . rails new chatieme-workercd chatieme-workerThen you could create the database, regardless what database you use: ➜ rails db:createCreated database 'db/development. sqlite3'Created database 'db/test. sqlite3'First of all, a model for message should be created. Rails offers command line tool to accelerate the process of creating code base (i. e. ‘rails –help’)2: ➜ rails generate model Message topic:string from_name:string content:textRunning via Spring preloader in process 38447   invoke active_record   create  db/migrate/20170421120013_create_messages. rb   create  app/models/message. rb   invoke  test_unit   create   test/models/message_test. rb   create   test/fixtures/messages. ymlIn fact, the model file app/models/message. rb doen’t contain any code about the structrure of the database. The migration file db/migrate/20170421115650_create_messages. rb (in your case, the file name should be different in relation to your date &amp; time) contains the structure: class CreateMessages &lt; ActiveRecord::Migration[5. 1] def change  create_table :messages do |t|   t. string :topic   t. string :from_name   t. text :content   t. timestamps  end endend Ruby is a ‘natural’ programming. You can easily understand these codes with a little bit experience of other programming language. Then migrate the database to latest version: rails db:migrateYou could see the structure of the sqlite database file db/development. sqlite3: While using rails console to open a REPL3 for your Rails project, we can create a data record easily by Message. create! topic: 'My Group Name', from_name: 'HailCat', content: 'Hiya, World!': ➜ rails consoleRunning via Spring preloader in process 39120Loading development environment (Rails 5. 1. 0. rc2)irb(main):001:0&gt; Message. create! topic: 'My Group Name', from_name: 'HailCat', content: 'Hiya, World!'  (0. 1ms) begin transaction SQL (0. 8ms) INSERT INTO  messages  ( topic ,  from_name ,  content ,  created_at ,  updated_at ) VALUES (?, ?, ?, ?, ?) [[ topic ,  My Group Name ], [ from_name ,  HailCat ], [ content ,  Hiya, World! ], [ created_at ,  2017-04-21 12:09:49. 440133 ], [ updated_at ,  2017-04-21 12:09:49. 440133 ]]  (0. 6ms) commit transaction=&gt; #&lt;Message id: 1, topic:  My Group Name , from_name:  HailCat , content:  Hiya, World! , created_at:  2017-04-21 12:09:49 , updated_at:  2017-04-21 12:09:49 &gt;At present, the code base has been set up and the directories would look like: ➜ cd . . ➜ tree -L 2. ├── chatieme-server│   ├── Gemfile│   ├── Gemfile. lock│   ├── README. md│   ├── Rakefile│   ├── app│   ├── bin│   ├── config│   ├── config. ru│   ├── db│   ├── lib│   ├── log│   ├── package. json│   ├── public│   ├── test│   ├── tmp│   └── vendor└── chatieme-worker  ├── bot. js  ├── chatieme. wechaty. json  ├── node_modules  └── package. json13 directories, 9 filesLet Wechaty communicate with Rails: Basicially, Rails is a web framework so that the most usual way for the communication is by HTTP (web). We hope there can be an architecture like this: Both Rails and Wechaty can be regarded as micro services, which can also be dockerized4 in the coming blogs. The most consierable advantage of this kind of architecture is that more than one Wechaty instances can share a single Rails app: So, let’s do it. Set up API of Rails: We need to create a controller to handle the HTTP requests about creating new Message record: ➜ rails generate controller MessagesRunning via Spring preloader in process 41917   create app/controllers/messages_controller. rb   invoke erb   create  app/views/messages   invoke test_unit   create  test/controllers/messages_controller_test. rb   invoke helper   create  app/helpers/messages_helper. rb   invoke  test_unit   invoke assets   invoke  coffee   create   app/assets/javascripts/messages. coffee   invoke  scss   create   app/assets/stylesheets/messages. scssEdit app/controllers/messages_controller. rb: class MessagesController &lt; ApplicationController  skip_before_action :verify_authenticity_token, :only =&gt; [:create]  def create    message_params = params. permit(:topic, :from_name, :content)    new_message = Message. new message_params    if new_message. save      render json: {error: nil}    else      render json: {error: true, error_message: new_message. errors. full_message}    end  endendThen edit config/routes. rb: Rails. application. routes. draw do # For details on the DSL available within this file, see http://guides. rubyonrails. org/routing. html post 'messages', to: 'messages#create'end Note: I would not explain detailed Rails app development because it is off the main topic. Run the development server of Rails: ➜ rails server=&gt; Booting Puma=&gt; Rails 5. 1. 0. rc2 application starting in development on http://localhost:3000=&gt; Run `rails server -h` for more startup optionsPuma starting in single mode. . . * Version 3. 8. 2 (ruby 2. 4. 1-p111), codename: Sassy Salamander* Min threads: 5, max threads: 5* Environment: development* Listening on tcp://0. 0. 0. 0:3000Use Ctrl-C to stopWe can test the API provided by Rails app using curl: ➜ curl -X POST -F 'topic=This is topic' -F 'from_name=HailCat' -F 'content=This is content' http://localhost:3000/messages{ error :null}%POST the data from Wechaty to Rails: We could take advantages of the library request, posting the data to Rails: import { Wechaty } from 'wechaty';import request from 'request';function startBot() {  const bot = Wechaty. instance({ profile: 'chatieme' });  bot. on('scan', (url, code) =&gt; console. log(`Scan QrCode to login: ${code}\n${url}`))    . on('login', user =&gt; console. log(`User ${user} logined`))    . on('message', onMessage)    . init();}function onMessage(message) {  const room = message. room();  const sender = message. from();  const receiver = message. to();  const content = message. content();  if (!room || !receiver) {    // onPersonalMessage(message);    return;  }  const topic = room. topic();  const from_name = sender. name();  const data = { topic, from_name, content };  console. log(data);  // New code starts  request. post({    url: 'http://localhost:3000/messages',    form: data  },    function (err, httpResponse, body) {      console. log(body);    });  // New code ends}startBot();Restart Wechaty node bot. js. Wechaty can post any group messages to Rails. A simple logger has been finished. Add admin panel for Rails: Recording messages in database is far from enough, initially, we need a admin panel helping us manage the data. RailsAdmin is a choice to build a simple control panel with a few lines of code. To get started, add gem 'rails_admin' into your Gemfile of Rails project: # Gemfile# . . . A lot of other codes abovegem 'rails_admin'gem 'erubis'Stop Rails development server and run bundle install to install the dependency: ➜ bundle install. . . a lot of lines above . . . Using rails 5. 1. 0. rc2Using sass-rails 5. 0. 6Installing rails_admin 1. 1. 1Bundle complete! 17 Gemfile dependencies, 79 gems now installed. Use `bundle show [gemname]` to see where a bundled gem is installed. Run rails g rails_admin:install. Then run rails server to start Rails development server. Visit http://localhost:3000/admin, you can see an awesome admin pannel of this logger: Conclusion: This blog should be a very specific tutorial for developers who want to build a message logger for WeChat. Rails is a fullstack web framework so that it can be very complex. Explaining the comcepts of Rails is not the main purpose of this blog. However, if you would like to build a powerful logger, it is worthy doing that. Powered by Rails, you can build the system with less time consumption and more joy. Thanks for your reading. Feel free to drop any questions. References: Author: @imWildCat, University of Portsmouth       Rails, StackShare: https://stackshare. io/rails &#8617;        The Rails Command Line — Ruby on Rails Guides: http://guides. rubyonrails. org/command_line. html &#8617;        Read–eval–print loop - Wikipedia: https://en. wikipedia. org/wiki/Read–eval–print_loop &#8617;        Docker (software) - Wikipedia: https://en. wikipedia. org/wiki/Docker_(software) &#8617;    "
    }, {
    "id": 409,
    "url": "https://wechaty.js.org/2017/04/16/how-chatie-is-used-in-haoshiyou-project/",
    "title": "用Chatie实现微信机器人商业逻辑之【好室友】群管理篇",
    "body": "2017/04/16 - 为了帮助新来硅谷的朋友找室友和租房，我们在所在地区组建了若干微信群。我们对这个项目的基本理念是简单专注，用完即走。 我们的应用场景是这样的：我们一共有数个微信群，按照硅谷旧金山湾区的几个租房区域进行分群，每个微信群常年满上限500人。我们要求入群的朋友修改群昵称，我们每周要按照一定的规则将不按照要求修改群昵称的群友和最早入群的人踢出，以实现群员的流动，确保群里都是最近有租房需求的朋友而不是许多租房群常见的僵尸群情况。 另外，我们不允许发布任何与租房无关的信息：广告、二手交易、机票信息等常见扩散信息都被视为禁止类型。在群管理员志愿者们的共同努力下，我们群在湾区朋友中间以简洁活跃赢得了相当不错的口碑，被常常被湾区的群友介绍给自己新来湾区的朋友。也是因为我们群初具规模，吸引了各种希望混入大群散发广告的各种运营号、广告号和宣传号。经常有人进入我们的微信群发布广告消息和无关消息，我们对于这种情况会予以警告直至踢出群并加入黑名单。 在使用机器人之前，我们的管理员志愿者们，每天需要手动登录手机，接受好友请求，然后根据相应的规则对群进行管理。由于加群请求巨大，群多而复杂，因此还经常要首先回答用户的问题再根据用户的意向分配进入相应的群。删除群好友的事儿也需要花费比较长的时间。 在得知Chatie之后，我们立即使用Chatie的接口开发了机器人来进行群的管理工作，大大简化了管理员志愿者们的工作流程和负担。我们这里介绍一下我们的业务逻辑模块。 逻辑模块: 1. 自动接受好友请求: 我们会自动接受所有用户加好友的请求，并发送问候消息，我们会在问候消息中解释我们群的群规和分区规划，以及如何回复意向进行加群。 exports = module. exports = async function onFriend(contact, request) { // . . .  if (request) { // 1. request to be friend from new contact  await request. accept();  await contact. say(greetingsMsg); } // . . . }2. 关键字确认用户的加群意向: 我们利用关键字来确认用户的加群意向，在确认了用户想加哪个群之后，会先确认群是不是满了，如果满了会先进行清理，然后在加群。 let maybeAddToHsyGroups = async function(m:Message):Promise&lt;Boolean&gt; { const contact = m. from(); const content = m. content(); const room = m. room(); let groupType:HsyGroupEnum; // only to me or entry group if (WechatyApiX. isTalkingToMePrivately(m) || /好室友. *入口群/. test(m. room(). topic())) {  let groupToAdd:HsyGroupEnum = null;  if (/加群/. test(content)) {   await m. say(greetingsMsg);   return;  } else {   groupToAdd = HsyUtil. getAddGroupIndentFromMessage(content);  }  if (groupToAdd != HsyGroupEnum. None) { // found no valid group   // . . .    let keyRoom = await HsyUtil. findHsyRoomByEnum(groupToAdd);   if (keyRoom) {    await maybeDownsizeKeyRoom(keyRoom, contact);    await keyRoom. add(contact);   }  }  return true; } return false;};// inside of HsyUtilpublic static getAddGroupIndentFromMessage = function(  content:string):HsyGroupEnum { if (/南湾西|Mountain View|mtv|sv|Sunnyvale|Palo Alto|Stanford|Facebook|Google|Menlo Park/. test(content)) {  return HsyGroupEnum. SouthBayEast; } else if (/南湾东|Milpitas|San Jose|Santa Clara|SJ|Campbell|Los Gatos/. test(content)) {  return HsyGroupEnum. SouthBayWest; } else if (/东湾|奥克兰|伯克利|Berkeley|Fremont|Hayward|Newark/. test(content)) {  return HsyGroupEnum. EastBay; } else if (. . . ) {  . . .  } else return HsyGroupEnum. None;}3. 基于群昵称和入群顺序进行群满自动踢人: 我们会检查每个管理的群，如果用户人数超过一个阈值（例如450人），就会触发削减群人数的函数。首先我们会寻找没有按照要求修改群昵称的群友，跳过管理员和群主以及机器人自己，从中间找出若干人（例如20个人），然后在从最早入群的用户中选择若干人（例如10人），作为踢出列表。我们会在群里宣布我们即将踢出人，以及踢人的原因（未修改区昵称和最早入群），然后私下告诉每个被踢的人具体被踢的原因，之后执行踢人。 let maybeDownsizeKeyRoom = async function(keyRoom: Room, c:Contact) { if (/老友/. test(keyRoom. topic())) return; if (keyRoom. memberList(). length &gt;= groupDownSizeTriggerThreshold) { // triggering  await keyRoom. say(hsyGroupClearMsg);  for (let i = 0; i &lt; keyRoom. memberList(). length - newComerSize/* never newComer */; i++) {   let c:Contact = cList[i];   if (c. self()) continue; // never does anything with haoshiyou-admin itself.    let groupNickName = WechatyApiX. getGroupNickNameFromContact(c);   if (/^(管|介|群主)-/. test(groupNickName) || /管理员/. test(c. alias())) {    // pass, never remove   } else if (/^(招|求)租/. test(groupNickName)) {    // good format, but need to rotate    potentialRotationList. push(c);   } else {    noGroupNickNames. push(c);   }   if (noGroupNickNames. length &gt;= shouldRemoveSize) {    shouldRemoveList = noGroupNickNames;    break;   } else if (noGroupNickNames. length + potentialRotationList. length &gt;= shouldRemoveSize) {    shouldRemoveList = noGroupNickNames      . concat(potentialRotationList. slice(0,        shouldRemoveSize - noGroupNickNames. length));    break;   }  }  if (shouldRemoveList. length &gt; 0) {   await c. say(`群里有点儿满，我先清一下人哦`);  }  await Promise. all(shouldRemoveList. map(async (c:Contact) =&gt; {   let msg = (`亲，我们要清人了哦`);   await c. say(msg);   await keyRoom. del(c);  })); }};4. 按照管理员的发言来加黑名单: 我们目前在微信里面加黑名单的流程是，首席先如果用户在群里发了什么无关信息或者长期没有修改群昵称，我们挂管理员可以在群里发消息说“@某用户，请不要发无关消息”，或者“@某用户，请修改群昵称”这样的口令将首先被机器人重复一遍“感谢管理员张三，@某用户请不要发无关消息”，以增加管理员在群里发言的威信，同时机器人会私信管理员询问是否要把该用户加入黑名单并提出，如果管理员回复确认，就会启动加黑名单和踢人逻辑。目前，我们管理黑名单的方式是在机器人的微信里把某位好友的备注加上#黑名单。 逻辑如下 let maybeBlacklistUser = async function(m: Message):Promise&lt;Boolean&gt; { if (! await HsyUtil. isHsyAdmin(m. from())) {  return false; // Not an admin } let admin = m. from(); if(WechatyApiX. isTalkingToMePrivately(m)   &amp;&amp; /加黑名单/. test(m. content())) {  // find the last one being marked blacklist by this admin  let blackListObj = GLOBAL_blackListCandidates[admin. alias()];  // not able to find a blacklist candidate.   if (blackListObj === undefined || blackListObj === null) return false;  if (blackListObj !== null &amp;&amp; blackListObj !== undefined) {    let indexOfCandidate = m. content(). slice(4); // 加黑名单1 取编号    let contactToBlacklist:Contact = blackListObj. candidates[indexOfCandidate];    await HsyUtil. addToBlacklist(contactToBlacklist);    let teamRoom = await HsyUtil. findHsyBigTeamRoom();    await HsyUtil. kickFromAllHsyGroups(contactToBlacklist);    await admin. say(`搞定!`);  }  return true; } else if (m. room() !== null &amp;&amp;   /好室友/. test(m. room(). topic()) &amp;&amp;   /无关|修改群昵称/. test(m. content()) &amp;&amp;   /^@/. test(m. content())) {  let mentionName = m. content(). slice(1)/*ignoring@*/    . replace(   /*Space Char in Chinese*/,    ). split(   )[0];  let foundUsers = findMemberFromGroup(m. room(), new RegExp(mentionName));  if (foundUsers. length &gt; 0) {   // Repeat the warning from the admin   await m. room(). say(`感谢管理员@${m. from(). name()}\n\n${m. content()}`);   let buffer = `管理员 ${m. from(). name()}，你好，你刚才在${m. room(). topic()}这个群` + `里警告了用户@${mentionName}，符合这个名称的群内的用户有：\n`;   for (let i = 0; i &lt; foundUsers. length; i++) {    let candidate = foundUsers[i];    buffer += `${i}. 昵称:${candidate. name()}, 备注:${candidate. alias()}, ` +      `群昵称: ${WechatyApiX. getGroupNickNameFromContact(candidate)} \n`;   }   buffer += `请问要不要把这个用户加黑名单？五分钟内回复  加黑名单[数字编号] \n`;   buffer += `例如  加黑名单0 ，将会把${foundUsers[1]} ` +     `加入黑名单:${WechatyApiX. contactToStringLong(foundUsers[0])}`;   await m. from(). say(buffer);   GLOBAL_blackListCandidates[m. from(). alias()] = {    time: Date. now(),    candidates: foundUsers   };  } else {   await admin. say(`管理员您好，您刚才在 ${m. room(). topic()} 群里要求踢出的用户 ${mentionName}  `+     `我们没有找到，请在确认该用户仍然在该群里，并且请在同一个群尝试at他的昵称而不是群昵称。`);  }  return true; } return false;};后记: 在本篇里我们介绍了我们如何应用Chatie实现【好室友】系列租房群的一系列日常管理任务，大大简化了管理员的工作量，也提高和改善了用户在群里的体验。我们将在未来的文章中介绍我们如何利用Chatie的可编程接口来实现微信和我们开发的网站和APP实现数据和信息互通。 撰写本文的时候，本文所描述的好室友机器人（haoshiyou-bot）代码处在这里 "
    }, {
    "id": 410,
    "url": "https://wechaty.js.org/2017/04/13/support-message-type-of-image-and-video/",
    "title": "给机器人添加发送图片视频功能",
    "body": "2017/04/13 - 公司活动，需要对入群用户进行管理和自动回复。前期在Node Party Beijing上接触到 @huan 的分享，Wechaty刚好能支持该活动，支持Docker部署，是一个很棒的Bot Framework。 开发过程中发现，#4 Support Message Type of Image/Video此功能还未实现，决定完成该项特征。 1. 问题分析: 为解Web微信是如何发送图片的，进行了数据抓包，并分析微信Web源码 onSuccess: function(e) {  if (0 == e. BaseResponse. Ret) {    var o = this. MMSendMsg;    o. MediaId = e. MediaId,    s. sendMessage(o),    t. $apply(function()      o. MMFileStatus = a. MM_SEND_FILE_STATUS_SUCCESS    })  } else    this. onError( Ret:   + e. BaseResponse. Ret)},Web中Message是通过此函数创建的，图片消息会被添加MediaId属性，因此如果我们能取得需要上传文件的MediaId，就可以直接调用sendMessage发送图片了。 2. 上传图片: 通过抓包，发现图片被POST请求发送到 https://file. wx. qq. com/cgi-bin/mmwebwx-bin/webwxuploadmedia?f=json搜索源码，找到 API_webwxdownloadmedia:  https://  + o +  /cgi-bin/mmwebwx-bin/webwxgetmedia ,API_webwxuploadmedia:  https://  + o +  /cgi-bin/mmwebwx-bin/webwxuploadmedia ,API_webwxpreview:  /cgi-bin/mmwebwx-bin/webwxpreview ,API_webwxuploadmedia就是图片上传地址，全局搜索这个变量是不是就可以找到上传文件的方法呢？经过搜索 window. WebUploader = e;Y = e. create({    auto: !0,    dnd:  #chatArea ,    paste: f. browser. webkit ?  #chatArea  : void 0,    swf: c. RES_PATH +  third_party/webuploader-0. 1. 5/Uploader. swf ,    server: c. API_webwxuploadmedia +  ?f=json ,    fileVal:  filename ,    pick:  . js_fileupload ,    compress: !1,    duplicate: !0,    threads: 1,    chunked: !0,    chunkSize: 524288})e就是webuploader，处理文件上传，单独打包在一个chunk里。由于控制游览器读取本地文件没有什么好的处理办法，所以决定通过使用直接post数据到此地址的方式进行文件上传，该请求并没有上传cookie信息，因此省去了很多麻烦。各个参数都可以直接调用Web信息获取到 let uploadMediaRequest = {   BaseRequest: baseRequest,   FileMd5: md5,   FromUserName: this. self(). id,   ToUserName: toUserName,   UploadType: 2,   ClientMediaId: +new Date,   MediaType: UploadMediaType. ATTACHMENT,   StartPos: 0,   DataLen: size,   TotalLen: size,}let formData = {   id: 'WU_FILE_1',   name: filename,   type: contentType,   lastModifiedDate: Date(). toString(),   size: size,   mediatype,   uploadmediarequest: JSON. stringify(uploadMediaRequest),   webwx_data_ticket: webwxDataTicket,   pass_ticket: passTicket || '',   filename: '文件数据',}返回结果为 { BaseResponse : { Ret : 0, ErrMsg :   }, MediaId :  @crypt_cd2308ca_e13f71eeb3879a52f58935743a1008b609f391eaa6bfcce5de32d9c523f934224a5327a37ad85ce2ad76f055d0205d17a6c1a7afe7200a1051a7eed41dd6d8696b43a3e61d8836759b30df3c9fb7abf9d89be37cb1ce787e22d1e947e4227beeb323937471d5c0548b976dcd22e3361694ac3ea53389b6185714a7cbf4ee40430c01925415804d758411ddf73ee6679c1ddea340455ed7eb803733f28c4b4e14b0218f84c5d938a01983b60e71a55131cb2d77f52ba3938089c7606d86078d1a7a097788ea7ed411d2f34889590ff49b2100a5942919d4256b9cb1f2032593268997957928350338ec1a3c50d2a64cd811c0227c4c4789ced408f64ac99f2ee64d4a59d415857205ea30bd74bb425d49ae0dfb6524d67d5d71e2dbea635db99be32dd8ca13f7b5fe14df96fbd0fd19b59fe5431451861a31e7d3754039f6f52e , StartPos : 19482, CDNThumbImgHeight : 100, CDNThumbImgWidth : 100}MediaId就是我们需要的，直接调用createMessage,sendMessage即可发送图片了。 3. 整合Wechaty: 为快速验证可行性，直接添加了Wechaty. sendMedia。后和@huan @lijiarui讨论，决定使用say(MediaMessage(filename))的形式发送媒体文件。重载 Wchaty. send(message: MediaMessage)Contact. say(mediaMessage: MediaMessage)Message. say(mediaMessage: MediaMessage)//准备后续添加Room. say(mediaMessage: MediaMessage)4. 坑:    测试期间发现，发送图片有时候会失败，原因是无法获取mediaId，第一感觉是，难道还有细节没有发现?对比post数据，完全一致，没有问题，那问题出在哪呢？   后来看源码才发现   var e = location. host , t =  weixin. qq. com  , o =  file. wx. qq. com  , n =  webpush. weixin. qq. com ; e. indexOf( wx2. qq. com ) &gt; -1 ? (t =  weixin. qq. com , o =  file2. wx. qq. com ,    原来还有个地址是wx2. qq. com。对应的文件上传地址是file2. wx. qq. com。不仔细啊   另一个坑是微信Web对视频大小有20M限制，这个也是开始没有注意的，发送大视频会失败 循环依赖 由于MediaMessage继承Message，Message. say(MediaMessage)又需要引用MediaMessage. OMG,循环引用,TS报错了不支持这么玩～ 所以我把MediaMessage移入了message. ts,删除了media-message. ts,无中生有了186行变更😊5. End: 现在Wechaty支持发送图片(bmp,jpg,png)视频(mp4)和其他文件。图片和视频是可以在聊天窗口直接查看的可以通过在ding-dong-bot里回复code来收到一张图片二维码。 作者：@mukaiu, Wechaty Contributor "
    }, {
    "id": 411,
    "url": "https://wechaty.js.org/2017/03/20/added-hot-reload-for-bots/",
    "title": "给微信机器人添加热重启功能",
    "body": "2017/03/20 -  Wechaty解决了很多我在使用微信运营过程中的痛点问题，这里就不再一一赘述了。同时Wechaty的API设计简洁优雅，部署方便也是另外一个吸引我的地方。 快速上手后，在开发调试过程中，修改代码需要频繁重启Wechaty程序。相信绝大多数人都有着类似的问题， 下面就聊一聊怎么避免类似问题。 1. 问题分析: 在开发调试过程中，修改代码后必须重启Wechaty程序。每次重启大概会花上30s-60s左右。还需要开发者频繁扫码登陆，对于在调试阶段的程序来说，成本还是很高的。因此考虑从这里入手看能否优化这里的启动时间。 对于扫码登陆的问题，从Wiki中找到答案：  Wechaty. instance(profile:string): Wechaty  profile(OPTIONAL): profile name. if a profile name is provided, wechaty will save login status to it, and automatically restored on next time of wechaty start(restart).    can be set by environment variable: WECHATY_PROFILE 也就是说设置一个profile就可以记住登录态，避免重启时的重复扫码动作。扫码问题可以得到解决，那么30-60s的启动时间是否还可以进一步优化呢？那就得弄清楚这30s的时间里，程序都在做什么。 通过查看源代码 browser-driver. ts 发现，在执行init时，程序会启动一个driver，可以看作是打开了一个浏览器，然后获取浏览器 session，重复尝试三次直到失败。这里是Wechaty运行的基础，我们没有办法从这里去避免这30s的时间开销。只能从另外的方面去思考。 2. Node. js 热重启: 这里实际就是Node. js本身的特性了，与Wechaty本身关联不大。可能通过监听文件改动从而动态加载模块内容，这里首先就要了解Node. js的模块缓存机制，参看module. js关键代码： // Check the cache for the requested file. // 1. If a module already exists in the cache: return its exports object. // 2. If the module is native: call `NativeModule. require()` with the//  filename and return the result. // 3. Otherwise, create a new module for the file and save it to the cache. //  Then have it load the file contents before returning its exports//  object. Module. _load = function(request, parent, isMain) {  if (parent) {    debug('Module. _load REQUEST %s parent: %s', request, parent. id);  }  var filename = Module. _resolveFilename(request, parent, isMain);  var cachedModule = Module. _cache[filename];  if (cachedModule) {    return cachedModule. exports;  }  if (NativeModule. nonInternalExists(filename)) {    debug('load native module %s', request);    return NativeModule. require(filename);  }  var module = new Module(filename, parent);  if (isMain) {    process. mainModule = module;    module. id = '. ';  }  Module. _cache[filename] = module;  tryModuleLoad(module, filename);  return module. exports;};require. cache = Module. _cache;如果Node. js已经require某个模块后，模块更新后，再次require这个模块时，实际读取的是内存中的原模块的缓存。除非手动清除掉require. cache的内容，这样才能重新加载更新后的模块内容。因此参照Node. js源码写出require缓存清除方法： // purge require cacheconst purgeCache = (moduleName) =&gt; {  var mod = require. resolve(moduleName);  if (mod &amp;&amp; ((mod = require. cache[mod]) !== undefined)) {    (function traverse(mod) {      mod. children. forEach(function (child) {        traverse(child);      });      delete require. cache[mod. id];    }(mod));  }  Object. keys(module. constructor. _pathCache). forEach(function(cacheKey) {    if (cacheKey. indexOf(moduleName)&gt;0) {      delete module. constructor. _pathCache[cacheKey];    }  });};再利用fs. watch或者chokidar之类的库完成文件监听功能，实现文件改动后重新加载模块： fs. watch('. /somedir', (e, filename) =&gt; {   purgeCache(`. /somedir/${filename}`);   require(`. /somedir/${filename}`);});3. 逻辑抽离: 在使用Wechaty的时候，开发者更多的是关心事件响应，比如响应扫码事件、好友请求事件、发送消息事件等等。因此可以单独将这些响应事件抽离出来。如果我需要关注好友请求事件，那么我就添加一个friend. js去处理。如果我需要关注发消息事件，那么就去添加一个message. js去处理。相反，不需要了我删除掉该js文件即可。每一个文件就是一个事件处理器。代码如下： const EVENT_LIST = ['scan', 'logout', 'login', 'friend', 'room-join', 'room-leave', 'room-topic', 'message', 'heartbeat', 'error'];let eventHandler = {};// Load lisenterconst loadListener = (evt) =&gt; {  let fn;  try {    fn = require(`. /listener/${evt}`);    console. log(`binded listener: ${evt}`);  } catch (e) {    fn = () =&gt; void 0;    if (e. toString(). indexOf('Cannot find module') &gt; -1) {      console. warn(`listener ${evt} is not defined. `);    } else {      console. error(e);    }  }  return fn;}// Bind eventsEVENT_LIST. forEach(evt =&gt; {  eventHandler[evt] = loadListener(evt);  bot. on(evt, eventHandler[evt]);});4. 整合: 接着就是整合逻辑代码与热重启功能，让每个事件处理器都具有热重启功能。 fs. watch('. /listener', (e, filename) =&gt; {  let evt = filename. substring(0, filename. length - 3);  console. log(`${e}: ${filename}`);  if (EVENT_LIST. indexOf(evt) &gt; -1) {    if (e === 'change') {      console. log(`${evt} listener reloaded. `);      purgeCache(`. /listener/${evt}`);      // It may read an empty file, if not use setTimeout      setTimeout(() =&gt; {        bot. removeListener(evt, eventHandler[evt]);        //console. log('filecontent: ' + fs. readFileSync(`. /listener/${evt}. js`));        eventHandler[evt] = loadListener(evt);        bot. on(evt, eventHandler[evt]);      }, 1000);    } else if (e === 'rename') {      console. log(`${evt} listener removed. `);      bot. removeListener(evt, eventHandler[evt]);      eventHandler[evt] = () =&gt; void 0;      bot. on(evt, eventHandler[evt]);    }  }});检测到. /listener目录下的文件改动后，自动删除原来事件监听并且更新，这样就完美的实现了Wechaty免重启开发调试了。 最后，还需要一个环境变量来区分开发模式和线上模式，在线上模式中就不需要使用热重启功能。 const isProd = process. env. NODE_ENV === 'production';if (isProd) {  fs. watch('. /listener', . . . . );}这样就可以通过以下命令来进入开发模式或者线上模式了。 // developmentdocker run -ti --rm --volume= $(pwd) :/bot zixia/wechaty index. js// productiondocker run -ti -e NODE_ENV=production --rm --volume= $(pwd) :/bot zixia/wechaty index. js附热重启机器人效果图： 到这里就基本介绍完了本篇文章的全部内容了，可以使用example代码来体验。 作者：@Gcaufy, Tencent, Wechaty Contributor "
    }, {
    "id": 412,
    "url": "https://wechaty.js.org/2017/02/22/the-secret-lives-of-wechat-chatbots/",
    "title": "The secret lives of WeChat’s chatbots",
    "body": "2017/02/22 - Chatbots rocketed into the limelight last year, bolstered by the enthusiasm of Facebook and Microsoft, though the technology wasn’t mature yet. In China, however, the response was more muted. While Facebook was busy pushing its new Messenger app – boasting when it hit 11,000 bots – Tencent, the maker of WeChat, quietly let millions of accounts develop AI-powered bots of their own, keeping a wary eye out for abuse. Accounts like Cara, for example, are shut down, as Tencent wants to confine bots to customer service-related functions within brand accounts. But unsanctioned bots run amok on the social network, often tactlessly spamming groups or artificially inflating a brand’s likes and follows. The Chinese tech firm clamped down last year on thousands of accounts, denouncing the use of external software to alter WeChat. Tencent did not reply to queries about its policies on bots. Unlike WeChat’s “official” accounts, designed for commerce and media, these rogue bots hijack personal accounts. They can be purchased on Taobao, the country’s most popular online marketplace, for a couple of dollars or less. Some accounts are even “farmed” before they’re sold, which means they already have friends and have logged a certain amount of human-like activity, such as posting on Moments, WeChat’s newsfeed-like feature. “If I grow a WeChat account to 3,000 to 5,000 friends, one ad on my Moments could be worth between [US$14 to US$140],” explains Li Jiarui, a Javascript and WeChat bot developer based in Beijing. “It depends on the quality of your account. ” More bots mean more WeChat accounts. This is another example of WeChat hacking: multiple apps installed on one device. Photo credit: Tencent. Jiarui doesn’t farm WeChat accounts, but she’s familiar with the industry. Account farming is driven by the needs of marketing and advertising agencies, as well as weishang, or “micro shops” run through personal WeChat accounts. Unlike brand accounts, personal accounts are easier to register and can participate in group chats. These shopkeepers often use their Moments to advertise all kinds of products, from imported baby powder to fake luxury handbags. “Because they often get shut down, we can learn a lot from their experience,” says Jiarui. Jiarui began developing WeChat bots about half a year ago to automate group management for her dance community on the messaging app. Her bot can automatically pull friends into groups and welcome new members, as well as hold basic conversations thanks to a Chinese natural language processing framework called Turing Robot. In fact, her chatbot is so popular that Tencent once chose it as a beta tester for WeChat. “They thought I was a serious WeChat addict,” she laughs. “They probably thought that I was on WeChat almost 24 hours a day, not doing much else. Because of my activity, they assumed I was a high-quality user. ” Jiarui says her bot, which has about 3,000 friends, receives more than 10,000 messages a day. Other chatbots, like “Micro Friend Assistant”, are also designed to tackle WeChat’s clunky group management system. Micro Friend Assistant lets group administrators set responses to keywords, automatically upload shared files to cloud storage, or even track and analyze group activity. But, like Cara, it too was shut down. “This Chinese New Year, I tested out a hongbao bot and then I was banned for like a week or so,” says an employee at a chatbot company, who requested anonymity. He forgot to program the bot to not be the first one to grab the red envelopes – a total bot giveaway. Adding too many friends in a short amount of time can also raise a red flag. Tencent is understandably opaque about its rules for catching bots to keep developers on their toes. But Jiarui has learned a few tricks from the app’s shopkeepers, such as using mobile data instead of wifi to send messages, and tying a bank card to the bot’s account. “Do your best to mimic a real account,” she advises. Chatbots should follow brand accounts, have a profile picture, post on Moments, and both proactively and passively make friends on the app. “Ideally have your friends add you first. And try to have these friends comment on the content in your Moments,” she says. At the moment, many WeChat bot developers rely on hacking the app’s web version. A quick search for “wechat bots” on Github pulls up multiple projects that can turn personal accounts into bots, such as Wechaty, the framework that Jiarui uses. However, that too has its limitations. Scraping the app’s web interface limits you to basic functions, such as sending messages and adding friends. “Web WeChat is this crippled, semi-supported project by Tencent,” emphasizes Alex, a freelance web developer who would only disclose his first name. You can only do about a quarter of what you can do with the mobile app, excluding all the “interesting features,” he says. “No hongbao […] and to re-login, you need to scan a QR code with phone,” Alex adds. Nevertheless, the commercial potential of chatbots has startups like Urbem, a WeChat-based restaurant recommendation and deals startup, interested in the technology. The startup’s account is already staffed with a bot that navigates Urbem’s database to recommend restaurants to its users. Urbem sees friendly chatbots as a way to generate leads from the various food groups it manages on WeChat. “We want to link this bot to the bot from our [brand] account’s knowledge base,” explains Steven Chen, founder and CEO of Urbem. “Then this bot [will be] interesting and knowledgeable, and people follow the bot. ” “Eventually, we would convert them to our WeChat account, so they can pay to be a member. That’s how we generate revenue,” he says. Given Tencent’s unforgiving stance towards rogue bots leaping into your messages, it’s uncertain how these bots, even those that have a positive impact or fulfill legitimate needs, will develop on the social network. Allowing unofficial bots to thrive on WeChat opens a Pandora’s box of possibilities, including AI of the Cara ilk. For now, bot developers will have to work hard to build increasingly human-like and believable messaging bots to slip under Tencent’s radar.  From: https://www. techinasia. com/wechat-unofficial-bots by Eva Xiao "
    }, {
    "id": 413,
    "url": "https://wechaty.js.org/2017/01/06/wechaty-101-presentation/",
    "title": "Wechaty 101: from v0.0 to v0.7",
    "body": "2017/01/06 - This talk was presented at Node Party Beijing #18 Dec 2016, all about ChatBots. My topic includes:  what does it do? why does it exist? how does it work? what’s in it for me? For visiters come from China who can not visit YouTube. com, this video is also hosted on YouKu. com &amp; Tencent Video:  Wechaty 101 @ YouKu Wechaty 101 @ TencentPresentation Slides: Here’s the slides of Wechaty 101 in this talk:  Wechaty 101 Slides is hosted on Google Slides(Docs) at here Learn more about Wechaty source code at: https://github. com/wechaty/wechaty "
    }, {
    "id": 414,
    "url": "https://wechaty.js.org/2017/01/01/getting-started-wechaty/",
    "title": "Getting Started with Wechaty - Live Coding Tutorial",
    "body": "2017/01/01 -  Wechaty is super easy to use, especially when you are using Docker. In this video, @lijiarui will show you how to getting started with Wechaty through a 10 minutes live coding tutorial, with Wechaty Docker Runtime. (Event Node. js Party #18, Beijing) For visiters come from China who can not visit YouTube. com, this video is also hosted on YouKu. com &amp; Tencent Video  Getting Started with Wechaty @ YouKu Getting Started with Wechaty @ TencentLearn more about how to use Wechaty: https://github. com/wechaty/wechaty/wiki/GettingStarted Code in the video: import {Wechaty, Room} from 'wechaty'const bot = Wechaty. instance()bot. on('scan', (url, code)=&gt;{  let loginUrl = url. replace('qrcode', 'l')  require('qrcode-terminal'). generate(loginUrl)  console. log(url)}). on('login', user=&gt;{  console. log(`${user} login`)}). on('friend', async function (contact, request){  if(request){    await request. accept()    console. log(`Contact: ${contact. name()} send request ${request. hello}`)  }}). on('message', async function(m){  const contact = m. from()  const content = m. content()  const room = m. room()  if(room){    console. log(`Room: ${room. topic()} Contact: ${contact. name()} Content: ${content}`)  } else{    console. log(`Contact: ${contact. name()} Content: ${content}`)  }  if(m. self()){    return  }  if(/hello/. test(content)){    m. say( hello how are you )  }  if(/room/. test(content)){    let keyroom = await Room. find({topic:  test })    if(keyroom){      await keyroom. add(contact)      await keyroom. say( welcome! , contact)    }  }  if(/out/. test(content)){    let keyroom = await Room. find({topic:  test })    if(keyroom){      await keyroom. say( Remove from the room , contact)      await keyroom. del(contact)    }  }}). init()docker command: docker run -ti --volume= $(pwd) :/bot --rm zixia/wechaty mybot. tsClick here to get the repo "
    }, {
    "id": 415,
    "url": "https://wechaty.js.org/2016/12/10/try-to-write-wexinrobot/",
    "title": "一个姑娘如何用6行代码写出微信聊天机器人",
    "body": "2016/12/10 - 我一直和我的小伙伴在业余时间拍摄舞蹈教学视频，叫“舞哩”，原创了几百个视频，近千万的播放，所以就建了微信群来和粉丝交流。 1. 与微信机器人的结缘: 当微信群超过100人以后，就必须要靠群主来手工拉人了，所以我在pad上注册了一个微信小号，让大家通过加小号进微信群，每天晚上9点，我登上这个小号，通过所有的好友请求，然后拉他们进来。有的时候会有几十个好友请求，我就先按一遍通过，然后用手机把这些新好友拍成照片，对照照片去通讯录里一个一个的找到这些好友，拉到微信群里。 直到有一次我出国玩，觉得Pad太沉了就没有带，这意味着有10天无法处理微信小号，等我回来以后，我发现了一个非常悲剧的事情……大概100多个好友请求，仅仅只是拍下这些好友请求，我就得拍好几十张照片！ 这明明就是一些机械化的流水作业啊！这怎么能让一个程序员去完成呢？于是我开始梳理了我的需求，其实只有三个：  自动通过好友请求。 当我的粉丝和我微信聊天的时候，能通过关键词进行自动回复。毕竟问题80%都是一样的。 自动的把他们拉进群里。所以我在GitHub上找到了Wechaty，发现只要几十行代码，就可以满足我的需求。最主要的是，机械化的流水操作，机器人做的比人工要好很多。 2. 一款简单的微信机器人框架介绍: GitHub上与微信机器人相关的开源项目有很多，通过JavaScript、Electron、Go、Perl、Python等等都可以实现。 因为我只对JavaScript比较熟悉，所以选择了Wechaty，他是使用Typescript进行编写的Node项目，是一个专门为个人微信号搭建的bot框架，使用Wechaty的API，只需要6行Javascript代码就可以搭建一个最简单的微信机器人，支持 Linux, Windows, Darwin(OSX/Mac) 和Docker。 我特别喜欢Wechaty的一点是，我不用关心任何实现逻辑，仅仅用JS写业务逻辑层面的事情，就可以了。当我把我需要做什么想清楚以后，JS实现起来，是非常简单便捷的。 Wechaty基本的实现原理，是通过Chrome实时监听微信网页版的各类信息，然后将抓取的信息封装成接口，供开发者使用。 她有9个基本的事件，基本上涵盖了我们Web微信上的所有事件，分别是：  scan事件会在需要扫码登陆微信的被触发 login事件会在机器人成功登陆后被触发 logout事件会在机器人掉线以后被触发 message事件会在有新消息的时候被触发 error事件会在程序出现error的时候被触发 friend事件会在有好友请求的时候被触发 room-join事件会在有人加入群时被触发 room-leave事件会在群主移好友出群时被触发 room-topic事件会在群名称被修改时被触发另外，Wechaty将机器人、联系人、微信群、好友请求封装成类，分别是Wechaty、Contact、Message、和FriendRequest，这样我只要import这些包，就可以直接使用这些类里面的函数模拟微信的各种操作了。比如给指定的人发送消息，我只要用contact. say(‘hello’) 就可以了。Wechaty里面的函数名称起的非常人性化，使用JS进行业务逻辑编写的时候，读代码像和读英文文档一样流畅舒服。 3. 如何安装Wechaty: 安装Wechaty有两种方式：  Docker NPM非常推荐使用Docker安装Wechaty，虽然我最开始是使用第二种方式，也正是因为我两种方式都试过，才会深深感慨出“Docker大法好” 。 两种方式的安装—Docker和NPM 我在这里进行简单的介绍： Docker: 安装Docker以后（可以点击这里查看如何安装docker），运行下面的命令，Wechaty就已经成功安装在电脑上了。 docker run -ti --rm --volume= $(pwd) :/bot zixia/wechaty run demo 首次运行以后会有如下的截图： Docker会自动的将相关的包部署到电脑里面，安装成功后，以后再运行就会是如下的截图了： Wechaty的编写者对这种特殊字体的热爱到疯狂的地步了，为了让大家了解的更清楚，我就把所有截图内容也就都放上来了。 通常情况下，我会将这串命令alias给wechaty： alias wechaty='docker run -t -i --rm -e WECHATY_LOG= silly  --volume= $(pwd) :/bot zixia/wechaty:0. 5. 9’ 并加入-e WECHATY_LOG=”silly” 和后面的版本号：zixia/wechaty:0. 5. 9，然后这样运行： wechaty run demo -e WECHATY_LOG=”silly” 是为了把wechaty的系统日志都打印出来，方便发现问题和代码调试，zixia/wechaty:0. 5. 9 在后面加了版本号，因为作者经常更新代码，最近的代码偶尔会出问题，0. 5. 9是我认为相对比较稳定的版本。 NPM: npm install --save wechatynode mybot. js有以下几点值得注意的是：  Wechaty需要的Node版本最少在6以上，我现在在使用7。 有一些环境是需要安装Chromedriver的，根据版本不同，大家可能需要注意一下。 如果是在服务器上，需要到Script的脚本中，运行下xvfb. sh的脚本，为Chrome提供一个虚拟的运行环境，并根据运行后的提示，设置程序运行的环境变量。 同样可以设置WECHATY_LOG的值来打印系统日志：WECHATY_LOG=SILLY node mybot. js关于服务器的说明 Wechaty依赖的很多包都在墙外，建议使用国外的VPS，我使用的是digitalocean 如果只是跑一个机器人服务的话，建议使2GB/2 CPUs 以上的配置，一个机器人服务会占用1G内存左右，如果配上swap的话，短期使用也可以。 4. 如何使用wechaty: 环境部署好以后下面6行代码，就可以成功的实现基础的bot功能：将微信机器人收到的所有消息打印出来： import { Wechaty } from 'wechaty'Wechaty. instance(). on('scan', (url, code) =&gt; console. log(`Scan QR Code to login: ${code}\n${url}`)). on('login', user =&gt; console. log(`User ${user. name()} logined`)). on('message', message =&gt; console. log(`Message: ${message. content()}`)). init()下面对这段代码进行简单的介绍：  scan事件：两个返回值     code：返回了扫描的状态         0：初始状态     200：已经成功登陆     201：微信已经扫码，等待确认     408：等待微信扫码中          url：登陆需要扫描的二维码图片的地址，你需要将这个url粘贴到浏览器中打开，进行扫码登陆    login事件：返回的user，代表登陆的用户，返回的是一个Contact的类型，打印出来，是可以看到你当前登陆的用户昵称的。通过user. id()可以获取用户唯一id，user. name()可以获取用户的微信昵称，user. weixin()可以获取用户的微信号。 message事件：返回的是message，代表收到的消息，是一个Message类型。通过message. content()可以获取到消息的内容，message. from()可以获取到消息的发送者，返回的是一个Contact类型。以上只是一些简单的接口介绍，更多详细的接口文档可以点击查看：Wechaty的接口文档 接口文档还在更新中，如果希望更多接口，直接clone源码查看代码，你会发现很多惊喜好玩的小东西。 除此之外，我还希望分享两个实用的Wechaty的工具： qrcode-terminal: 仅仅把需要扫描的二维码图片作为链接打印在屏幕上，复制链接到浏览器中再去扫描，依然很麻烦，我更希望在terminal上直接扫描二维码登陆进来，这样才能到达demo中的炫酷效果，只需要两步： 1. 安装依赖包： npm install qrcode-terminal 2. 稍微修改下scan事件后的代码就可以了： wechaty. on('scan', (url, code) =&gt; { if (!/201|200/. test(String(code))){  let loginUrl = url. replace(/\/qrcode\//, '/l/')  require('qrcode-terminal'). generate(loginUrl) } console. log(`${url}\n[${code}] Scan QR Code in above url to login: `)})Server酱: 虽然机器人可以稳定的跑在VPS中，但是网页版微信会经常把用户踢下线，所以我需要知道Wechaty的各种异常情况，有一个简单的第三方工具：Server酱，他是一个能从服务器推报警和日志到手机的工具，非常简单易操作： 1. 用GitHub账号登入后，获得一个SCKEY（在「发送消息」页面） 按照引导，点击“微信推送”，扫码关注“方糖”后即可完成绑定2. 在login、logout、scan、和error事件触发后，将一些关键信息往 http://sc. ftqq. com/SCKEY. send 发Get请求，我自己的微信里就收到消息了。 这样，当我的机器人出现各种异常情况，我随时随地都可以知道，需要再扫码进入的时候，方糖这公众号就会把二维码推到我的手机上，我只要用机器人的微信扫码就可以了。 恩，就是这样，我实现了闭着眼镜就可以拉人的美梦中。 5. 后续: 当我开始使用机器人做所有的重复操作的时候，对于加群的工作，我有了进一步的思考，比如我把很多微商拉入黑名单，他们再也无法进入我的微信群；另外我写了个功能，在微信群中加入了管理员功能，这样管理员即使不是群主，也可以把用户踢出微信群；有的时候脑洞大开，还会做个恶作剧，专门收集群友撤回信息，娱乐大众…… 忽然想起了一句话： “People should think, Bot should work”。 当机器能够帮助我们把机械化的工作完成之后，我们才会有更多的时间，思考真正有价值的事情。 Wechaty解放了我的一些重复性工作，我也希望能为Wechaty做点什么，所以我现在在业余时间更新Wechaty的文档，有的时候也会分享一些我在使用Wechaty时候遇到的问题，希望帮助更多的人能够快速上手使用Wechaty。 如果你对Wechaty感兴趣，希望一起交流，一起分享，共同学习，可以扫码添加”桔小秘”为好友，回复wechaty加入WECHATY DEVELOPERS’ HOME。也可以顺便体验下wechaty实现的小功能。 "
    }, {
    "id": 416,
    "url": "https://wechaty.js.org/2016/12/08/jaslin-user-case/",
    "title": "Wechaty Case Study - a letter from JasLin",
    "body": "2016/12/08 - Usercase of using wechat robot with Wechaty: hi brother, the attachments are the screenshot of the little system which i using wechaty. story about it : we have a meditation group, people in the group take meditation every day, after meditation they check in with a emotion image in the group, to help encourage the others or themselves keep meditation every day.  people send specific emotion.  the program record the emotion and map they to hours some stastics. at the beginning, we do this job manually, it spent us much time. at last i decide to build a wechat robot to do this job. before use wechaty , i used a python sdk to build the robot. but it was not stable enough,it logout often and some other problems, because the protocol base implements can not take about the details, i think the tencent company can Identify the robot behavior. and then, i thought may be i can build a chrome plugin instead of using protocol directly. :) lucky, after that, i found wechaty, it’s what i need exactly :). i rewrite the code very javascript, and the robot works well, it’s stable ,It seldom exits the program itself. thanks for wechaty! Jas, 3/12/2016  Author: @JasLin, BotWave CTO, Wechaty Contributor "
    }, {
    "id": 417,
    "url": "https://wechaty.js.org/2016/12/07/beijing-nodejs-meetup-party/",
    "title": "Node Party #18 重新认识聊天机器人",
    "body": "2016/12/07 -  What is Node Party?: 每月组织JavaScript/Node开发者聚会，关注热门的前端、后端框架，开发工具和方法。  学习新东西 认识新朋友 聚餐我们会为你准备：  咖啡，甜点，爆米花和动听的音乐，一起度过一个愉快的下午。 时间：12月11日 星期日 下午13:00 ～ 18:00 地点：科技寺创业空间(北新桥店) 地址: 东城区 东四北大街107号科林大厦B座107室(近北新桥地铁站) 报名地址：http://www. bagevent. com/event/291037内容：: 13:00 ~ 13:30 入场 13:30 - 14:30 如何用6行JavaScript写出微信聊天机器人: 李卓桓，PreAngel合伙人，zixia BBS、叽歪网创始人。曾任优酷网首席科学家，ChinaRen系统工程师，水木清华BBS站长。清华大学本科，中欧国际工商学院EMBA。15年互联网创业经验，20年编程经验。著有《Linux网络编程》(2000年)、《反垃圾邮件完全手册》(2006年)等技术作品。热爱极限运动，喜欢和勇敢、富有激情、愿意接受新鲜事物并不断挑战突破自己的人做朋友。生活中喜爱跑步、滑雪、SALSA、MMA、跑酷、滑翔伞等极限运动。 李佳芮，桔子互动创始人/CEO，北京邮电大学计算机系硕士；2014年创立婚庆O2O平台“艾娘子”，同年获得500万天使投资；历任北京的邮电大学IDEA精英汇会长、学生会公关部副部长；曾获得第二届腾讯全国互联网创新创业大赛银奖、第三届京津冀营销创业大赛亚军。桔子互动是一家社区运营服务解决方案提供商，如基于微信的定制开发和运营推广服务。曾服务过亚马逊、腾讯、京东等多家上市公司。 爵士舞爱好者，业余时间创立舞蹈视频教学自媒体“舞哩”，搭建舞蹈社群。半年内原创视频全网播放近千万。多次被美拍、腾讯视频、B站、优酷评为热门精选。 演讲内容介绍:  Why Wechaty Wechaty from Scratch Why Browser Selenium WebDriver Wechat Browser Insight Why TypeScript Stacks DevOps What is Chatie. IO Vision Demo Q/A15:00 - 16:00 Chatbot的场景化应用 王守崑@Ein，个性化推荐系统和相关技术在中国的早期实践者。毕业于清华大学自动化系，豆瓣早期初创团队成员之一，曾长期担任豆瓣网首席科学家兼副总裁，负责豆瓣个性化推荐系统搭建。目前创业中，担任爱因互动（Ein）创始人、CEO，专注于自然语言处理和对话服务，向企业和个人用户提供专业、高质量的对话机器人产品。 演讲内容介绍  Chatbot兴起的两大基础 Chatbot历史、技术和现状 Chatbot的适用场景 展望16:20 - 17:20 Barcamp 简单介绍，公司，工作，兴趣，擅长的技术栈 结束后 晚上有空的，在附近一起吃饭。 往期回顾：照片，PPT，Slides https://git. oschina. net/ubiware/node-party 主办Rockq社区 "
    }, {
    "id": 418,
    "url": "https://wechaty.js.org/2016/12/05/ghostcloud-wechaty-docker/",
    "title": "Docker玩转微信机器人框架Wechaty",
    "body": "2016/12/05 - Wechaty(https://github. com/wechaty/wechaty)是一款开源的微信SDK，它基于微信公开的API，对接口进行了一系列的封装，提供一系列简单的接口，然后开发者可以在其之上进行微信机器人的开发。在跟作者沟通试用以后，发现其中有着非常多的应用场景，比如：  如果你的好友众多，如何管理和维护好友分组； 如何快速有序地处理海量聊天信息，并区分重要性； 如何处理海量的聊天组，特别是微信可以任意建组，长期以后会出现非常多的聊天组； 能否可以自动智能地进行聊天回复 …… 本文作者：@shevyan 晏东，精灵云GhostCloud创始人&amp;CEO 原文地址：http://mp. weixin. qq. com/s/o-4VMcAMz0K8yJVdNaUXow 1 快速上手: wechaty使用node编写，所以支持几乎所有的平台，wechaty的hello-world只需要6行代码即可实现聊天记录的动态收集。为了使用方便作者还进行了docker化的封装，结合docker绝对是一个不错的选择。 Step 1: 新建一个mybot. js，内容如下： import { Wechaty } from 'wechaty'Wechaty. instance() // Singleton. on('scan', (url, code) =&gt; console. log(`Scan QR Code to login: ${code}\n${url}`)). on('login',    user =&gt; console. log(`User ${user} logined`)). on('message', message =&gt; console. log(`Message: ${message}`)). init()Step 2: 在主机上运行命令 docker run -ti --rm --volume $(pwd) :/bot zixia/wechaty mybot. jsStep 3: 拷贝二维码到浏览器 Step 4: 所有聊天记录就会打印到屏幕上 2 容器化分析: wechaty是一个比较好的docker化例子，其工程根目录下的Dockerfile详细描述了如何构建镜像，也就是需要哪些环境。通过Dockerfile我们可以看出，它使用的基础镜像是基于alpine的node镜像mhart/alpine-node:7 alpine是我们日常比较推荐的镜像，最小的只有4M左右。之后是一些常用的包的安装，具体可以参看Dockerfile。在运行时，会将mybot. js映射到容器内部，这样就相当于把运行环境和具体的应用进行了隔离。 3 其他例子: hello-world一般只是最简单的例子，这个框架真正厉害的是包含了其他一些用例，具体位于https://github. com/wechaty/wechaty/tree/master/example 其中包含了：  api-ai-bot. ts : 通过调用api. ai，进行人工智能方面的识别 contact-bot. ts : 列举的好友weixin id 和 name ding-dong-bot. ts : 一个自动回复例子，如果好友输入’ding’，自动回复’dong’ friend-bot. ts : 添加好友，同意添加，消息验证的例子 media-file-bot. ts : 多种不同消息类型十倍的例子，保存media-file到本地 room-bot. ts : 对于聊天组的一系列例子，包括查找、添加、删除、改主题、监控组事件等等 speech-to-text-bot. ts : 当收到语音时，调用第三方接口，转换成文字，用户可以根据需求选择不同的语音识别API tuling123-bot. ts : 国内的一个机器人集成例子其实细心的朋友，看到这里会问，到底这个框架能否支持动态抢红包呢？这就留给有兴趣的朋友去研究了。同时，我们也会在后续分享一些其他的开源项目介绍。 4 通过Ghostcloud EcOS部署wechaty: EcOS (Enterprise container Operation System)是由Ghostcloud精灵云全自主研发的Docker容器云平台, 为企业研发、运维及新业务上线部署提供了一整套解决方案和管理平台。通过EcOS用户可以快速在私有云和混合云环境安装Docker，官方地址是：www. ghostcloud. cn Ghostcloud EcOS，安装步骤如下：  浏览器访问 http://ecospkg. ghostcloud. cn/EcOS/stable/ ， 下载最新的安装文件（EcOS-install*）和服务镜像文件(srvimgs. tgz)到需要安装的服务器根目录 解压安装文件，执行安装脚本: tar -zxf Ecos-install* &amp;&amp; bash install. sh IPADDR(这里的IPADDR是安装EcOS所在的服务器IP地址) 解压服务镜像文件，执行push镜像操作tar -zxvf srvimgs. tag &amp;&amp; . /srvimgs/pushimgs. sh 详细安装步骤请移步至：http://ecospkg. ghostcloud. cn/EcOS/video/EcOS_Install. mp4部署 1）创建wechaty服务 通过EcOS平台创建wechaty容器（容器具体操作见http://ecospkg. ghostcloud. cn/EcOS/video/EcOS_Contianer. mp4）镜像选择wechaty:latest, 创建启动选择为是，可适当的增加内存容量（允许容器使用的内存） 2）监听 wechaty 容器的日志 使用putty或其他ssh客户端工具登录到创建wechaty容器的主机，执行docker logs -f wechaty 扫描日志中的二维码或将URL地址复制到浏览器中扫描，然后正常的使用微信，可以看到终端中会有相关信息。 "
    }, {
    "id": 419,
    "url": "https://wechaty.js.org/2016/12/04/gitchat-lijiarui-interview/",
    "title": "Chat实录｜李佳芮：向前一步的程序媛",
    "body": "2016/12/04 - 11月24日周四晚8点，GitChat团队开启了来自一位前端女技术工程师李佳芮的问答交流，以下是主持人小冰将交流过程重新整理，记录下了分享者和用户之间对微信机器人的交流精彩片段。 GitChat 访谈: 问：你能说说目前微信机器人能做什么，不能做什么？: 答：Wechaty的实现原理，是监听Web微信的所有内容，封装成接口给开发者使用。所以原则上，只要能在Web微信上能实现的事情，微信机器人都可以做。注意我说的是Web微信，不是微信客户端。微信在Web上阉割了很多功能，相比较，PC客户端的功能丰富的多。所以抢红包功能做不了。因为在Web微信里面，是无法识别到有红包的事件的。还有，转账功能机器人也做不了。 问：机器人是PC端监听浏览器然后调用微信Api，应用号是基于“微信OS”的“本地”app，这么解释对么？: 答：机器人是在监听浏览器，但是和微信Api没有任何关系，完全是Hack进去的。机器人更像是在解决运营中的机械化重复操作，希望在Chat的过程中，提供服务。 问：既然是Hack到Web微信的，会不会有一天被封杀了呢？: 答：如果他强制封杀，肯定是有办法的，但是我个人觉得可能性比较低。第一，封杀的话，技术是有成本的，微信也是要考虑投入产出比的；第二，Git上最少有20多个这样的开源项目，而且好多都是几年前就做好了，微信不可能不知道，而且从技术研究和Chatbot的应用研究层面的角度看，这个是有意义的；第三是，这件事如果没有威胁到微信的生态，就不会封杀，不过之前可以批量删除好友的功能就被封了。 PS：我倒是觉得，这个被封杀最大的可能性，是把你的个人微信号封了，之前我看过一个技术社区上有人说，他做了一个防撤回机器人，就是在有人撤回消息的时候用聊天机器人把撤回的消息原封不动发出来。然后就扔到群里让大家玩了。但是因为没有写字数限制，群里发多长的消息，他都会原封不动的发出来，就构成了炸群。 微信就把这个号封了7天，不能给好友发信息，不能发朋友圈，但是可以给好友发红包，然后红包里面带回复内容，我觉得也挺逗的。我有一次也因为没有判断消息是不是自己发的，然后测试修改群名称，结果系统消息和自己发的消息混了，忽然群也不能用了。所以使用的时候，注意一下，比如限制字数啊，屏蔽bot自己发的消息之类的，用message. self()就可以了。 问：微信机器人跟微信官方近期推出的应用号是怎样一个关系，如何结合？: 答：微信机器人和官方近期推出的应用号是不一样的应用场景。应用号，或者说小程序，是在微信的应用上提供一个入口为用户提供服务，这样可以免去下载app的苦恼，很多低频场景的app很适合做小程序。而微信机器人，本质就是一个微信号，现阶段主要是为了释放人力，免去人在微信上做的很多机械性的工作，比如批量通过好友请求啊，比如拉人进群啊，或者批量删好友。这个可能更类似于Chatbot，希望再chat的过程中提供服务。机器人除了做些机械操作，还可以在聊天页面推送一些链接给好友，这个链接可以是小程序的链接，也可以是app的链接，也可以是公众号。 问：机器人断线概率高么？: 答：从我自己使用的情况来看，Wechaty这个框架很稳定，但是网页微信定期会把你踢下去，所以需要重新登录。Wechaty有一个功能，就是通过wechaty. instance({ profile: ‘test’ }) 会把你的session信息存到一个test. wechaty. json的文件中，如果掉线了，会自动重新登录，test可以随便换名字哈。我现在长期在我的服务器上跑两个机器人，基本上一周会掉一次，我在文章里介绍了server酱，是一个从服务器推报警信息到微信的工具，结合server酱，在logout和scan事件的时候加入一个推送，掉线以后会有提醒，如果session没了也会把二维码推给你，还是挺爽的，也不用怕掉线再去服务器上登录了。 问：GitChat现在想用一个微信号实现自动拉人进群的功能（突破扫二维码100人的限制），不知道Wechaty是不是最好的选择？: 答：我认为是很好的选择，实际上我最开始使用Wechaty也单纯是为了突破群二维码100人限制。使用三个关键函数：在聊天页面通过m. from() 获取联系人contact，通过room. find() 找到群，然后room. add(contact) 就可以实现自动拉人了。 问：微信机器人可以检测自己是否还是某个联系人的好友吗？: 答：可以的，Contact有一个Contact. findAll()的函数，返回一个Contact数组，会找到你所有的联系人，然后遍历这个数组，使用contact. say()给所有好友群发消息，判断回复的类型和内容，回复消息的类型可以通过Message. type()获取，如果返回的是10000就是系统消息，一旦判断出返回的是一个“对方不是你好友”的系统消息，那们就判断出这个联系人不是好友了。 问：微信机器人不是走的微信接口去获取数据么，在想一个找回群的需求，不知道是否可以实现？: 答：机器人不是走的微信接口，不过你的要求可以实现，不过需要你常年登着，然后把你所有消息都存进去，这样从登录开始算起的所有内容都可以搜索。我之前做的自动拉人进群的功能，有个小点和你这个需求比较类似。这个人回复机器人暗号，机器人会拉他进去，如果这个人已经在群里了，机器人就会在群里@他一下，这样这个群就在你的聊天界面最前面了。这样有些人群多就可以通过这种方式找到某个沉寂已久的微信群了。 问：现在微信机器人可以处理个人微信号的很多事情，有考虑接下来如何设计机器人让它更加智能化？: 答：恩，有考虑。但是更多的希望，第一步先让这个微信机器人更好的完成自动化的工作，就是说本来需要人做的重复性工作，比如拉群、自动回复、加人、一键群发等等，机器人都帮你先完成了，这个也是很多企业在微信社群运营中面临的很大的困惑。有一句话说的特别好：“Machine should work, People should think” 。 我希望我的微信机器人，在第一步能把很多运营人员面临的问题先解决了，让他们更多的时间放在思考如何进行活动策划、如何留存用户，甚至如何进行商业变现。一方面希望帮助企业节约成本，实现让一个运营人员管理上千个群和微信号，另外一方面，希望帮助企业释放人力，让运营人员从复杂机械化的操作中解放出来，做有创造性的东西。 人工智能方面，现在有一些机器人的平台做的已经很好了，他们是专门研究这个的，做的比我们专业好多，每天就是有好多聪明绝顶的算法工程师在研究，智能化可以使用他们的接口，比如我之前用我的微信机器人接过图灵机器人，效果还不错。我更希望和做智能机器人的企业有合作，共同解决聊天或者社群运营过程中的繁琐问题，或者说，我做的更多是一个应用层面的chatbot尝试，以更少的成本探索更多需求并小成本迭代解决问题。 问：文中提到了好几个实现微信机器人的类库，你是怎样比较最终选择了Wehaty？: 答：我当时确实对比了几个不同的类库，我选择的原因很简单，就是看是用什么语言实现的，因为我对JS比较熟悉，所以使用了Wechaty。其实选类库的时候，我发现Python的库是最早的，且相对比较最完善的。但是有两点原因我没有选择，一是我对Python没有JS熟悉， 二是Python的库虽然早，但是接口封装的不是很干净。 JS的有这几个，你们可以参考下哈：Wechat4U：微信 Wechat web 网页版接口的JavaScript实现，兼容Node和浏览器；Weixinbot Nodejs：封装网页版微信的接口，可编程控制微信消息；WechatBot：面向个人的微信Wechat机器人平台 - 使用微信网页版接口Wechat4u；Wechat-user-bot：正在组装中的微信机器人；Hubot-WeChat Hubot：是一个具有真实微信号的机器人，可以自动回复信息到微信群和某联系人，并能给维护者的微信自动发送Hubot在线状态。 问：文章里提到教舞蹈做视频，你觉得舞蹈给你带来了哪些好处呢？: 答：首先，舞蹈给我带来了很多朋友，认识了工作之外的各种人，而且都是很有趣的人，我在生活中有的时候比较无趣，多和这些人在一起能让我变得有趣一点。另外，当你有一个兴趣爱好的时候，每周的生活过起来就会丰富多彩一点，因为我们拍摄的是系列视频，你会有一个期待，就像追剧一样，而你是剧中的主角或者编导，这种感觉是很美妙的。 最主要的一点，跳舞对我来说是一种运动方式，每周出一点汗是身体和心理的双重放松，也能让我更好的投入工作中，这种运动还有一个副产品，就是可以保持身材，对于姑娘来说，这个还是非常重要的。 问：桔子互动是提供微信运营服务的，是怎样契机开始运营微信服务，以后想要如何发展呢？: 我在研一的时候，公众号刚刚火起来，一个机缘巧合，一个毕业的学长知道我在实验室写php，他的朋友正好有外包需求，所以他牵头，找了几个技术的同学开始接项目。后来索性在学校附近租了个工作室，每周大家都会到工作室里碰一下，一起做项目。随着项目的同质化越来越严重，我们就尝试着做了一个小平台，将一些通用需求，比如签到、填写表单、微信墙、微信婚礼请柬等做成一个一个的模块，然后内部使用，后来接开发接的多了，也开始尝试着打包成服务，可能这就是一个契机吧。 后来我拿着我们做的婚礼请柬参加了创业比赛，还拿了风投，就去深圳做了婚庆O2O，结果因为线下资源和产品方向等原因失败了，回北京之后就又重操旧业，做一些微信运营的项目。我们现在也会接一些H5的项目、网站的项目和内容运营相关的需求，但是现在这一块已经成为一片红海，利润并不是很高。 最近我发现，微信个人号上有很多重复的工作，需要自动化，所以正在尝试往这个方向转，接下来我会把产品模块化，希望可以帮助帮助更多企业在微信社群运营商提供自动化服务，帮助他们节约成本，释放人力。 问：对于创业，你有什么想法可以和大家分享的，又有什么建议是想告诉想要创业的朋友的呢？: 答：对于创业，从我这几年走过的各种弯路来看，专注可能是最重要的。之前一直觉得自己精力充沛，有的时候觉得自己可以做很多东西，然后就会去做各种尝试，但是所有的尝试最好能在一个有限域里面，做的项目也一定要切分一块比较垂直的领域，将这一块做好再去迅速的规模化。 另外，创业就是一场生意，所以整个产品是一定要有商业逻辑在里面的，我最开始做婚庆O2O的时候，可能也是因为拿到了几百万的风投，团队规模又不是很大，以为公司又不缺钱，所以就单纯的想产品做好了，其他东西自然就来了，然后就会陷入闷头做产品的窘况。甚至连如何产生现金流，如何盈利都没有想的非常明白，就去做了。 所以现在我做的内容，也会尽量更加聚焦一点，希望在Chatbot的领域里面，从微信运营自动化入手，帮助企业和某些个人解决实际的运营自动化需求，然后尽量把产品打磨好做精。我希望对Chatbot有兴趣的，可以一起聊聊，希望碰出一些好想法。 问：作为一名优秀的程序媛，有想要给其他程序媛或者想要成为程序媛的妹子一些建议么？: 答：首先，就是不要害怕。桑德伯格有一本书叫《向前一步》，鼓励女性追求自己的目标，其实我觉得这几个字在程序世界中也很对。对很多姑娘来说，无论是不是技术出身，都会对程序有一种恐惧，比如总怕把服务器弄坏了，或者什么程序搞崩了。其实不然，去做就好了，大不了重新装个系统，重新写个代码，不要因为害怕出错而不敢做。包括现在，我有的时候也会有这种恐惧，其实应该自己克服的，程序里面很多东西，也像一层窗户纸，向前一步，一捅破，你会发现程序的世界也没有那么扑朔迷离。 另外，是当一大段代码调不通，你也不知道什么问题的时候，好多女生会忽然觉得很绝望，其实有一个小窍门，可以把整个代码分成几个小片段，一个一个去调，就会捉到问题，很多大牛也是这样去调程序的，但是有的时候，我们不敢去拆分，就会陷入很困惑的情况跳不出来。 最后，也是我最想说的，不是只有男生才可以驾驭程序，很多工作，不分男女，只分强弱，其实创业也是一样。 原文地址：GitChat - Chat实录｜李佳芮：向前一步的程序媛 "
    }, {
    "id": 420,
    "url": "https://wechaty.js.org/2016/12/03/welcome-to-wechaty/",
    "title": "Welcome to Wechaty!",
    "body": "2016/12/03 -  Hello, ChatBot Developers! Today is a big day because Wechaty got a brand new Blog! ;-) In the past half year, Wechaty growth from version 0. 0. 1 to 0. 6. 32. Today, it has dozens of pull requests, 100+ issues, 200+ stars, 1,400+ commits and 10,000+ lines of code. The Worlds Smallest ChatBot: Wechaty is a easy to use ChatBot Framework which can help you write the worlds smallest chatbot. Maybe you are very interesting in ChatBot industory, or you just want to get your own wechat personal account robot, Wechaty will always be your friend. The following 6 lines javascript code example will show you how does Wechaty work: import { Wechaty } from 'wechaty'Wechaty. instance() // Singleton. on('scan', (url, code) =&gt; console. log(`Scan QR Code to login: ${code}\n${url}`)). on('login',    user =&gt; console. log(`User ${user} logined`)). on('message', message =&gt; console. log(`Message: ${message}`)). init()How to run this piece of code? Easy. Wechaty has a docker image which can help you put your bot on duty in seconds: docker run -ti --rm --volume= $(pwd) :/bot zixia/wechaty mybot. js mybot. js contains our source code in the above example. See? death easy to use! Last but not least:  Check out the Chatie IO for more info on how to get the most out of Wechaty.  File all bugs/feature requests at Wechaty’s GitHub repo.  If you have questions, you can ask other developers in Wechaty Developers’ Home by scan belowing Qr Code and send the secret code: wechaty. secret code: wechaty Visit Wechaty Github: https://github. com/wechaty/wechaty/ Cheers! Best, Huan, a ChatBot &amp; Deep Learning Fan "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});



function lunr_search(term) {
    $('#lunrsearchresults').show( 1000 );
    $( "body" ).addClass( "modal-open" );

    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-secondary btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
</script>
<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>




<form class="bd-search hidden-sm-down" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
<input type="text" class="form-control text-small"  id="lunrsearch" name="q" value="" placeholder="Type keyword and enter...">
</form>

            </ul>
        </div>
    </div>
    </nav>

    <!-- Search Results -->
    <div id="lunrsearchresults">
        <ul class="mb-0"></ul>
    </div>

    <!-- Content -->
    <main role="main" class="site-content">
        

<div class="container">
<div class="jumbotron jumbotron-fluid mb-3 pl-0 pt-0 pb-0 bg-white position-relative">
		<div class="h-100 tofront">
			<div class="row  justify-content-between ">
				<div class=" col-md-6  pr-0 pr-md-4 pt-4 pb-4 align-self-center">
					<p class="text-uppercase font-weight-bold">
            <span class="catlist">

            
              <a class="sscroll text-danger" href="/categories.html#gsod">gsod</a><span class="sep">, </span>
            

            </span>
					</p>
					<h1 class="display-4 mb-4 article-headline">Shwetal Soni: GSOD'21 project proposal for wechaty</h1>
					<div class="d-flex align-items-center">
                        
                          <a href="/contributors/shwetalsoni">
                            <img class="rounded-circle" src="/assets/contributors/shwetalsoni/avatar.webp" alt="Shwetal Soni" width="70"/>
                          </a>
                        
						<small class="ml-3"> Shwetal Soni <span><a target="_blank" href="https://twitter.com/shwetalsoni19" class="btn btn-outline-success btn-sm btn-round ml-1">Follow</a></span>
                            <span class="text-muted d-block mt-1">May 03, 2021 · <span class="reading-time">
  
  
    8 mins read
  
</span>
</span>
						</small>
					</div>
				</div>
                
				<div class="col-md-6 pr-0 align-self-center">
					<img class="rounded" src="/assets/2021/05-gsod-project-proposal-shwetal-wechaty/profilepic.webp" alt="Shwetal Soni: GSOD'21 project proposal for wechaty">
				</div>
                
			</div>
		</div>
	</div>
</div>





<div class="container-lg pt-4 pb-4">
	<div class="row justify-content-center">

    <!-- Share -->
<div class="col-lg-2 pr-4 mb-5 col-md-12">
  <div class="sticky-top sticky-top-offset text-center">
    <div class="text-muted">
    </div>
    <div class="share d-inline-block">
      <!-- AddToAny BEGIN -->
      <div class="a2a_kit a2a_kit_size_32 a2a_default_style">
        <a class="a2a_button_wechat" title='Wechat'>
          <img id="qrcode" title="Wechat"
            src="/assets/contributors/wechaty/icon.png"
            width="64" height="64"
          />
        </a>
        <a class="a2a_button_wechat" title='Wechat'></a>
        <a class="a2a_button_sina_weibo" title='Weibo'></a>
        <a class="a2a_button_linkedin" title='LinkedIn'></a>
        <a class="a2a_button_facebook" title='FaceBook'></a>
        <a class="a2a_button_twitter" title='Twitter'></a>
        <a class="a2a_dd" href="https://www.addtoany.com/share"></a>
        <!-- AddToAny BEGIN -->
      </div>
      <script async src="https://static.addtoany.com/menu/page.js"></script>
      <!-- AddToAny END -->
    </div>
  </div>
</div>

<script>
  var href = document.location.href
  var url = 'https://api.qrserver.com/v1/create-qr-code/?data='
            + href
            + '&size=512x512'
  var img = document.getElementById('qrcode')

  img.src=encodeURI(url)
</script>


		<div class="col-md-12 col-lg-8">

      <!-- Article -->
			<article class="article-post">
			<h2 id="gsod21-proposal-for-wechaty">GSOD21 Proposal for Wechaty</h2>

<h2 id="introduction">Introduction</h2>

<p>Hello Fellow Developers!</p>

<p><img src="https://avatars.githubusercontent.com/u/57187745?v=4" alt="Shwetal Soni" /></p>

<p>Myself Shwetal Soni. I’m CSE Sophomore from National Institue of Technology Hamirpur, Himachal Pradesh, India and a Frontend Web Developer and UI/UX Designer also. Currently I’m exploring blockchains. I’m interested in contributing to wechaty’s tutorial.</p>

<h2 id="technical-writer">Technical Writer</h2>

<p>Shwetal Soni</p>

<h2 id="contact-email">Contact Email</h2>

<p>sonishwetal704@gmail.com</p>

<h2 id="professional-information">Professional Information</h2>

<h2 id="writing-samples">Writing Samples</h2>

<ul>
  <li>
    <p><a href="https://shwetalsoni.medium.com/building-your-first-dapp-on-tezos-part-1-writing-smart-contract-on-smartpy-d7cdf27476f9">Tutorial for writing Smart Contracts on Tezos</a></p>
  </li>
  <li>
    <p><a href="https://shwetalsoni.medium.com/getting-over-imposter-syndrome-ccafb14aee12">Getting over Imposter Syndrome</a></p>
  </li>
</ul>

<h2 id="my-resume">My Resume</h2>

<p><a href="https://drive.google.com/file/d/1IVq10MpokB8-LMYBVvBXDKcqpBY4m-t0/view?usp=sharing">shwetalsoni_resume</a></p>

<h2 id="my-portfolio">My Portfolio</h2>

<p><a href="https://shwetalsoni.github.io/">shwetalsoni.github.io</a></p>

<h2 id="overview-of-my-recent-work">Overview of my recent work</h2>

<p>Recently I had written a beginner-friendly tutorial for writing smart contracts on SmartPy which takes the user from introducing to blockchain to finally deploying a smart contract. To make it easier to understand I have attached screenshots guiding them throughout the whole process ensuring they learn by doing. I got it reviewed by some people and they really found it useful and easy to follow.</p>

<h2 id="project-title">Project Title</h2>

<p>Create easy to learn tutorials for beginner users of Wechaty</p>

<h2 id="abstract">Abstract</h2>

<p>Tutorials are lessons that take the reader by the hand through a series of steps to complete running Wechaty code. They are what our project needs in order to show a beginner that they can achieve something with it. They are wholly learning-oriented, and specifically, they are oriented towards learning ‘how’ rather than learning ‘what’. Tutorials need to be useful for the beginner, easy to follow, meaningful, extremely robust, and kept up-to-date.
The Tutorial project should:</p>

<ul>
  <li>
    <p>Allow the user to learn by doing</p>
  </li>
  <li>
    <p>Get the user started</p>
  </li>
  <li>
    <p>Make sure that the tutorial works all the time</p>
  </li>
  <li>
    <p>Ensure the user sees results immediately</p>
  </li>
  <li>
    <p>Make the tutorial repeatable</p>
  </li>
  <li>
    <p>Focus on concrete steps, not abstract concepts</p>
  </li>
  <li>
    <p>Provide the minimum necessary explanation</p>
  </li>
  <li>
    <p>Focus only on the steps the user needs to take</p>
  </li>
  <li>
    <p>Work with the contributor team to update the documentation on the Wechaty site.</p>
  </li>
</ul>

<h2 id="current-situation">Current Situation</h2>

<p>Users come to Wechaty website seeking how to use Wechaty to build a chatbot application for solving their problems. Unfortunately, the learning curve is not friendly to our users, they always struggle with setting up with their development environment, can not get started with the simplest example source code, and find it hard to know what they can do with our API. This problem leads to us losing lots of new users, an increased number of questions asked in the community, and lowered user satisfaction.</p>

<h2 id="analysis">Analysis</h2>

<p>Being a new user to wechaty I encountered a lot of problems while running Ding Dong Bot. For deep analysis, I asked some of my friends to go through the documentation and try running the bot. Almost everyone faced a lot of issues while running the bot. This clearly depicts that the Tutorial is not properly structured.<br /><br /></p>

<p><strong>Following are the problems I have found out with the tutorials</strong><br /></p>

<ul>
  <li>
    <p>Quick Start is a place where most of the beginners will head over to and should be mentioned at the top of tutorials unlike now it is inside a <code class="language-plaintext highlighter-rouge">Getting Started</code> dropdown.</p>
  </li>
  <li>
    <p>Don’t mention something a learner doesn’t need to know in order to complete the tutorial. Inside Quick Start under the first heading <code class="language-plaintext highlighter-rouge">In Next 10 min,</code> I found out that the points written there about getting QR Code for wechaty and QR Code for WhatsApp are useless and even misleading. It messed me up when clicking on <code class="language-plaintext highlighter-rouge">WeChat</code> QR Code it didn’t open and later found out that it has nothing to do with the tutorial.</p>
  </li>
  <li>
    <p>Tutorials overview didn’t have necessary info on what are the ways in which users can get started. In many good documentations, I have found out that they provide the main link on the overview page so that users can head over from there directly.</p>
  </li>
  <li>
    <p>Tutorials should always be working but Usage with Heroku is not working.</p>
  </li>
  <li>
    <p>Video Tutorials are like icing on the cake and should be provided in a language that is widely spoken other than Chinese. I even found a comment on youtube requesting for English video.</p>
  </li>
  <li>
    <p>There is a link <a href="https://wechaty.js.org/2021/02/06/wechaty-getting-started-without-leave-your-browser/">Getting started without leaving your browser</a> after <code class="language-plaintext highlighter-rouge">Let's run your first Ding Dong Bot</code>  given in the read more section by <code class="language-plaintext highlighter-rouge">Huan Li</code>. It is very well written and should be mentioned separately in the sidebar under the Gitpod option.</p>
  </li>
  <li>
    <p>Currently Tutorials only teach the user to set up wechaty but a tutorial should also give the user an experience of working with the features of wechaty.<br /></p>
  </li>
</ul>

<div style="page-break-after: always"></div>

<h2 id="based-on-the-above-analysis-i-propose-the-following-structure">Based on the above analysis I propose the following structure</h2>

<p>Getting Started with Wechaty
  |- Overview
  |  -&gt; Beginner Level
  |     -&gt; Running on Gitpod
  |     -&gt; Running on Google Cloud Shell
  |     -&gt; Running Locally
  |     -&gt; Creating your first bot from scratch
  |  -&gt; Intermediate and Advanced Level
  |     -&gt; Usage with Docker
  |     -&gt; Using with Heroku
  |     -&gt; Using Plugin with wechaty
  |     -&gt; Using Redux  with wechaty
  |     -&gt; Using Vorpal with wechaty
  |- Quick Start
  |  |- Running on Gitpod
  |  |- Running on Google Cloud Shell
  |  |- Running Locally
  |- Tutorial Series(Creating your first bot from scratch)
  |  |- From Scratch
  |  |  |- Overview
  |  |  |- Installation
  |  |- Tutorial
  |  |  |- Create a bot
  |  |  |- Dealing with messages
  |  |  |- Processing files
  |  |  |- Writing tests
  |- Video Tutorials
  |  -&gt; Chinese Tutorials
  |  -&gt; Other than Chinese Tutorials
  |- Advanced Topics
  |  |  |- Usage with Docker
  |  |  |- Using with Heroku
  |  |  |- Using Plugin with wechaty
  |  |  |- Using Redux  with wechaty
  |  |  |- Using Vorpal with wechaty</p>

<ul>
  <li>
    <p>The above structure is well organized from beginner to advanced level.</p>
  </li>
  <li><strong>The overview section</strong>  should give a complete overview of the topics. If a person is a beginner he can either simply run the app using any of the following options <code class="language-plaintext highlighter-rouge">Running on Gitpod</code>, <code class="language-plaintext highlighter-rouge">Running on Google Cloud Shell</code>, <code class="language-plaintext highlighter-rouge">Running locally</code> by clicking on the given links here.
    <ul>
      <li>Also the link for <code class="language-plaintext highlighter-rouge">Tutorial Series (Creating your first bot from scratch)</code> will also be given in case a user want to follow up with steps creating their own chatbot.</li>
      <li>If a user has prior knowledge about wechaty, they can go to the advanced topics by clicking on the links given for respective topics <code class="language-plaintext highlighter-rouge">Usage with Docker</code>, <code class="language-plaintext highlighter-rouge">Using with Heroku</code>, etc.</li>
    </ul>
  </li>
  <li>
    <p><strong>Quick Start</strong> should be divided into sections. If a user wants to run the app using Gitpod, there should be a separate page for that. Similarly for the remaining two options also. This will enable proper step-wise step tutorial for every option unlike now <code class="language-plaintext highlighter-rouge">Running with Gitpod</code> and <code class="language-plaintext highlighter-rouge">Running with Google Cloud Shell</code> are both on the same page messing it up and leading to skipping of some important points.</p>
  </li>
  <li>
    <p><strong>Tutorial Series(Creating your first bot from scratch)</strong> is the most important part of this tutorial as this will allow the user to create their own chatbot from scratch and then playing around with the features provided by wechaty. It should be well equiped with code snippets with proper explanation and screenshots of how the result will look after running a given code/command. This will make sure that they learn by doing and will definitely gather interest of more users.</p>
  </li>
  <li>
    <p><strong>Video Tutorial</strong> plays a great role in providing a better understanding and should be available in the language which is widely spoken.</p>
  </li>
  <li><strong>Advanced Topics</strong> At the end, if a user has gone through the easy concepts they can dive into intermediate and advanced concepts.<br /></li>
</ul>

<h3 id="why-is-my-proposed-tutorial-better">Why is my proposed tutorial better?</h3>

<p>QuickStart will get the user started. The Tutorial Series will allow the user to learn by doing. Users can see immediate results in the form of output screenshots attached with every step. The whole structure focuses only on the steps the user needs to take with the minimum necessary explanation.</p>

<h3 id="why-am-i-the-right-person-for-this-project">Why am I the right person for this project?</h3>

<p>From last year I have building many personal projects and also writing Readme for that. Recently I learned to write Smart Contracts on Tezos blockchain and it had very few resources available to get the user started and hence I struggled a lot. This motivated me to write a medium article <a href="https://shwetalsoni.medium.com/building-your-first-dapp-on-tezos-part-1-writing-smart-contract-on-smartpy-d7cdf27476f9">Tutorial for writing Smart Contracts on Tezos</a>. So, I know what people expect from a tutorial. Hence, combining all my experience and analysis of this project I can assure a great tutorial.</p>

<h2 id="proposed-timeline">Proposed Timeline</h2>

<ul>
  <li><strong>2 weeks</strong> -&gt; Information Gathering</li>
  <li><strong>3 weeks</strong> -&gt; Restructuring the tutorials. Organizing and presenting the content in a better way.</li>
  <li><strong>5 weeks</strong> -&gt; Creating a tutorial series.</li>
  <li><strong>2 weeks</strong> -&gt; Improvising and publication.<br /></li>
</ul>

<h2 id="proposed-budget">Proposed Budget</h2>

<p>Technical Writer Stipend -&gt; 5000 (Decided by the organization)</p>

			</article>

			<!-- Tags -->
			<div class="mb-4">
				<span class="taglist">
				
				  <a class="sscroll btn btn-light btn-sm font-weight-bold" href="/tags.html#gsod">gsod</a>
				
				  <a class="sscroll btn btn-light btn-sm font-weight-bold" href="/tags.html#docs">docs</a>
				
				  <a class="sscroll btn btn-light btn-sm font-weight-bold" href="/tags.html#introduction">introduction</a>
				
				  <a class="sscroll btn btn-light btn-sm font-weight-bold" href="/tags.html#project">project</a>
				
				  <a class="sscroll btn btn-light btn-sm font-weight-bold" href="/tags.html#proposal">proposal</a>
				
				</span>
			</div>

            <!-- Mailchimp Subscribe Form -->
            
			<div class="border p-5 bg-lightblue">
				<div class="row justify-content-between">
					<div class="col-md-6 mb-2 mb-md-0">
						<h5 class="font-weight-bold">Join Newsletter</h5>
						 Get the latest news right in your inbox. We never spam!
					</div>
					<div class="col-md-6">
						<div class="row">
              <form action="https://zixia.us4.list-manage.com/subscribe/post?u=a8584b55dea5aa8bbc14bd1a0&amp;id=d9899f0d70" method="post" name="mc-embedded-subscribe-form" class="wj-contact-form validate w-100" target="_blank" novalidate>
                <input type="email" placeholder="Enter e-mail address" name="EMAIL" class="required email form-control w-100" id="mce-EMAIL" autocomplete="on" required>
                <input type="text"  placeholder="Name"                 name="FNAME" class="required form-control w-100"       id="mce-FNAME" autocomplete="on" required>
                <button type="submit" value="Subscribe" name="subscribe" class="heart btn btn-success btn-block w-100 mt-2">Subscribe</button>
              </form>
						</div>
					</div>
				</div>
			</div>
            


             <!-- Author Box -->
                
				<div class="row mt-5">
					<div class="col-md-2 align-self-center">
                        
                          <a href="/contributors/shwetalsoni">
                            <img class="rounded-circle" src="/assets/contributors/shwetalsoni/avatar.webp" alt="Shwetal Soni" width="90"/>
                          </a>
                        
					</div>
					<div class="col-md-10">
                        <h5 class="font-weight-bold">Written by Shwetal Soni <span><a target="_blank" href="https://twitter.com/shwetalsoni19" class="btn btn-outline-success btn-sm btn-round ml-2">Follow</a></span></h5>
						Web Developer | UI/UX Designer | Open Source Developer | Hackathon Enthusiast | Exploring Blockchains
					</div>
				</div>
                

            <!-- Comments -->
            
                <!--  Don't edit anything here. Set your disqus id in _config.yml -->

<div id="comments" class="mt-5">
    <div id="disqus_thread">
    </div>
    <script type="text/javascript">
        var disqus_shortname = 'wechaty'; 
        var disqus_developer = 0;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>
    Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>
</div>
            

		</div>


	</div>
</div>


<!-- Aletbar Prev/Next -->
<div class="alertbar">
    <div class="container">
        <div class="row prevnextlinks small font-weight-bold">
          
            <div class="col-md-6 rightborder pl-0">
                <a class="text-dark" href="/2021/05/03/gsod-2021-applicant-jaya2320/"> <img height="30px" class="mr-1" src="https://wechaty.js.org/assets/2021/05-gsod-2021-applicant-jaya2320/profile.webp">  Create easy to learn tutorials for beginner users of Wechaty</a>
            </div>
          
          
            <div class="col-md-6 text-right pr-0">
                <a class="text-dark" href="/2021/05/03/interactive-tutorials-for-newcomers/"> Soumi Bardhan: Interactive tutorials for newcomers  <img height="30px" class="ml-1" src="https://wechaty.js.org/assets/2021/05-interactive-tutorials-for-newcomers/gsod_s.webp"> </a>
            </div>
          
        </div>
    </div>
</div>

    </main>


    <!-- Scripts: popper, bootstrap, theme, lunr -->
    <script src="https://cdnjs.loli.net/ajax/libs/popper.js/1.14.6/umd/popper.min.js" crossorigin="anonymous"></script>

    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" crossorigin="anonymous"></script>

    <script src="/assets/js/theme.js"></script>


    <!-- Footer -->
    <footer class="bg-white border-top p-3 text-muted small">
        <div class="container">
        <div class="row align-items-center justify-content-between">
            <div>
                <a href="#" class="text-muted navbar-brand mr-2 mb-0">
                  <strong>Wechaty</strong>
                </a>
                <span>Copyright © <script>document.write(new Date().getFullYear())</script></span>
                |
                <a
                  class="text-muted"
                  target="_blank"
                  href="/branding/"
                >
                  Branding
                </a>

                <!--  Github Repo Star Btn-->
                <a class="text-dark ml-1" target="_blank" href="https://github.com/wechaty"><i class="fab fa-github"></i> </a>

            </div>

            <div class="text-gray">
              Powered by
              <a
                class="text-gray font-weight-bold"
                target="_blank"
                href="https://www.wowthemes.net/mundana-jekyll-theme/"
              >
                Mundana Jekyll Theme
              </a>
              .
            </div>
        </div>
        </div>
    </footer>

    <!-- All this area goes before             <script>
                window.onload = function () {
                    var script = document.createElement('script');
                    var firstScript = document.getElementsByTagName('script')[0];
                    script.type = 'text/javascript';
                    script.async = true;
                    script.src = '/sw-register.js?v=' + Date.now();
                    firstScript.parentNode.insertBefore(script, firstScript);
                };
            </script>
            </body>
 closing tag -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'wechaty/wechaty'
  }
</script>
<script async src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script>

<style>
  .gitter-chat-embed {
    z-index: 1200;
  }
</style>


</body>

</html>
